kernel void ellipticPartialAxTri2D_v0(const int Nelements,
				      const iint   * restrict elementList,
				      const dfloat * restrict ggeo,
				      const dfloat * restrict Srr,
				      const dfloat * restrict Srs,
				      const char4   * restrict IndT,
				      const dfloat * restrict Sss,
				      const dfloat * restrict MM,
				      const dfloat lambda,
				      const dfloat  * restrict q,
				      dfloat  * restrict Aq){

  // needs p_NnodesV (nodes per thread) and p_NblockV (elements per chunk) defined

  for(iint eo=0;eo<Nelements;eo+=p_NnodesV*p_NblockV;outer0){

    shared dfloat s_q[p_NnodesV][p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        occaUnroll(p_NnodesV)
          for(iint et=0;et<p_NnodesV;++et){
            const iint e = eo + es + et*p_NblockV;
            if(e<Nelements){
              //prefetch q
              const iint element = elementList[e];
              const iint id = n + element*p_Np;
              s_q[et][es][n] = q[id];
            }
          }
      }
    }

    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        // do this part irrespective of e
        dfloat r_qrr[p_NnodesV];
        dfloat r_qrs[p_NnodesV];
        dfloat r_qss[p_NnodesV];

        occaUnroll(p_NnodesV)
          for(iint et=0;et<p_NnodesV;++et){
            r_qrr[et] = 0;
            r_qrs[et] = 0;
            r_qss[et] = 0;
          }

        int shift = p_maxNnzPerRow/4; // TW: need to make sure this is multiple of 4
        occaUnroll(p_maxNnzPerRow/4)
          for (int k=0;k<shift;k++) {
            // prefetch operators to register for reuse

            const char4 Indn = IndT[n*shift+k];
            int indicesn[4];
            indicesn[0] = (int) Indn.x;
            indicesn[1] = (int) Indn.y;
            indicesn[2] = (int) Indn.z;
            indicesn[3] = (int) Indn.w;

            occaUnroll(4)
              for (int k2 =0; k2<4; k2++){
		int idk = indicesn[k2];
                if (idk != 0){
		  --idk;

                  // assume Srr, Srs, Sss are stored as a row-major matrix with maxNnzPerRow rows and Np columns
                  const int id = n + (k2+4*k)*p_Np;
                  const dfloat Srr_nk = Srr[id];
                  const dfloat Srs_nk = Srs[id];
                  const dfloat Sss_nk = Sss[id];

                  occaUnroll(p_NnodesV){
                    for(iint et=0;et<p_NnodesV;++et){
                      // fetch from shared (for reuse three times)
                      // 6 flops per 8 bytes
                      const dfloat r_qk = s_q[et][es][idk];
                      r_qrr[et] += Srr_nk*r_qk;
                      r_qrs[et] += Srs_nk*r_qk;
                      r_qss[et] += Sss_nk*r_qk;
                    }
                  }
                }
              }
          }

        // this part has to check for element index validity
        occaUnroll(p_NnodesV){
          for(iint et=0;et<p_NnodesV;++et){
            const iint e = eo + es + et*p_NblockV;

            if (e<Nelements) {
              const iint element = elementList[e];

              const iint gid = element*p_Nggeo;

              const dfloat Grr = ggeo[gid + p_G00ID];
              const dfloat Grs = ggeo[gid + p_G01ID];
              const dfloat Gss = ggeo[gid + p_G11ID];
              const dfloat J   = ggeo[gid + p_GWJID];

              const dfloat res1 = Grr*r_qrr[et];
              const dfloat res2 = Grs*r_qrs[et];
              const dfloat res3 = Gss*r_qss[et];

              const iint id = n + element*p_Np;
              Aq[id] = res1+res2+res3;
            }
          }
        }
      }
    }
  }
}


