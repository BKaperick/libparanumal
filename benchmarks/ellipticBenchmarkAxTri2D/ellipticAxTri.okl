kernel void ellipticPartialAxTri2D_v0(const int Nelements,
				      const iint   * restrict elementList,
				      const dfloat * restrict ggeo,
				      const dfloat * restrict Srr,
				      const dfloat * restrict Srs,
				      const char4  * restrict IndT,
				      const dfloat * restrict Sss,
				      const dfloat * restrict MM,
				      const dfloat lambda,
				      const dfloat * restrict q,
				      dfloat * restrict Aq){

  // needs p_NnodesV (nodes per thread) and p_NblockV (elements per chunk) defined

  for(iint eo=0;eo<Nelements;eo+=p_NnodesV*p_NblockV;outer0){
#if 1
    shared dfloat s_q[p_NnodesV][p_NblockV][p_Np];
#endif

    shared dfloat s_ggeo[p_NnodesV][p_NblockV][p_Nggeo];


    for(iint es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
	
	// coalesced read of ggeo 
	int t = n + p_Np*es;
	while(t<p_NnodesV*p_NblockV*p_Nggeo && eo*p_Nggeo+t<Nelements*p_Nggeo){
	  
	  s_ggeo[0][0][t] = ggeo[eo*p_Nggeo+t];
	  t += p_Np*p_NblockV;
	}
	

        occaUnroll(p_NnodesV)
          for(iint et=0;et<p_NnodesV;++et){
            const iint e = eo + es + et*p_NblockV;
            if(e<Nelements){
              //prefetch q
	      //	      element = elementList[e];
	      //	      const int element = s_elements[et][es];
	      const int element = e;
              const iint id = n + element*p_Np;
              s_q[et][es][n] = q[id];
            }
          }
      }
    }

    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        // do this part irrespective of e
        dfloat r_qrr[p_NnodesV];
        dfloat r_qrs[p_NnodesV];
        dfloat r_qss[p_NnodesV];

        occaUnroll(p_NnodesV)
          for(iint et=0;et<p_NnodesV;++et){
            r_qrr[et] = 0;
            r_qrs[et] = 0;
            r_qss[et] = 0;
          }

	//p_maxNnzPerRow)/4)
	//	occaUnroll()
	for (int k=0;k<( ((int)p_maxNnzPerRow/4));k++) {
	    
	  const char4 Indn = IndT[n*((int)p_maxNnzPerRow/4)+k]; // IndT[n*shift+k]; <== this was bad
	  const char * pt_Indn = (char*) &Indn;
	    
	    
	  //	    occaUnroll(4) //seems inefficient
	  for (int k2 =0; k2<4; k2++){
	      
	    int idk = pt_Indn[k2];
	      
	    if(!idk) break;
	      
	    {
	      --idk;
		
	      // assume Srr, Srs, Sss are stored as a row-major matrix with maxNnzPerRow rows and Np columns
	      const int id = n + (k2+4*k)*p_Np;
	      // 3 loads from global (probably L1 for NnodesV*6 flops)
	      const dfloat Srr_nk = Srr[id];
	      const dfloat Srs_nk = Srs[id];
	      const dfloat Sss_nk = Sss[id];
  
	      occaUnroll(p_NnodesV)
		for(iint et=0;et<p_NnodesV;++et){
		  const iint e = eo + es + et*p_NblockV;
		  // fetch from shared (for reuse three times)
		  // 6 flops per 8 bytes
		  const dfloat r_qk = s_q[et][es][idk];
		  
		  r_qrr[et] += Srr_nk*r_qk;
		  r_qrs[et] += Srs_nk*r_qk;
		  r_qss[et] += Sss_nk*r_qk;
		}
	    }
	  }
	}
	

        // this part has to check for element index validity
        occaUnroll(p_NnodesV)
          for(iint et=0;et<p_NnodesV;++et){
            const iint e = eo + es + et*p_NblockV;
	    
            if (e<Nelements) {
	      //	      const iint element = elementList[e];
	      //	      const int element = s_elements[et][es];
	      const int element = e;
	      
              dfloat res1 = s_ggeo[et][es][p_G00ID]*r_qrr[et];
              res1 += s_ggeo[et][es][p_G01ID]*r_qrs[et];
              res1 += s_ggeo[et][es][p_G11ID]*r_qss[et];
	      
              const iint id = n + element*p_Np;
              Aq[id] = res1;
	      
            }
	  }
      }
    }
  }
}


