
kernel void applyWADG(const iint Nelements,
		      const int cubNp,
		      const dfloat * restrict cubInterp,
		      const dfloat * restrict cubProject,
		      const dfloat * restrict c2,
		      dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

    shared dfloat s_p[cubNp];
    exclusive dfloat r_p;

    for(iint n=0; n < cubNp; ++n; inner0){  

      if (n < p_Np){
	const iint id = p_Nfields*(e*p_Np + n);
	s_p[n] = q[id]; // extract field var
      }

      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<cubNp;++n;inner0){

      // Prefetch value of c2
      const dfloat c2n = c2[n + e*cubNp];
      
      dfloat val = 0.f;
      for (int i=0;i<p_Np;++i){
	val += cubInterp[n + i*cubNp] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<cubNp;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<cubNp;++n;inner0){

      if (n < p_Np){

	// Extract velocity rhs
	
	// Project scaled rhs down
	dfloat pp = 0.f;
	for (int i=0;i<cubNp;++i){
	  pp += cubProject[n + i*p_Np] * s_p[i];
	}

	// Increment solutions
	const iint id = p_Nfields*(e*p_Np + n);	
	for (int fld = 0; fld < p_Nfields; ++fld){ 
	  q[id + fld] = pp;
	}


      }      
    }

  }
}


kernel void applyMassInv(const iint Nelements,
			 const dfloat * restrict invM,
			 dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

    shared dfloat s_p[p_Np];

    for(iint n=0; n < p_Np; ++n; inner0){  

      const iint id = p_Nfields*(e*p_Np + n);
      s_p[n] = q[id]; // extract pressure rhs
    }
    barrier(localMemFence);

    for(iint n=0; n < p_Np; ++n; inner0){

      const iint Np2 = p_Np*p_Np;
      
      dfloat val = 0.f;
      for(iint m=0; m < p_Np; ++m){
	val += invM[n + m*p_Np + e*Np2] * s_p[m];
      }
      
      const iint id = p_Nfields*(e*p_Np + n);
      q[id] = val;
    }
  }
}

