
// Base implementation
kernel void insSubCycleCubatureSurface2D_v0(iint Nelements,
                                            dfloat * sgeo,
                                            dfloat * intInterpT, // interpolate to integration nodes
                                            dfloat * intLIFTT, // lift from integration to interpolation nodes
                                            iint   * vmapM,
                                            iint   * vmapP,
                                            iint   * EToB,
                                            dfloat time,
                                            dfloat * intx, // integration nodes
                                            dfloat * inty,
                                            dfloat * U,
                                            dfloat * V,
                                            dfloat * Ud,
                                            dfloat * Vd,
                                            dfloat * rhsU,
                                            dfloat * rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          iint face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(iint m=0;m<p_Nfp;++m){
            dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

            iint id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
            iint idM = vmapM[id];
            iint idP = vmapP[id];

            iUM  += iInm*U[idM];
            iVM  += iInm*V[idM];
            iUdM += iInm*Ud[idM];
            iVdM += iInm*Vd[idM];

            iUP  += iInm*U[idP];
            iVP  += iInm*V[idP];
            iUdP += iInm*Ud[idP];
            iVdP += iInm*Vd[idP];
          }

          // apply boundary conditions
          iint bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(iint m=0;m<p_intNfpNfaces;++m){
            dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}


// resrict and const
kernel void insSubCycleCubatureSurface2D_v1(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          const iint face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

            const iint id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
            const iint idM = vmapM[id];
            const iint idP = vmapP[id];

            iUM  += iInm*U[idM];
            iVM  += iInm*V[idM];
            iUdM += iInm*Ud[idM];
            iVdM += iInm*Vd[idM];

            iUP  += iInm*U[idP];
            iVP  += iInm*V[idP];
            iUdP += iInm*Ud[idP];
            iVdP += iInm*Vd[idP];
          }

          // apply boundary conditions
          const iint bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(iint m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// shared memory
kernel void insSubCycleCubatureSurface2D_v2(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const iint id  = e*p_Nfp*p_Nfaces + n;

          const iint idM = vmapM[id];
          const iint idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_UM[n] = U[idM];
          s_VM[n] = V[idM];
          s_UP[n] = U[idP];
          s_VP[n] = V[idP];

          s_UdM[n] = Ud[idM];
          s_VdM[n] = Vd[idM];
          s_UdP[n] = Ud[idP];
          s_VdP[n] = Vd[idP];

        }
      }
    }

    barrier(localMemFence);


    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            iUM  += iInm*s_UM[fm];
            iVM  += iInm*s_VM[fm];
            iUdM += iInm*s_UdM[fm];
            iVdM += iInm*s_VdM[fm];

            iUP  += iInm*s_UP[fm];
            iVP  += iInm*s_VP[fm];
            iUdP += iInm*s_UdP[fm];
            iVdP += iInm*s_VdP[fm];
          }

          // apply boundary conditions
          const iint bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          for(iint m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// loop unrolling
kernel void insSubCycleCubatureSurface2D_v3(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const iint id  = e*p_Nfp*p_Nfaces + n;

          const iint idM = vmapM[id];
          const iint idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_UM[n] = U[idM];
          s_VM[n] = V[idM];
          s_UP[n] = U[idP];
          s_VP[n] = V[idP];

          s_UdM[n] = Ud[idM];
          s_VdM[n] = Vd[idM];
          s_UdP[n] = Ud[idP];
          s_VdP[n] = Vd[idP];

        }
      }
    }

    barrier(localMemFence);


    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            iUM  += iInm*s_UM[fm];
            iVM  += iInm*s_VM[fm];
            iUdM += iInm*s_UdM[fm];
            iVdM += iInm*s_VdM[fm];

            iUP  += iInm*s_UP[fm];
            iVP  += iInm*s_VP[fm];
            iUdP += iInm*s_UdP[fm];
            iVdP += iInm*s_VdP[fm];
          }

          // apply boundary conditions
          const iint bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ ;

          s_iFluxU[n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                           +ny*(iVP*iUdP + iVM*iUdM)
                           +unmax*(iUdM-iUdP));

          s_iFluxV[n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                          + ny*(iVP*iVdP + iVM*iVdM)
                          + unmax*(iVdM-iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          const iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
          for(iint m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}


// multiple elements per block
kernel void insSubCycleCubatureSurface2D_v4(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for fields and reused for flux terms
    shared dfloat s_U[p_NblockS][p_intNfpNfaces];
    shared dfloat s_V[p_NblockS][p_intNfpNfaces];

    exclusive dfloat r_iUM , r_iUP ;
    exclusive dfloat r_iVM , r_iVP ;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    exclusive iint idM, idP;
    exclusive int face;

    /* Loop for minus traces */
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // indices of negative and positive traces of face node
          const iint id  = e*p_Nfp*p_Nfaces + n;
          idM = vmapM[id];
          idP = vmapP[id];

          // load negative and positive trace node values of velocity
          s_U[es][n] = U[idM];
          s_V[es][n] = U[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node
          r_iUM  = 0.f;
          r_iUP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;
            r_iUM  += iInm*s_U[es][fm];
            r_iUP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of advection field
          s_U[es][n] = Ud[idM];
          s_V[es][n] = Ud[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iUdM  = 0.f;
          r_iUdP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;
            r_iUdM  += iInm*s_U[es][fm];
            r_iUdP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    //////////////////////////////////////////////////////

    /* Loop for positive traces */
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of velocity
          s_U[es][n] = V[idM];
          s_V[es][n] = V[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iVM  = 0.f;
          r_iVP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;
            r_iVM  += iInm*s_U[es][fm];
            r_iVP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = es + eo;
        if((n<(p_Nfaces*p_Nfp))&&(e<Nelements)) {
          // load negative and positive trace node values of advection field
          s_U[es][n] = Vd[idM];
          s_V[es][n] = Vd[idP];
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          r_iVdM  = 0.f;
          r_iVdP  = 0.f;

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;
            r_iVdM  += iInm*s_U[es][fm];
            r_iVdP  += iInm*s_V[es][fm];
          }
        }
      }
    }
    barrier(localMemFence);

    /* Use traces to compuite and store flux */
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = es + eo;
        if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
          // load surface geofactors for this face
          const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          // apply boundary conditions
          const iint bc = EToB[face+p_Nfaces*e];
          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &(r_iUdP), &(r_iVdP));
          }

          // Find max normal velocity on the face
          const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
          const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);
          const dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          const dfloat sc = 0.5f*invJ*sJ;

          // bad notation here //
          s_U[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM)
                         + ny*(r_iVP*r_iUdP + r_iVM*r_iUdM)
                         + unmax*(r_iUdM-r_iUdP));

          s_V[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM)
                         + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM)
                         + unmax*(r_iVdM-r_iVdP));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          const iint e = es + eo;
          if(e<Nelements) {
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            r_iUM = rhsU[id];
            r_iVM = rhsV[id];


            occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              r_iUM += L*s_U[es][m];
              r_iVM += L*s_V[es][m];
            }

            rhsU[id] = r_iUM;
            rhsV[id] = r_iVM;
          }
        }
      }
    }
  }
}


// Based on v4 multiple elements per node
kernel void insSubCycleCubatureSurface2D_v5(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for fields and reused for flux terms
    shared dfloat s_U[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_V[p_Nnodes][p_NblockS][p_intNfpNfaces];

    exclusive dfloat r_iUM [p_Nnodes], r_iUP [p_Nnodes];
    exclusive dfloat r_iVM [p_Nnodes], r_iVP [p_Nnodes];
    exclusive dfloat r_iUdM[p_Nnodes], r_iUdP[p_Nnodes];
    exclusive dfloat r_iVdM[p_Nnodes], r_iVdP[p_Nnodes];

    exclusive iint idM[p_Nnodes], idP[p_Nnodes];
    exclusive int face;

    /* Loop for minus traces */
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + n;
              idM[et] = vmapM[id];
              idP[et] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[et][es][n] = U[idM[et]];
              s_V[et][es][n] = U[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iUM[et]  = 0.f;
            r_iUP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUM[et]  += iInm*s_U[et][es][fm];
              r_iUP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[et][es][n] = Ud[idM[et]];
              s_V[et][es][n] = Ud[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iUdM[et]  = 0.f;
            r_iUdP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUdM[et]  += iInm*s_U[et][es][fm];
              r_iUdP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    //////////////////////////////////////////////////////

    /* Loop for positive traces */
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[et][es][n] = V[idM[et]];
              s_V[et][es][n] = V[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iVM[et]  = 0.f;
            r_iVP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iVM[et]  += iInm*s_U[et][es][fm];
              r_iVP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[et][es][n] = Vd[idM[et]];
              s_V[et][es][n] = Vd[idP[et]];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            r_iVdM[et]  = 0.f;
            r_iVdP[et]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iVdM[et]  += iInm*s_U[et][es][fm];
              r_iVdP[et]  += iInm*s_V[et][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    /* Use traces to compuite and store flux */
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const iint e = et*p_NblockS + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[et],r_iVdM[et], &(r_iUdP[et]), &(r_iVdP[et]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[et] + ny*r_iVM[et]);
            const dfloat unp   = occaFabs(nx*r_iUP[et] + ny*r_iVP[et]);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_U[et][es][n] = sc*(nx*(r_iUP[et]*r_iUdP[et] + r_iUM[et]*r_iUdM[et])
                                +ny*(r_iVP[et]*r_iUdP[et] + r_iVM[et]*r_iUdM[et])
                                +unmax*(r_iUdM[et]-r_iUdP[et]));

            s_V[et][es][n] = sc*(nx*(r_iUP[et]*r_iVdP[et] + r_iUM[et]*r_iVdM[et])
                               + ny*(r_iVP[et]*r_iVdP[et] + r_iVM[et]*r_iVdM[et])
                               + unmax*(r_iVdM[et]-r_iVdP[et]));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if(e<Nelements) {
              const iint id = n + p_Np*e;
              // prefetch volume rhs
              r_iUM[et] = rhsU[id];
              r_iVM[et] = rhsV[id];
            }
          }

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              r_iUM[et] += L*s_U[et][es][m];
              r_iVM[et] += L*s_V[et][es][m];
            }
          }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const iint e = et*p_NblockS + es + eo;
            if(e<Nelements) {
              const iint id = n + p_Np*e;
              // prefetch volume rhs
              rhsU[id] = r_iUM[et];
              rhsV[id] = r_iVM[et];
            }
          }
        }
      }
    }
  }
}


/*
// Multiple element per threadblock,
kernel void insSubCycleCubatureSurface2D_v4(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;

            const iint idM = vmapM[id];
            const iint idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][n] = U[idM];
            s_VM[es][n] = V[idM];
            s_UP[es][n] = U[idP];
            s_VP[es][n] = V[idP];

            s_UdM[es][n] = Ud[idM];
            s_VdM[es][n] = Vd[idM];
            s_UdP[es][n] = Ud[idP];
            s_VdP[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){

            const iint face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }


            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_iFluxU[es][m];
                rhsv += L*s_iFluxV[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv;
          }
        }
      }
    }
  }
}



// restict to p_Np threads
kernel void insSubCycleCubatureSurface2D_v5(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + m;

            const iint idM = vmapM[id];
            const iint idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][m] = U[idM];
            s_VM[es][m] = V[idM];
            s_UP[es][m] = U[idP];
            s_VP[es][m] = V[idP];

            s_UdM[es][m] = Ud[idM];
            s_VdM[es][m] = Vd[idM];
            s_UdP[es][m] = Ud[idP];
            s_VdP[es][m] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){
            const iint face = m/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint k=0;k<p_Nfp;++k){
                const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+k;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][m] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][m] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          const iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              rhsu += L*s_iFluxU[es][m];
              rhsv += L*s_iFluxV[es][m];
            }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

//shared geofacts
kernel void insSubCycleCubatureSurface2D_v6(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_NblockS][p_Nfaces][p_Nsgeo];

    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int k = n + p_Np*es;
        while(k<p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + k;
          s_sgeo[0][0][k] = sgeo[id];
          k+=p_Np*p_NblockS;
        }

        const iint e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + m;

            const iint idM = vmapM[id];
            const iint idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_UM[es][m] = U[idM];
            s_VM[es][m] = V[idM];
            s_UP[es][m] = U[idP];
            s_VP[es][m] = V[idP];

            s_UdM[es][m] = Ud[idM];
            s_VdM[es][m] = Vd[idM];
            s_UdP[es][m] = Ud[idP];
            s_VdP[es][m] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint e = eo + es;

        if(e<Nelements){
          for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){
            const iint face = m/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const dfloat nx   = s_sgeo[es][face][p_NXID];
            const dfloat ny   = s_sgeo[es][face][p_NYID];
            const dfloat sJ   = s_sgeo[es][face][p_SJID];
            const dfloat invJ = s_sgeo[es][face][p_IJID];

            dfloat iUM  = 0.f, iVM  = 0.f;
            dfloat iUP  = 0.f, iVP  = 0.f;
            dfloat iUdM = 0.f, iVdM = 0.f;
            dfloat iUdP = 0.f, iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint k=0;k<p_Nfp;++k){
                const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+k;

                iUM  += iInm*s_UM[es][fm];
                iVM  += iInm*s_VM[es][fm];
                iUdM += iInm*s_UdM[es][fm];
                iVdM += iInm*s_VdM[es][fm];

                iUP  += iInm*s_UP[es][fm];
                iVP  += iInm*s_VP[es][fm];
                iUdP += iInm*s_UdP[es][fm];
                iVdP += iInm*s_VdP[es][fm];
              }

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][m] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][m] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          const iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          occaUnroll(p_intNfpNfaces)
            for(int m=0;m<p_intNfpNfaces;++m){
              const dfloat L = intLIFTT[n+m*p_Np];
              rhsu += L*s_iFluxU[es][m];
              rhsv += L*s_iFluxV[es][m];
            }

          rhsU[id] = rhsu;
          rhsV[id] = rhsv;
        }
      }
    }
  }
}

// multiple elements per node
kernel void insSubCycleCubatureSurface2D_v7(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_Nnodes][p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_Nnodes][p_NblockS][p_Nfaces][p_Nsgeo];

    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;
        while(m<p_Nnodes*p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + m;
          s_sgeo[0][0][0][m] = sgeo[id];
          m+=p_Np*p_NblockS;
        }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + m;

              const iint idM = vmapM[id];
              const iint idP = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[et][es][m] = U[idM];
              s_VM[et][es][m] = V[idM];
              s_UP[et][es][m] = U[idP];
              s_VP[et][es][m] = V[idP];

              s_UdM[et][es][m] = Ud[idM];
              s_VdM[et][es][m] = Vd[idM];
              s_UdP[et][es][m] = Ud[idP];
              s_VdP[et][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){

        dfloat iUM [p_Nnodes], iVM [p_Nnodes];
        dfloat iUP [p_Nnodes], iVP [p_Nnodes];
        dfloat iUdM[p_Nnodes], iVdM[p_Nnodes];
        dfloat iUdP[p_Nnodes], iVdP[p_Nnodes];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }

          const iint face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
            for(iint k=0;k<p_Nfp;++k){
              const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
              const iint fm = face*p_Nfp+k;

              occaUnroll(p_Nnodes)
              for (int et=0;et<p_Nnodes;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const iint bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et])
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et])
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et])
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et])
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){

        dfloat rhsu[p_Nnodes];
        dfloat rhsv[p_Nnodes];

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }

        occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            const iint id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}

// interp in shared
kernel void insSubCycleCubatureSurface2D_v8(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS*p_Nnodes;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_Nnodes][p_NblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_Nnodes][p_NblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_Nnodes][p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_Nnodes][p_NblockS][p_intNfpNfaces];

    shared dfloat s_sgeo[p_Nnodes][p_NblockS][p_Nfaces][p_Nsgeo];
    shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];


    for (int es=0;es<p_NblockS;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;
        while(m<p_Nnodes*p_NblockS*p_Nfaces*p_Nsgeo){
          const int id = eo*p_Nfaces*p_Nsgeo + m;
          s_sgeo[0][0][0][m] = sgeo[id];
          m+=p_Np*p_NblockS;
        }

        if (es==0) {
          for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
            s_intInterpT[m] = intInterpT[m];
          }
        }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + m;

              const iint idM = vmapM[id];
              const iint idP = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[et][es][m] = U[idM];
              s_VM[et][es][m] = V[idM];
              s_UP[et][es][m] = U[idP];
              s_VP[et][es][m] = V[idP];

              s_UdM[et][es][m] = Ud[idM];
              s_VdM[et][es][m] = Vd[idM];
              s_UdP[et][es][m] = Ud[idP];
              s_VdP[et][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){

        dfloat iUM [p_Nnodes], iVM [p_Nnodes];
        dfloat iUP [p_Nnodes], iVP [p_Nnodes];
        dfloat iUdM[p_Nnodes], iVdM[p_Nnodes];
        dfloat iUdP[p_Nnodes], iVdP[p_Nnodes];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }

          const iint face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
            for(iint k=0;k<p_Nfp;++k){
              const dfloat iInm = s_intInterpT[m+k*p_Nfaces*p_intNfp];
              const iint fm = face*p_Nfp+k;

              occaUnroll(p_Nnodes)
              for (int et=0;et<p_Nnodes;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          occaUnroll(p_Nnodes)
          for (int et=0;et<p_Nnodes;++et){
            const int e = et*p_NblockS + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const iint bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et])
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et])
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et])
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et])
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){

        dfloat rhsu[p_Nnodes];
        dfloat rhsv[p_Nnodes];

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }

        occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_Nnodes)
            for (int et=0;et<p_Nnodes;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }

        occaUnroll(p_Nnodes)
        for (int et=0;et<p_Nnodes;++et){
          const int e = et*p_NblockS + es + eo;
          if(e<Nelements){
            const iint id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}

// Based on v4. Assume trace buffers are pre-built
kernel void insSubCycleCubatureSurface2D_v2(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict fU,
                                            const dfloat * restrict fV,
                                            const dfloat * restrict fUd,
                                            const dfloat * restrict fVd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

    // get surface integration nodes and compute flux
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){

            const iint face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            const iint idM  = e*p_intNfp*p_Nfaces + n;
            const iint idP  = idM;

            const dfloat iUM  = fU[idM];
            const dfloat iUP  = fU[idP];
            const dfloat iUdM = fUd[idM];
            const dfloat iUdP = fUd[idP];

            const dfloat iVM  = fV[idM];
            const dfloat iVP  = fV[idP];
            const dfloat iVdM = fVd[idM];
            const dfloat iVdP = fVd[idP];

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            //if(bc>0){
            //  insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
            //}

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
            const dfloat unp   = occaFabs(nx*iUP + ny*iVP);
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM)
                             +ny*(iVP*iUdP + iVM*iUdM)
                             +unmax*(iUdM-iUdP));

            s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM)
                            + ny*(iVP*iVdP + iVM*iVdM)
                            + unmax*(iVdM-iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_iFluxU[es][m];
                rhsv += L*s_iFluxV[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv;
          }
        }
      }
    }
  }
}
*/
