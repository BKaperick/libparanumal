//v0: packed node offsets

kernel void ellipticBRBBGradientPackedVolume3D_v0(const iint Nelements,
						  const dfloat * restrict vgeo,
						  const iint * restrict D0ids,
						  const char4 * restrict packedDids,
						  const dfloat * restrict Dvals,
						  const dfloat * restrict q,
						  dfloat * restrict gradq) {
    
  for(iint eo=0;eo<Nelements;eo+=p_NblockV*p_Nnodes;outer0) {
    // for all elements
    shared dfloat s_q[p_Nnodes][p_NblockV][p_Np];

    shared  int s_D0[4][p_Np];
    shared  dfloat s_Dvals[4][p_Np];

    shared  char4 s_packedDids[3][p_Np];
			
    for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
	
	int m = n + es*p_Np;
	while(m<p_Nnodes*p_NblockV*p_Np && m+eo*p_Np<Nelements*p_Np){
	  s_q[0][0][m] = q[m + eo*p_Np];
	  m+=p_NblockV*p_Np;
	}

#if 0
	occaUnroll(p_Nnodes)
	  for (int et=0; et<p_Nnodes; et++) {
	    const iint e = eo + es + et*p_NblockV;
	    if(e<Nelements) {
	      s_q[et][es][n]  = q[n + e*p_Np];
	    }
	  }
#endif								
	m=n + es*p_Np;
	while(m<4*p_Np){
	  s_Dvals[0][m] = Dvals[m];
	  s_D0[0][m]    = D0ids[m];
	  m+=p_NblockV*p_Np;
	}

	m=n + es*p_Np;

	while(m<3*p_Np){
	  s_packedDids[0][m] = packedDids[m];
	  m+=p_NblockV*p_Np;
	}
      }
    }
    
    // Make sure all node data is loaded into shared
    barrier(localMemFence);
			
    for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element

	// extract sparse derivative matrix once 
	const int D0i1 = s_D0[0][n];
	const int D0i2 = s_D0[1][n];
	const int D0i3 = s_D0[2][n];
	const int D0i4 = s_D0[3][n];
	
	const char4 dD1 = s_packedDids[0][n];	
	const char4 dD2 = s_packedDids[1][n];
	const char4 dD3 = s_packedDids[2][n];

	// reconstruct indices by offsetting D0 indices
	const int D1i1 = dD1.x + D0i1;
	const int D1i2 = dD1.y + D0i2;
	const int D1i3 = dD1.z + D0i3;
	const int D1i4 = dD1.w + D0i4;
	
	const int D2i1 = dD2.x + D0i1;
	const int D2i2 = dD2.y + D0i2;
	const int D2i3 = dD2.z + D0i3;
	const int D2i4 = dD2.w + D0i4;
	
	const int D3i1 = dD3.x + D0i1;
	const int D3i2 = dD3.y + D0i2;
	const int D3i3 = dD3.z + D0i3;
	const int D3i4 = dD3.w + D0i4;
	
	const dfloat Dval1 = s_Dvals[0][n];
	const dfloat Dval2 = s_Dvals[1][n];
	const dfloat Dval3 = s_Dvals[2][n];
	const dfloat Dval4 = s_Dvals[3][n];

	// reuse derivative info for each node
	occaUnroll(p_Nnodes)
	  for (int et=0; et<p_Nnodes; et++) {
	    const iint e = eo + es + et*p_NblockV;
	    
	    if(e<Nelements) {
	      
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
	      const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
	      const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
	      const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
	
	      // four shared loads for 7 flops
	      const dfloat tmp = 
		Dval1*s_q[et][es][D0i1] + 
		Dval2*s_q[et][es][D0i2] + 
		Dval3*s_q[et][es][D0i3] + 
		Dval4*s_q[et][es][D0i4];	      
	      
	      // should also build 0.5 into Dval#
	      const dfloat dqdr = .5f*(Dval1*s_q[et][es][D1i1] +
				       Dval2*s_q[et][es][D1i2] +
				       Dval3*s_q[et][es][D1i3] +
				       Dval4*s_q[et][es][D1i4] - tmp);  // four shared loads for 9 (really 8) flops
	      const dfloat dqds = .5f*(Dval1*s_q[et][es][D2i1] +
				       Dval2*s_q[et][es][D2i2] +
				       Dval3*s_q[et][es][D2i3] +
				       Dval4*s_q[et][es][D2i4] - tmp);
	      const dfloat dqdt = .5f*(Dval1*s_q[et][es][D3i1] + 
				       Dval2*s_q[et][es][D3i2] + 
				       Dval3*s_q[et][es][D3i3] + 
				       Dval4*s_q[et][es][D3i4] - tmp);
	      
	      const iint id = e*3*p_Np;
	      gradq[id+       n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
	      gradq[id+  p_Np+n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
	      gradq[id+2*p_Np+n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
	    }
	  }
      }
    }
  }
}



