kernel void ellipticBRBBGradientVolume3D_v0(const iint Nelements,
    const dfloat * restrict vgeo,
    const iint * restrict D0ids,
    const iint * restrict D1ids,
    const iint * restrict D2ids,
    const iint * restrict D3ids,
    const dfloat * restrict Dvals,
    const dfloat * restrict q,
    dfloat * restrict gradq) {
    
	for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0) {
			// for all elements
			shared dfloat s_q[p_NblockV][p_Np];
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
							const iint e = eo+es; // element in block
							if(e<Nelements) {
									s_q[es][n]  = q[n + e*p_Np];
								}
						}
				}
				
			// Make sure all node data is loaded into shared
			barrier(localMemFence);
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
							const iint e = eo+es; // element in block
							if(e<Nelements) {
									// prefetch geometric factors (constant on triangle)
									const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
									const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
									const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
									const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
									const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
									const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
									const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
									const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
									const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
									
									// compute 'r', 's',  and 't' derivatives of (q_m) at node n
									const iint D0i1 = D0ids[n];
									const iint D1i1 = D1ids[n];
									const iint D2i1 = D2ids[n];
									const iint D3i1 = D3ids[n];
									const dfloat Dval1 = Dvals[n];
									
									const iint D0i2 = D0ids[n+p_Np];
									const iint D1i2 = D1ids[n+p_Np];
									const iint D2i2 = D2ids[n+p_Np];
									const iint D3i2 = D3ids[n+p_Np];
									const dfloat Dval2 = Dvals[n+p_Np];
									
									const iint D0i3 = D0ids[n+2*p_Np];
									const iint D1i3 = D1ids[n+2*p_Np];
									const iint D2i3 = D2ids[n+2*p_Np];
									const iint D3i3 = D3ids[n+2*p_Np];
									const dfloat Dval3 = Dvals[n+2*p_Np];
									
									const iint D0i4 = D0ids[n+3*p_Np];
									const iint D1i4 = D1ids[n+3*p_Np];
									const iint D2i4 = D2ids[n+3*p_Np];
									const iint D3i4 = D3ids[n+3*p_Np];
									const dfloat Dval4 = Dvals[n+3*p_Np];
									
									const dfloat dqdr = .5f*(Dval1*(s_q[es][D1i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D1i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D1i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D1i4] - s_q[es][D0i4]));
									const dfloat dqds = .5f*(Dval1*(s_q[es][D2i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D2i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D2i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D2i4] - s_q[es][D0i4]));
									const dfloat dqdt = .5f*(Dval1*(s_q[es][D3i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D3i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D3i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D3i4] - s_q[es][D0i4]));
									                         
									const iint id = e*3*p_Np;
									gradq[id+       n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
									gradq[id+  p_Np+n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
									gradq[id+2*p_Np+n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
								}
						}
				}
		}
}

//derivative matrices in shared

kernel void ellipticBRBBGradientVolume3D_v1(const iint Nelements,
    const dfloat * restrict vgeo,
    const iint * restrict D0ids,
    const iint * restrict D1ids,
    const iint * restrict D2ids,
    const iint * restrict D3ids,
    const dfloat * restrict Dvals,
    const dfloat * restrict q,
    dfloat * restrict gradq) {
    
	for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0) {
			// for all elements
			shared dfloat s_q[p_NblockV][p_Np];
			shared  int s_D0[3*p_Np];
			shared  int s_D1[3*p_Np];
			shared  int s_D2[3*p_Np];
			shared  int s_D3[3*p_Np];
			
			shared dfloat s_Dvals[4*p_Np];
			
			exclusive int  D0i1, D1i1,  D2i1,  D3i1, D0i2, D1i2,  D2i2,  D3i2,D0i3, D1i3,  D2i3,  D3i3, D0i4, D1i4, D2i4, D3i4;
			exclusive dfloat Dval1, Dval2, Dval3, Dval4;
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
							const iint e = eo+es; // element in block
							if(e<Nelements) {
									s_q[es][n]  = q[n + e*p_Np];
								}
							if (es== 0) {
							
									s_D0[n]=D1ids[n];
									s_D0[n+p_Np] = D1ids[n+p_Np];
									s_D0[n+2*p_Np] = D1ids[n+2*p_Np];
									
								}
								
							if (es== 1) {
							
									s_D1[n]=D1ids[n];
									s_D1[n+p_Np] = D1ids[n+p_Np];
									s_D1[n+2*p_Np] = D1ids[n+2*p_Np];
									
								}
							if (es== 2) {
									s_D2[n]=D2ids[n];
									s_D2[n+p_Np] = D2ids[n+p_Np];
									s_D2[n+2*p_Np] = D2ids[n+2*p_Np];
								}
								
							if (es== 3) {
									s_D3[n]=D3ids[n];
									s_D3[n+p_Np] = D3ids[n+p_Np];
									s_D3[n+2*p_Np] = D3ids[n+2*p_Np];
								}
							if (es== 4) {
									s_Dvals[n] = Dvals[n];
									s_Dvals[n+p_Np] = Dvals[n+p_Np];
									s_Dvals[n+2*p_Np] = Dvals[n+2*p_Np];
									s_Dvals[n+3*p_Np] = Dvals[n+3*p_Np];
								}
								
								
						}
				}
				
			// Make sure all node data is loaded into shared
			barrier(localMemFence);
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
							const iint e = eo+es; // element in block
							if(e<Nelements) {
									// prefetch geometric factors (constant on triangle)
									const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
									const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
									const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
									const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
									const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
									const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
									const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
									const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
									const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
									
									// compute 'r', 's',  and 't' derivatives of (q_m) at node n
									D0i1 = s_D0[n];
									D1i1 = s_D1[n];
									D2i1 = s_D2[n];
									D3i1 = s_D3[n];
									Dval1 = s_Dvals[n];
									
									D0i2 = s_D0[n+p_Np];
									D1i2 = s_D1[n+p_Np];
									D2i2 = s_D2[n+p_Np];
									D3i2 = s_D3[n+p_Np];
									Dval2 = s_Dvals[n+p_Np];
									
									D0i3 = s_D0[n+2*p_Np];
									D1i3 = s_D1[n+2*p_Np];
									D2i3 = s_D2[n+2*p_Np];
									D3i3 = s_D3[n+2*p_Np];
									Dval3 = s_Dvals[n+2*p_Np];
									
									D0i4 = s_D0[n+3*p_Np];
									D1i4 = s_D1[n+3*p_Np];
									D2i4 = s_D2[n+3*p_Np];
									D3i4 = s_D3[n+3*p_Np];
									Dval4 = s_Dvals[n+3*p_Np];
									
									const dfloat dqdr = .5f*(Dval1*(s_q[es][D1i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D1i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D1i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D1i4] - s_q[es][D0i4]));
									const dfloat dqds = .5f*(Dval1*(s_q[es][D2i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D2i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D2i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D2i4] - s_q[es][D0i4]));
									const dfloat dqdt = .5f*(Dval1*(s_q[es][D3i1] - s_q[es][D0i1]) +
									                         Dval2*(s_q[es][D3i2] - s_q[es][D0i2]) +
									                         Dval3*(s_q[es][D3i3] - s_q[es][D0i3]) +
									                         Dval4*(s_q[es][D3i4] - s_q[es][D0i4]));
									                         
									const iint id = e*3*p_Np;
									gradq[id+       n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
									gradq[id+  p_Np+n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
									gradq[id+2*p_Np+n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
								}
						}
				}
		}
}

//v2: version with Nnodes =/= 1

kernel void ellipticBRBBGradientVolume3D_v2(const iint Nelements,
    const dfloat * restrict vgeo,
    const iint * restrict D0ids,
    const iint * restrict D1ids,
    const iint * restrict D2ids,
    const iint * restrict D3ids,
    const dfloat * restrict Dvals,
    const dfloat * restrict q,
    dfloat * restrict gradq) {
    
	for(iint eo=0;eo<Nelements;eo+=p_NblockV*p_Nnodes;outer0) {
			// for all elements
			shared dfloat s_q[p_Nnodes][p_NblockV][p_Np];
			shared  int s_D0[3*p_Np];
			shared  int s_D1[3*p_Np];
			shared  int s_D2[3*p_Np];
			shared  int s_D3[3*p_Np];
			
			shared dfloat s_Dvals[4*p_Np];
			
			exclusive int  D0i1, D1i1,  D2i1,  D3i1, D0i2, D1i2,  D2i2,  D3i2,D0i3, D1i3,  D2i3,  D3i3, D0i4, D1i4, D2i4, D3i4;
			exclusive dfloat Dval1, Dval2, Dval3, Dval4;
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
							//		const iint e = eo+es; // element in block
							
							for (int et=0; et<p_Nnodes; et++) {
									iint e = eo + es + et*p_NblockV;
									if(e<Nelements) {
											s_q[et][es][n]  = q[n + e*p_Np];
										}
								}
								
							if (es== 0) {
							
									s_D0[n]=D1ids[n];
									s_D0[n+p_Np] = D1ids[n+p_Np];
									s_D0[n+2*p_Np] = D1ids[n+2*p_Np];
									
								}
								
							if (es== 1) {
							
									s_D1[n]=D1ids[n];
									s_D1[n+p_Np] = D1ids[n+p_Np];
									s_D1[n+2*p_Np] = D1ids[n+2*p_Np];
									
								}
							if (es== 2) {
									s_D2[n]=D2ids[n];
									s_D2[n+p_Np] = D2ids[n+p_Np];
									s_D2[n+2*p_Np] = D2ids[n+2*p_Np];
								}
								
							if (es== 3) {
									s_D3[n]=D3ids[n];
									s_D3[n+p_Np] = D3ids[n+p_Np];
									s_D3[n+2*p_Np] = D3ids[n+2*p_Np];
								}
							if (es== 4) {
									s_Dvals[n] = Dvals[n];
									s_Dvals[n+p_Np] = Dvals[n+p_Np];
									s_Dvals[n+2*p_Np] = Dvals[n+2*p_Np];
									s_Dvals[n+3*p_Np] = Dvals[n+3*p_Np];
								}
								
								
						}
				}
				
			// Make sure all node data is loaded into shared
			barrier(localMemFence);
			
			for(iint es=0;es<p_NblockV;++es;inner1) {// for all elements in block
					for(iint n=0;n<p_Np;++n;inner0) {     // for all nodes in this element
					
							for (int et=0; et<p_Nnodes; et++) {
									const iint e = eo + es + et*p_NblockV;
									//		const iint e = eo+es; // element in block
									if(e<Nelements) {
											// prefetch geometric factors (constant on triangle)
											const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
											const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
											const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
											const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
											const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
											const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
											const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
											const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
											const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];
											
											// compute 'r', 's',  and 't' derivatives of (q_m) at node n
											D0i1 = s_D0[n];
											D1i1 = s_D1[n];
											D2i1 = s_D2[n];
											D3i1 = s_D3[n];
											Dval1 = s_Dvals[n];
											
											D0i2 = s_D0[n+p_Np];
											D1i2 = s_D1[n+p_Np];
											D2i2 = s_D2[n+p_Np];
											D3i2 = s_D3[n+p_Np];
											Dval2 = s_Dvals[n+p_Np];
											
											D0i3 = s_D0[n+2*p_Np];
											D1i3 = s_D1[n+2*p_Np];
											D2i3 = s_D2[n+2*p_Np];
											D3i3 = s_D3[n+2*p_Np];
											Dval3 = s_Dvals[n+2*p_Np];
											
											D0i4 = s_D0[n+3*p_Np];
											D1i4 = s_D1[n+3*p_Np];
											D2i4 = s_D2[n+3*p_Np];
											D3i4 = s_D3[n+3*p_Np];
											Dval4 = s_Dvals[n+3*p_Np];
											
											const dfloat dqdr = .5f*(Dval1*(s_q[et][es][D1i1] - s_q[et][es][D0i1]) +
											                         Dval2*(s_q[et][es][D1i2] - s_q[et][es][D0i2]) +
											                         Dval3*(s_q[et][es][D1i3] - s_q[et][es][D0i3]) +
											                         Dval4*(s_q[et][es][D1i4] - s_q[et][es][D0i4]));
											const dfloat dqds = .5f*(Dval1*(s_q[et][es][D2i1] - s_q[et][es][D0i1]) +
											                         Dval2*(s_q[et][es][D2i2] - s_q[et][es][D0i2]) +
											                         Dval3*(s_q[et][es][D2i3] - s_q[et][es][D0i3]) +
											                         Dval4*(s_q[et][es][D2i4] - s_q[et][es][D0i4]));
											const dfloat dqdt = .5f*(Dval1*(s_q[et][es][D3i1] - s_q[et][es][D0i1]) +
											                         Dval2*(s_q[et][es][D3i2] - s_q[et][es][D0i2]) +
											                         Dval3*(s_q[et][es][D3i3] - s_q[et][es][D0i3]) +
											                         Dval4*(s_q[et][es][D3i4] - s_q[et][es][D0i4]));
											                         
											const iint id = e*3*p_Np;
											gradq[id+       n] = drdx*dqdr + dsdx*dqds + dtdx*dqdt;
											gradq[id+  p_Np+n] = drdy*dqdr + dsdy*dqds + dtdy*dqdt;
											gradq[id+2*p_Np+n] = drdz*dqdr + dsdz*dqds + dtdz*dqdt;
										}
								}
						}
				}
		}
}



