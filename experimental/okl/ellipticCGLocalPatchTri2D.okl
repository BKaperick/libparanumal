/*

The MIT License (MIT)

Copyright (c) 2017 Tim Warburton, Noel Chalmers, Jesse Chan, Ali Karakus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/


occaKernel void ellipticCGLocalPatchTri2D_v0(const int Nelements,
                                      @restrict const  int *  vmapM,
                                      const dfloat lambda,
                                      const dfloat tau,
                                      @restrict const  dfloat *  vgeo,
                                      @restrict const  dfloat *  sgeo,
                                      @restrict const  int   *  EToB,
                                      @restrict const  dfloat *  DrT,
                                      @restrict const  dfloat *  DsT,
                                      @restrict const  dfloat *  LIFTT,
                                      @restrict const  dfloat *  MM,
                                      @restrict const  dfloat *  invDegree,
                                      @restrict const  dfloat *  q,
                                            @restrict dfloat *  Sq,
                                      const dfloat TOL) {

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_x[p_Np];
    @shared  dfloat s_r[p_Np];
    @shared  dfloat s_p[p_Np];
    @shared  dfloat s_Ap[p_Np];

    @shared volatile dfloat s_xy[p_Np];

    @shared dfloat s_rdotr, s_rdotr1, s_pAp, s_alpha, s_beta;

    @shared  dfloat s_dpdx[p_Np];
    @shared  dfloat s_dpdy[p_Np];
    @shared  dfloat s_lapq[p_Np];
    @shared  dfloat s_nxdq[p_NfacesNfp];
    @shared  dfloat s_nydq[p_NfacesNfp];
    @shared  dfloat s_lapflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdq[p_Np];
    @shared  dfloat s_Lnydq[p_Np];
    @shared  dfloat s_vgeo[p_Nvgeo];
    @shared  dfloat s_sgeo[p_Nfaces][p_Nsgeo];
    @exclusive int idM, bc;
    
    //fetch q into rhs
    for(int n=0;n<p_Nmax;++n;@inner(0)){
      if(n<p_Np) {
        s_r[n] = q[e*p_Np+n];
        s_p[n] = q[e*p_Np+n];
        s_x[n] = 0.f;
      }
    }

    @barrier("local");

    // sanity check
    /*---------------------Local Inner product -----------------*/
    for(int n=0;n<p_Nmax;++n;@inner(0)) if(n<p_Np) s_xy[n] = s_r[n]*s_r[n];
    @barrier("local");

    #if p_Np>256
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
    @barrier("local");
    #endif

    #if p_Np>128
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
    @barrier("local");
    #endif

    #if p_Np>64
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
    @barrier("local");
    #endif

    #if p_Np>32
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
    @barrier("local");
    #endif

    #if p_Np>16
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
        // @barrier("local");
    #endif

    #if p_Np>8
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
        // @barrier("local");
    #endif

    #if p_Np>4
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
        // @barrier("local");
    #endif

    #if p_Np>2
    for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
        // @barrier("local");
    #endif

    for(int n=0;n<p_Nmax;++n;@inner(0)) 
      if((n< 1)&&(n+1<p_Np)) {
        s_rdotr = s_xy[0] + s_xy[1];
      }
    @barrier("local");

    /*---------------------End Local Inner product -----------------*/    

    if (s_rdotr<TOL*TOL) {
      for(int n=0;n<p_Nmax;++n;@inner(0)) {
        if(n<p_Np) {
          Sq[e*p_Np+n] = invDegree[e]*s_r[n];
        }
        return;
      }
    }
    // read in geo data to @shared
    for(int n=0;n<p_Nmax;++n;@inner(0)){
      int m = n;
      const int gid = e*p_Nvgeo;
      while(m<p_Nvgeo){
        s_vgeo[m] = vgeo[gid + m];
        m+=p_Nmax;
      }

      m = n;
      const int sid = p_Nsgeo*e*p_Nfaces;
      while(m<p_Nsgeo*p_Nfaces){
        s_sgeo[0][m] = sgeo[sid + m];
        m+=p_Nmax;
      }

      if(n<p_NfacesNfp){
        const int id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id]%p_Np; //local id
         // find face that owns this node
        const int face = n/p_Nfp;
        bc = EToB[face+p_Nfaces*e];
      }
    }

    @barrier("local");
    //do an inner CG solve
    while(s_rdotr>TOL*TOL) {
    //for (int k=0;k<p_Np;k++) {

      /*---------------------Local Ax operator -----------------*/
      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if (n<p_Np) {
          const dfloat drdx = s_vgeo[p_RXID];
          const dfloat drdy = s_vgeo[p_RYID];
          const dfloat dsdx = s_vgeo[p_SXID];
          const dfloat dsdy = s_vgeo[p_SYID];
          
          // compute 1D derivatives
          dfloat qr = 0.f, qs = 0.f;
          for(int i=0;i<p_Np;++i){
            qr += DrT[n+i*p_Np]*s_p[i];
            qs += DsT[n+i*p_Np]*s_p[i];
          }
          
          s_dpdx[n] = drdx*qr + dsdx*qs;
          s_dpdy[n] = drdy*qr + dsdy*qs;
        }
      }
      
      @barrier("local");

      // TW      
      for(int n=0;n<p_Nmax;++n;@inner(0)){
        
        if(n<p_Np){
          s_lapq[n] = lambda*s_p[n];
        }
        
        if(n<p_NfacesNfp){
          // load surface geofactors for this face
          const int face = n/p_Nfp;
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];
          const dfloat hinv = s_sgeo[face][p_IHID];
          
          const dfloat qM = s_p[idM];
          const dfloat qxM = s_dpdx[idM];
          const dfloat qyM = s_dpdy[idM];
          
          dfloat qP = 0.f;
          dfloat qxP = 0.f;
          dfloat qyP = 0.f;
          
          if(bc>0) {
            ellipticHomogeneousBC2D(bc, qM, qxM, qyM, qP, qxP, qyP);
            qP = 2.f*qP - qM;
            qxP = 2.f*qxP - qxM;
            qyP = 2.f*qyP - qyM;
          }
          
          const dfloat dq = qP - qM;
          const dfloat half = 0.5f;

          s_nxdq[n]    = half*sJ*invJ*nx*dq;
          s_nydq[n]    = half*sJ*invJ*ny*dq;
          s_lapflux[n] = half*sJ*invJ*(-nx*(qxP-qxM)-ny*(qyP-qyM)-tau*hinv*dq);
        }
      }
      
      @barrier("local");
      // TW2
      
      // dqdx += LIFT*(sJ/J)*nx*dq
      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_Np){
          const dfloat drdx = s_vgeo[p_RXID];
          const dfloat drdy = s_vgeo[p_RYID];
          const dfloat dsdx = s_vgeo[p_SXID];
          const dfloat dsdy = s_vgeo[p_SYID];
          
          dfloat Lnxdq = 0.f;
          dfloat Lnydq = 0.f;

          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
          }

          dfloat dqdx = s_dpdx[n] + Lnxdq;
          dfloat dqdy = s_dpdy[n] + Lnydq;
          s_dpdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
          s_dpdy[n] = dsdx*dqdx + dsdy*dqdy;

          s_Lnxdq[n] = Lnxdq;
          s_Lnydq[n] = Lnydq;
        }
      }

      // TW3
      @barrier("local");

      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_NfacesNfp){
          const int face = n/p_Nfp;
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];

          s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[idM]+ny*s_Lnydq[idM]);
        }

        if(n<p_Np){
          dfloat lapr = 0.f, laps = 0.f;

          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dpdx[i];
            laps += DsT[n+i*p_Np]*s_dpdy[i];
          }

          s_lapq[n] -= (lapr+laps);
        }
        
      }

      // TW4
      @barrier("local");

      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_Np){
          dfloat lap = 0.f;

          // lift remaining surface terms
          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

          s_lapq[n] += lap;
        }
      }

      // TW5
      @barrier("local");

      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_Np){
          const dfloat J = s_vgeo[p_JID];

          dfloat Mlapq = 0.f;

          // multiply by mass matrix
          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }
          s_Ap[n] = J*Mlapq;
        }
      }
      @barrier("local");

      /*---------------------p.Ap -----------------*/
      for(int n=0;n<p_Nmax;++n;@inner(0)) if(n<p_Np) s_xy[n] = s_p[n]*s_Ap[n];
      @barrier("local");

#if p_Np>256
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
      @barrier("local");
#endif

#if p_Np>128
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
      @barrier("local");
#endif

#if p_Np>64
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
      @barrier("local");
#endif

#if p_Np>32
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
      @barrier("local");
#endif

#if p_Np>16
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
          // @barrier("local");
#endif

#if p_Np>8
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
          // @barrier("local");
#endif

#if p_Np>4
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
          // @barrier("local");
#endif

#if p_Np>2
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
          // @barrier("local");
#endif

      for(int n=0;n<p_Nmax;++n;@inner(0)) 
        if((n< 1)&&(n+1<p_Np)) {
          s_pAp = s_xy[0] + s_xy[1];
          s_alpha = s_rdotr/s_pAp;
        }
      @barrier("local");
      /*---------------------End p.Ap -----------------*/    

      /*--------------------- x += alpha*p -----------------*/    
      /*--------------------- r -= alpha*Ap -----------------*/    
      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_Np) {
          s_x[n] += s_alpha* s_p[n];
          s_r[n] -= s_alpha*s_Ap[n];
        } 
      } 
      @barrier("local");

      /*---------------------r.r -----------------*/
      for(int n=0;n<p_Nmax;++n;@inner(0)) if(n<p_Np) s_xy[n] = s_r[n]*s_r[n];
      @barrier("local");

#if p_Np>256
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
      @barrier("local");
#endif

#if p_Np>128
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
      @barrier("local");
#endif
    
#if p_Np>64
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
      @barrier("local");
#endif

#if p_Np>32
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
      @barrier("local");
#endif

#if p_Np>16
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
          // @barrier("local");
#endif

#if p_Np>8
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
          // @barrier("local");
#endif

#if p_Np>4
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
          // @barrier("local");
#endif

#if p_Np>2
      for(int n=0;n<p_Nmax;++n;@inner(0)) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
          // @barrier("local");
#endif
    
      for(int n=0;n<p_Nmax;++n;@inner(0)) 
        if((n< 1)&&(n+1<p_Np)) {
          s_rdotr1 = s_xy[0] + s_xy[1];
          s_beta = s_rdotr1/s_rdotr;
        }
      @barrier("local");
      /*---------------------End r.r -----------------*/    

      for(int n=0;n<p_Nmax;++n;@inner(0)) 
        if(s_rdotr1 < TOL*TOL) break;

      //precon would go here
    
      /*--------------------- p = beta*p + r -----------------*/    
      for(int n=0;n<p_Nmax;++n;@inner(0)){
        if(n<p_Np) s_p[n] = s_beta*s_p[n]+s_r[n];
        if(n==0) s_rdotr = s_rdotr1;
      } 
      @barrier("local");

    }
    
    for(int n=0;n<p_Nmax;++n;@inner(0)) {
      if(n<p_Np) {
        Sq[e*p_Np+n] = invDegree[e]*s_x[n];
      }
    }
  }
}

//@kernel is blocked into chucks of SIMDSIZE threads manually to avoid barriers
#define SIMDSIZE 32
occaKernel void ellipticCGLocalPatchTri2D(const int Nelements,
                                      @restrict const  int *  vmapM,
                                      const dfloat lambda,
                                      const dfloat tau,
                                      @restrict const  dfloat *  vgeo,
                                      @restrict const  dfloat *  sgeo,
                                      @restrict const  int   *  EToB,
                                      @restrict const  dfloat *  DrT,
                                      @restrict const  dfloat *  DsT,
                                      @restrict const  dfloat *  LIFTT,
                                      @restrict const  dfloat *  MM,
                                      @restrict const  dfloat *  invDegree,
                                      @restrict const  dfloat *  q,
                                            @restrict dfloat *  Sq,
                                      const dfloat TOL) {

  for(int e=0;e<Nelements;++e;@outer(0)){
    @shared volatile  dfloat s_x[p_Np];
    @shared volatile  dfloat s_r[p_Np];
    @shared volatile  dfloat s_p[p_Np];
    @shared volatile  dfloat s_Ap[p_Np];

    @shared volatile dfloat s_xy[SIMDSIZE];

    @shared volatile dfloat s_rdotr, s_rdotr1, s_pAp, s_alpha, s_beta;

    @shared volatile  dfloat s_dpdx[p_Np];
    @shared volatile  dfloat s_dpdy[p_Np];
    @shared volatile  dfloat s_lapq[p_Np];
    @shared volatile  dfloat s_nxdq[p_NfacesNfp];
    @shared volatile  dfloat s_nydq[p_NfacesNfp];
    @shared volatile  dfloat s_lapflux[p_NfacesNfp];
    @shared volatile  dfloat s_Lnxdq[p_Np];
    @shared volatile  dfloat s_Lnydq[p_Np];
    @shared volatile  dfloat s_vgeo[p_Nvgeo];
    @shared volatile  dfloat s_sgeo[p_Nfaces][p_Nsgeo];
    @shared volatile    int s_idM[p_NfacesNfp], s_bc[p_NfacesNfp];
    
    //fetch q into rhs
    for(int n=0;n<SIMDSIZE;++n;@inner(0)){
      int m = n;
      while (m<p_Np) {
        s_r[m] = q[e*p_Np+m];
        s_p[m] = q[e*p_Np+m];
        s_x[m] = 0.f;
        m += SIMDSIZE;
      }
    }

    // sanity check
    /*---------------------Local Inner product -----------------*/    
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      s_xy[n] = 0.f;
      int m = n;
      while (m<p_Np) {
        s_xy[n] += s_r[m]*s_r[m];
        m += SIMDSIZE;
      } 
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 16) s_xy[n] += s_xy[n+16];
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 8)  s_xy[n] += s_xy[n+8];
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 4)  s_xy[n] += s_xy[n+4];
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 2)  s_xy[n] += s_xy[n+2];
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n==0)  s_rdotr = s_xy[0] + s_xy[1];    
    /*---------------------End Local Inner product -----------------*/    

    if (s_rdotr<TOL*TOL) {
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        int m = n;
        while (m<p_Np) {
          Sq[e*p_Np+m] = invDegree[e]*s_r[m];
          m += SIMDSIZE;
        } 
        return;
      }
    }
    // read in geo data to @shared
    for(int n=0;n<SIMDSIZE;++n;@inner(0)){
      int m = n;
      const int gid = e*p_Nvgeo;
      while(m<p_Nvgeo){
        s_vgeo[m] = vgeo[gid + m];
        m+=SIMDSIZE;
      }

      m = n;
      const int sid = p_Nsgeo*e*p_Nfaces;
      while(m<p_Nsgeo*p_Nfaces){
        s_sgeo[0][m] = sgeo[sid + m];
        m+=SIMDSIZE;
      }

      m = n;
      while(m<p_NfacesNfp){
        const int id  = m + e*p_Nfaces*p_Nfp;
        s_idM[m] = vmapM[id]%p_Np; //local id
         // find face that owns this node
        const int face = m/p_Nfp;
        s_bc[m] = EToB[face+p_Nfaces*e];
        m+=SIMDSIZE;
      }
    }

    //do an inner CG solve
    while(s_rdotr>TOL*TOL) {

    //for (int k=0;k<p_Np;k++) {

      /*---------------------Local Ax operator -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        const dfloat drdx = s_vgeo[p_RXID];
        const dfloat drdy = s_vgeo[p_RYID];
        const dfloat dsdx = s_vgeo[p_SXID];
        const dfloat dsdy = s_vgeo[p_SYID];

        while(m<p_Np){  
          // compute 1D derivatives
          dfloat qr = 0.f, qs = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat p_i = s_p[i];
              qr += DrT[m+i*p_Np]*p_i;
              qs += DsT[m+i*p_Np]*p_i;
            }
    
          s_dpdx[m] = drdx*qr + dsdx*qs;
          s_dpdy[m] = drdy*qr + dsdy*qs;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np){
          s_lapq[m] = lambda*s_p[m];
          m += SIMDSIZE;
        }
        
        m = n;
        while(m<p_NfacesNfp){
          // load surface geofactors for this face
          const int face = m/p_Nfp;
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];
          const dfloat hinv = s_sgeo[face][p_IHID];
          
          const int idm = s_idM[m];
          const dfloat qM = s_p[idm];
          const dfloat qxM = s_dpdx[idm];
          const dfloat qyM = s_dpdy[idm];
          
          dfloat qP = 0.f;
          dfloat qxP = 0.f;
          dfloat qyP = 0.f;
          
          if(s_bc[m]>0) {
            ellipticHomogeneousBC2D(s_bc[m], qM, qxM, qyM, qP, qxP, qyP);
            qP = 2.f*qP - qM;
            qxP = 2.f*qxP - qxM;
            qyP = 2.f*qyP - qyM;
          }
          
          const dfloat dq = qP - qM;
          const dfloat half = 0.5f;

          s_nxdq[m]    = half*sJ*invJ*nx*dq;
          s_nydq[m]    = half*sJ*invJ*ny*dq;
          s_lapflux[m] = half*sJ*invJ*(-nx*(qxP-qxM)-ny*(qyP-qyM)-tau*hinv*dq);
          m += SIMDSIZE;
        }
      }

      
      // dqdx += LIFT*(sJ/J)*nx*dq
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        const dfloat drdx = s_vgeo[p_RXID];
        const dfloat drdy = s_vgeo[p_RYID];
        const dfloat dsdx = s_vgeo[p_SXID];
        const dfloat dsdy = s_vgeo[p_SYID];
        
        int m = n;
        while(m<p_Np){          
          dfloat Lnxdq = 0.f;
          dfloat Lnydq = 0.f;

          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[m+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[m+i*p_Np]*s_nydq[i];
          }

          dfloat dqdx = s_dpdx[m] + Lnxdq;
          dfloat dqdy = s_dpdy[m] + Lnydq;
          s_dpdx[m] = drdx*dqdx + drdy*dqdy; // abuse of notation
          s_dpdy[m] = dsdx*dqdx + dsdy*dqdy;

          s_Lnxdq[m] = Lnxdq;
          s_Lnydq[m] = Lnydq;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_NfacesNfp){
          const int face = m/p_Nfp;
          const int idm = s_idM[m];
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];

          s_lapflux[m] += sJ*invJ*(nx*s_Lnxdq[idm]+ny*s_Lnydq[idm]);
          m += SIMDSIZE;
        }

        m = n;
        while(m<p_Np){
          dfloat lapr = 0.f, laps = 0.f;

          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[m+i*p_Np]*s_dpdx[i];
            laps += DsT[m+i*p_Np]*s_dpdy[i];
          }

          s_lapq[m] -= (lapr+laps);
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np){
          dfloat lap = 0.f;

          // lift remaining surface terms
          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[m+i*p_Np]*s_lapflux[i];
          }

          s_lapq[m] += lap;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m =n;
        while(m<p_Np){
          const dfloat J = s_vgeo[p_JID];

          dfloat Mlapq = 0.f;

          // multiply by mass matrix
          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[m+i*p_Np]*s_lapq[i];
          }
          s_Ap[m] = J*Mlapq;
          m += SIMDSIZE;
        }
      }

      
      /*---------------------p.Ap -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        s_xy[n] = 0.f;
        int m = n;
        while(m<p_Np) {
          s_xy[n] += s_p[m]*s_Ap[m];
          m += SIMDSIZE;
        }
      }
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<16) s_xy[n] += s_xy[n+16];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<8)  s_xy[n] += s_xy[n+8];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<4)  s_xy[n] += s_xy[n+4];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<2)  s_xy[n] += s_xy[n+2];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(n==0) {
          s_pAp = s_xy[0] + s_xy[1];
          s_alpha = s_rdotr/s_pAp;
        }
      }
      /*---------------------End p.Ap -----------------*/    

      /*--------------------- x += alpha*p -----------------*/    
      /*--------------------- r -= alpha*Ap -----------------*/    
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np) {
          s_x[m] += s_alpha* s_p[m];
          s_r[m] -= s_alpha*s_Ap[m];
          m += SIMDSIZE;
        } 
      } 

      /*---------------------r.r -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        s_xy[n] = 0.f;
        int m = n;
        while(m<p_Np) {
          s_xy[n] += s_r[m]*s_r[m];
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 16) s_xy[n] += s_xy[n+16];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 8)  s_xy[n] += s_xy[n+8];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 4)  s_xy[n] += s_xy[n+4];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 2)  s_xy[n] += s_xy[n+2];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(n==0) {
          s_rdotr1 = s_xy[0] + s_xy[1];
          s_beta = s_rdotr1/s_rdotr;
        }
      }
      /*---------------------End r.r -----------------*/    

      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(s_rdotr1 < TOL*TOL) {
          break;
        }
      }
      //precon would go here
    
      /*--------------------- p = beta*p + r -----------------*/    
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np) {
          s_p[m] = s_beta*s_p[m]+s_r[m];
          m += SIMDSIZE;
        }
        if(n==0) s_rdotr = s_rdotr1;
      }
    }
    
    
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      int m = n;
      while(m<p_Np) {
        Sq[e*p_Np+m] = invDegree[e]*s_x[m];
        m += SIMDSIZE;
      }
    }
  }
}
#undef SIMDSIZE

#if 0
//@kernel is blocked into chucks of SIMDSIZE threads manually to avoid barriers
#define SIMDSIZE 32
#define Nnodes 4
occaKernel void ellipticCGLocalPatchTri2D(const int Nelements,
                                      @restrict const  int *  vmapM,
                                      const dfloat lambda,
                                      const dfloat tau,
                                      @restrict const  dfloat *  vgeo,
                                      @restrict const  dfloat *  sgeo,
                                      @restrict const  int   *  EToB,
                                      @restrict const  dfloat *  DrT,
                                      @restrict const  dfloat *  DsT,
                                      @restrict const  dfloat *  LIFTT,
                                      @restrict const  dfloat *  MM,
                                      @restrict const  dfloat *  invDegree,
                                      @restrict const  dfloat *  q,
                                            @restrict dfloat *  Sq,
                                      const dfloat TOL) {

  for(int es=0;es<Nelements;es+=Nnodes;@outer(0)){
    @shared volatile  dfloat s_x[Nnodes][p_Np];
    @shared volatile  dfloat s_r[Nnodes][p_Np];
    @shared volatile  dfloat s_p[Nnodes][p_Np];
    @shared volatile  dfloat s_Ap[Nnodes][p_Np];

    @shared volatile dfloat s_xy[Nnodes][SIMDSIZE];

    @shared volatile dfloat s_rdotr[Nnodes], s_rdotr1[Nnodes], s_pAp[Nnodes], s_alpha[Nnodes], s_beta[Nnodes];
    @shared volatile dfloat s_avgrdotr;

    @shared volatile  dfloat s_dpdx[Nnodes][p_Np];
    @shared volatile  dfloat s_dpdy[Nnodes][p_Np];
    @shared volatile  dfloat s_lapq[Nnodes][p_Np];
    @shared volatile  dfloat s_nxdq[Nnodes][p_NfacesNfp];
    @shared volatile  dfloat s_nydq[Nnodes][p_NfacesNfp];
    @shared volatile  dfloat s_lapflux[Nnodes][p_NfacesNfp];
    @shared volatile  dfloat s_Lnxdq[Nnodes][p_Np];
    @shared volatile  dfloat s_Lnydq[Nnodes][p_Np];
    @shared volatile  dfloat s_vgeo[Nnodes][p_Nvgeo];
    @shared volatile  dfloat s_sgeo[Nnodes][p_Nfaces][p_Nsgeo];
    @shared volatile    int s_idM[Nnodes][p_NfacesNfp], s_bc[Nnodes][p_NfacesNfp];
    
    //fetch q into rhs
    for(int n=0;n<SIMDSIZE;++n;@inner(0)){
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) {
        int m = n;
        while (m<p_Np) {
          s_r[k][m] = q[(es+k)*p_Np+m];
          s_p[k][m] = q[(es+k)*p_Np+m];
          s_x[k][m] = 0.f;
          m += SIMDSIZE;
        }
      }
    }

    // sanity check
    /*---------------------Local Inner product -----------------*/    
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) {
        s_xy[k][n] = 0.f;
        int m = n;
        while (m<p_Np) {
          s_xy[k][n] += s_r[k][m]*s_r[k][m];
          m += SIMDSIZE;
        } 
      }
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) 
        if(n< 16) s_xy[k][n] += s_xy[k][n+16];
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) 
        if(n< 8) s_xy[k][n] += s_xy[k][n+8];
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) 
        if(n< 4) s_xy[k][n] += s_xy[k][n+4];
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) 
        if(n< 2) s_xy[k][n] += s_xy[k][n+2];
    }
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      #pragma unroll Nnodes
      for (int k=0;k<Nnodes;k++) 
        if(n==0)  s_rdotr[k] = s_xy[k][0] + s_xy[k][1]; 

    }
    /*---------------------End Local Inner product -----------------*/    

    if (s_rdotr<TOL*TOL) {
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        int m = n;
        while (m<p_Np) {
          Sq[e*p_Np+m] = invDegree[e]*s_r[m];
          m += SIMDSIZE;
        } 
        return;
      }
    }
    // read in geo data to @shared
    for(int n=0;n<SIMDSIZE;++n;@inner(0)){
      int m = n;
      const int gid = e*p_Nvgeo;
      while(m<p_Nvgeo){
        s_vgeo[m] = vgeo[gid + m];
        m+=SIMDSIZE;
      }

      m = n;
      const int sid = p_Nsgeo*e*p_Nfaces;
      while(m<p_Nsgeo*p_Nfaces){
        s_sgeo[0][m] = sgeo[sid + m];
        m+=SIMDSIZE;
      }

      m = n;
      while(m<p_NfacesNfp){
        const int id  = m + e*p_Nfaces*p_Nfp;
        s_idM[m] = vmapM[id]%p_Np; //local id
         // find face that owns this node
        const int face = m/p_Nfp;
        s_bc[m] = EToB[face+p_Nfaces*e];
        m+=SIMDSIZE;
      }
    }

    //do an inner CG solve
    while(s_rdotr>TOL*TOL) {

    //for (int k=0;k<p_Np;k++) {

      /*---------------------Local Ax operator -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        const dfloat drdx = s_vgeo[p_RXID];
        const dfloat drdy = s_vgeo[p_RYID];
        const dfloat dsdx = s_vgeo[p_SXID];
        const dfloat dsdy = s_vgeo[p_SYID];

        while(m<p_Np){  
          // compute 1D derivatives
          dfloat qr = 0.f, qs = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat p_i = s_p[i];
              qr += DrT[m+i*p_Np]*p_i;
              qs += DsT[m+i*p_Np]*p_i;
            }
    
          s_dpdx[m] = drdx*qr + dsdx*qs;
          s_dpdy[m] = drdy*qr + dsdy*qs;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np){
          s_lapq[m] = lambda*s_p[m];
          m += SIMDSIZE;
        }
        
        m = n;
        while(m<p_NfacesNfp){
          // load surface geofactors for this face
          const int face = m/p_Nfp;
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];
          const dfloat hinv = s_sgeo[face][p_IHID];
          
          const int idm = s_idM[m];
          const dfloat qM = s_p[idm];
          const dfloat qxM = s_dpdx[idm];
          const dfloat qyM = s_dpdy[idm];
          
          dfloat qP = 0.f;
          dfloat qxP = 0.f;
          dfloat qyP = 0.f;
          
          if(s_bc[m]>0) {
            ellipticHomogeneousBC2D(s_bc[m], qM, qxM, qyM, qP, qxP, qyP);
            qP = 2.f*qP - qM;
            qxP = 2.f*qxP - qxM;
            qyP = 2.f*qyP - qyM;
          }
          
          const dfloat dq = qP - qM;
          const dfloat half = 0.5f;

          s_nxdq[m]    = half*sJ*invJ*nx*dq;
          s_nydq[m]    = half*sJ*invJ*ny*dq;
          s_lapflux[m] = half*sJ*invJ*(-nx*(qxP-qxM)-ny*(qyP-qyM)-tau*hinv*dq);
          m += SIMDSIZE;
        }
      }

      
      // dqdx += LIFT*(sJ/J)*nx*dq
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        const dfloat drdx = s_vgeo[p_RXID];
        const dfloat drdy = s_vgeo[p_RYID];
        const dfloat dsdx = s_vgeo[p_SXID];
        const dfloat dsdy = s_vgeo[p_SYID];
        
        int m = n;
        while(m<p_Np){          
          dfloat Lnxdq = 0.f;
          dfloat Lnydq = 0.f;

          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[m+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[m+i*p_Np]*s_nydq[i];
          }

          dfloat dqdx = s_dpdx[m] + Lnxdq;
          dfloat dqdy = s_dpdy[m] + Lnydq;
          s_dpdx[m] = drdx*dqdx + drdy*dqdy; // abuse of notation
          s_dpdy[m] = dsdx*dqdx + dsdy*dqdy;

          s_Lnxdq[m] = Lnxdq;
          s_Lnydq[m] = Lnydq;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_NfacesNfp){
          const int face = m/p_Nfp;
          const int idm = s_idM[m];
          const dfloat nx   = s_sgeo[face][p_NXID];
          const dfloat ny   = s_sgeo[face][p_NYID];
          const dfloat sJ   = s_sgeo[face][p_SJID];
          const dfloat invJ = s_sgeo[face][p_IJID];

          s_lapflux[m] += sJ*invJ*(nx*s_Lnxdq[idm]+ny*s_Lnydq[idm]);
          m += SIMDSIZE;
        }

        m = n;
        while(m<p_Np){
          dfloat lapr = 0.f, laps = 0.f;

          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            lapr += DrT[m+i*p_Np]*s_dpdx[i];
            laps += DsT[m+i*p_Np]*s_dpdy[i];
          }

          s_lapq[m] -= (lapr+laps);
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np){
          dfloat lap = 0.f;

          // lift remaining surface terms
          #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[m+i*p_Np]*s_lapflux[i];
          }

          s_lapq[m] += lap;
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m =n;
        while(m<p_Np){
          const dfloat J = s_vgeo[p_JID];

          dfloat Mlapq = 0.f;

          // multiply by mass matrix
          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[m+i*p_Np]*s_lapq[i];
          }
          s_Ap[m] = J*Mlapq;
          m += SIMDSIZE;
        }
      }

      
      /*---------------------p.Ap -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        s_xy[n] = 0.f;
        int m = n;
        while(m<p_Np) {
          s_xy[n] += s_p[m]*s_Ap[m];
          m += SIMDSIZE;
        }
      }
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<16) s_xy[n] += s_xy[n+16];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<8)  s_xy[n] += s_xy[n+8];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<4)  s_xy[n] += s_xy[n+4];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n<2)  s_xy[n] += s_xy[n+2];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(n==0) {
          s_pAp = s_xy[0] + s_xy[1];
          s_alpha = s_rdotr/s_pAp;
        }
      }
      /*---------------------End p.Ap -----------------*/    

      /*--------------------- x += alpha*p -----------------*/    
      /*--------------------- r -= alpha*Ap -----------------*/    
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np) {
          s_x[m] += s_alpha* s_p[m];
          s_r[m] -= s_alpha*s_Ap[m];
          m += SIMDSIZE;
        } 
      } 

      /*---------------------r.r -----------------*/
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        s_xy[n] = 0.f;
        int m = n;
        while(m<p_Np) {
          s_xy[n] += s_r[m]*s_r[m];
          m += SIMDSIZE;
        }
      }

      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 16) s_xy[n] += s_xy[n+16];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 8)  s_xy[n] += s_xy[n+8];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 4)  s_xy[n] += s_xy[n+4];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) if(n< 2)  s_xy[n] += s_xy[n+2];
      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(n==0) {
          s_rdotr1 = s_xy[0] + s_xy[1];
          s_beta = s_rdotr1/s_rdotr;
        }
      }
      /*---------------------End r.r -----------------*/    

      for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
        if(s_rdotr1 < TOL*TOL) {
          break;
        }
      }
      //precon would go here
    
      /*--------------------- p = beta*p + r -----------------*/    
      for(int n=0;n<SIMDSIZE;++n;@inner(0)){
        int m = n;
        while(m<p_Np) {
          s_p[m] = s_beta*s_p[m]+s_r[m];
          m += SIMDSIZE;
        }
        if(n==0) s_rdotr = s_rdotr1;
      }
    }
    
    
    for(int n=0;n<SIMDSIZE;++n;@inner(0)) {
      int m = n;
      while(m<p_Np) {
        Sq[e*p_Np+m] = invDegree[e]*s_x[m];
        m += SIMDSIZE;
      }
    }
  }
}
#undef SIMDSIZE

#endif