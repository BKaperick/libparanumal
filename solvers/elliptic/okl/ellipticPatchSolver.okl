
// experimental overlapping patch solver
@kernel void ellipticApproxBlockJacobiSolver(const dlong Nelements,
                                              @restrict const  dlong  *  patchesIndex,
                                              @restrict const  dfloat *  invAP,
                                              @restrict const  dfloat *  invDegree,
                                              @restrict const  dfloat *  q,
                                              @restrict dfloat *  invAPq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    @barrier("local");

    // loop over elements/nodes in patch and do local smooth
    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];

          // patch matrices offset
          const dlong offset = patchesIndex[e]*p_Np*p_Np + n;
          dfloat res = 0.f;
          #pragma unroll p_Np
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np ]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}
