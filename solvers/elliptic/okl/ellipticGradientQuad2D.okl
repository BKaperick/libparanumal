// compute local gradients

kernel void ellipticGradientQuad2D(const dlong Nelements,
                                   const dfloat * restrict vgeo,
                                   const dfloat * restrict const D,
                                   const dfloat * restrict q,
                                   dfloat4 * restrict gradq){  

  for(dlong e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_Nq][p_Nq];
    shared dfloat s_q[p_Nq][p_Nq];
    
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){

        // prefetch D
        s_D[j][i] = D[i + p_Nq*j];
        
        // prefetch q
        const dlong id = e*p_Np+j*p_Nq+i;
        s_q[j][i] = q[id];
        
      }
    }
    
    barrier(localMemFence);
    
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        
        const dlong gid = i + j*p_Nq + e*p_Np*p_Nvgeo;
                
        const dfloat drdx = vgeo[gid + p_RXID*p_Np];
        const dfloat drdy = vgeo[gid + p_RYID*p_Np];
        
        const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
        const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

        // compute 1D derivatives
        dfloat qr = 0, qs = 0;
        occaUnroll(p_Nq)
          for(int n=0;n<p_Nq;++n){
            qr += s_D[i][n]*s_q[j][n];
            qs += s_D[j][n]*s_q[n][i];
          }
        
        dfloat4 gradqn;
        gradqn.x = drdx*qr + dsdx*qs;
        gradqn.y = drdy*qr + dsdy*qs;
        gradqn.w = s_q[j][i];
        
        const dlong id = e*p_Np+j*p_Nq+i; 
        gradq[id] = gradqn;
      }
    }
  }
}

kernel void ellipticPartialGradientQuad2D(const dlong Nelements,
                                   const dlong offset,
                                   const dfloat * restrict vgeo,
                                   const dfloat * restrict D,
                                   const dfloat * restrict q,
                                   dfloat4 * restrict gradq){  

  for(dlong e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_Nq][p_Nq];
    shared dfloat s_q[p_Nq][p_Nq];
    
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        // prefetch D
        s_D[j][i] = D[i + p_Nq*j];
        
        // prefetch q
        const dlong id = (e+offset)*p_Np+j*p_Nq+i;
        s_q[j][i] = q[id];
        
      }
    }
    
    barrier(localMemFence);
    
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        
        const dlong gid = i + j*p_Nq + (e+offset)*p_Np*p_Nvgeo;
                
        const dfloat drdx = vgeo[gid + p_RXID*p_Np];
        const dfloat drdy = vgeo[gid + p_RYID*p_Np];
        
        const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
        const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

        // compute 1D derivatives
        dfloat qr = 0, qs = 0;
        occaUnroll(p_Nq)
          for(int n=0;n<p_Nq;++n){
            qr += s_D[i][n]*s_q[j][n];
            qs += s_D[j][n]*s_q[n][i];
          }
        
        dfloat4 gradqn;
        gradqn.x = drdx*qr + dsdx*qs;
        gradqn.y = drdy*qr + dsdy*qs;
        gradqn.w = s_q[j][i];
        
        const dlong id = (e+offset)*p_Np+j*p_Nq+i; 
        gradq[id] = gradqn;
      }
    }
  }
}
