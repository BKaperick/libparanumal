// Compute Gradient in Strong Form
@kernel void mppfVelocityGradientVolumeTri2D(const dlong Nelements,
                                            @restrict const  dfloat *  vgeo,
                                            @restrict const  dfloat *  Dmatrices,
                                            const dlong offset,
                                            @restrict const  dfloat *  U,
                                                 @restrict dfloat *  gradU){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    // for all elements
    @shared dfloat s_U[p_NblockV][p_Np];
    @shared dfloat s_V[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dlong id = e*p_Np + n; 
          s_U[es][n]  = U[id + 0*offset];
          s_V[es][n]  = U[id + 1*offset];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dudr  = 0.f, duds  = 0.f;
          dfloat dvdr  = 0.f, dvds  = 0.f;

          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = Dmatrices[n+i*p_Np+0*p_Np*p_Np];
              const dfloat Dsni = Dmatrices[n+i*p_Np+1*p_Np*p_Np];
              dudr  += Drni*s_U[es][i];
              duds  += Dsni*s_U[es][i];
              dvdr  += Drni*s_V[es][i];
              dvds  += Dsni*s_V[es][i];
            }

          const dlong id = e*p_Np+n;
          gradU[id+0*offset] = drdx*dudr + dsdx*duds;   // dudx
          gradU[id+1*offset] = drdy*dudr + dsdy*duds;   // dudy
          gradU[id+2*offset] = drdx*dvdr + dsdx*dvds;   // dvdx
          gradU[id+3*offset] = drdy*dvdr + dsdy*dvds;   // dvdy

        }
      }
    }
  }
}


@kernel void mppfVelocityGradientSurfaceTri2D(const dlong Nelements,
                                              @restrict const  dfloat *  sgeo,
                                              @restrict const  dfloat *  LIFTT,
                                              @restrict const  dlong  *  vmapM,
                                              @restrict const  dlong  *  vmapP,
                                              @restrict const  int    *  EToB,
                                              @restrict const  dfloat *  x,
                                              @restrict const  dfloat *  y,
                                              @restrict const  dfloat *  z,
                                              const dfloat time,
                                              const dlong offset,
                                              @restrict const  dfloat *  U,
                                              @restrict  dfloat *  gradU){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxVx[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxVy[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            const int face = n/p_Nfp;
            // load surface geofactors for this face
            const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            const dlong id  = e*p_Nfp*p_Nfaces + n;
            const dlong idM = vmapM[id];
            const dlong idP = vmapP[id];

            // load negative and positive trace node values of U, V, Pr
            const dfloat  uM = U[idM+0*offset], vM = U[idM+1*offset];
                  dfloat  uP = U[idP+0*offset], vP = U[idP+1*offset];

            // apply boundary condition
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              mppfVelocityDirichletConditions2D(bc, time, x[idM], y[idM], nx, ny, uM, vM, &uP, &vP);  
              uP = 2.f*uP - uM; // Strong form bcs
              vP = 2.f*vP - vM; // Strong form bcs
            }

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;
            // Centered flux for pr = 0.5(Up-Um) // Central Flux
            s_fluxUx[es][n]  = sc*(.5f*nx*(uP-uM));
            s_fluxUy[es][n]  = sc*(.5f*ny*(uP-uM));
            s_fluxVx[es][n]  = sc*(.5f*nx*(vP-vM));
            s_fluxVy[es][n]  = sc*(.5f*ny*(vP-vM));
          }
        }
      }
    }

    // wait for all flux functions are written to @shared
    @barrier("local");

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const dlong id = e*p_Np + n;;

            dfloat dudx  = 0.f; 
            dfloat dudy  = 0.f; 
            dfloat dvdx  = 0.f; 
            dfloat dvdy  = 0.f; 
                         // Lift
            #pragma unroll p_NfacesNfp
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                const dfloat L = LIFTT[n+m*p_Np];
                dudx += L*s_fluxUx[es][m];
                dudy += L*s_fluxUy[es][m];
                dvdx += L*s_fluxVx[es][m];
                dvdy += L*s_fluxVy[es][m];
              }
          // Add surface contribution
          gradU[id+0*offset] += dudx;
          gradU[id+1*offset] += dudy;
          gradU[id+2*offset] += dvdx;
          gradU[id+3*offset] += dvdy;
          }
        }
      }
    }

    }
  }

