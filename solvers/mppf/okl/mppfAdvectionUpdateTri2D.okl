// rhsU^s = MM*(U^n - \sum^s-1 ea_si N(U^i) + \sum^s-1 ia_si LU^i - \sum^s-1 pa_si GP^i)/ia_ss nu dt
@kernel void mppfAdvectionUpdateTri2D(const dlong Nelements,
                                @restrict const  dfloat *  vgeo,
                                @restrict const  dfloat *  Dmatrices,
                                @restrict const  dfloat *  x,
                                @restrict const  dfloat *  y,
                                @restrict const  dfloat *  z,
                                const dfloat dt,
                                const dfloat time,
                                @restrict const  dfloat *  extbdfA,
                                @restrict const  dfloat *  extbdfB,
                                const dlong fieldOffset,
                                @restrict const  dfloat *  U,
                                @restrict const  dfloat *  Rho,
                                @restrict const  dfloat *  Mu,
                                @restrict const  dfloat *  GMu,
                                @restrict const  dfloat *  NU,
                                @restrict const  dfloat *  GU,
                                @restrict const  dfloat *  GP,
                                @restrict const  dfloat *  Psi,
                                @restrict const  dfloat *  GPhi,
                                      @restrict dfloat *   Uhat){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_rhsU[p_NblockV][p_Np];
    
    @exclusive dfloat curlx, curly; 

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dlong id = n + p_Np*e;
          // const dfloat J = vgeo[e*p_Nvgeo + p_JID];
          // First compute the surface tension and viscous stress tensor using gradient data
          // wz =  dv/dx- du/dy;
          s_rhsU[es][n]  = GU[id + 3*fieldOffset] - GU[id + 2*fieldOffset];
          }
        }
      } 

    // Make sure all node data is loaded into @shared
      @barrier("local");


      for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){           
        const dlong e = eo+es; 
        if(e<Nelements){          
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
          // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat dwdr = 0.f, dwds = 0.f; 
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = Dmatrices[n+i*p_Np+0*p_Np*p_Np];
              const dfloat Dsni = Dmatrices[n+i*p_Np+1*p_Np*p_Np];
              dwdr += Drni*s_rhsU[es][i];
              dwds += Dsni*s_rhsU[es][i];
            }

          curlx  =   drdy*dwdr + dsdy*dwds;  // dw/dy 
          curly  = -(drdx*dwdr + dsdx*dwds); //-dw/dx      
        }
      }
    }

    // Make sure all node data is loaded into @shared
      @barrier("local");

      for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){           
        const dlong e = eo+es; 
        if(e<Nelements){  
          const dlong id = n + p_Np*e;
          
          dfloat rhsu = 0.;
          dfloat rhsv = 0.;

          const dfloat invrho  = 1.f / Rho[id];
          const dfloat mu      = Mu[id];
          const dfloat gmux    = GMu[id + 0*fieldOffset];
          const dfloat gmuy    = GMu[id + 1*fieldOffset];


          for (int s=0;s<p_Nstages;s++) {
            //U 
            const dfloat Um  = U[id+0*fieldOffset+s*p_NVfields*fieldOffset];
            const dfloat Vm  = U[id+1*fieldOffset+s*p_NVfields*fieldOffset];

            // NU
            const dfloat NUm  = NU[id+0*fieldOffset+s*p_NVfields*fieldOffset];
            const dfloat NVm  = NU[id+1*fieldOffset+s*p_NVfields*fieldOffset];

            // GP
            const dfloat GPx  = GP[id+0*fieldOffset+s*p_NVfields*fieldOffset];
            const dfloat GPy  = GP[id+1*fieldOffset+s*p_NVfields*fieldOffset];

            rhsu +=  extbdfB[s]*Um  - dt*extbdfA[s]*(NUm - (p_invrho0 - invrho)*GPx);
            rhsv +=  extbdfB[s]*Vm  - dt*extbdfA[s]*(NVm - (p_invrho0 - invrho)*GPy);
          }

          // Add surface tension
          rhsu += dt*(-mu*invrho)*curlx;
          rhsv += dt*(-mu*invrho)*curly;

          const dfloat dudx = GU[id + 0*fieldOffset];
          const dfloat dudy = GU[id + 1*fieldOffset];
          const dfloat dvdx = GU[id + 2*fieldOffset];
          const dfloat dvdy = GU[id + 3*fieldOffset];
          // Add explicit viscous stress 
          rhsu += dt*(invrho)*(gmux*(2.f*dudx) + gmuy*(dudy + dvdx));
          rhsv += dt*(invrho)*(gmux*(dudy + dvdx) + gmuy*(2.f*dvdy));


          const dfloat psi  = Psi[id];
          const dfloat phix = GPhi[id + 0*fieldOffset];
          const dfloat phiy = GPhi[id + 1*fieldOffset];

          // Add explicit viscous stress 
          rhsu -= dt*p_chL*(invrho)*(psi*phix);
          rhsv -= dt*p_chL*(invrho)*(psi*phiy);

          // Add explicit viscous stress 
          #if 1            
          dfloat fbx = 0.f; 
          dfloat fby = 0.f; 
          mppfVelocitySource2D(time,x[id],y[id],&fbx, &fby);
          #endif
          rhsu += dt*fbx;
          rhsv += dt*fby;



          Uhat[id + 0*fieldOffset] = rhsu;
          Uhat[id + 1*fieldOffset] = rhsv;
        }
      }
    }

    // // make sure all node data is loaded into @shared
    // @barrier("local");

    // for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
    //   for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
    //     const dlong e = eo+es; // element in block
    //     if(e<Nelements){
    //       // Multiplay with Mass Matrix
    //       const dlong id = e*p_Np+n;

    //       dfloat rhsu = 0.f, rhsv = 0.f;
    //       #pragma unroll p_Np
    //         for(int i=0;i<p_Np;++i){
    //           const dfloat M = MM[n+i*p_Np];
    //           rhsu  += M*rhsu;
    //           rhsv  += M*s_rhsV[es][i];
    //         }
    //       // Update
    //       rhsU[id] = rhsu;
    //       rhsV[id] = rhsv;
    //     }
    //   }
    // }
  }
}