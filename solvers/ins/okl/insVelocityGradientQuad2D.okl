@kernel void insVelocityGradientQuad2D(const dlong Nelements,
                                   const dlong offset,
                                   @restrict const  dfloat *  vgeo,
                                   @restrict const  dfloat *  D,
                                   const dlong fieldOffset,
                                   @restrict const  dfloat *  U,
                                   @restrict dfloat4 *  GU){  

  for(dlong e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_D[p_Nq][p_Nq];
    @shared dfloat s_q[p_Nq][p_Nq];
    
    #pragma unroll p_NVfields
    for (int fld=0; fld<p_NVfields; fld++) {

      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          // prefetch D
          s_D[j][i] = D[i + p_Nq*j];
          
          // prefetch q
          const dlong id = (e+offset)*p_Np+j*p_Nq+i;
          s_q[j][i] = U[id+fld*fieldOffset];
          
        }
      }
      
      @barrier("local");
      
      for(int j=0;j<p_Nq;++j;@inner(1)){
        for(int i=0;i<p_Nq;++i;@inner(0)){
          
          const dlong gid = i + j*p_Nq + (e+offset)*p_Np*p_Nvgeo;
                  
          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

          // compute 1D derivatives
          dfloat qr = 0, qs = 0;
          #pragma unroll p_Nq
            for(int n=0;n<p_Nq;++n){
              qr += s_D[i][n]*s_q[j][n];
              qs += s_D[j][n]*s_q[n][i];
            }
          
          dfloat4 gradqn;
          gradqn.x = drdx*qr + dsdx*qs;
          gradqn.y = drdy*qr + dsdy*qs;
          gradqn.w = s_q[j][i];
          
          const dlong id = (e+offset)*p_Np+j*p_Nq+i; 
          GU[id+fld*fieldOffset] = gradqn;
        }
      }
    }
  }
}