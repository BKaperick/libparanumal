// holmes/solvers/gradient/src/gradientReport2.c
// extract isosurfaces, compact tri data, export for gmsh
// 2018/06/02
//---------------------------------------------------------
#include "gradient.h"

int weldTriVerts(gradient_t *gradient, int isoNtris, double *isoq);

void gradientWriteIsoGmsh(
  gradient_t *gradient, 
  int isoNtris, 
  char *fname,
  int tstep,        // simulation time-step
  int N_offset,     // gmsh mpi node offset
  int E_offset,     // gmsh mpi element offset
  int plotnum,      // plot counter
  double plottime,  // simulation time
  bool bBinary);


void gradientReport(gradient_t *gradient, dfloat time, setupAide &options){

  int rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  mesh3D *mesh = gradient->mesh;

  int isoField = 3;
  int isoNlevels = 6;
  int isoMaxNtris = 1E6;
  
  dfloat *isoLevels = (dfloat*) calloc(isoNlevels, sizeof(dfloat));
  int *isoNtris = (int*) calloc(1, sizeof(int));

  size_t isoMax = (mesh->dim + gradient->Nfields)*3*isoMaxNtris;
  dfloat *isoq = (dfloat*) calloc(isoMax, sizeof(dfloat));

  dfloat isoMinVal = -0.8;
  dfloat isoMaxVal =  0.8;

  for(int l=0;l<isoNlevels;++l){
    isoLevels[l] = isoMinVal + (isoMaxVal-isoMinVal)*l/(dfloat)(isoNlevels-1);
  }
  occa::memory o_isoLevels = mesh->device.malloc(isoNlevels*sizeof(dfloat), isoLevels);
  occa::memory o_isoq      = mesh->device.malloc(isoMax*sizeof(dfloat), isoq);

  // note that this should be zero before calling isoSurface kernel
  occa::memory o_isoNtris  = mesh->device.malloc(1*sizeof(int), isoNtris);

  gradient->isoSurfaceKernel(
    mesh->Nelements,    // number of elements
    isoField,     // which field to use for isosurfacing
    isoNlevels,   // number of isosurface levels
    o_isoLevels,  // array of isosurface levels
    isoMaxNtris,  // maximum number of generated triangles
    mesh->o_x,
    mesh->o_y,
    mesh->o_z,
    gradient->o_q,
    gradient->o_plotInterp,
    gradient->o_plotEToV,
    o_isoNtris,   // output: number of generated triangles
    o_isoq);      // output: (p_dim+p_Nfields)*3*isoNtris[0] values (x,y,z,q0,q1..)

  // find number of generated triangles
  o_isoNtris.copyTo(isoNtris);
  isoNtris[0] = mymin(isoNtris[0], isoMaxNtris);

  printf("generated %d triangles\n", isoNtris[0]);

  int offset = 0;
  o_isoq.copyTo(isoq, isoNtris[0]*(mesh->dim+gradient->Nfields)*3*sizeof(dfloat), offset);

  // output field files
  char fname[BUFSIZ];
  string outName;
  options.getArgs("OUTPUT FILE NAME", outName);

  // NBN: compact trimesh data
  //#######################################################
  // Ntris1 = num tris generated by kernel
  // Ntris2 = Ntris1 - Ndegenerate tris
  int Ntris1 = isoNtris[0];
  int Ntris2 = weldTriVerts(gradient, Ntris1, isoq);
  //#######################################################

  int plotnum = gradient->frame;
  int N_offset = 0;         // Gmsh mpi node offset
  int E_offset = 0;         // Gmsh mpi element offset
  double plottime = 0.0;    // record time
//bool bBinary = false;     // toggle binary/ascii
  bool bBinary = true;      // toggle binary/ascii
  int tstep = plotnum;      // dummy time-step

  sprintf(fname, "%s_%04d_%04d.msh",(char*)outName.c_str(), rank, gradient->frame++);
  gradientWriteIsoGmsh(gradient, Ntris2, fname, tstep, N_offset, E_offset, plotnum, plottime,bBinary);

  free(isoq);
}
