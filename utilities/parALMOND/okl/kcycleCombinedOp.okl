#define p_RDIMX 32
#define p_RDIMY 8

// used a macro since I am not sure what happens with exclusive variables in OpenMP mode
#define twoPhaseReduction(r_ip, s_ip, s_res, g_ip)		\
  							\
  barrier(localMemFence);					\
								\
  for(int ty=0;ty<p_RDIMY;++ty;inner1){				\
    for(int tx=0;tx<p_RDIMX;++tx;inner0){			\
      s_ip[ty][tx] = r_ip;					\
      if(tx<p_RDIMX/2) s_ip[ty][tx] += s_ip[ty][tx+p_RDIMX/2];	\
      if(tx<p_RDIMX/4) s_ip[ty][tx] += s_ip[ty][tx+p_RDIMX/4];	\
      if(tx<p_RDIMX/8) s_ip[ty][tx] += s_ip[ty][tx+p_RDIMX/8];	\
      if(tx<p_RDIMX/16)s_ip[ty][tx] += s_ip[ty][tx+p_RDIMX/16];	\
      if(tx<p_RDIMX/32)s_ip[ty][tx] += s_ip[ty][tx+p_RDIMX/32];	\
      if(tx==0) s_res[ty] = s_ip[ty][tx];			\
    }								\
  }								\
								\
  barrier(localMemFence);					\
								\
  for(int ty=0;ty<p_RDIMY;++ty;inner1){				\
    for(int tx=0;tx<p_RDIMX;++tx;inner0){			\
      if(ty==0){						\
      	if(tx<p_RDIMY/2)  s_res[tx] += s_res[tx+p_RDIMY/2];	\
      	if(tx<p_RDIMY/4)  s_res[tx] += s_res[tx+p_RDIMY/4];	\
      	if(tx<p_RDIMY/8)  s_res[tx] += s_res[tx+p_RDIMY/8];	\
      	if(tx<p_RDIMY/16) s_res[tx] += s_res[tx+p_RDIMY/16];	\
      	if(tx<p_RDIMY/32) s_res[tx] += s_res[tx+p_RDIMY/32];	\
      	if(tx==0) { \
          atomicAdd(g_ip, s_res[0]);			\
        } \
      }								\
    }								\
  }

// a.b, a.c, b.b
kernel void kcycleCombinedOp1Kernel(const int outerDim0,
					      const int   N,
					      const datafloat *restrict a,
					      const datafloat *restrict b,
					      const datafloat *restrict c,
					      datafloat *ips){

  for(int g=0;g<outerDim0;++g;outer0){

    shared volatile datafloat s_ip[p_RDIMY][p_RDIMX];
    shared datafloat s_res[p_RDIMY];

    exclusive datafloat abi, aci, bbi;
    
    for(int ty=0;ty<p_RDIMY;++ty;inner1){
      for(int tx=0;tx<p_RDIMX;++tx;inner0){
	      int i = tx + ty*p_RDIMX + g*p_RDIMX*p_RDIMY;

      	abi = 0.f;
      	aci = 0.f;
      	bbi = 0.f;
      	
      	while(i<N){ // scan through whole array
      	  const datafloat ai =  a[i];
      	  const datafloat bi =  b[i];
      	  const datafloat ci =  c[i];
      	  abi += ai*bi;
      	  aci += ai*ci;
      	  bbi += bi*bi;
      	  i += outerDim0*p_RDIMX*p_RDIMY; 
      	}
      }
    }

    twoPhaseReduction(abi, s_ip, s_res, ips+0);
    twoPhaseReduction(aci, s_ip, s_res, ips+1);
    twoPhaseReduction(bbi, s_ip, s_res, ips+2);
  }
}

// a.b, a.c, b.b
kernel void kcycleCombinedOp2Kernel(const int outerDim0,
                const int   N,
                const datafloat *restrict a,
                const datafloat *restrict b,
                const datafloat *restrict c,
                const datafloat *restrict d,
                datafloat *ips){

  for(int g=0;g<outerDim0;++g;outer0){

    shared volatile datafloat s_ip[p_RDIMY][p_RDIMX];
    shared datafloat s_res[p_RDIMY];

    exclusive datafloat abi, aci, adi;
    
    for(int ty=0;ty<p_RDIMY;++ty;inner1){
      for(int tx=0;tx<p_RDIMX;++tx;inner0){
        int i = tx + ty*p_RDIMX + g*p_RDIMX*p_RDIMY;

        abi = 0.f;
        aci = 0.f;
        adi = 0.f;
        
        while(i<N){ // scan through whole array
          const datafloat ai =  a[i];
          const datafloat bi =  b[i];
          const datafloat ci =  c[i];
          const datafloat di =  d[i];
          abi += ai*bi;
          aci += ai*ci;
          adi += ai*di;
          i += outerDim0*p_RDIMX*p_RDIMY; 
        }
      }
    }

    twoPhaseReduction(abi, s_ip, s_res, ips+0);
    twoPhaseReduction(aci, s_ip, s_res, ips+1);
    twoPhaseReduction(adi, s_ip, s_res, ips+2);
  }
}
    
