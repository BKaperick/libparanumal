// Compute volume term: weak implementation
kernel void mnsReinitializationVolumeTri2D(const dlong Nelements,
                                   const dfloat * restrict vgeo,
                                   const dfloat * restrict Dmatrices,
                                   const dlong offset,
                                   const dfloat * restrict Phi,
                                         dfloat * restrict GPhi){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    // for all elements
    shared dfloat s_Phi[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          s_Phi[es][n]  = Phi[n + e*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dpdr  = 0.f, dpds  = 0.f;
          occaUnroll(p_Np)
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = Dmatrices[n+i*p_Np+0*p_Np*p_Np];
              const dfloat Dsni = Dmatrices[n+i*p_Np+1*p_Np*p_Np];
              // const dfloat Drni = Dmatrices[i+n*p_Np+0*p_Np*p_Np];
              // const dfloat Dsni = Dmatrices[i+n*p_Np+1*p_Np*p_Np];

              dpdr  += Drni*s_Phi[es][i];
              dpds  += Dsni*s_Phi[es][i];
            }

          const dlong id = e*p_Np+n;
          GPhi[id+0*offset] = (drdx*dpdr + dsdx*dpds); // dphi/dx 
          GPhi[id+1*offset] = (drdy*dpdr + dsdy*dpds); // dphi/dy
        }
      }
    }
  }
}

kernel void mnsReinitializationSurfaceTri2D(const dlong Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict LIFTT,
                                            const dlong  * restrict vmapM,
                                            const dlong  * restrict vmapP,
                                            const int    * restrict EToB,
                                            const dfloat * restrict x,
                                            const dfloat * restrict y,
                                            const dfloat * restrict z,
                                            const dfloat time,
                                            const dlong offset,
                                            const dfloat * restrict Phi,
                                            const dfloat * restrict SPhi,
                                            const dfloat * restrict GPhi,
                                                  dfloat * restrict rhsPhi){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    shared dfloat s_fluxP1[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxP2[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxQ1[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxQ2[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            const int face = n/p_Nfp;
            // load surface geofactors for this face
            const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            const dlong id = e*p_Nfp*p_Nfaces + n;
            const dlong idM = vmapM[id];
            const dlong idP = vmapP[id];
          
            const dfloat PhiM = Phi[idM];
                  dfloat PhiP = Phi[idP];

            // apply boundary condition
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              mnsLevelSetBoundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, PhiM, &PhiP);
              // PP = 2.f*PP - PM; //Strong form BCs
            }

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;
            // Directional upwind
            dfloat fp1 = (nx>0) ? PhiP:PhiM ; // right upwind 
            dfloat fp2 = (nx>0) ? PhiM:PhiP ; // left upwind 
            dfloat fq1 = (ny>0) ? PhiP:PhiM ; 
            dfloat fq2 = (ny>0) ? PhiM:PhiP ; 
          
            s_fluxP1[es][n]  = sc*nx*(fp1-PhiM);
            s_fluxP2[es][n]  = sc*nx*(fp2-PhiM);
            s_fluxQ1[es][n]  = sc*ny*(fq1-PhiM);
            s_fluxQ2[es][n]  = sc*ny*(fq2-PhiM);

          }
        }
      }
    }

    // wait for all flux functions are written to shared
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const dlong id = e*p_Np + n;
            dfloat sgnPhi = SPhi[id]; 
            dfloat p1     = GPhi[id+0*offset];
            dfloat q1     = GPhi[id+1*offset];
            // Same Volume Kernel
            dfloat p2 = p1; 
            dfloat q2 = q1; 
            occaUnroll(p_NfacesNfp)
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                const dfloat L = LIFTT[n+m*p_Np];
                p1 += L*s_fluxP1[es][m];
                p2 += L*s_fluxP2[es][m];
                q1 += L*s_fluxQ1[es][m];
                q2 += L*s_fluxQ2[es][m];
              }

              dfloat zero = 0.f;
              dfloat rhs  = 0.f;  
              #if 0   // LLF Numerical Hemiltonian
              dfloat p = 0.5f*(p1 + p2); 
              dfloat q = 0.5f*(q1 + q2); 
              rhs= -sgnPhi*( sqrt(p*p + q*q) -1.0f) + 0.5f*(p1-p2) + 0.5*(q1-q2);       
              #else  // Compute Simplified Godunov flux for Hemiltonian
              
              dfloat p1p = occaMax(p1,zero); 
              dfloat p1m = occaMin(p1,zero);
              dfloat p2p = occaMax(p2,zero); 
              dfloat p2m = occaMin(p2,zero);
              
              dfloat q1p = occaMax(q1,zero); 
              dfloat q1m = occaMin(q1,zero);
              dfloat q2p = occaMax(q2,zero); 
              dfloat q2m = occaMin(q2,zero);

             
              if(sgnPhi>0)
                rhs= -sgnPhi*(occaSqrt(occaMax(p1m*p1m, p2p*p2p) + occaMax(q1m*q1m, q2p*q2p)) -1.0f); 
              else                  
                rhs= -sgnPhi*(occaSqrt(occaMax(p1p*p1p, p2m*p2m) + occaMax(q1p*q1p, q2m*q2m)) -1.0f); 

              #endif

              rhsPhi[id] = rhs; 

            
          }
        }
      }
    }
  }
}

