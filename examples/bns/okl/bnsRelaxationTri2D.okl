// MRAB relaxation cub
kernel void bnsRelaxationTri2D(const dlong Nelements,
                               const dlong * restrict elementIds,
                               const dfloat * restrict cubInterpT,
                               const dfloat * restrict cubProjectT,
                               const dfloat * restrict q,
                                     dfloat * restrict rhsq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_NblockCub;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockCub][p_Nfields][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockCub][p_cubNp];
    shared dfloat s_cubN5[p_NblockCub][p_cubNp];
    shared dfloat s_cubN6[p_NblockCub][p_cubNp];

    exclusive dlong e;

    // prefetch q to shared
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){    
    
    dlong et = eo+es; // element in block
    if(et<Nelements){
      e = elementIds[et];

      if(n<p_Np){
        const dlong id = e*p_Nfields*p_Np + n;

        occaUnroll(p_Nfields)
        for(int fld=0; fld<p_Nfields;++fld){
          s_q[es][fld][n] = q[id+fld*p_Np];
        }

      }
     }
    }
   }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
    dlong et = eo+es; // element in block
    if(et<Nelements){
      if(n<p_cubNp){
        dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
        dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
        
        occaUnroll(p_Np)
        for(int m=0;m<p_Np;++m){
          const dfloat Icn  = cubInterpT[m*p_cubNp+n];
          cubq1 += Icn*s_q[es][0][m];
          cubq2 += Icn*s_q[es][1][m];
          cubq3 += Icn*s_q[es][2][m];
          cubq4 += Icn*s_q[es][3][m];
          cubq5 += Icn*s_q[es][4][m];
          cubq6 += Icn*s_q[es][5][m];
        }
       
        dfloat icubq1 = 1.f/cubq1;
        // BGK relaxation approximation to the Boltzmann collision operator
        s_cubN4[es][n] = -p_tauInv*(cubq4 -            cubq2*cubq3*icubq1);
        s_cubN5[es][n] = -p_tauInv*(cubq5 - p_invsqrt2*cubq2*cubq2*icubq1);
        s_cubN6[es][n] = -p_tauInv*(cubq6 - p_invsqrt2*cubq3*cubq3*icubq1);
      }
    }
      }
    }

    //make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
        dlong et = eo+es; // element in block
        if(et<Nelements){
            if(n<p_Np){
             //Update 
                // const dlong id    = p_Nfields*(e*p_Np + n);
                // const dlong rhsId = nrhs*id + p_Nfields*shift;

                const dlong id    = e*p_Nfields*p_Np + n;
                const dlong rhsId = id ; 

                dfloat N4 = rhsq[rhsId + 3*p_Np];
                dfloat N5 = rhsq[rhsId + 4*p_Np];
                dfloat N6 = rhsq[rhsId + 5*p_Np];
                
                occaUnroll(p_cubNp)
                for(int i=0;i<p_cubNp;++i){
                  const dfloat Pnc  = cubProjectT[i*p_Np+n];
                  N4 += Pnc*s_cubN4[es][i];
                  N5 += Pnc*s_cubN5[es][i];
                  N6 += Pnc*s_cubN6[es][i];
                }

              // Update  
              rhsq[rhsId + 3*p_Np] = N4;
              rhsq[rhsId + 4*p_Np] = N5;
              rhsq[rhsId + 5*p_Np] = N6;
        
           }
         }
        }
     }
  }
}



// Fully Explicit Scheme Uses Clasical half Half Splitting
kernel void bnsPmlRelaxationTri2D(const dlong pmlNelements,
                                  const dlong * restrict pmlElementIds,
                                  const dlong * restrict pmlIds,
                                  const dfloat * restrict cubInterpT,
                                  const dfloat * restrict cubProjectT,
                                  const dfloat * restrict pmlSigmaX,
                                  const dfloat * restrict pmlSigmaY, 
                                  const dfloat * restrict pmlSigmaZ, 
                                  const dfloat * restrict q,
                                  const dfloat * restrict pmlqx,
                                  const dfloat * restrict pmlqy,
                                  const dfloat * restrict pmlqz,
                                        dfloat * restrict rhsq,
                                        dfloat * restrict pmlrhsqx,
                                        dfloat * restrict pmlrhsqy,
                                        dfloat * restrict pmlrhsqz){

    for(dlong eo=0;eo<pmlNelements;eo+=p_NblockCub;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat  s_q[p_NblockCub][p_Nfields][p_Np];
    shared dfloat s_qx[p_NblockCub][p_Nfields][p_Np];
    shared dfloat s_qy[p_NblockCub][p_Nfields][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubq[p_NblockCub][p_Nfields][p_cubNp];
    shared dfloat s_cubqx[p_NblockCub][p_Nfields][p_cubNp];
    shared dfloat s_cubqy[p_NblockCub][p_Nfields][p_cubNp];
   
    exclusive dlong e, pmlId;

    // prefetch q to shared
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){      
        const dlong et = eo+es; // element in block
        if(et<pmlNelements){
            e     = pmlElementIds[et];
            pmlId = pmlIds[et];
            
            if(n<p_Np){

              const dlong id  = e*p_Nfields*p_Np + n;
              const dlong pid = pmlId*p_Nfields*p_Np + n;
              
              occaUnroll(p_Nfields)
              for(int fld=0; fld<p_Nfields;++fld){
                s_q[es][fld][n]   = q[id +fld*p_Np];
                s_qx[es][fld][n]  = pmlqx[pid+fld*p_Np];
                s_qy[es][fld][n]  = pmlqy[pid+fld*p_Np];
              }
            }
         }
       }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){     
        const dlong et = eo+es; // element in block
        if(et<pmlNelements){
          if(n<p_cubNp){
            dfloat r_q[p_Nfields];
            dfloat r_qx[p_Nfields];
            dfloat r_qy[p_Nfields];
            
            occaUnroll(p_Nfields)
            for(int fld=0; fld<p_Nfields ; fld++){
              r_q[fld]  = 0.f;
              r_qx[fld] = 0.f;
              r_qy[fld] = 0.f;
            }
            
            occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              const dfloat Icn  = cubInterpT[m*p_cubNp+n];   
              occaUnroll(p_Nfields)
              for(int fld=0; fld<p_Nfields;++fld){
                r_q[fld]  += Icn*s_q[es][fld][m];
                r_qx[fld] += Icn*s_qx[es][fld][m];
                r_qy[fld] += Icn*s_qy[es][fld][m];
              }
            }
            
            // Prefetch sigma
            const dfloat sigmaxe = pmlSigmaX[pmlId*p_cubNp+n];
            const dfloat sigmaye = pmlSigmaY[pmlId*p_cubNp+n];
            // M-PML sigma midification
            const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
            const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;
            
            occaUnroll(p_Nfields)
            for(int fld=0; fld<p_Nfields ; fld++){
              s_cubqx[es][fld][n]= -msigmaxe*r_qx[fld];
              s_cubqy[es][fld][n]= -msigmaye*r_qy[fld];
              s_cubq[es][fld][n] = -msigmaxe*r_qx[fld]-msigmaye*r_qy[fld];
            }
            
            
            dfloat icubq1 = 1.f/r_q[0];
            // BGK relaxation approximation to the Boltzmann collision operator
            s_cubq[es][3][n] -= p_tauInv*(r_q[3]-(           r_q[1]*r_q[2]*icubq1));
            s_cubq[es][4][n] -= p_tauInv*(r_q[4]-(p_invsqrt2*r_q[1]*r_q[1]*icubq1));
            s_cubq[es][5][n] -= p_tauInv*(r_q[5]-(p_invsqrt2*r_q[2]*r_q[2]*icubq1));
          }
        }
      }
    }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(int es=0;es<p_NblockCub;++es;inner1){
      for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
        const dlong et = eo+es; // element in block
          if(et<pmlNelements){
            if(n<p_Np){
          // Update
              // const int rhsId    = nrhs*p_Nfields*(p_Np*e + n)     + p_Nfields*shift;
              // const int pmlrhsId = nrhs*p_Nfields*(p_Np*pmlId + n) + p_Nfields*shift;
              const dlong rhsId    = e*p_Nfields*p_Np + n;
              const dlong pmlrhsId = pmlId*p_Nfields*p_Np + n;

              dfloat r_rhsq[p_Nfields];
              dfloat r_rhsqx[p_Nfields];
              dfloat r_rhsqy[p_Nfields]; 
              // dfloat r_rhsqt[p_Nfields];
            
              occaUnroll(p_Nfields)
              for(int fld=0; fld<p_Nfields;++fld){
                r_rhsq[fld]  = rhsq[rhsId + fld*p_Np];
                r_rhsqx[fld] = pmlrhsqx[pmlrhsId + fld*p_Np];
                r_rhsqy[fld] = pmlrhsqy[pmlrhsId + fld*p_Np];
              }

              // use temporaries for part sums for N4,N5,N6 because of exclusives
              occaUnroll(p_cubNp)
              for(int m=0;m<p_cubNp;++m){
                const dfloat Pnc  = cubProjectT[m*p_Np+n];                  
                 occaUnroll(p_Nfields)
                 for(int fld=0; fld<p_Nfields; fld++){
                  r_rhsq [fld] += Pnc*s_cubq[es][fld][m];
                  r_rhsqx[fld] += Pnc*s_cubqx[es][fld][m];
                  r_rhsqy[fld] += Pnc*s_cubqy[es][fld][m];
                 }
              }
                
             occaUnroll(p_Nfields) 
             for(int fld=0; fld<p_Nfields;++fld){
                pmlrhsqx[pmlrhsId + fld*p_Np] = r_rhsqx[fld];
                pmlrhsqy[pmlrhsId + fld*p_Np] = r_rhsqy[fld];
                rhsq[rhsId + fld*p_Np]        = r_rhsq[fld];
              }   
          }
        }
      }
    }

  }
}








// // MRAB relaxation cub
// kernel void boltzmannSARelaxationCub2D(const int Nelements,
//                          const int * restrict elementIds,
//                          const int nrhs, 
//                          const int shift,
//                          const dfloat * restrict cubInterpT,
//                          const dfloat * restrict cubProjectT,
//                          const dfloat * restrict q,
//                                dfloat * restrict rhsq){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockCub;outer0){  // for all elements

//     // shared memory for q at nodes
//     shared dfloat s_q[p_NblockCub][p_Nfields][p_Np];

//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     shared dfloat s_cubN4[p_NblockCub][p_cubNp];
//     shared dfloat s_cubN5[p_NblockCub][p_cubNp];
//     shared dfloat s_cubN6[p_NblockCub][p_cubNp];

//     exclusive int e;

//     // prefetch q to shared
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){    
    
//     int et = eo+es; // element in block
//     if(et<Nelements){
//       e = elementIds[et];

//       if(n<p_Np){
//         const int id = p_Nfields*(e*p_Np + n);
//         occaUnroll(p_Nfields)
//         for(int fld=0; fld<p_Nfields;++fld){
//           s_q[es][fld][n] = q[id+fld];
//         }
//       }

//      }
//     }
//    }
    
//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
//     int et = eo+es; // element in block
//     if(et<Nelements){
//       if(n<p_cubNp){
//         dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
//         dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
        
//         occaUnroll(p_Np)  
//         for(int m=0;m<p_Np;++m){
//           const dfloat Icn  = cubInterpT[m*p_cubNp+n];
//           cubq1 += Icn*s_q[es][0][m];
//           cubq2 += Icn*s_q[es][1][m];
//           cubq3 += Icn*s_q[es][2][m];
//           cubq4 += Icn*s_q[es][3][m];
//           cubq5 += Icn*s_q[es][4][m];
//           cubq6 += Icn*s_q[es][5][m];
//         }
//         //
//         dfloat icubq1 = 1.f/cubq1;

//         // BGK relaxation approximation to the Boltzmann collision operator
//         s_cubN4[es][n] = p_tauInv*(           cubq2*cubq3*icubq1);
//         s_cubN5[es][n] = p_tauInv*(p_invsqrt2*cubq2*cubq2*icubq1);
//         s_cubN6[es][n] = p_tauInv*(p_invsqrt2*cubq3*cubq3*icubq1);
//       }
//     }
//       }
//     }

//     //make sure all cubature node data is loaded into shared
//     barrier(localMemFence);
    
//     // partial projection to nodes from cubature-sub-group
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
//         int et = eo+es; // element in block
//         if(et<Nelements){
//             if(n<p_Np){
//              //Update 
//                 const int id = p_Nfields*(e*p_Np + n);
//                 const int rhsId = nrhs*id + p_Nfields*shift;

//                 dfloat N4 = rhsq[rhsId + 3];
//                 dfloat N5 = rhsq[rhsId + 4];
//                 dfloat N6 = rhsq[rhsId + 5];
                
//                 occaUnroll(p_cubNp)
//                 for(int i=0;i<p_cubNp;++i){
//                   const dfloat Pnc  = cubProjectT[i*p_Np+n];
//                   N4 += Pnc*s_cubN4[es][i];
//                   N5 += Pnc*s_cubN5[es][i];
//                   N6 += Pnc*s_cubN6[es][i];
//                 }

//               // Update  
//               rhsq[rhsId + 3] = N4;
//               rhsq[rhsId + 4] = N5;
//               rhsq[rhsId + 5] = N6;
        
//            }
//          }
//         }
//      }
//   }
// }




// // 
// kernel void boltzmannSAPmlRelaxationCub2D(const int pmlNelements,
//                                     const int * restrict pmlElementIds,
//                                     const int * restrict pmlIds,
//                                     const int nrhs,
//                                     const int shift,
//                                     const dfloat * restrict cubInterpT,
//                                     const dfloat * restrict cubProjectT,
//                                     const dfloat * restrict pmlSigmaX,
//                                     const dfloat * restrict pmlSigmaY, 
//                                     const dfloat * restrict q,
//                                     const dfloat * restrict pmlqx,
//                                     const dfloat * restrict pmlqy,
//                                           dfloat * restrict rhsq,
//                                           dfloat * restrict pmlrhsqx,
//                                           dfloat * restrict pmlrhsqy){
  
//    for(int eo=0;eo<pmlNelements;eo+=p_NblockCub;outer0){  // for all elements

//     // shared memory for q at nodes
//     shared dfloat  s_q[p_NblockCub][p_Nfields][p_Np];
//     shared dfloat s_qx[p_NblockCub][p_Nfields][p_Np];
//     shared dfloat s_qy[p_NblockCub][p_Nfields][p_Np];

//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     shared dfloat s_cubq[p_NblockCub][p_Nfields][p_cubNp];
//     shared dfloat s_cubqx[p_NblockCub][p_Nfields][p_cubNp];
//     shared dfloat s_cubqy[p_NblockCub][p_Nfields][p_cubNp];

//     exclusive int e, pmlId;

//     // prefetch q to shared
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){      
//         int et = eo+es; // element in block
//         if(et<pmlNelements){
//             e     = pmlElementIds[et];
//             pmlId = pmlIds[et];
            
//             if(n<p_Np){
//               const int id  = p_Nfields*(e*p_Np + n);
//               const int pid = p_Nfields*(pmlId*p_Np + n);
              
//               occaUnroll(p_Nfields)
//               for(int fld=0; fld<p_Nfields;++fld){
//                 s_q[es][fld][n]   = q[id +fld];
//                 s_qx[es][fld][n]  = pmlqx[pid+fld];
//                 s_qy[es][fld][n]  = pmlqy[pid+fld];
//               }
//             }
//          }
//        }
//     }
    
//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){     
//         int et = eo+es; // element in block
//         if(et<pmlNelements){
//           if(n<p_cubNp){
//             dfloat r_q[p_Nfields];
//             dfloat r_qx[p_Nfields];
//             dfloat r_qy[p_Nfields];

//             occaUnroll(p_Nfields)
//             for(int fld=0; fld<p_Nfields ; fld++){
//               r_q[fld]  = 0.f;
//               r_qx[fld] = 0.f;
//               r_qy[fld] = 0.f;
//             }

//             occaUnroll(p_Np)
//             for(int m=0;m<p_Np;++m){
//               const dfloat Icn  = cubInterpT[m*p_cubNp+n];
//               occaUnroll(p_Nfields)
//               for(int fld=0; fld<p_Nfields;++fld){
//                 r_q[fld]  += Icn*s_q[es][fld][m];
//                 r_qx[fld] += Icn*s_qx[es][fld][m];
//                 r_qy[fld] += Icn*s_qy[es][fld][m];
//               }    
//             }
//             //
            
//              // Prefetch sigma
//             const dfloat sigmaxe = pmlSigmaX[pmlId*p_cubNp+n];
//             const dfloat sigmaye = pmlSigmaY[pmlId*p_cubNp+n];

//             const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha; //
//             const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;
            
//             occaUnroll(p_Nfields)
//             for(int fld=0; fld<p_Nfields;++fld){
//               s_cubqx[es][fld][n] = -msigmaxe*r_qx[fld];
//               s_cubqy[es][fld][n] = -msigmaye*r_qy[fld];
//               s_cubq[es][fld][n]  = -msigmaxe*r_qx[fld] - msigmaye*r_qy[fld];  
//             }
            

//             dfloat icubq1 = 1.f/r_q[0];
//             // BGK relaxation approximation to the Boltzmann collision operator
//             s_cubq[es][3][n] += p_tauInv*(           r_q[1]*r_q[2]*icubq1);
//             s_cubq[es][4][n] += p_tauInv*(p_invsqrt2*r_q[1]*r_q[1]*icubq1);
//             s_cubq[es][5][n] += p_tauInv*(p_invsqrt2*r_q[2]*r_q[2]*icubq1);

//           }
//         }
//       }
//     }

//     // make sure all cubature node data is loaded into shared
//     barrier(localMemFence);
    
//     // partial projection to nodes from cubature-sub-group
//     for(int es=0;es<p_NblockCub;++es;inner1){
//       for(int n=0;n<p_maxCubNodes;++n;inner0){     
    
//         int et = eo+es; // element in block
//           if(et<pmlNelements){
//             if(n<p_Np){
//           // Update
//               const int rhsId    = nrhs*p_Nfields*(p_Np*e + n)     + p_Nfields*shift;
//               const int pmlrhsId = nrhs*p_Nfields*(p_Np*pmlId + n) + p_Nfields*shift;

//               dfloat r_rhsq[p_Nfields];
//               dfloat r_rhsqx[p_Nfields];
//               dfloat r_rhsqy[p_Nfields];
              
//               occaUnroll(p_Nfields)
//               for(int fld=0; fld<p_Nfields;++fld){
//                 r_rhsq[fld]  = 0.f;
//                 r_rhsqx[fld] = 0.f;
//                 r_rhsqy[fld] = 0.f;
//               }
              
//               // use temporaries for part sums for N4,N5,N6 because of exclusives
//               occaUnroll(p_cubNp)
//               for(int m=0;m<p_cubNp;++m){
//                 const dfloat Pnc  = cubProjectT[m*p_Np+n];
//                  occaUnroll(p_Nfields)
//                  for(int fld=0; fld<p_Nfields; fld++){
//                   r_rhsq[fld]  += Pnc*s_cubq[es][fld][m];
//                   r_rhsqx[fld] += Pnc*s_cubqx[es][fld][m];
//                   r_rhsqy[fld] += Pnc*s_cubqy[es][fld][m];
//                  }
//               }
            
//              occaUnroll(p_Nfields)
//              for(int fld=0; fld<p_Nfields;++fld){
//                 pmlrhsqx[pmlrhsId + fld] += r_rhsqx[fld];
//                 pmlrhsqy[pmlrhsId + fld] += r_rhsqy[fld];
//                 rhsq[rhsId + fld]        += r_rhsq[fld];
//               }   
//           }
//         }
//       }
//     }

//   }
// }