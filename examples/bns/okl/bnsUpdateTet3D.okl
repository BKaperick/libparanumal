kernel void bnsLSERKUpdateTet3D(const dlong Nelements,
                                const dlong * restrict elementIds,
                                const dfloat dt,  
                                const dfloat rka,
                                const dfloat rkb,
                                const dfloat * restrict rhsq,
                                      dfloat * restrict resq,
                                      dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(dlong es=0;es<Nelements;++es;outer0){

    for(int n=0;n<p_Np;++n;inner0){
      const dlong e = elementIds[es];
      const dlong id = e*p_Np*p_Nfields + n;
                  
        for(int fld=0; fld< p_Nfields; ++fld){

         const dlong idn = id + fld*p_Np;
         dfloat r_resq = resq[idn];
         dfloat r_rhsq = rhsq[idn]; 
         dfloat r_q    = q[idn];
         
         r_resq = rka*r_resq + dt*r_rhsq;
         r_q   += rkb*r_resq;
         
         resq[idn] = r_resq;
         q[idn]    = r_q;
      }
    }
  }
}



kernel void bnsLSERKPmlUpdateTet3D(const dlong pmlNelements,
                                   const dlong   * restrict pmlElementIds,
                                   const dlong   * restrict pmlIds,
                                   const dfloat dt,  
                                   const dfloat rka,
                                   const dfloat rkb,
                                   const dfloat ramp, 
                                   const dfloat * restrict rhsq, 
                                   const dfloat * restrict rhsqx,
                                   const dfloat * restrict rhsqy, 
                                   const dfloat * restrict rhsqz, 
                                        dfloat * restrict resq,
                                        dfloat * restrict resqx,
                                        dfloat * restrict resqy,
                                        dfloat * restrict resqz,
                                        dfloat * restrict qx,
                                        dfloat * restrict qy,
                                        dfloat * restrict qz,
                                        dfloat * restrict q){
  
// Low storage Runge Kutta time step update
for(dlong es=0;es<pmlNelements;++es;outer0){
  exclusive dlong e;
  for(int n=0; n < p_Np; ++n; inner0){
    e = pmlElementIds[es];

    if (n < p_Np){
      const dlong pmlId = pmlIds[es];
      const dlong idb  = e*p_Nfields*p_Np + n;
      const dlong pidb = pmlId*p_Nfields*p_Np + n;
      //
      occaUnroll(p_Nfields)
      for (int fld =0; fld<p_Nfields; ++fld){
        const dlong id  = idb  + fld*p_Np;
        const dlong pid = pidb + fld*p_Np;

        const dfloat r_q  = q [id ];
        const dfloat r_qx = qx[pid];
        const dfloat r_qy = qy[pid];
        const dfloat r_qz = qz[pid];

        dfloat r_resq  = resq [id ];      
        dfloat r_resqx = resqx[pid];
        dfloat r_resqy = resqy[pid];
        dfloat r_resqz = resqz[pid];

        const dfloat r_rhsq  = rhsq [id ];
        const dfloat r_rhsqx = rhsqx[pid];
        const dfloat r_rhsqy = rhsqy[pid];
        const dfloat r_rhsqz = rhsqz[pid];

        r_resq  = rka*r_resq  + dt*r_rhsq ;
        r_resqx = rka*r_resqx + dt*r_rhsqx;
        r_resqy = rka*r_resqy + dt*r_rhsqy;
        r_resqz = rka*r_resqz + dt*r_rhsqz;

        q [id ] = r_q  + rkb*r_resq ;
        qx[pid] = r_qx + rkb*r_resqx;
        qy[pid] = r_qy + rkb*r_resqy;
        qz[pid] = r_qz + rkb*r_resqz;

        resq [id ]  = r_resq ;      
        resqx[pid]  = r_resqx;
        resqy[pid]  = r_resqy;
        resqz[pid]  = r_resqz;
      } 
    }
  }
}
}





// // This kernel does not use float 4 format, 
// kernel void boltzmannSRABUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt,  
//             const dfloat a1,
//             const dfloat a2,
//             const dfloat a3,
//             const int   shift,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict q){
  
// // Low storage Runge Kutta time step update
// for(int es=0;es<Nelements;++es;outer0){

//   // shared dfloat s_q[p_Np*p_Nfields];
//   exclusive int e; 

//   for(int n=0;n<p_maxNodes;++n;inner0){
//     e  = elementIds[es];
//     if(n<p_Np){
//       const int id = p_Nfields*(n + e*p_Np);
//       // hard-coded for 3th order
//       const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//       const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//       const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

//       occaUnroll(p_Nfields)
//       for(int fld=0; fld< p_Nfields; ++fld){
//         q[id+fld] += (a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
//       }
//     }
//   }
// }
// }



// kernel void boltzmannSRABPmlUpdate2D(const int pmlNelements,
//                const int   * restrict pmlElementIds,
//                const int   * restrict pmlIds,
//                const dfloat dt,  
//                const dfloat a1,
//                const dfloat a2,
//                const dfloat a3,
//                const int   shift,
//                const dfloat * restrict rhsq, 
//                const dfloat * restrict pmlrhsqx,
//                const dfloat * restrict pmlrhsqy,
//                      dfloat * restrict q,
//                      dfloat * restrict pmlqx,
//                      dfloat * restrict pmlqy){
// // Low storage Runge Kutta time step update
// for(int es=0;es<pmlNelements;++es;outer0){
//   // shared dfloat s_q[p_Np*p_Nfields];
//   exclusive int e;
//   for(int n=0; n < p_maxNodes; ++n; inner0){
//     e = pmlElementIds[es];
//     if (n < p_Np){

//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       const int pid = p_Nfields*(pmlId*p_Np + n);

//       const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//       const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//       const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
//       const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//       const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
//       const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;

//       occaUnroll(p_Nfields)
//       for(int fld=0; fld< p_Nfields; ++fld){

//         pmlqx[pid+fld] += (a1*pmlrhsqx[pmlrhsId1+fld] + a2*pmlrhsqx[pmlrhsId2+fld] + a3*pmlrhsqx[pmlrhsId3+fld]);
//         pmlqy[pid+fld] += (a1*pmlrhsqy[pmlrhsId1+fld] + a2*pmlrhsqy[pmlrhsId2+fld] + a3*pmlrhsqy[pmlrhsId3+fld]);

//         q[id+fld]      += (a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);

//       }
//     }
//   }      
// }
// }


// //  
// kernel void boltzmannSAABUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat expdt, 
//             const dfloat ab1,
//             const dfloat ab2,
//             const dfloat ab3,
//             const dfloat saab1,
//             const dfloat saab2,
//             const dfloat saab3,
//             const int   shift,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict q){
  
// // Low storage Runge Kutta time step update
// for(int es=0;es<Nelements;++es;outer0){

//   exclusive int e; 

//   for(int n=0;n<p_maxNodes;++n;inner0){
//     e  = elementIds[es];
//     if(n<p_Np){
//       const int id = p_Nfields*(n + e*p_Np);
//       // hard-coded for 3th order
//       const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//       const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//       const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
//       //
//       q[id+0] = q[id+0] + ab1*rhsq[rhsId1+0] + ab2*rhsq[rhsId2+0] + ab3*rhsq[rhsId3+0];
//       q[id+1] = q[id+1] + ab1*rhsq[rhsId1+1] + ab2*rhsq[rhsId2+1] + ab3*rhsq[rhsId3+1];
//       q[id+2] = q[id+2] + ab1*rhsq[rhsId1+2] + ab2*rhsq[rhsId2+2] + ab3*rhsq[rhsId3+2];
//       //
//       q[id+3] = expdt*q[id+3] + saab1*rhsq[rhsId1+3] + saab2*rhsq[rhsId2+3] + saab3*rhsq[rhsId3+3];
//       q[id+4] = expdt*q[id+4] + saab1*rhsq[rhsId1+4] + saab2*rhsq[rhsId2+4] + saab3*rhsq[rhsId3+4];
//       q[id+5] = expdt*q[id+5] + saab1*rhsq[rhsId1+5] + saab2*rhsq[rhsId2+5] + saab3*rhsq[rhsId3+5];
//     }
//   }
// }
// }



// kernel void boltzmannSAABPmlUpdate2D(const int pmlNelements,
//                const int   * restrict pmlElementIds,
//                const int   * restrict pmlIds,
//                const dfloat expdt,  
//                const dfloat ab1,
//                const dfloat ab2,
//                const dfloat ab3,
//                const dfloat saab1,
//                const dfloat saab2,
//                const dfloat saab3,
//                const int   shift,
//                const dfloat * restrict rhsq, 
//                const dfloat * restrict pmlrhsqx,
//                const dfloat * restrict pmlrhsqy,
//                      dfloat * restrict q,
//                      dfloat * restrict pmlqx,
//                      dfloat * restrict pmlqy){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//     // shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e;
//     for(int n=0; n < p_maxNodes; ++n; inner0){
//      e = pmlElementIds[es];
//       if (n < p_Np){

//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

//         const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//         const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
//         const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
         
//          occaUnroll(p_Nfields) 
//          for(int fld=0; fld< p_Nfields; ++fld){

//           pmlqx[pid+fld] += (ab1*pmlrhsqx[pmlrhsId1+fld] + ab2*pmlrhsqx[pmlrhsId2+fld] + ab3*pmlrhsqx[pmlrhsId3+fld]);
//           pmlqy[pid+fld] += (ab1*pmlrhsqy[pmlrhsId1+fld] + ab2*pmlrhsqy[pmlrhsId2+fld] + ab3*pmlrhsqy[pmlrhsId3+fld]);
//           if(fld<3)
//             q[id+fld]      += (ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld]);
//           else
//             q[id+fld]      = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];

//          }
//       }
//     }      
//   }
// }



// kernel void boltzmannDOPRIRKStage2D(const int Nelements,
//                          const int * restrict elementIds,
//                          const int NtotalElements,
//                          const int rk,
//                          const dfloat dt,  
//                          const dfloat * restrict rkA,
//                          const dfloat * restrict q,
//                          const dfloat * restrict rkrhsq,
//                                dfloat * restrict rkq){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e = elementIds[es];
//       const int id = p_Nfields*(n + e*p_Np);

//       for(int fld=0; fld< p_Nfields; ++fld){

//         // const int idn = id + fld;        
//         dfloat r_q = q[id +fld];

//         for (int i=0;i<rk;i++) {
//           const int offset = NtotalElements*p_Nfields*p_Np;
//           r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
//         }
//         rkq[id + fld] = r_q;
//       }
//     }
//   }
// }


// kernel void boltzmannDOPRIRKUpdate2D(const int Nelements,
//                                     const int * restrict elementIds,
//                                     const int NtotalElements,
//                                     const int rk,
//                                     const dfloat dt,  
//                                     const dfloat * restrict rkA,
//                                     const dfloat * restrict rkE,
//                                     const dfloat * restrict q,
//                                     const dfloat * restrict rhsq,
//                                           dfloat * restrict rkrhsq,
//                                           dfloat * restrict rkq,
//                                           dfloat * restrict rkerr){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e = elementIds[es];
//       const int id = p_Nfields*(n + e*p_Np);

//       for(int fld=0; fld< p_Nfields; ++fld){
//         // const int idn = id + fld; 
//         const int offset = NtotalElements*p_Nfields*p_Np;
  
//         dfloat r_rhsq = rhsq[id + fld];

//         if (rk==(p_NrkStages-1)) { //last stage

//           dfloat r_q = q[id +fld];
//           dfloat r_rkerr = 0.f;
//           for (int i=0;i<(p_NrkStages-1);i++) {
//             r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
//             r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//           }
//           r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//           r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;

//           rkq[id   +fld] = r_q;
//           rkerr[id +fld] = r_rkerr;
//         }

//         rkrhsq[id+fld+rk*offset] = r_rhsq;
//       }
//     }
//   }
// }


// kernel void boltzmannDOPRIRKPmlStage2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,  
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rkrhsq,
//                                         const dfloat * restrict rkrhsqx,
//                                         const dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         for(int fld=0; fld< p_Nfields; ++fld){
//           // const int idn = id + fld;        
//           dfloat r_q  = q[id  + fld];
//           dfloat r_qx = qx[pid+ fld];
//           dfloat r_qy = qy[pid+ fld];

//           for (int i=0;i<rk;i++) {
//             const int offset    = NtotalElements*p_Nfields*p_Np;
//             const int offsetpml = pmlNelements*p_Nfields*p_Np;
//             r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
//             r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
//             r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
//           }
//         rkq [id  +fld] = r_q;
//         rkqx[pid +fld] = r_qx;
//         rkqy[pid +fld] = r_qy;
//       }
//     }
//   }
// }

// }


// kernel void boltzmannXDOPRIRKStage2D(const int Nelements,
//                          const int * restrict elementIds,
//                          const int NtotalElements,
//                          const int rk,
//                          const dfloat dt, 
//                          const dfloat expmca, 
//                          const dfloat * restrict rkA,
//                          const dfloat * restrict q,
//                          const dfloat * restrict rkrhsq,
//                                dfloat * restrict rkq){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e = elementIds[es];
//       const int id = p_Nfields*(n + e*p_Np);

//       for(int fld=0; fld< p_Nfields; ++fld){

//         // const int idn = id + fld;        
//         dfloat r_q = q[id +fld];

//         for (int i=0;i<rk;i++) {
//           const int offset = NtotalElements*p_Nfields*p_Np;
//           r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
//         }

//         if(fld>2){
//           r_q = expmca * r_q ; 
//         }

//         rkq[id + fld] = r_q;
//       }
//     }
//   }
// }



// kernel void boltzmannSAADRKStage2D(const int Nelements,
//                          const int * restrict elementIds,
//                          const int NtotalElements,
//                          const int rk,
//                          const dfloat dt,
//                          const dfloat * restrict sarkC, 
//                          const dfloat * restrict rkA,
//                          const dfloat * restrict sarkA,
//                          const dfloat * restrict q,
//                          const dfloat * restrict rkrhsq,
//                                dfloat * restrict rkq){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e      = elementIds[es];
//       const int id     = p_Nfields*(n + e*p_Np);
//       const int offset = NtotalElements*p_Nfields*p_Np;

//       for(int fld=0; fld< p_Nfields; ++fld){

//         dfloat r_q = 0.f; 

//         if(fld<3){
//           r_q = q[id +fld];
//           for (int i=0;i<rk;i++){
//             r_q += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
//           }
//         }
//         else{
//           r_q = sarkC[rk]*q[id +fld];
//           for (int i=0;i<rk;i++){
//             r_q += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[id + fld +i*offset];
//           }
//         }
//         rkq[id + fld] = r_q;
//       }
//     }
//   }
// }






// kernel void boltzmannDOPRIRKPmlUpdate2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,  
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict rkE,
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rhsq,
//                                         const dfloat * restrict rhsqx,
//                                         const dfloat * restrict rhsqy,
//                                               dfloat * restrict rkrhsq,
//                                               dfloat * restrict rkrhsqx,
//                                               dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy,
//                                               dfloat * restrict rkerr){
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         for(int fld=0; fld< p_Nfields; ++fld){

//           const int offset    = NtotalElements*p_Nfields*p_Np;
//           const int offsetpml = pmlNelements*p_Nfields*p_Np;

//           dfloat r_rhsq  = rhsq [id  + fld];
//           dfloat r_rhsqx = rhsqx[pid + fld];
//           dfloat r_rhsqy = rhsqy[pid + fld];

//          if (rk==(p_NrkStages-1)) { //last stage

//             dfloat r_q  = q [id  +fld];
//             dfloat r_qx = qx[pid +fld];
//             dfloat r_qy = qy[pid +fld];

//             dfloat r_rkerr = 0.f;

//             for (int i=0;i<(p_NrkStages-1);i++) {
//               r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
//               r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
//               r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

//               r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//             }

//             r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//             r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
//             r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

//             r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;

//             rkq[  id  +fld] = r_q;
//             rkqx[pid  +fld] = r_qx;
//             rkqy[pid  +fld] = r_qy;

//             rkerr[id +fld] = r_rkerr;
//           }

//         rkrhsq[id+fld+rk*offset]      = r_rhsq;
//         rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
//         rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
//         }
//       }
//     }
//   }
// }





// kernel void boltzmannXDOPRIRKPmlStage2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,
//                                         const dfloat expmca,  
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rkrhsq,
//                                         const dfloat * restrict rkrhsqx,
//                                         const dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         for(int fld=0; fld< p_Nfields; ++fld){
//           // const int idn = id + fld;        
//           dfloat r_q  = q[id  + fld];
//           dfloat r_qx = qx[pid+ fld];
//           dfloat r_qy = qy[pid+ fld];

//           for (int i=0;i<rk;i++) {
//             const int offset    = NtotalElements*p_Nfields*p_Np;
//             const int offsetpml = pmlNelements*p_Nfields*p_Np;
//             r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
//             r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
//             r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
//           }

//           if(fld>2){
//             r_q = expmca * r_q ; 
//           }

//           rkq [id  +fld] = r_q;
//           rkqx[pid +fld] = r_qx;
//           rkqy[pid +fld] = r_qy;
//       }
//     }
//   }
// }

// }




// kernel void boltzmannSAADRKPmlStage2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,
//                                         const dfloat * restrict sarkC,  
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict sarkA,                                        
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rkrhsq,
//                                         const dfloat * restrict rkrhsqx,
//                                         const dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId     = pmlIds[es];
//         const int id        = p_Nfields*(e*p_Np + n);
//         const int pid       = p_Nfields*(pmlId*p_Np + n);
//         const int offset    = NtotalElements*p_Nfields*p_Np;
//         const int offsetpml = pmlNelements*p_Nfields*p_Np;

//         for(int fld=0; fld< p_Nfields; ++fld){
//           // const int idn = id + fld;        
//           dfloat r_q  = 0.f;
//           dfloat r_qx = 0.f;
//           dfloat r_qy = 0.f;

//           if(fld<3){
//             r_q  = q[id  + fld];
//             r_qx = qx[pid+ fld];
//             r_qy = qy[pid+ fld];

//             for (int i=0;i<rk;i++){
//               r_q  += dt*rkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
//               r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
//               r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
//             }
//           }
//           else{
//             r_q  = sarkC[rk]*q[id  + fld];
//             r_qx = qx[pid+ fld];
//             r_qy = qy[pid+ fld];

//             for (int i=0;i<rk;i++){
//               r_q  += dt*sarkA[p_NrkStages*rk+i]*rkrhsq[id+fld+i*offset];
//               r_qx += dt*rkA[p_NrkStages*rk+i]*rkrhsqx[pid+fld+i*offsetpml];
//               r_qy += dt*rkA[p_NrkStages*rk+i]*rkrhsqy[pid+fld+i*offsetpml];
//             }
//           }

//           rkq [id  +fld] = r_q;
//           rkqx[pid +fld] = r_qx;
//           rkqy[pid +fld] = r_qy;
//       }
//     }
//   }
// }

// }

// kernel void boltzmannXDOPRIRKUpdate2D(const int Nelements,
//                                     const int * restrict elementIds,
//                                     const int NtotalElements,
//                                     const int rk,
//                                     const dfloat dt,
//                                     const dfloat expca,
//                                     const dfloat expma,  
//                                     const dfloat * restrict rkA,
//                                     const dfloat * restrict rkE,
//                                     const dfloat * restrict q,
//                                     const dfloat * restrict rhsq,
//                                           dfloat * restrict rkrhsq,
//                                           dfloat * restrict rkq,
//                                           dfloat * restrict rkerr){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e = elementIds[es];
//       const int id = p_Nfields*(n + e*p_Np);

//       for(int fld=0; fld< p_Nfields; ++fld){
//         // const int idn = id + fld; 
//         const int offset = NtotalElements*p_Nfields*p_Np;
//          dfloat r_rhsq = rhsq[id + fld]; 
        
//         // multiply rhs with exp(c_i*invtau*dt)
//         if(fld>2){
//           r_rhsq = expca*r_rhsq;
//         }

//         if (rk==(p_NrkStages-1)) { //last stage

//           dfloat r_q = q[id +fld];
//           dfloat r_rkerr = 0.f;
//           for (int i=0;i<(p_NrkStages-1);i++) {
//             r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
//             r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//           }
//           r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//           r_rkerr += dt*rkE[p_NrkStages-1]*r_rhsq;
          
//           // multply with exp(-invtau*dt)
//           if(fld>2){
//             r_q     = expma * r_q;
//             // r_rkerr =  r_rkerr;
//             r_rkerr = r_rkerr * expma;
//           }
          
//           rkq[id   +fld] = r_q;
//           rkerr[id +fld] = r_rkerr;
//         }

//         rkrhsq[id+fld+rk*offset] = r_rhsq;
//       }
//     }
//   }
// }



// kernel void boltzmannSAADRKUpdate2D(const int Nelements,
//                                     const int * restrict elementIds,
//                                     const int NtotalElements,
//                                     const int rk,
//                                     const dfloat dt,
//                                     const dfloat *restrict sarkC, 
//                                     const dfloat * restrict rkA,
//                                     const dfloat * restrict rkE,
//                                     const dfloat * restrict sarkA,
//                                     const dfloat * restrict sarkE,
//                                     const dfloat * restrict q,
//                                     const dfloat * restrict rhsq,
//                                           dfloat * restrict rkrhsq,
//                                           dfloat * restrict rkq,
//                                           dfloat * restrict rkerr){
  
//   // Runge Kutta intermediate stage
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){

//       const int e = elementIds[es];
//       const int id = p_Nfields*(n + e*p_Np);

//       for(int fld=0; fld< p_Nfields; ++fld){
//         // const int idn = id + fld; 
//         const int offset = NtotalElements*p_Nfields*p_Np;

//         dfloat r_rhsq  = rhsq[id + fld];
//         dfloat r_q     = 0.f;
//         dfloat r_rkerr = 0.f;

//         if(rk==(p_NrkStages-1)){

//           if(fld<3){

//             r_q = q[id +fld];

//             for (int i=0;i<(p_NrkStages-1);i++) {
//               r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
//               r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//             }
//             r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//             r_rkerr += dt*rkE[                 p_NrkStages-1]*r_rhsq;
//           }
//           else{

//             r_q = sarkC[rk]*q[id +fld];

//              for (int i=0;i<(p_NrkStages-1);i++) {
//               r_q     += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[id + fld + i*offset];
//               r_rkerr += dt*sarkE[                 i]*rkrhsq[id + fld + i*offset];
//             }
//             r_q     += dt*sarkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//             r_rkerr += dt*sarkE[                 p_NrkStages-1]*r_rhsq;
//           }

//           rkq[id   +fld] = r_q;
//           rkerr[id +fld] = r_rkerr;
//         }

//         rkrhsq[id+fld+rk*offset] = r_rhsq;
//       }
//     }
//   }
// }



// kernel void boltzmannXDOPRIRKPmlUpdate2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,
//                                         const dfloat expca,
//                                         const dfloat expma,   
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict rkE,
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rhsq,
//                                         const dfloat * restrict rhsqx,
//                                         const dfloat * restrict rhsqy,
//                                               dfloat * restrict rkrhsq,
//                                               dfloat * restrict rkrhsqx,
//                                               dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy,
//                                               dfloat * restrict rkerr){
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         for(int fld=0; fld< p_Nfields; ++fld){

//           const int offset    = NtotalElements*p_Nfields*p_Np;
//           const int offsetpml = pmlNelements*p_Nfields*p_Np;

//           dfloat r_rhsq  = rhsq [id  + fld];
//           dfloat r_rhsqx = rhsqx[pid + fld];
//           dfloat r_rhsqy = rhsqy[pid + fld];

//           if(fld>2){
//             r_rhsq = expca*r_rhsq;
//           }



//           if (rk==(p_NrkStages-1)) { //last stage

//             dfloat r_q  = q [id  +fld];
//             dfloat r_qx = qx[pid +fld];
//             dfloat r_qy = qy[pid +fld];

//             dfloat r_rkerr = 0.f;

//             for (int i=0;i<(p_NrkStages-1);i++){
//               r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
//               r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
//               r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

//               r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//             }

//             r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//             r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
//             r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

//             r_rkerr += dt*rkE[       p_NrkStages-1]*r_rhsq;


//             if(fld>2){
//               r_q     = expma * r_q;
//               // r_rkerr = expma * r_rkerr;
//               // r_rkerr = r_rkerr;
//               r_rkerr = r_rkerr*expma;
//            }

//             rkq[  id  +fld] = r_q;
//             rkqx[pid  +fld] = r_qx;
//             rkqy[pid  +fld] = r_qy;

//             rkerr[id +fld] = r_rkerr;
//           }

//         rkrhsq[id+fld+rk*offset]      = r_rhsq;
//         rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
//         rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
//         }
//       }
//     }
//   }
// }



// kernel void boltzmannSAADRKPmlUpdate2D(const int pmlNelements,
//                                         const int   * restrict pmlElementIds,
//                                         const int   * restrict pmlIds,
//                                         const int NtotalElements,
//                                         const int rk,
//                                         const dfloat dt,
//                                         const dfloat *restrict sarkC, 
//                                         const dfloat * restrict rkA,
//                                         const dfloat * restrict rkE,
//                                         const dfloat * restrict sarkA,
//                                         const dfloat * restrict sarkE,
//                                         const dfloat * restrict q,
//                                         const dfloat * restrict qx,
//                                         const dfloat * restrict qy,
//                                         const dfloat * restrict rhsq,
//                                         const dfloat * restrict rhsqx,
//                                         const dfloat * restrict rhsqy,
//                                               dfloat * restrict rkrhsq,
//                                               dfloat * restrict rkrhsqx,
//                                               dfloat * restrict rkrhsqy,
//                                               dfloat * restrict rkq,
//                                               dfloat * restrict rkqx,
//                                               dfloat * restrict rkqy,
//                                               dfloat * restrict rkerr){
//   // Runge Kutta intermediate stage
//   for(int es=0;es<pmlNelements;++es;outer0){
//     exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//       e = pmlElementIds[es];
//       if (n < p_Np){
//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         for(int fld=0; fld< p_Nfields; ++fld){

//           const int offset    = NtotalElements*p_Nfields*p_Np;
//           const int offsetpml = pmlNelements*p_Nfields*p_Np;

//           dfloat r_rhsq  = rhsq [id  + fld];
//           dfloat r_rhsqx = rhsqx[pid + fld];
//           dfloat r_rhsqy = rhsqy[pid + fld];

//           if(rk==(p_NrkStages-1)){
//             //
//             dfloat r_q     = 0.f;
//             dfloat r_qx    = 0.f;
//             dfloat r_qy    = 0.f;
//             dfloat r_rkerr = 0.f;

//             if(fld<3){
//               r_q  = q [id  +fld];
//               r_qx = qx[pid +fld];
//               r_qy = qy[pid +fld];

//               dfloat r_rkerr = 0.f;

//               for (int i=0;i<(p_NrkStages-1);i++) {
//                 r_q     += dt*rkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
//                 r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
//                 r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];
//                 r_rkerr += dt*rkE[       i]*rkrhsq[id + fld + i*offset];
//               }

//               r_q     += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//               r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
//               r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

//               r_rkerr += dt*rkE[p_NrkStages-1]*r_rhsq;
//             }
//             else{

//               r_q  = sarkC[rk]*q [id  +fld];
//               r_qx = qx[pid +fld];
//               r_qy = qy[pid +fld];

//               dfloat r_rkerr = 0.f;

//               for (int i=0;i<(p_NrkStages-1);i++) {
//                 r_q     += dt*sarkA[p_NrkStages*rk + i]*rkrhsq[  id + fld + i*offset];
//                 r_qx    += dt*rkA[p_NrkStages*rk + i]*rkrhsqx[pid + fld + i*offsetpml];
//                 r_qy    += dt*rkA[p_NrkStages*rk + i]*rkrhsqy[pid + fld + i*offsetpml];

//                 r_rkerr += dt*sarkE[       i]*rkrhsq[id + fld + i*offset];
//               }

//               r_q     += dt*sarkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsq;
//               r_qx    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqx;
//               r_qy    += dt*rkA[p_NrkStages*rk + p_NrkStages-1]*r_rhsqy;

//               r_rkerr += dt*sarkE[p_NrkStages-1]*r_rhsq;
//             }
//           }

//         rkrhsq[id+fld+rk*offset]      = r_rhsq;
//         rkrhsqx[pid+fld+rk*offsetpml] = r_rhsqx;
//         rkrhsqy[pid+fld+rk*offsetpml] = r_rhsqy;
//         }     
//       }
//     }
//   }
// }








// kernel void boltzmannErrorEstimate2D(const int N,
//                                const dfloat ATOL,
//                                const dfloat RTOL,
//                                const dfloat * restrict q,
//                                const dfloat * restrict rkq,
//                                const dfloat * restrict rkerr,
//                                      dfloat * restrict errtmp){
  
//   for(int b=0;b<(N+p_blockSize-1)/p_blockSize;++b;outer0){
    
//     volatile shared dfloat s_err[p_blockSize];

//     for(int t=0;t<p_blockSize;++t;inner0){
//       const int id = t + p_blockSize*b;
//       if (id<N) {
//         const dfloat   qn =   q[id];
//         const dfloat rkqn = rkq[id];
//         const dfloat qmax = (qn>rkqn) ? qn : rkqn;
//         // const dfloat qmax = rkqn;
//         dfloat sk = ATOL + RTOL*qmax;

//         s_err[t] = (rkerr[id]/sk)*(rkerr[id]/sk);
//       } else {
//         s_err[t] = 0.f;  
//       }
//     }

//     barrier(localMemFence);
// #if p_blockSize>512
//     for(int t=0;t<p_blockSize;++t;inner0) if(t<512) s_err[t] += s_err[t+512];
//     barrier(localMemFence);
// #endif
// #if p_blockSize>256
//     for(int t=0;t<p_blockSize;++t;inner0) if(t<256) s_err[t] += s_err[t+256];
//     barrier(localMemFence);
// #endif

//     for(int t=0;t<p_blockSize;++t;inner0) if(t<128) s_err[t] += s_err[t+128];
//     barrier(localMemFence);

//     for(int t=0;t<p_blockSize;++t;inner0) if(t< 64) s_err[t] += s_err[t+64];
//     barrier(localMemFence);

//     for(int t=0;t<p_blockSize;++t;inner0) if(t< 32) s_err[t] += s_err[t+32];
//     for(int t=0;t<p_blockSize;++t;inner0) if(t< 16) s_err[t] += s_err[t+16];
//     for(int t=0;t<p_blockSize;++t;inner0) if(t<  8) s_err[t] += s_err[t+8];
//     for(int t=0;t<p_blockSize;++t;inner0) if(t<  4) s_err[t] += s_err[t+4];
//     for(int t=0;t<p_blockSize;++t;inner0) if(t<  2) s_err[t] += s_err[t+2];

//     for(int t=0;t<p_blockSize;++t;inner0) if(t<  1) errtmp[b] = s_err[0] + s_err[1];
//   }
// }












// // Check indexing for SARK KERNELS !!!!!!!!!!!!!
// kernel void boltzmannSARKStageUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt, 
//             const dfloat expdt, 
//             const dfloat rka,
//             const dfloat erka,
//             const dfloat rkb,
//             const dfloat erkb,
//             const int shift,
//             const dfloat * restrict rhsq,
//             const dfloat * restrict qs,
//                   dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){
//       const int e = elementIds[es];
      
//       const int id = p_Nfields*(n + e*p_Np);
//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
      
//         q[id+0] = qs[id+0] + dt*(rka*rhsq[rhsId1+0] + rkb*rhsq[rhsId2+0]);
//         q[id+1] = qs[id+1] + dt*(rka*rhsq[rhsId1+1] + rkb*rhsq[rhsId2+1]);
//         q[id+2] = qs[id+2] + dt*(rka*rhsq[rhsId1+2] + rkb*rhsq[rhsId2+2]);
//         //
//         q[id+3] = expdt*qs[id+3] + dt*(erka*rhsq[rhsId1+3] + erkb*rhsq[rhsId2+3]);
//         q[id+4] = expdt*qs[id+4] + dt*(erka*rhsq[rhsId1+4] + erkb*rhsq[rhsId2+4]);
//         q[id+5] = expdt*qs[id+5] + dt*(erka*rhsq[rhsId1+5] + erkb*rhsq[rhsId2+5]);
//     }
//   }
// }



// kernel void boltzmannSARKUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt, 
//             const dfloat expdt, 
//             const dfloat rka,
//             const dfloat erka,
//             const dfloat rkb,
//             const dfloat erkb,
//             const dfloat rkc,
//             const dfloat erkc,
//             const int shift,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict qs,
//                   dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){
//       const int e = elementIds[es];
      
//       const int id = p_Nfields*(n + e*p_Np);
//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+2)%3)*p_Nfields;
        
//         occaUnroll(p_Nfields)
//         for(int fld=0; fld<p_Nfields; ++fld ){
//          dfloat r_q = 0.f; 
//          if(fld<3)
//            r_q = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld] + rkc*rhsq[rhsId3+fld]);
//          else
//            r_q = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld] + erkc*rhsq[rhsId3+fld]);

//           q [id+fld] = r_q;
//           qs[id+fld] = r_q;
//         }
//     }
//   }
// }



// kernel void boltzmannSARKPmlStageUpdate2D(const int pmlNelements,
//               const int * restrict pmlElementIds, 
//               const int *restrict pmlIds,
//               const dfloat dt,  
//               const dfloat expdt, 
//               const dfloat rka,
//               const dfloat erka,
//               const dfloat rkb,
//               const dfloat erkb,
//               const dfloat ramp, 
//               const int shift,
//               const dfloat * restrict rhsq,
//               const dfloat * restrict rhsqx,
//               const dfloat * restrict rhsqy,
//               const dfloat * restrict qs,
//               const dfloat * restrict qsx,
//               const dfloat * restrict qsy,
//                     dfloat * restrict qx,
//                     dfloat * restrict qy,
//                     dfloat * restrict q){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//   exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//     e = pmlElementIds[es];

//     if (n < p_Np){
//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       const int pid = p_Nfields*(pmlId*p_Np + n);

//       const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//       const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
      
//       const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//       const int pmlrhsId2 = 3*pid + ((shift+1)%3)*p_Nfields;
//       //
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld< p_Nfields; ++fld){

//       qx[pid+fld] = qsx[pid+fld] + dt*( rka*rhsqx[pmlrhsId1+fld] + rkb*rhsqx[pmlrhsId2+fld]);
//       qy[pid+fld] = qsy[pid+fld] + dt*( rka*rhsqy[pmlrhsId1+fld] + rkb*rhsqy[pmlrhsId2+fld]);

//       if(fld<3)
//         q[id+fld] = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld]);
//       else
//         q[id+fld] = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld]);
//       }
//     }
//   }
// }
// }


// kernel void boltzmannSARKPmlUpdate2D(const int pmlNelements,
//               const int * restrict pmlElementIds, 
//               const int *restrict pmlIds,
//               const dfloat dt,  
//               const dfloat expdt, 
//               const dfloat rka,
//               const dfloat erka,
//               const dfloat rkb,
//               const dfloat erkb,
//               const dfloat rkc,
//               const dfloat erkc,
//               const dfloat ramp, 
//               const int shift,
//               const dfloat * restrict rhsq,
//               const dfloat * restrict rhsqx,
//               const dfloat * restrict rhsqy,
//                     dfloat * restrict qs,
//                     dfloat * restrict qsx,
//                     dfloat * restrict qsy,
//                     dfloat * restrict qx,
//                     dfloat * restrict qy,
//                     dfloat * restrict q){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//   exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//     e = pmlElementIds[es];

//     if (n < p_Np){
//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       const int pid = p_Nfields*(pmlId*p_Np + n);

//       const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//       const int rhsId2 = 3*id + ((shift+1)%3)*p_Nfields;
//       const int rhsId3 = 3*id + ((shift+2)%3)*p_Nfields;

//       const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//       const int pmlrhsId2 = 3*pid + ((shift+1)%3)*p_Nfields;
//       const int pmlrhsId3 = 3*pid + ((shift+2)%3)*p_Nfields;
//       //
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld< p_Nfields; ++fld){

//         dfloat r_qx =0.f, r_qy =0.f, r_q = 0.f; 
        
//         r_qx = qsx[pid+fld] + dt*( rka*rhsqx[pmlrhsId1+fld] + rkb*rhsqx[pmlrhsId2+fld] +rkc*rhsqx[pmlrhsId3+fld]);
//         r_qy = qsy[pid+fld] + dt*( rka*rhsqy[pmlrhsId1+fld] + rkb*rhsqy[pmlrhsId2+fld] +rkc*rhsqy[pmlrhsId3+fld]);

//         qx[pid+fld]  = r_qx;
//         qy[pid+fld]  = r_qy;
//         qsx[pid+fld] = r_qx;
//         qsy[pid+fld] = r_qy;

//         if(fld<3)
//           r_q = qs[id+fld] + dt*(rka*rhsq[rhsId1+fld] + rkb*rhsq[rhsId2+fld] + rkc*rhsq[rhsId3+fld]);
//         else
//           r_q = expdt*qs[id+fld] + dt*(erka*rhsq[rhsId1+fld] + erkb*rhsq[rhsId2+fld] +erkc*rhsq[rhsId3+fld]);

//         q[id+fld]  = r_q;
//         qs[id+fld] = r_q;

//       }
//     }
//   }
// }
// }




// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXResidualUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt, 
//             const dfloat aki,
//             const dfloat ake, 
//             const dfloat * restrict q,
//             const dfloat * restrict qZ,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict qY){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){
//       const int e = elementIds[es];
      
//       const int id = p_Nfields*(n + e*p_Np);
      
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld<p_Nfields; ++fld){
//         qY[id +fld] = q[id+fld] + dt*( ake*rhsq[id +fld] + aki*qZ[id +fld]);
//       }
//     }
//   }
// }



// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXPmlResidualUpdate2D(const int pmlNelements,
//             const int * restrict pmlElementIds, 
//             const int *restrict pmlIds,
//             const dfloat dt,
//             const dfloat ramp, 
//             const dfloat c_im,
//             const dfloat c_ex, 
//             const dfloat * restrict q,
//             const dfloat  * restrict pmlqx,
//             const dfloat  * restrict pmlqy,
//             const dfloat  * restrict qZ,      
//             const dfloat  * restrict rhsq,
//             const dfloat  * restrict rhsqx,
//             const dfloat  * restrict rhsqy,
//                   dfloat  * restrict qY,  
//                   dfloat  * restrict pmlYx,
//                   dfloat  * restrict pmlYy){

//   for(int es=0;es<pmlNelements;++es;outer0){
//   exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//     e = pmlElementIds[es];

//     if (n < p_Np){
//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       const int pid = p_Nfields*(pmlId*p_Np + n);
      
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld<p_Nfields; ++fld){
//         pmlYx[pid+fld] = pmlqx[pid+fld] + c_ex*dt*rhsqx[pid+fld]; // fully explicit
//         pmlYy[pid+fld] = pmlqy[pid+fld] + c_ex*dt*rhsqy[pid+fld]; // fully explicit
//         qY[id+fld]     = q[id+fld]      + dt*(c_ex*rhsq[id+fld] + c_im*qZ[id+fld]); // imlicit-explicit
//       }
//     }
//   }
// }
// }
      


// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXImplicitUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt, 
//             const dfloat akk,
//             const dfloat * restrict qZ,
//                   dfloat * restrict qY){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){
//       const int e = elementIds[es];
      
//       const int id = p_Nfields*(n + e*p_Np);
      
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld<p_Nfields; ++fld){
//        qY[id + fld] += akk*dt*qZ[id+fld];
//       }
//     }
//   }
// }




// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt, 
//             const dfloat akk,
//             const dfloat * restrict qZ,
//                   dfloat * restrict qY,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict q){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){
//     for(int n=0;n<p_Np;++n;inner0){
//       const int e = elementIds[es];

//       const int id = p_Nfields*(n + e*p_Np);
//       occaUnroll(p_Nfields)
//        for(int fld=0; fld<p_Nfields; ++fld){
//         q[id  +fld] += akk*dt*(rhsq[id+fld] + qZ[id+fld]);
//        }
//     }
//   }
// }



// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXPmlImplicitUpdate2D(const int pmlNelements,
//             const int * restrict pmlElementIds, 
//             const int *restrict pmlIds,
//             const dfloat dt, 
//             const dfloat ramp,
//             const dfloat akk,
//             const dfloat  * restrict qZ,
//                   dfloat  * restrict qY){
//  for(int es=0;es<pmlNelements;++es;outer0){
//   exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//     e = pmlElementIds[es];

//     if (n < p_Np){
//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       // const int pid = p_Nfields*(pmlId*p_Np + n);
      
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld<p_Nfields; ++fld){
//         qY[id + fld] +=  akk*dt*qZ[id+fld];
//       }
//     }
//   }
// }
// }



// // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// kernel void boltzmannLSIMEXPmlUpdate2D(const int pmlNelements,
//             const int * restrict pmlElementIds, 
//             const int *restrict pmlIds,
//             const dfloat dt, 
//             const dfloat akk,
//             const dfloat ramp,
//             const dfloat  * restrict qZ,
//             const dfloat  * restrict qY,
//             const dfloat  * restrict qYx,
//             const dfloat  * restrict qYy,
//             const dfloat  * restrict rhsq,
//             const dfloat  * restrict rhsqx,
//             const dfloat  * restrict rhsqy,    
//                   dfloat  * restrict pmlqx,
//                   dfloat  * restrict pmlqy,
//                   dfloat  * restrict q ){
//   for(int es=0;es<pmlNelements;++es;outer0){
//   exclusive int e;
//     for(int n=0; n < p_Np; ++n; inner0){
//     e = pmlElementIds[es];

//     if (n < p_Np){
//       const int pmlId = pmlIds[es];
//       const int id  = p_Nfields*(e*p_Np + n);
//       const int pid = p_Nfields*(pmlId*p_Np + n);
      
//       occaUnroll(p_Nfields)
//       for(int fld=0; fld<p_Nfields; ++fld){
        
//         //update qx
//         pmlqx[pid+fld] +=  akk*dt*rhsqx[pid+fld];
//         pmlqy[pid+fld] +=  akk*dt*rhsqy[pid+fld];
//         q[id  +fld]    +=  akk*dt*(rhsq[id+fld] + qZ[id+fld]);
//       }
//     }
//   }
// }
// }
    






// // This kernel does not use float 4 format, 
// kernel void boltzmannMRABUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt,  
//             const dfloat a1,
//             const dfloat a2,
//             const dfloat a3,
//             const int   shift,
//             const int   * restrict vmapM,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict fQM,
//                   dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){

//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e; 

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       e  = elementIds[es];
//       if(n<p_Np){
//         const int id = p_Nfields*(n + e*p_Np);

//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
        
//         occaUnroll(p_Nfields)
//         for(int fld=0; fld< p_Nfields; ++fld){
//           s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
//         }
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){

//       // Update q
//       if(n<p_Np){

//         const int id = p_Nfields*(e*p_Np + n);
//         occaUnroll(p_Nfields)
//         for (int fld = 0; fld < p_Nfields; ++fld){
//           q[id+fld]   = s_q[p_Nfields*n+fld];
//         } 

//       }

//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
         
//          occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];  
//         }   
//       }

//     }

//   }
// }



// // This kernel does not use float 4 format, 
// kernel void boltzmannMRSAABUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat expdt, 
//             const dfloat ab1,
//             const dfloat ab2,
//             const dfloat ab3,
//             const dfloat saab1,
//             const dfloat saab2,
//             const dfloat saab3,
//             const int   shift,
//             const int   * restrict vmapM,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict fQM,
//                   dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){

//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e; 

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       e  = elementIds[es];
//       if(n<p_Np){
//         const int id = p_Nfields*(n + e*p_Np);

//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

//         //
//         s_q[p_Nfields*n+0] = q[id+0] + ab1*rhsq[rhsId1+0] + ab2*rhsq[rhsId2+0] + ab3*rhsq[rhsId3+0];
//         s_q[p_Nfields*n+1] = q[id+1] + ab1*rhsq[rhsId1+1] + ab2*rhsq[rhsId2+1] + ab3*rhsq[rhsId3+1];
//         s_q[p_Nfields*n+2] = q[id+2] + ab1*rhsq[rhsId1+2] + ab2*rhsq[rhsId2+2] + ab3*rhsq[rhsId3+2];
//         //
//         s_q[p_Nfields*n+3] = expdt*q[id+3] + saab1*rhsq[rhsId1+3] + saab2*rhsq[rhsId2+3] + saab3*rhsq[rhsId3+3];
//         s_q[p_Nfields*n+4] = expdt*q[id+4] + saab1*rhsq[rhsId1+4] + saab2*rhsq[rhsId2+4] + saab3*rhsq[rhsId3+4];
//         s_q[p_Nfields*n+5] = expdt*q[id+5] + saab1*rhsq[rhsId1+5] + saab2*rhsq[rhsId2+5] + saab3*rhsq[rhsId3+5];
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){

//       // Update q
//       if(n<p_Np){

//         const int id = p_Nfields*(e*p_Np + n);
//         occaUnroll(p_Nfields)
//         for (int fld = 0; fld < p_Nfields; ++fld){
//           q[id+fld]   = s_q[p_Nfields*n+fld];
//         } 

//       }

//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
//          occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];  
//         }   
//       }

//     }

//   }
// }





// kernel void boltzmannMRABPmlUpdate2D(const int pmlNelements,
//                const int   * restrict pmlElementIds,
//                const int   * restrict pmlIds,
//                const dfloat dt,  
//                const dfloat a1,
//                const dfloat a2,
//                const dfloat a3,
//                const int   shift,
//                const int   * restrict vmapM,
//                const dfloat * restrict rhsq, 
//                const dfloat * restrict pmlrhsqx,
//                const dfloat * restrict pmlrhsqy,
//                      dfloat * restrict q,
//                      dfloat * restrict pmlqx,
//                      dfloat * restrict pmlqy,
//                      dfloat * restrict fQM){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e;
//     for(int n=0; n < p_maxNodes; ++n; inner0){
//      e = pmlElementIds[es];
//       if (n < p_Np){

//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

//         const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//         const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
//         const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
//         //
//         occaUnroll(p_Nfields)
//         for(int fld=0; fld< p_Nfields; ++fld){

//           pmlqx[pid+fld] += dt*(a1*pmlrhsqx[pmlrhsId1+fld] + a2*pmlrhsqx[pmlrhsId2+fld] + a3*pmlrhsqx[pmlrhsId3+fld]);
//           pmlqy[pid+fld] += dt*(a1*pmlrhsqy[pmlrhsId1+fld] + a2*pmlrhsqy[pmlrhsId2+fld] + a3*pmlrhsqy[pmlrhsId3+fld]);
          
//           dfloat n_q      = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
          
//           s_q[p_Nfields*n+fld] = n_q;
//           q[id+fld]            = n_q;
//          }
//       }
//     }


//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
        
//         occaUnroll(p_Nfields)
//         for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];
//         }   
//       }

//     }
      
//   }
// }


// kernel void boltzmannMRSAABPmlUpdate2D(const int pmlNelements,
//                const int   * restrict pmlElementIds,
//                const int   * restrict pmlIds,
//                const dfloat expdt,  
//                const dfloat ab1,
//                const dfloat ab2,
//                const dfloat ab3,
//                const dfloat saab1,
//                const dfloat saab2,
//                const dfloat saab3,
//                const int   shift,
//                const int   * restrict vmapM,
//                const dfloat * restrict rhsq, 
//                const dfloat * restrict pmlrhsqx,
//                const dfloat * restrict pmlrhsqy,
//                      dfloat * restrict q,
//                      dfloat * restrict pmlqx,
//                      dfloat * restrict pmlqy,
//                      dfloat * restrict fQM){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e;
//     for(int n=0; n < p_maxNodes; ++n; inner0){
//      e = pmlElementIds[es];
//       if (n < p_Np){

//         const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         const int pid = p_Nfields*(pmlId*p_Np + n);

//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;

//         const int pmlrhsId1 = 3*pid + ((shift+0)%3)*p_Nfields;
//         const int pmlrhsId2 = 3*pid + ((shift+2)%3)*p_Nfields;
//         const int pmlrhsId3 = 3*pid + ((shift+1)%3)*p_Nfields;
//         //
//         occaUnroll(p_Nfields)
//          for(int fld=0; fld<p_Nfields; ++fld){

//           pmlqx[pid+fld] += ab1*pmlrhsqx[pmlrhsId1+fld] + ab2*pmlrhsqx[pmlrhsId2+fld] + ab3*pmlrhsqx[pmlrhsId3+fld];
//           pmlqy[pid+fld] += ab1*pmlrhsqy[pmlrhsId1+fld] + ab2*pmlrhsqy[pmlrhsId2+fld] + ab3*pmlrhsqy[pmlrhsId3+fld];

//           dfloat n_q = 0.f; 

//           if(fld<3)
//             n_q      = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
//           else
//             n_q      = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
//           //          
//           s_q[p_Nfields*n+fld] = n_q;
//           q[id+fld]            = n_q;
//          }
//       }
//     }


//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
//         occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];
//         }   
//       }

//     }
      
//   }
// }

// // This kernel does not use float4 format, 
// kernel void boltzmannMRABTraceUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat dt,  
//             const dfloat a1,
//             const dfloat a2,
//             const dfloat a3,
//             const int   shift,
//             const int   * restrict vmapM,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict fQM,
//             const dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){

//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e; 

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       e  = elementIds[es];
//       if(n<p_Np){
//         const int id = p_Nfields*(n + e*p_Np);

//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
        
//         occaUnroll(p_Nfields)
//           for(int fld=0; fld< p_Nfields; ++fld){
//           s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
//           }
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
        
//          occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];  
//         }   
//       }

//     }

//   }
// }


// // This kernel does not use float4 format, 
// kernel void boltzmannMRSAABTraceUpdate2D(const int Nelements,
//             const int * restrict elementIds,
//             const dfloat expdt, 
//             const dfloat ab1,
//             const dfloat ab2,
//             const dfloat ab3,
//             const dfloat saab1,
//             const dfloat saab2,
//             const dfloat saab3,
//             const int   shift,
//             const int   * restrict vmapM,
//             const dfloat * restrict rhsq,
//                   dfloat * restrict fQM,
//             const dfloat * restrict q){
  
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<Nelements;++es;outer0){

//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e; 

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       e  = elementIds[es];
//       if(n<p_Np){
//         const int id = p_Nfields*(n + e*p_Np);

//         // hard-coded for 3th order
//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
       
//         occaUnroll(p_Nfields)
//           for(int fld=0; fld< p_Nfields; ++fld){
//             if(fld<3)
//               s_q[p_Nfields*n+fld] = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
//             else
//               s_q[p_Nfields*n+fld] = expdt*q[id+fld] + saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
//           }
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
        
//         occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];  
//         }   
//       }

//     }

//   }
// }

// kernel void boltzmannMRABPmlTraceUpdate2D(const int pmlNelements,
//                const int   * restrict pmlElementIds,
//                const int   * restrict pmlIds,
//                const dfloat dt,  
//                const dfloat a1,
//                const dfloat a2,
//                const dfloat a3,
//                const int   shift,
//                const int   * restrict vmapM,
//                const dfloat * restrict rhsq, 
//                const dfloat * restrict pmlrhsqx,
//                const dfloat * restrict pmlrhsqy,
//                const dfloat * restrict q,
//                const dfloat * restrict pmlqx,
//                const dfloat * restrict pmlqy,
//                      dfloat * restrict fQM){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e;
//     for(int n=0; n < p_maxNodes; ++n; inner0){
//      e = pmlElementIds[es];
//       if (n < p_Np){
//         // const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         // const int pid = p_Nfields*(pmlId*p_Np + n);

//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
//         //
//         occaUnroll(p_Nfields)
//          for(int fld=0; fld< p_Nfields; ++fld){      
//           s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
//          }
//       }
//     }

//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 
        
//         occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];
//         }   
//       }

//     }
      
//   }
// }





// kernel void boltzmannMRSAABPmlTraceUpdate2D(const int pmlNelements,
//                       const int   * restrict pmlElementIds,
//                       const int   * restrict pmlIds,
//                       const dfloat expdt, 
//                       const dfloat ab1,
//                       const dfloat ab2,
//                       const dfloat ab3,
//                       const dfloat saab1,
//                       const dfloat saab2,
//                       const dfloat saab3,
//                       const int   shift,
//                       const int   * restrict vmapM,
//                       const dfloat * restrict rhsq, 
//                       const dfloat * restrict pmlrhsqx,
//                       const dfloat * restrict pmlrhsqy,
//                       const dfloat * restrict q,
//                       const dfloat * restrict pmlqx,
//                       const dfloat * restrict pmlqy,
//                             dfloat * restrict fQM){
//   // Low storage Runge Kutta time step update
//   for(int es=0;es<pmlNelements;++es;outer0){
//     shared dfloat s_q[p_Np*p_Nfields];
//     exclusive int e;
//     for(int n=0; n < p_maxNodes; ++n; inner0){
//      e = pmlElementIds[es];
//       if (n < p_Np){
//         // const int pmlId = pmlIds[es];
//         const int id  = p_Nfields*(e*p_Np + n);
//         // const int pid = p_Nfields*(pmlId*p_Np + n);

//         const int rhsId1 = 3*id + ((shift+0)%3)*p_Nfields;
//         const int rhsId2 = 3*id + ((shift+2)%3)*p_Nfields;
//         const int rhsId3 = 3*id + ((shift+1)%3)*p_Nfields;
       
//         occaUnroll(p_Nfields)
//           for(int fld=0; fld< p_Nfields; ++fld){
//             if(fld<3)
//               s_q[p_Nfields*n+fld] = q[id+fld]+ab1*rhsq[rhsId1+fld]+ab2*rhsq[rhsId2+fld]+ab3*rhsq[rhsId3+fld];
//             else
//               s_q[p_Nfields*n+fld] = expdt*q[id+fld]+saab1*rhsq[rhsId1+fld] + saab2*rhsq[rhsId2+fld] + saab3*rhsq[rhsId3+fld];
//           }
//       }
//     }

//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodes;++n;inner0){
//       if(n<p_Nfaces*p_Nfp){

//         const int iid  = e*p_Nfp*p_Nfaces + n;
//         const int qidM = p_Nfields*(vmapM[iid]-e*p_Np);
//         const int qid  = p_Nfields*iid; 

//         occaUnroll(p_Nfields)
//          for (int fld = 0; fld < p_Nfields; ++fld){
//           fQM[qid+fld] = s_q[qidM+fld];
//         }   
//       }

//     }
      
//   }
// }



// // kernel void boltzmannSARK3StageUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat expdt, 
// //             const dfloat rka,
// //             const dfloat erka,
// //             const dfloat rkb,
// //             const dfloat erkb,
// //             const dfloat4 * restrict rhsq1,
// //             const dfloat4 * restrict rhsq2,
// //             const dfloat4 * restrict qold,
// //                   dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];
// //       const int base = 2*(n + element*p_Np);

// //       dfloat4 rhsq1a = rhsq1[base+0];
// //       dfloat4 rhsq1b = rhsq1[base+1];

// //       dfloat4 rhsq2a = rhsq2[base+0];
// //       dfloat4 rhsq2b = rhsq2[base+1];


// //       dfloat4 qoa = qold[base+0];
// //       dfloat4 qob = qold[base+1];
      
// //       //
// //       dfloat4 qa, qb;
// //       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x ); // + rkc* rhsq3a.x );
// //       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y ); // + rkc* rhsq3a.y );
// //       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z ); //+ rkc* rhsq3a.z );
      
// //       //
// //       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w); // +erkc*rhsq3a.w );
// //       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x); //+erkc*rhsq3b.x );
// //       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y);//+erkc*rhsq3b.y );
      
// //       q[base+0] = qa;
// //       q[base+1] = qb;

// //     }
// //   }
// // }


// // kernel void boltzmannSARK3PmlStageUpdate2D(const int Nelements,
// //               const int * restrict elementIds, 
// //               const dfloat dt,  
// //               const dfloat expdt, 
// //               const dfloat rka,
// //               const dfloat erka,
// //               const dfloat rkb,
// //               const dfloat erkb,
// //               const dfloat ramp, 
// //               const dfloat4 * restrict rhsq1,
// //               const dfloat * restrict rhsqx1,
// //               const dfloat * restrict rhsqy1,
// //               const dfloat4 * restrict rhsq2, 
// //               const dfloat * restrict rhsqx2,
// //               const dfloat * restrict rhsqy2,
// //               const dfloat4 * restrict qold,
// //               const dfloat * restrict qxold,
// //               const dfloat * restrict qyold,
// //                     dfloat * restrict qx,
// //                     dfloat * restrict qy,
// //                     dfloat4 * restrict q){
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){

// //       const int element = elementIds[e];
// //       const int base = n + element*p_Nfields*p_Np;


// //       dfloat rhsqx11 = rhsqx1[base+0*p_Np];
// //       dfloat rhsqx12 = rhsqx1[base+1*p_Np];
// //       dfloat rhsqx13 = rhsqx1[base+2*p_Np];
// //       dfloat rhsqx14 = rhsqx1[base+3*p_Np];
// //       dfloat rhsqx15 = rhsqx1[base+4*p_Np];
// //       dfloat rhsqx16 = rhsqx1[base+5*p_Np];

// //       dfloat rhsqy11 = rhsqy1[base+0*p_Np];
// //       dfloat rhsqy12 = rhsqy1[base+1*p_Np];
// //       dfloat rhsqy13 = rhsqy1[base+2*p_Np];
// //       dfloat rhsqy14 = rhsqy1[base+3*p_Np];
// //       dfloat rhsqy15 = rhsqy1[base+4*p_Np];
// //       dfloat rhsqy16 = rhsqy1[base+5*p_Np];
      
// //       //
// //       dfloat rhsqx21 = rhsqx2[base+0*p_Np];
// //       dfloat rhsqx22 = rhsqx2[base+1*p_Np];
// //       dfloat rhsqx23 = rhsqx2[base+2*p_Np];
// //       dfloat rhsqx24 = rhsqx2[base+3*p_Np];
// //       dfloat rhsqx25 = rhsqx2[base+4*p_Np];
// //       dfloat rhsqx26 = rhsqx2[base+5*p_Np];

// //       dfloat rhsqy21 = rhsqy2[base+0*p_Np];
// //       dfloat rhsqy22 = rhsqy2[base+1*p_Np];
// //       dfloat rhsqy23 = rhsqy2[base+2*p_Np];
// //       dfloat rhsqy24 = rhsqy2[base+3*p_Np];
// //       dfloat rhsqy25 = rhsqy2[base+4*p_Np];
// //       dfloat rhsqy26 = rhsqy2[base+5*p_Np];
// //       //
// //       dfloat qxold1 = qxold[base+0*p_Np];
// //       dfloat qxold2 = qxold[base+1*p_Np];
// //       dfloat qxold3 = qxold[base+2*p_Np];
// //       dfloat qxold4 = qxold[base+3*p_Np];
// //       dfloat qxold5 = qxold[base+4*p_Np];
// //       dfloat qxold6 = qxold[base+5*p_Np];

// //       dfloat qyold1 = qyold[base+0*p_Np];
// //       dfloat qyold2 = qyold[base+1*p_Np];
// //       dfloat qyold3 = qyold[base+2*p_Np];
// //       dfloat qyold4 = qyold[base+3*p_Np];
// //       dfloat qyold5 = qyold[base+4*p_Np];
// //       dfloat qyold6 = qyold[base+5*p_Np];


// //       //
// //       dfloat qx1 = qxold1 + dt*( rka*rhsqx11 + rkb*rhsqx21);
// //       dfloat qx2 = qxold2 + dt*( rka*rhsqx12 + rkb*rhsqx22);
// //       dfloat qx3 = qxold3 + dt*( rka*rhsqx13 + rkb*rhsqx23);
// //       dfloat qx4 = qxold4 + dt*( rka*rhsqx14 + rkb*rhsqx24);
// //       dfloat qx5 = qxold5 + dt*( rka*rhsqx15 + rkb*rhsqx25);
// //       dfloat qx6 = qxold6 + dt*( rka*rhsqx16 + rkb*rhsqx26);
          
// //       // 
// //       dfloat qy1 = qyold1 + dt*(  rka*rhsqy11 +  rkb*rhsqy21);
// //       dfloat qy2 = qyold2 + dt*(  rka*rhsqy12 +  rkb*rhsqy22);
// //       dfloat qy3 = qyold3 + dt*(  rka*rhsqy13 +  rkb*rhsqy23);
// //       dfloat qy4 = qyold4 + dt*(  rka*rhsqy14 +  rkb*rhsqy24);
// //       dfloat qy5 = qyold5 + dt*(  rka*rhsqy15 +  rkb*rhsqy25);
// //       dfloat qy6 = qyold6 + dt*(  rka*rhsqy16 +  rkb*rhsqy26);
      
// //       //
// //       qx[base+0*p_Np] = qx1;
// //       qx[base+1*p_Np] = qx2;
// //       qx[base+2*p_Np] = qx3;
// //       qx[base+3*p_Np] = qx4;
// //       qx[base+4*p_Np] = qx5;
// //       qx[base+5*p_Np] = qx6;

// //       qy[base+0*p_Np] = qy1;
// //       qy[base+1*p_Np] = qy2;
// //       qy[base+2*p_Np] = qy3;
// //       qy[base+3*p_Np] = qy4;
// //       qy[base+4*p_Np] = qy5;
// //       qy[base+5*p_Np] = qy6;

// //       //
// //       const int id = 2*(n + element*p_Np);

// //       dfloat4 rhsq1a = rhsq1[id+0];
// //       dfloat4 rhsq1b = rhsq1[id+1];

// //       dfloat4 rhsq2a = rhsq2[id+0];
// //       dfloat4 rhsq2b = rhsq2[id+1];
// //       //
// //       dfloat4 qoa    = qold[id+0];
// //       dfloat4 qob    = qold[id+1];

// //  //
// //       dfloat4 qa, qb;
// //       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x ); 
// //       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y ); 
// //       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z ); 
      
// //       //
// //       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w); 
// //       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x); 
// //       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y);
      
// //       q[id+0] = qa;
// //       q[id+1] = qb;
      
     
// //     }
// //   }
// // }




// // kernel void boltzmannSARK3Update2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat expdt, 
// //             const dfloat rka,
// //             const dfloat erka,
// //             const dfloat rkb,
// //             const dfloat erkb,
// //             const dfloat rkc,
// //             const dfloat erkc,
// //             const dfloat4 * restrict rhsq1,
// //             const dfloat4 * restrict rhsq2,
// //             const dfloat4 * restrict rhsq3,
// //                   dfloat4 * restrict qold,
// //                   dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];
// //       const int base = 2*(n + element*p_Np);
// //       //
// //       dfloat4 rhsq1a = rhsq1[base+0];
// //       dfloat4 rhsq1b = rhsq1[base+1];
// //       //
// //       dfloat4 rhsq2a = rhsq2[base+0];
// //       dfloat4 rhsq2b = rhsq2[base+1];
// //       //
// //       dfloat4 rhsq3a = rhsq3[base+0];
// //       dfloat4 rhsq3b = rhsq3[base+1];
// //       //    
// //       dfloat4 qoa = qold[base+0];
// //       dfloat4 qob = qold[base+1];
      
// //       dfloat4 qa, qb; 
// //       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x + rkc* rhsq3a.x );
// //       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y + rkc* rhsq3a.y );
// //       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z + rkc* rhsq3a.z );
// //       //
// //       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w +erkc*rhsq3a.w );
// //       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x +erkc*rhsq3b.x );
// //       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y +erkc*rhsq3b.y );
      
// //       q[base+0] = qa;
// //       q[base+1] = qb;
// //       //
// //       qold[base+0] = qa;
// //       qold[base+1] = qb;


// //     }
// //   }
// // }



// // kernel void boltzmannSARK3PmlUpdate2D(const int Nelements,
// //               const int * restrict elementIds, 
// //               const dfloat dt,  
// //               const dfloat expdt, 
// //               const dfloat rka,
// //               const dfloat erka,
// //               const dfloat rkb,
// //               const dfloat erkb,
// //               const dfloat rkc,
// //               const dfloat erkc,
// //               const dfloat ramp, 
// //               const dfloat4 * restrict rhsq1,
// //               const dfloat * restrict rhsqx1,
// //               const dfloat * restrict rhsqy1, 
// //               const dfloat4 * restrict rhsq2,
// //               const dfloat * restrict rhsqx2,
// //               const dfloat * restrict rhsqy2,
// //               const dfloat4 * restrict rhsq3,
// //               const dfloat * restrict rhsqx3,
// //               const dfloat * restrict rhsqy3,
// //                     dfloat4 * restrict qold, 
// //                     dfloat * restrict qxold,
// //                     dfloat * restrict qyold,
// //                     dfloat * restrict qx,
// //                     dfloat * restrict qy,
// //                     dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){

// //       const int element = elementIds[e];
// //       const int base = n + element*p_Nfields*p_Np;


// //       dfloat rhsqx11 = rhsqx1[base+0*p_Np];
// //       dfloat rhsqx12 = rhsqx1[base+1*p_Np];
// //       dfloat rhsqx13 = rhsqx1[base+2*p_Np];
// //       dfloat rhsqx14 = rhsqx1[base+3*p_Np];
// //       dfloat rhsqx15 = rhsqx1[base+4*p_Np];
// //       dfloat rhsqx16 = rhsqx1[base+5*p_Np];

// //       dfloat rhsqy11 = rhsqy1[base+0*p_Np];
// //       dfloat rhsqy12 = rhsqy1[base+1*p_Np];
// //       dfloat rhsqy13 = rhsqy1[base+2*p_Np];
// //       dfloat rhsqy14 = rhsqy1[base+3*p_Np];
// //       dfloat rhsqy15 = rhsqy1[base+4*p_Np];
// //       dfloat rhsqy16 = rhsqy1[base+5*p_Np];

// //       //
// //       dfloat rhsqx21 = rhsqx2[base+0*p_Np];
// //       dfloat rhsqx22 = rhsqx2[base+1*p_Np];
// //       dfloat rhsqx23 = rhsqx2[base+2*p_Np];
// //       dfloat rhsqx24 = rhsqx2[base+3*p_Np];
// //       dfloat rhsqx25 = rhsqx2[base+4*p_Np];
// //       dfloat rhsqx26 = rhsqx2[base+5*p_Np];

// //       dfloat rhsqy21 = rhsqy2[base+0*p_Np];
// //       dfloat rhsqy22 = rhsqy2[base+1*p_Np];
// //       dfloat rhsqy23 = rhsqy2[base+2*p_Np];
// //       dfloat rhsqy24 = rhsqy2[base+3*p_Np];
// //       dfloat rhsqy25 = rhsqy2[base+4*p_Np];
// //       dfloat rhsqy26 = rhsqy2[base+5*p_Np];

// //       //
// //       dfloat rhsqx31 = rhsqx3[base+0*p_Np];
// //       dfloat rhsqx32 = rhsqx3[base+1*p_Np];
// //       dfloat rhsqx33 = rhsqx3[base+2*p_Np];
// //       dfloat rhsqx34 = rhsqx3[base+3*p_Np];
// //       dfloat rhsqx35 = rhsqx3[base+4*p_Np];
// //       dfloat rhsqx36 = rhsqx3[base+5*p_Np];

// //       dfloat rhsqy31 = rhsqy3[base+0*p_Np];
// //       dfloat rhsqy32 = rhsqy3[base+1*p_Np];
// //       dfloat rhsqy33 = rhsqy3[base+2*p_Np];
// //       dfloat rhsqy34 = rhsqy3[base+3*p_Np];
// //       dfloat rhsqy35 = rhsqy3[base+4*p_Np];
// //       dfloat rhsqy36 = rhsqy3[base+5*p_Np];

      
// //       //
// //       dfloat qxold1 = qxold[base+0*p_Np];
// //       dfloat qxold2 = qxold[base+1*p_Np];
// //       dfloat qxold3 = qxold[base+2*p_Np];
// //       dfloat qxold4 = qxold[base+3*p_Np];
// //       dfloat qxold5 = qxold[base+4*p_Np];
// //       dfloat qxold6 = qxold[base+5*p_Np];

// //       dfloat qyold1 = qyold[base+0*p_Np];
// //       dfloat qyold2 = qyold[base+1*p_Np];
// //       dfloat qyold3 = qyold[base+2*p_Np];
// //       dfloat qyold4 = qyold[base+3*p_Np];
// //       dfloat qyold5 = qyold[base+4*p_Np];
// //       dfloat qyold6 = qyold[base+5*p_Np];

// //       //
// //       dfloat qx1 = qxold1 + dt*( rka*rhsqx11 + rkb*rhsqx21 + rkc*rhsqx31);
// //       dfloat qx2 = qxold2 + dt*( rka*rhsqx12 + rkb*rhsqx22 + rkc*rhsqx32);
// //       dfloat qx3 = qxold3 + dt*( rka*rhsqx13 + rkb*rhsqx23 + rkc*rhsqx33);
// //       dfloat qx4 = qxold4 + dt*( rka*rhsqx14 + rkb*rhsqx24 + rkc*rhsqx34);
// //       dfloat qx5 = qxold5 + dt*( rka*rhsqx15 + rkb*rhsqx25 + rkc*rhsqx35);
// //       dfloat qx6 = qxold6 + dt*( rka*rhsqx16 + rkb*rhsqx26 + rkc*rhsqx36);
      
// //       // //
// //       dfloat qy1 = qyold1 + dt*( rka*rhsqy11 + rkb*rhsqy21 + rkc*rhsqy31);
// //       dfloat qy2 = qyold2 + dt*( rka*rhsqy12 + rkb*rhsqy22 + rkc*rhsqy32);
// //       dfloat qy3 = qyold3 + dt*( rka*rhsqy13 + rkb*rhsqy23 + rkc*rhsqy33);
// //       dfloat qy4 = qyold4 + dt*( rka*rhsqy14 + rkb*rhsqy24 + rkc*rhsqy34);
// //       dfloat qy5 = qyold5 + dt*( rka*rhsqy15 + rkb*rhsqy25 + rkc*rhsqy35);
// //       dfloat qy6 = qyold6 + dt*( rka*rhsqy16 + rkb*rhsqy26 + rkc*rhsqy36);
// //       //
// //       qx[base+0*p_Np] = qx1;
// //       qx[base+1*p_Np] = qx2;
// //       qx[base+2*p_Np] = qx3;
// //       qx[base+3*p_Np] = qx4;
// //       qx[base+4*p_Np] = qx5;
// //       qx[base+5*p_Np] = qx6;

// //       qy[base+0*p_Np] = qy1;
// //       qy[base+1*p_Np] = qy2;
// //       qy[base+2*p_Np] = qy3;
// //       qy[base+3*p_Np] = qy4;
// //       qy[base+4*p_Np] = qy5;
// //       qy[base+5*p_Np] = qy6;
// //       //
// //       qxold[base+0*p_Np] = qx1;
// //       qxold[base+1*p_Np] = qx2;
// //       qxold[base+2*p_Np] = qx3;
// //       qxold[base+3*p_Np] = qx4;
// //       qxold[base+4*p_Np] = qx5;
// //       qxold[base+5*p_Np] = qx6;

// //       qyold[base+0*p_Np] = qy1;
// //       qyold[base+1*p_Np] = qy2;
// //       qyold[base+2*p_Np] = qy3;
// //       qyold[base+3*p_Np] = qy4;
// //       qyold[base+4*p_Np] = qy5;
// //       qyold[base+5*p_Np] = qy6;
// //       //

// //       const int id = 2*(n + element*p_Np);
// //       //
// //       dfloat4 rhsq1a = rhsq1[id+0];
// //       dfloat4 rhsq1b = rhsq1[id+1];
// //       //
// //       dfloat4 rhsq2a = rhsq2[id+0];
// //       dfloat4 rhsq2b = rhsq2[id+1];
// //       //
// //       dfloat4 rhsq3a = rhsq3[id+0];
// //       dfloat4 rhsq3b = rhsq3[id+1];
// //       //    
// //       dfloat4 qoa = qold[id+0];
// //       dfloat4 qob = qold[id+1];
      
// //       dfloat4 qa, qb; 
// //       qa.x   = qoa.x + dt*( rka* rhsq1a.x + rkb* rhsq2a.x + rkc* rhsq3a.x );
// //       qa.y   = qoa.y + dt*( rka* rhsq1a.y + rkb* rhsq2a.y + rkc* rhsq3a.y );
// //       qa.z   = qoa.z + dt*( rka* rhsq1a.z + rkb* rhsq2a.z + rkc* rhsq3a.z );
// //       //
// //       qa.w  = expdt*qoa.w  + dt*( erka*rhsq1a.w + erkb*rhsq2a.w +erkc*rhsq3a.w );
// //       qb.x  = expdt*qob.x  + dt*( erka*rhsq1b.x + erkb*rhsq2b.x +erkc*rhsq3b.x );
// //       qb.y  = expdt*qob.y  + dt*( erka*rhsq1b.y + erkb*rhsq2b.y +erkc*rhsq3b.y );
      
// //       q[id+0] = qa;
// //       q[id+1] = qb;
// //       //
// //       qold[id+0] = qa;
// //       qold[id+1] = qb;


      

// //       //

// //     }
// //   }
// // }








// // kernel void boltzmannSAAB3Update2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat expdt, 
// //             const dfloat ab1,
// //             const dfloat ab2,
// //             const dfloat ab3,
// //             const dfloat saab1,
// //             const dfloat saab2,
// //             const dfloat saab3,
// //                   dfloat4 * restrict rhsq3,
// //                   dfloat4 * restrict rhsq2,
// //                   dfloat4 * restrict rhsq1,
// //                   dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];

// //       const int base = 2*(n + element*p_Np);

// //       dfloat4 rhsq1a = rhsq1[base+0];
// //       dfloat4 rhsq1b = rhsq1[base+1];

// //       dfloat4 rhsq2a = rhsq2[base+0];
// //       dfloat4 rhsq2b = rhsq2[base+1];

// //       dfloat4 rhsq3a = rhsq3[base+0];
// //       dfloat4 rhsq3b = rhsq3[base+1];
// //       //
// //       dfloat4 qa = q[base+0];
// //       dfloat4 qb = q[base+1];
// //       //
// //        //
// //       qa.x += ab1*rhsq1a.x +  ab2*rhsq2a.x + ab3*rhsq3a.x;
// //       qa.y += ab1*rhsq1a.y +  ab2*rhsq2a.y + ab3*rhsq3a.y;
// //       qa.z += ab1*rhsq1a.z +  ab2*rhsq2a.z + ab3*rhsq3a.z;
// //       //
// //       qa.w  = expdt*qa.w  + saab1*rhsq1a.w +  saab2*rhsq2a.w + saab3*rhsq3a.w;
// //       qb.x  = expdt*qb.x  + saab1*rhsq1b.x +  saab2*rhsq2b.x + saab3*rhsq3b.x;
// //       qb.y  = expdt*qb.y  + saab1*rhsq1b.y +  saab2*rhsq2b.y + saab3*rhsq3b.y;
// //       //           
// //       rhsq3[base+0] = rhsq2a;
// //       rhsq3[base+1] = rhsq2b;
// //       //
// //       rhsq2[base+0] = rhsq1a;
// //       rhsq2[base+1] = rhsq1b;
// //       //
// //       q[base+0] = qa;
// //       q[base+1] = qb;
// //     }
// //   }
// // }



// // kernel void boltzmannSAAB3PmlUpdate2D(const int Nelements,
// //               const int * restrict elementIds, 
// //               const dfloat dt,  
// //               const dfloat expdt, 
// //               const dfloat ramp, 
// //               const dfloat ab1,
// //               const dfloat ab2,
// //               const dfloat ab3,
// //               const dfloat saab1,
// //               const dfloat saab2,
// //               const dfloat saab3,
// //               const dfloat4 * restrict rhsq1,
// //               const dfloat * restrict rhsqx1,
// //               const dfloat * restrict rhsqy1,
// //                     dfloat4 * restrict rhsq2,  
// //                     dfloat * restrict rhsqx2,
// //                     dfloat * restrict rhsqy2,
// //                     dfloat4 * restrict rhsq3,
// //                     dfloat * restrict rhsqx3,
// //                     dfloat * restrict rhsqy3,
// //                     dfloat * restrict qx,
// //                     dfloat * restrict qy,
// //                     dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){

// //       const int element = elementIds[e];
// //       const int base = n + element*p_Nfields*p_Np;
// //       const int id1 = base + 0*p_Np;
// //       const int id2 = base + 1*p_Np;
// //       const int id3 = base + 2*p_Np;
// //       const int id4 = base + 3*p_Np;
// //       const int id5 = base + 4*p_Np;
// //       const int id6 = base + 5*p_Np;


// //       dfloat rhsqx11 = rhsqx1[id1];
// //       dfloat rhsqx12 = rhsqx1[id2];
// //       dfloat rhsqx13 = rhsqx1[id3];
// //       dfloat rhsqx14 = rhsqx1[id4];
// //       dfloat rhsqx15 = rhsqx1[id5];
// //       dfloat rhsqx16 = rhsqx1[id6];

// //       dfloat rhsqy11 = rhsqy1[id1];
// //       dfloat rhsqy12 = rhsqy1[id2];
// //       dfloat rhsqy13 = rhsqy1[id3];
// //       dfloat rhsqy14 = rhsqy1[id4];
// //       dfloat rhsqy15 = rhsqy1[id5];
// //       dfloat rhsqy16 = rhsqy1[id6];

// //       //
// //       dfloat rhsqx21 = rhsqx2[id1];
// //       dfloat rhsqx22 = rhsqx2[id2];
// //       dfloat rhsqx23 = rhsqx2[id3];
// //       dfloat rhsqx24 = rhsqx2[id4];
// //       dfloat rhsqx25 = rhsqx2[id5];
// //       dfloat rhsqx26 = rhsqx2[id6];

// //       dfloat rhsqy21 = rhsqy2[id1];
// //       dfloat rhsqy22 = rhsqy2[id2];
// //       dfloat rhsqy23 = rhsqy2[id3];
// //       dfloat rhsqy24 = rhsqy2[id4];
// //       dfloat rhsqy25 = rhsqy2[id5];
// //       dfloat rhsqy26 = rhsqy2[id6];

// //       //
// //       dfloat rhsqx31 = rhsqx3[id1];
// //       dfloat rhsqx32 = rhsqx3[id2];
// //       dfloat rhsqx33 = rhsqx3[id3];
// //       dfloat rhsqx34 = rhsqx3[id4];
// //       dfloat rhsqx35 = rhsqx3[id5];
// //       dfloat rhsqx36 = rhsqx3[id6];

// //       dfloat rhsqy31 = rhsqy3[id1];
// //       dfloat rhsqy32 = rhsqy3[id2];
// //       dfloat rhsqy33 = rhsqy3[id3];
// //       dfloat rhsqy34 = rhsqy3[id4];
// //       dfloat rhsqy35 = rhsqy3[id5];
// //       dfloat rhsqy36 = rhsqy3[id6];

// //       //
// //       qx[id1] += ab1*rhsqx11 + ab2*rhsqx21 + ab3*rhsqx31;
// //       qx[id2] += ab1*rhsqx12 + ab2*rhsqx22 + ab3*rhsqx32;
// //       qx[id3] += ab1*rhsqx13 + ab2*rhsqx23 + ab3*rhsqx33;
// //       qx[id4] += ab1*rhsqx14 + ab2*rhsqx24 + ab3*rhsqx34;
// //       qx[id5] += ab1*rhsqx15 + ab2*rhsqx25 + ab3*rhsqx35;
// //       qx[id6] += ab1*rhsqx16 + ab2*rhsqx26 + ab3*rhsqx36;

// //       qy[id1] += ab1*rhsqy11 + ab2*rhsqy21 + ab3*rhsqy31;
// //       qy[id2] += ab1*rhsqy12 + ab2*rhsqy22 + ab3*rhsqy32;
// //       qy[id3] += ab1*rhsqy13 + ab2*rhsqy23 + ab3*rhsqy33;
// //       qy[id4] += ab1*rhsqy14 + ab2*rhsqy24 + ab3*rhsqy34;
// //       qy[id5] += ab1*rhsqy15 + ab2*rhsqy25 + ab3*rhsqy35;
// //       qy[id6] += ab1*rhsqy16 + ab2*rhsqy26 + ab3*rhsqy36;
// //       //
// //       rhsqx2[id1] = rhsqx11;
// //       rhsqx2[id2] = rhsqx12;
// //       rhsqx2[id3] = rhsqx13;
// //       rhsqx2[id4] = rhsqx14;
// //       rhsqx2[id5] = rhsqx15;
// //       rhsqx2[id6] = rhsqx16;
// //       //
// //       rhsqx3[id1] = rhsqx21;
// //       rhsqx3[id2] = rhsqx22;
// //       rhsqx3[id3] = rhsqx23;
// //       rhsqx3[id4] = rhsqx24;
// //       rhsqx3[id5] = rhsqx25;
// //       rhsqx3[id6] = rhsqx26;
// //       //
// //       //
// //       rhsqy2[id1] = rhsqy11;
// //       rhsqy2[id2] = rhsqy12;
// //       rhsqy2[id3] = rhsqy13;
// //       rhsqy2[id4] = rhsqy14;
// //       rhsqy2[id5] = rhsqy15;
// //       rhsqy2[id6] = rhsqy16;
// //       //
// //       rhsqy3[id1] = rhsqy21;
// //       rhsqy3[id2] = rhsqy22;
// //       rhsqy3[id3] = rhsqy23;
// //       rhsqy3[id4] = rhsqy24;
// //       rhsqy3[id5] = rhsqy25;
// //       rhsqy3[id6] = rhsqy26;
// //       //
// //       const int id = 2*(n + element*p_Np);

// //       dfloat4 rhsq1a = rhsq1[id+0];
// //       dfloat4 rhsq1b = rhsq1[id+1];

// //       dfloat4 rhsq2a = rhsq2[id+0];
// //       dfloat4 rhsq2b = rhsq2[id+1];

// //       dfloat4 rhsq3a = rhsq3[id+0];
// //       dfloat4 rhsq3b = rhsq3[id+1];
// //       //
// //       dfloat4 qa = q[id+0];
// //       dfloat4 qb = q[id+1];
// //       //
// //       qa.x += ab1*rhsq1a.x +  ab2*rhsq2a.x + ab3*rhsq3a.x;
// //       qa.y += ab1*rhsq1a.y +  ab2*rhsq2a.y + ab3*rhsq3a.y;
// //       qa.z += ab1*rhsq1a.z +  ab2*rhsq2a.z + ab3*rhsq3a.z;
// //       //
// //       qa.w  = expdt*qa.w  + saab1*rhsq1a.w +  saab2*rhsq2a.w + saab3*rhsq3a.w;
// //       qb.x  = expdt*qb.x  + saab1*rhsq1b.x +  saab2*rhsq2b.x + saab3*rhsq3b.x;
// //       qb.y  = expdt*qb.y  + saab1*rhsq1b.y +  saab2*rhsq2b.y + saab3*rhsq3b.y;
// //       //           
// //       rhsq3[id+0] = rhsq2a;
// //       rhsq3[id+1] = rhsq2b;
// //       //
// //       rhsq2[id+0] = rhsq1a;
// //       rhsq2[id+1] = rhsq1b;
// //       //
// //       q[id+0] = qa;
// //       q[id+1] = qb;

// //     }
// //   }
// // }











// // kernel void boltzmannLSERKPmlUpdate2D_0(const int Nelements,
// //               const int * restrict elementIds, 
// //               const dfloat dt,  
// //               const dfloat rka,
// //               const dfloat rkb,
// //               const dfloat ramp, 
// //               const dfloat4 * restrict rhsq, 
// //               const dfloat * restrict rhsqx,
// //               const dfloat * restrict rhsqy, 
// //                     dfloat4 * restrict resq,
// //                     dfloat * restrict resqx,
// //                     dfloat * restrict resqy,
// //                     dfloat * restrict qx,
// //                     dfloat * restrict qy,
// //                     dfloat4 * restrict q){
  
// //   // Low storage Runge Kutta time step update
// //   for(int es=0;es<Nelements;++es;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){

// //       const int e  = elementIds[es];
      
// //       const int base = n + e*p_Nfields*p_Np;
// //       const int id   = 2*(n + e*p_Np); 

// //       dfloat resqx1 = resqx[base+0*p_Np];
// //       dfloat resqx2 = resqx[base+1*p_Np];
// //       dfloat resqx3 = resqx[base+2*p_Np];
// //       dfloat resqx4 = resqx[base+3*p_Np];
// //       dfloat resqx5 = resqx[base+4*p_Np];
// //       dfloat resqx6 = resqx[base+5*p_Np];

// //       dfloat resqy1 = resqy[base+0*p_Np];
// //       dfloat resqy2 = resqy[base+1*p_Np];
// //       dfloat resqy3 = resqy[base+2*p_Np];
// //       dfloat resqy4 = resqy[base+3*p_Np];
// //       dfloat resqy5 = resqy[base+4*p_Np];
// //       dfloat resqy6 = resqy[base+5*p_Np];
// //       //
// //       dfloat rhsqx1 = rhsqx[base+0*p_Np];
// //       dfloat rhsqx2 = rhsqx[base+1*p_Np];
// //       dfloat rhsqx3 = rhsqx[base+2*p_Np];
// //       dfloat rhsqx4 = rhsqx[base+3*p_Np];
// //       dfloat rhsqx5 = rhsqx[base+4*p_Np];
// //       dfloat rhsqx6 = rhsqx[base+5*p_Np];

// //       dfloat rhsqy1 = rhsqy[base+0*p_Np];
// //       dfloat rhsqy2 = rhsqy[base+1*p_Np];
// //       dfloat rhsqy3 = rhsqy[base+2*p_Np];
// //       dfloat rhsqy4 = rhsqy[base+3*p_Np];
// //       dfloat rhsqy5 = rhsqy[base+4*p_Np];
// //       dfloat rhsqy6 = rhsqy[base+5*p_Np];
      
// //       //Compute  Residual
// //       resqx1 = rka*resqx1 + dt*rhsqx1;
// //       resqx2 = rka*resqx2 + dt*rhsqx2;
// //       resqx3 = rka*resqx3 + dt*rhsqx3;
// //       resqx4 = rka*resqx4 + dt*rhsqx4;
// //       resqx5 = rka*resqx5 + dt*rhsqx5;
// //       resqx6 = rka*resqx6 + dt*rhsqx6;

// //       resqy1 = rka*resqy1 + dt*rhsqy1;
// //       resqy2 = rka*resqy2 + dt*rhsqy2;
// //       resqy3 = rka*resqy3 + dt*rhsqy3;
// //       resqy4 = rka*resqy4 + dt*rhsqy4;
// //       resqy5 = rka*resqy5 + dt*rhsqy5;
// //       resqy6 = rka*resqy6 + dt*rhsqy6;
      

// //       // Update Q
// //       qx[base+0*p_Np] += rkb*resqx1;
// //       qx[base+1*p_Np] += rkb*resqx2;
// //       qx[base+2*p_Np] += rkb*resqx3;
// //       qx[base+3*p_Np] += rkb*resqx4;
// //       qx[base+4*p_Np] += rkb*resqx5;
// //       qx[base+5*p_Np] += rkb*resqx6;

// //       qy[base+0*p_Np] += rkb*resqy1;
// //       qy[base+1*p_Np] += rkb*resqy2;
// //       qy[base+2*p_Np] += rkb*resqy3;
// //       qy[base+3*p_Np] += rkb*resqy4;
// //       qy[base+4*p_Np] += rkb*resqy5;
// //       qy[base+5*p_Np] += rkb*resqy6;
      
// //       //Update Res
// //       resqx[base+0*p_Np] = resqx1;
// //       resqx[base+1*p_Np] = resqx2;
// //       resqx[base+2*p_Np] = resqx3;
// //       resqx[base+3*p_Np] = resqx4;
// //       resqx[base+4*p_Np] = resqx5;
// //       resqx[base+5*p_Np] = resqx6;

// //       resqy[base+0*p_Np] = resqy1;
// //       resqy[base+1*p_Np] = resqy2;
// //       resqy[base+2*p_Np] = resqy3;
// //       resqy[base+3*p_Np] = resqy4;
// //       resqy[base+4*p_Np] = resqy5;
// //       resqy[base+5*p_Np] = resqy6;
      
// //       // Update Q
// //       dfloat4 resqa = resq[id + 0];
// //       dfloat4 resqb = resq[id + 1];

// //       dfloat4 rhsqa = rhsq[id+0];
// //       dfloat4 rhsqb = rhsq[id+1];

// //       dfloat4 qa = q[id+0];
// //       dfloat4 qb = q[id+1];

// //       resqa = rka*resqa + dt*rhsqa;
// //       resqb = rka*resqb + dt*rhsqb;

// //       resq[id+0] = resqa;
// //       resq[id+1] = resqb;
       
// //       qa += rkb*resqa;
// //       qb += rkb*resqb;
// //       //
// //       q[id+0] = qa;
// //       q[id+1] = qb;

      
// //     }
// //   }
// // }











// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXResidualUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat aki,
// //             const dfloat ake, 
// //             const dfloat4 * restrict q,
// //             const dfloat4 * restrict qZ,
// //                   dfloat4 * restrict qY){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];

// //       const int id0 = 2*(n + element*p_Np);
// //       const int id1 = id0 + 1; 

// //       dfloat4 qima = qZ[id0];
// //       dfloat4 qimb = qZ[id1];

// //       dfloat4 qexa = qY[id0];
// //       dfloat4 qexb = qY[id1];
// //       //
// //       dfloat4 qa   = q[id0];
// //       dfloat4 qb   = q[id1];

// //       qY[id0] = qa + ake*dt*qexa + aki*dt*qima;
// //       qY[id1] = qb + ake*dt*qexb + aki*dt*qimb;
      

// //     }
// //   }
// // }


// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXImplicitUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat akk,
// //             const dfloat4 * restrict qZ,
// //             const dfloat4 * restrict qY,
// //                   dfloat4 * restrict q,
// //                   dfloat4 * restrict qS){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       //
// //       const int element = elementIds[e];
// //       const int id0 = 2*(n + element*p_Np);
// //       const int id1 = id0 + 1; 

// //       dfloat4 qima = qZ[id0];
// //       dfloat4 qimb = qZ[id1];

// //       dfloat4 qexa = qY[id0];
// //       dfloat4 qexb = qY[id1];
// //       //
// //       dfloat4 qa  = q[id0];
// //       dfloat4 qb  = q[id1];

// //       qS[id0] = qa; 
// //       qS[id1] = qb; 

// //       q[id0] = qexa + akk*dt*qima;
// //       q[id1] = qexb + akk*dt*qimb;      

// //     }
// //   }
// // }


// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat akk,
// //             const dfloat4 * restrict qZ,
// //             const dfloat4 * restrict qY,
// //             const dfloat4 * restrict qS,
// //                   dfloat4 * restrict q){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];

// //       const int id0 = 2*(n + element*p_Np);
// //       const int id1 = id0 + 1; 

// //       dfloat4 qia = qZ[id0];
// //       dfloat4 qib = qZ[id1];

// //       dfloat4 qea = qY[id0];
// //       dfloat4 qeb = qY[id1];
// //       //
// //       dfloat4 qa  = qS[id0];
// //       dfloat4 qb  = qS[id1];
// //       //
// //       q[id0] = qa+ akk*dt*(qia + qea);
// //       q[id1] = qb+ akk*dt*(qib + qeb);     

// //     }
// //   }
// // }






// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXPmlResidualUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt,
// //             const dfloat ramp, 
// //             const dfloat c_im,
// //             const dfloat c_ex, 
// //             const dfloat4 * restrict q,
// //             const dfloat  * restrict pmlqx,
// //             const dfloat  * restrict pmlqy,
// //                   dfloat4 * restrict qZ,
// //                   dfloat4 * restrict qY,  
// //                   dfloat  * restrict pmlYx,
// //                   dfloat  * restrict pmlYy){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];
// //       //
// //       const int base = n + element*p_Nfields*p_Np;
// //       const int id1 = base + 0*p_Np;
// //       const int id2 = base + 1*p_Np;
// //       const int id3 = base + 2*p_Np;
// //       const int id4 = base + 3*p_Np;
// //       const int id5 = base + 4*p_Np;
// //       const int id6 = base + 5*p_Np;
// //       // PML UPDATES
// //       dfloat qx1 = pmlqx[id1];
// //       dfloat qx2 = pmlqx[id2];
// //       dfloat qx3 = pmlqx[id3];
// //       dfloat qx4 = pmlqx[id4];
// //       dfloat qx5 = pmlqx[id5];
// //       dfloat qx6 = pmlqx[id6]; 
// //       //
// //       dfloat qy1 = pmlqy[id1];
// //       dfloat qy2 = pmlqy[id2];
// //       dfloat qy3 = pmlqy[id3];
// //       dfloat qy4 = pmlqy[id4];
// //       dfloat qy5 = pmlqy[id5];
// //       dfloat qy6 = pmlqy[id6]; 

// //       // PML UPDATES
// //       dfloat qxe1 = pmlYx[id1];
// //       dfloat qxe2 = pmlYx[id2];
// //       dfloat qxe3 = pmlYx[id3];
// //       dfloat qxe4 = pmlYx[id4];
// //       dfloat qxe5 = pmlYx[id5];
// //       dfloat qxe6 = pmlYx[id6]; 
// //       //
// //       dfloat qye1 = pmlYy[id1];
// //       dfloat qye2 = pmlYy[id2];
// //       dfloat qye3 = pmlYy[id3];
// //       dfloat qye4 = pmlYy[id4];
// //       dfloat qye5 = pmlYy[id5];
// //       dfloat qye6 = pmlYy[id6]; 
     
// //       // PML UPDATES
// //       pmlYx[id1] = qx1 + c_ex*dt*qxe1;
// //       pmlYx[id2] = qx2 + c_ex*dt*qxe2;
// //       pmlYx[id3] = qx3 + c_ex*dt*qxe3;
// //       pmlYx[id4] = qx4 + c_ex*dt*qxe4;
// //       pmlYx[id5] = qx5 + c_ex*dt*qxe5;
// //       pmlYx[id6] = qx6 + c_ex*dt*qxe6; 
// //       //
// //       pmlYy[id1] = qy1 + c_ex*dt*qye1;
// //       pmlYy[id2] = qy2 + c_ex*dt*qye2;
// //       pmlYy[id3] = qy3 + c_ex*dt*qye3;
// //       pmlYy[id4] = qy4 + c_ex*dt*qye4;
// //       pmlYy[id5] = qy5 + c_ex*dt*qye5;
// //       pmlYy[id6] = qy6 + c_ex*dt*qye6; 
      
// //       //
// //       const int id = 2*(n + element*p_Np);

// //       dfloat4 qima = qZ[id];
// //       dfloat4 qimb = qZ[id+1];

// //       dfloat4 qexa = qY[id];
// //       dfloat4 qexb = qY[id+1];
// //       //
// //       dfloat4 qa   = q[id];
// //       dfloat4 qb   = q[id+1];

// //       qY[id]   = qa + c_ex*dt*qexa + c_im*dt*qima;
// //       qY[id+1] = qb + c_ex*dt*qexb + c_im*dt*qimb;
     
// //     }
// //   }
// // }







// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXPmlImplicitUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat ramp,
// //             const dfloat akk,
// //             const dfloat4 * restrict qY,
// //             const dfloat  * restrict qYx,
// //             const dfloat  * restrict qYy,
// //             const dfloat4 * restrict qZ,
// //                   dfloat  * restrict pmlqx,
// //                   dfloat  * restrict pmlqy,
// //                   dfloat  * restrict qSx,
// //                   dfloat  * restrict qSy,   
// //                   dfloat4 * restrict qS,
// //                   dfloat4 * restrict q ){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];
// //       //
// //       const int base = n + element*p_Nfields*p_Np;
// //       const int id1 = base + 0*p_Np;
// //       const int id2 = base + 1*p_Np;
// //       const int id3 = base + 2*p_Np;
// //       const int id4 = base + 3*p_Np;
// //       const int id5 = base + 4*p_Np;
// //       const int id6 = base + 5*p_Np;
// //       // There are many dummy operation to keep the readable update later
// //       dfloat qx1 = pmlqx[id1];
// //       dfloat qx2 = pmlqx[id2];
// //       dfloat qx3 = pmlqx[id3];
// //       dfloat qx4 = pmlqx[id4];
// //       dfloat qx5 = pmlqx[id5];
// //       dfloat qx6 = pmlqx[id6]; 
// //       //
// //       dfloat qy1 = pmlqy[id1];
// //       dfloat qy2 = pmlqy[id2];
// //       dfloat qy3 = pmlqy[id3];
// //       dfloat qy4 = pmlqy[id4];
// //       dfloat qy5 = pmlqy[id5];
// //       dfloat qy6 = pmlqy[id6];         
      
// //       // PML UPDATES
// //       dfloat qxe1 = qYx[id1];
// //       dfloat qxe2 = qYx[id2];
// //       dfloat qxe3 = qYx[id3];
// //       dfloat qxe4 = qYx[id4];
// //       dfloat qxe5 = qYx[id5];
// //       dfloat qxe6 = qYx[id6]; 
// //       //
// //       dfloat qye1 = qYy[id1];
// //       dfloat qye2 = qYy[id2];
// //       dfloat qye3 = qYy[id3];
// //       dfloat qye4 = qYy[id4];
// //       dfloat qye5 = qYy[id5];
// //       dfloat qye6 = qYy[id6]; 
      
// //       // PML UPDATES
// //       qSx[id1] = qx1;
// //       qSx[id2] = qx2;
// //       qSx[id3] = qx3;
// //       qSx[id4] = qx4;
// //       qSx[id5] = qx5;
// //       qSx[id6] = qx6; 
// //       //
// //       qSy[id1] = qy1;
// //       qSy[id2] = qy2;
// //       qSy[id3] = qy3;
// //       qSy[id4] = qy4;
// //       qSy[id5] = qy5;
// //       qSy[id6] = qy6;   

// //       // PML UPDATES
// //       pmlqx[id1] = qxe1;
// //       pmlqx[id2] = qxe2;
// //       pmlqx[id3] = qxe3;
// //       pmlqx[id4] = qxe4;
// //       pmlqx[id5] = qxe5;
// //       pmlqx[id6] = qxe6; 
// //        // PML UPDATES
// //       pmlqy[id1] = qye1;
// //       pmlqy[id2] = qye2;
// //       pmlqy[id3] = qye3;
// //       pmlqy[id4] = qye4;
// //       pmlqy[id5] = qye5;
// //       pmlqy[id6] = qye6; 
// //       //
      
// //       const int id = 2*(n + element*p_Np);
      
// //       dfloat4 qima = qZ[id];
// //       dfloat4 qimb = qZ[id+1];

// //       dfloat4 qexa = qY[id];
// //       dfloat4 qexb = qY[id+1];
// //       //
// //       dfloat4 qa  = q[id];
// //       dfloat4 qb  = q[id+1];

// //       qS[id] = qa; 
// //       qS[id+1] = qb; 

// //       q[id]   = qexa + akk*dt*qima;
// //       q[id+1] = qexb + akk*dt*qimb;  

// //     }
// //   }
// // }



// // // Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
// // kernel void boltzmannLSIMEXPmlUpdate2D(const int Nelements,
// //             const int * restrict elementIds,
// //             const dfloat dt, 
// //             const dfloat akk,
// //             const dfloat ramp,
// //             const dfloat4  * restrict qZ,
// //             const dfloat4  * restrict qY,
// //             const dfloat  * restrict qYx,
// //             const dfloat  * restrict qYy,
// //             const dfloat4  * restrict qS,
// //             const dfloat  * restrict qSx,
// //             const dfloat  * restrict qSy,    
// //                   dfloat  * restrict pmlqx,
// //                   dfloat  * restrict pmlqy,
// //                   dfloat4 * restrict q ){
// //   // Low storage Runge Kutta time step update
// //   for(int e=0;e<Nelements;++e;outer0){
// //     for(int n=0;n<p_Np;++n;inner0){
// //       const int element = elementIds[e];

// //       //
// //       const int base = n + element*p_Nfields*p_Np;
// //       const int id1 = base + 0*p_Np;
// //       const int id2 = base + 1*p_Np;
// //       const int id3 = base + 2*p_Np;
// //       const int id4 = base + 3*p_Np;
// //       const int id5 = base + 4*p_Np;
// //       const int id6 = base + 5*p_Np; 
// //       // 
// //       dfloat qxe1 = qYx[id1];
// //       dfloat qxe2 = qYx[id2];
// //       dfloat qxe3 = qYx[id3];
// //       dfloat qxe4 = qYx[id4];
// //       dfloat qxe5 = qYx[id5];
// //       dfloat qxe6 = qYx[id6]; 
// //       //
// //       dfloat qye1 = qYy[id1];
// //       dfloat qye2 = qYy[id2];
// //       dfloat qye3 = qYy[id3];
// //       dfloat qye4 = qYy[id4];
// //       dfloat qye5 = qYy[id5];
// //       dfloat qye6 = qYy[id6];      
// //       // 
// //       dfloat qsx1 = qSx[id1];
// //       dfloat qsx2 = qSx[id2];
// //       dfloat qsx3 = qSx[id3];
// //       dfloat qsx4 = qSx[id4];
// //       dfloat qsx5 = qSx[id5];
// //       dfloat qsx6 = qSx[id6]; 
// //       // 
// //       dfloat qsy1 = qSy[id1];
// //       dfloat qsy2 = qSy[id2];
// //       dfloat qsy3 = qSy[id3];
// //       dfloat qsy4 = qSy[id4];
// //       dfloat qsy5 = qSy[id5];
// //       dfloat qsy6 = qSy[id6];  
// //       // 
// //       pmlqx[id1] =qsx1 + akk*dt*qxe1;
// //       pmlqx[id2] =qsx2 + akk*dt*qxe2;
// //       pmlqx[id3] =qsx3 + akk*dt*qxe3;
// //       pmlqx[id4] =qsx4 + akk*dt*qxe4;
// //       pmlqx[id5] =qsx5 + akk*dt*qxe5;
// //       pmlqx[id6] =qsx6 + akk*dt*qxe6; 
// //       // 
// //       pmlqy[id1] =qsy1 + akk*dt*qye1;
// //       pmlqy[id2] =qsy2 + akk*dt*qye2;
// //       pmlqy[id3] =qsy3 + akk*dt*qye3;
// //       pmlqy[id4] =qsy4 + akk*dt*qye4;
// //       pmlqy[id5] =qsy5 + akk*dt*qye5;
// //       pmlqy[id6] =qsy6 + akk*dt*qye6; 
// //       //
// //       const int id = 2*(n + element*p_Np);
      
// //       dfloat4 qia = qZ[id];
// //       dfloat4 qib = qZ[id+1];

// //       dfloat4 qea = qY[id];
// //       dfloat4 qeb = qY[id+1];
// //       //
// //       dfloat4 qa  = qS[id];
// //       dfloat4 qb  = qS[id+1];
// //       //
// //       q[id]   = qa+ akk*dt*(qia + qea);
// //       q[id+1] = qb+ akk*dt*(qib + qeb);    

// //     }
// //   }
// // }

