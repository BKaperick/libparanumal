kernel void bnsLSERKUpdateTet3D(const dlong Nelements,
                                const dlong * restrict elementIds,
                                const dfloat dt,  
                                const dfloat rka,
                                const dfloat rkb,
                                const dfloat * restrict rhsq,
                                      dfloat * restrict resq,
                                      dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(dlong es=0;es<Nelements;++es;outer0){

    for(int n=0;n<p_Np;++n;inner0){
      const dlong e = elementIds[es];
      const dlong id = e*p_Np*p_Nfields + n;
                  
        for(int fld=0; fld< p_Nfields; ++fld){

         const dlong idn = id + fld*p_Np;
         dfloat r_resq = resq[idn];
         dfloat r_rhsq = rhsq[idn]; 
         dfloat r_q    = q[idn];
         
         r_resq = rka*r_resq + dt*r_rhsq;
         r_q   += rkb*r_resq;
         
         resq[idn] = r_resq;
         q[idn]    = r_q;
      }
    }
  }
}



kernel void bnsLSERKPmlUpdateTet3D(const dlong pmlNelements,
                                   const dlong   * restrict pmlElementIds,
                                   const dlong   * restrict pmlIds,
                                   const dfloat dt,  
                                   const dfloat rka,
                                   const dfloat rkb,
                                   const dfloat ramp, 
                                   const dfloat * restrict rhsq, 
                                   const dfloat * restrict rhsqx,
                                   const dfloat * restrict rhsqy, 
                                   const dfloat * restrict rhsqz, 
                                        dfloat * restrict resq,
                                        dfloat * restrict resqx,
                                        dfloat * restrict resqy,
                                        dfloat * restrict resqz,
                                        dfloat * restrict qx,
                                        dfloat * restrict qy,
                                        dfloat * restrict qz,
                                        dfloat * restrict q){
  
// Low storage Runge Kutta time step update
for(dlong es=0;es<pmlNelements;++es;outer0){
  exclusive dlong e;
  for(int n=0; n < p_Np; ++n; inner0){
    e = pmlElementIds[es];

    if (n < p_Np){
      const dlong pmlId = pmlIds[es];
      const dlong idb  = e*p_Nfields*p_Np + n;
      const dlong pidb = pmlId*p_Nfields*p_Np + n;
      //
      occaUnroll(p_Nfields)
      for (int fld =0; fld<p_Nfields; ++fld){
        const dlong id  = idb  + fld*p_Np;
        const dlong pid = pidb + fld*p_Np;

        const dfloat r_q  = q [id ];
        const dfloat r_qx = qx[pid];
        const dfloat r_qy = qy[pid];
        const dfloat r_qz = qz[pid];

        dfloat r_resq  = resq [id ];      
        dfloat r_resqx = resqx[pid];
        dfloat r_resqy = resqy[pid];
        dfloat r_resqz = resqz[pid];

        const dfloat r_rhsq  = rhsq [id ];
        const dfloat r_rhsqx = rhsqx[pid];
        const dfloat r_rhsqy = rhsqy[pid];
        const dfloat r_rhsqz = rhsqz[pid];

        r_resq  = rka*r_resq  + dt*r_rhsq ;
        r_resqx = rka*r_resqx + dt*r_rhsqx;
        r_resqy = rka*r_resqy + dt*r_rhsqy;
        r_resqz = rka*r_resqz + dt*r_rhsqz;

        q [id ] = r_q  + rkb*r_resq ;
        qx[pid] = r_qx + rkb*r_resqx;
        qy[pid] = r_qy + rkb*r_resqy;
        qz[pid] = r_qz + rkb*r_resqz;

        resq [id ]  = r_resq ;      
        resqx[pid]  = r_resqx;
        resqy[pid]  = r_resqy;
        resqz[pid]  = r_resqz;
      } 
    }
  }
}
}