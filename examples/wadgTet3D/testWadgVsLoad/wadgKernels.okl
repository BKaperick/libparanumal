#define dfloat float
#define iint unsigned int

kernel void applyWADG(const iint Nelements,
                      const dfloat * restrict cubInterp,
                      const dfloat * restrict cubProject,
                      const dfloat * restrict weight,
                      dfloat * restrict q){

  for(iint eo = 0; eo < Nelements; eo += p_Kblk; outer0){

    shared dfloat s_p[p_Kblk][p_cubNp];
    exclusive dfloat r_p;

    for(iint es = 0; es < p_Kblk; ++es;inner1){
      for(iint n=0; n < p_cubNp; ++n; inner0){

        const int e = es + eo;

        if (n < p_Np & e < Nelements){

          const iint id = e*p_Np + n;
          s_p[es][n] = q[id]; // extract field var

          // Initialize register variable
          r_p = 0.f;
        }

      }
    }
    barrier(localMemFence);

    for(iint es = 0; es < p_Kblk; ++es;inner1){

      // Interpolate to cubature nodes
      for(iint n=0; n < p_cubNp; ++n; inner0){

        const iint e = es + eo;

        if (e < Nelements){

          // Prefetch value of weight
          const dfloat weight_n = weight[n + e*p_cubNp];

          dfloat val = 0.f;
          for (int i=0;i<p_Np;++i){
            val += cubInterp[n + i*p_cubNp] * s_p[es][i];
          }

          // Multiply by weight at cubature node
          r_p = val * weight_n;
        }
      }
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint es = 0; es < p_Kblk; ++es;inner1){
      for(iint n=0;n<p_cubNp;++n;inner0){
        const iint e = es+eo;
        if (e < Nelements){
          s_p[es][n] = r_p;
        }
      }
    }
    barrier(localMemFence);

    // Increment solution, project result back down
    for(iint es = 0; es < p_Kblk; ++es; inner1){
      for(iint n=0; n<p_cubNp; ++n; inner0){
        const iint e = es + eo;
        if (n < p_Np & e < Nelements){

          // Project scaled rhs down
          dfloat pp = 0.f;
          for (int i=0;i<p_cubNp;++i){
            pp += cubProject[n + i*p_Np] * s_p[es][i];
          }

          // Increment solutions
          q[n + e*p_Np] = pp;

        }

      }
    }

  }
}


kernel void applyPw(const iint Nelements,
                    const dfloat * restrict Pw,
                    dfloat * restrict rhs){

  for(iint eo = 0; eo < Nelements; eo += p_Kblk; outer0){

    shared dfloat s_p[p_Kblk][p_Np];

    for(iint es = 0; es < p_Kblk; ++es; inner1){
      for(iint n=0; n < p_Np; ++n; inner0){
        const int e = eo + es;
        if (e < Nelements){
          s_p[es][n] = q[n + e*p_Np];
        }
      }
    }
    barrier(localMemFence);

    for(iint es = 0; es < p_Kblk; ++es; inner1){
      for(iint n=0; n < p_Np; ++n; inner0){
        const iint e = es+eo;
        if (e < Nelements){
          dfloat val = 0.f;
          for(iint m=0; m < p_Np; ++m){
            const dfloat Pwm = Pw[n + m*p_Np + e*p_Np2];
            val += Pwm * s_p[es][m];
          }
          q[n + e*p_Np] = val;
        }
      }
    }

  }
}
