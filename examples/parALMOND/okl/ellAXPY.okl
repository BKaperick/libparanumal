kernel void ellAXPY(const dlong   numRows,
        const int             nnzPerRow,
        const dlong             strideLength,
        const dfloat           alpha,
        const dfloat           beta,
        const dlong  *restrict cols,
        const dfloat *restrict coefs,
        const dfloat *restrict x,
              dfloat *restrict y){

  // y = alpha * A * x + beta * y
  for(dlong i=0;i<numRows;++i;tile(256)){

    if(i < numRows){
      const dfloat betay = beta*y[i];

      dfloat result = 0.;
      for(int c=0; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        if (col >-1) {
          const dfloat coeffn = coefs[address];
          const dfloat xn = x[col];

          result += coeffn*xn;
        }
      }
      y[i] = alpha*result + betay;//beta*y[row];
    }
  }
}

kernel void ellZeqAXPY(const dlong   numRows,
           const int   nnzPerRow,
           const dlong   strideLength,
           const dfloat   alpha,
           const dfloat   beta,
           const dlong  *restrict cols,
           const dfloat *restrict coefs,
           const dfloat *restrict x,
           const dfloat *restrict y,
                 dfloat *restrict z){

  // z = alpha * A * x + beta * y
  for(dlong i=0;i<numRows;++i;tile(256)){
    if(i < numRows){
      dfloat result = 0.;
      for(int c=0; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        // dont access coefs[address] if col is -ve
        if(col > -1) result += coefs[address]*x[col];
      }
      z[i] = alpha*result + beta*y[i];
    }
  }
}

kernel void ellJacobi(const dlong   numRows,
           const int   nnzPerRow,
           const dlong   strideLength,
           const dlong  *restrict cols,
           const dfloat *restrict coefs,
           const dfloat *restrict x,
           const dfloat *restrict r,
                 dfloat *restrict z){

  // z = r - (A-D)*x
  for(dlong i=0;i<numRows;++i;tile(256)){
    if(i < numRows){
      dfloat result = r[i];

      // skip the first stride since it corresponds to diag
      for(int c=1; c<nnzPerRow; c++){
        // location in the memory
        const dlong address = c*strideLength+i;

        // access column index
        const dlong col = cols[address];

        // dont access coefs[address] or x[col] if col is -ve
        if(col > -1) result -= coefs[address]*x[col];
      }
      z[i] = result;
    }
  }
}

