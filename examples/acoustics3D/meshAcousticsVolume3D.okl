#define RXID 0  
#define RYID 1  
#define RZID 2  
#define SXID 3
#define SYID 4
#define SZID 5
#define TXID 6
#define TYID 7
#define TZID 8

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
kernel void meshAcousticsVolume3D_o0(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat * restrict q,
				     dfloat * restrict rhsq){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
      
      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
	const iint id = p_Nfields*(e*p_Np + i);
	const dfloat u = q[id+0], v = q[id+1], w = q[id+2], p = q[id+3];

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	dudr += Drni*u; duds += Dsni*u; dudt += Dtni*u;
	dvdr += Drni*v; dvds += Dsni*v; dvdt += Dtni*v;
	dwdr += Drni*w; dwds += Dsni*w; dwdt += Dtni*w;
	dpdr += Drni*p;	dpds += Dsni*p; dpdt += Dtni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = p_Nfields*(e*p_Np + n);
      rhsq[id+0] = -dpdx;
      rhsq[id+1] = -dpdy;
      rhsq[id+2] = -dpdz;
      rhsq[id+3] = -dudx-dvdy-dwdz;
    }
  }
}



// o1: float4s
kernel void meshAcousticsVolume3D_o1(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
      
      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;      
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
	const iint id = e*p_Np + i;
	const dfloat4 q4i = q4[id];
	const dfloat u = q4i.x, v = q4i.y, w = q4i.z, p = q4i.w;

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r', 's', and 't'
	dudr += Drni*u; duds += Dsni*u; dudt += Dtni*u;
	dvdr += Drni*v; dvds += Dsni*v; dvdt += Dtni*v;
	dwdr += Drni*w; dwds += Dsni*w; dwdt += Dtni*w;
	dpdr += Drni*p;	dpds += Dsni*p; dpdt += Dtni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dpdz;
      rhsq4n.w = -dudx-dvdy-dwdz;
      rhsq4[id] = rhsq4n;
    }
  }
}



// o2: load q into shared
kernel void meshAcousticsVolume3D_o2(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

    shared dfloat s_u[p_Np], s_v[p_Np], s_w[p_Np], s_p[p_Np];
    
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      const iint id = e*p_Np + n;
      const dfloat4 q4n = q4[id];
      s_u[n] = q4n.x;
      s_v[n] = q4n.y;
      s_w[n] = q4n.z;
      s_p[n] = q4n.w;
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
      const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
      const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
      const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];

      // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
      dfloat dudr = 0, duds = 0, dudt = 0;
      dfloat dvdr = 0, dvds = 0, dvdt = 0;
      dfloat dwdr = 0, dwds = 0, dwdt = 0;
      dfloat dpdr = 0, dpds = 0, dpdt = 0;
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];
	const dfloat Dtni = DtT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*s_u[i]; duds += Dsni*s_u[i]; dudt += Dtni*s_u[i];
	dvdr += Drni*s_v[i]; dvds += Dsni*s_v[i]; dvdt += Dtni*s_v[i];
	dpdr += Drni*s_p[i]; dpds += Dsni*s_p[i]; dpdt += Dtni*s_p[i];
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
      const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
      const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dpdz;
      rhsq4n.w = -dudx-dvdy-dwdz;
      rhsq4[id] = rhsq4n;
    }
  }
}

// o3: multiple elements for each outer iteration
kernel void meshAcousticsVolume3D_o3(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_w[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];

	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  for(iint i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    const dfloat Dtni = DtT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o4: unroll 
kernel void meshAcousticsVolume3D_o4(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_w[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      // load data at node i of element e
	      const dfloat Drni = DrT[n+i*p_Np];
	      const dfloat Dsni = DsT[n+i*p_Np];
	      const dfloat Dtni = DtT[n+i*p_Np];
	    
	      // differentiate (u,v,p) with respect to 'r' and 's'
	      dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	      dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	      dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o5: DrT,Ds into shared
kernel void meshAcousticsVolume3D_o5(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_w[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    shared dfloat s_DrT[p_Np][p_Np];
    shared dfloat s_DsT[p_Np][p_Np];
    shared dfloat s_DtT[p_Np][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	// prefetch DrT, Ds into shared
	iint t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  s_DtT[0][t] = DtT[t];
	  t += p_Np*p_NblockV;
	}
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;
	  
	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = s_DrT[i][n];
	    const dfloat Dsni = s_DsT[i][n];	  
	    const dfloat Dtni = s_DtT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i]; dudt += Dtni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i]; dvdt += Dtni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i]; dpdt += Dtni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;

	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}


// o6: vgeo in shared
kernel void meshAcousticsVolume3D_o6(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict DtT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_w[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    shared dfloat s_DrT[p_Np][p_Np];
    shared dfloat s_DsT[p_Np][p_Np];
    shared dfloat s_DtT[p_Np][p_Np];

    shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	// prefetch DrT, Ds into shared
	iint t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  s_DtT[0][t] = DtT[t];

	  t += p_Np*p_NblockV;
	}

	t = n+es*p_Np;
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<p_Nvgeo*Nelements)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t += p_Np*p_NblockV;
	}

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_w[es][n] = q4n.z;
	  s_p[es][n] = q4n.w;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];
	  
	  // compute 'r', 's', and 't' derivatives of (u,v,w,p) at node n
	  dfloat dudr = 0, duds = 0, dudt = 0;
	  dfloat dvdr = 0, dvds = 0, dvdt = 0;
	  dfloat dwdr = 0, dwds = 0, dwdt = 0;
	  dfloat dpdr = 0, dpds = 0, dpdt = 0;

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      const dfloat Drni = s_DrT[i][n];
	      
	      // differentiate (u,v,p) with respect to 'r' and 's'
	      dudr += Drni*s_u[es][i]; 
	      dvdr += Drni*s_v[es][i];
	      dwdr += Drni*s_w[es][i];
	      dpdr += Drni*s_p[es][i];
	    }
	  
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      
	      const dfloat Dsni = s_DsT[i][n];
	      
	      duds += Dsni*s_u[es][i];	    
	      dvds += Dsni*s_v[es][i];
	      dwds += Dsni*s_w[es][i];
	      dpds += Dsni*s_p[es][i];
	    }

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      
	      const dfloat Dtni = s_DtT[i][n];
	      
	      dudt += Dtni*s_u[es][i];	    
	      dvdt += Dtni*s_v[es][i];
	      dwdt += Dtni*s_w[es][i];
	      dpdt += Dtni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
	  const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
	  const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dpdz;
	  rhsq4n.w = -dudx-dvdy-dwdz;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}



