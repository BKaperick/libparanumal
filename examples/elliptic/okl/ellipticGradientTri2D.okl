// compute local gradients

kernel void ellipticGradientTri2D_v0(const dlong Nelements,
                                     const dfloat * restrict vgeo,
                                     const dfloat * restrict const Dmatrices,
                                     const dfloat * restrict q,
                                     dfloat4 * restrict gradq){  

  for(dlong e=0;e<Nelements;++e;outer0){

    shared dfloat s_q[p_Np];

    for(int n=0;n<p_Np;++n;inner0){
        
      // prefetch q
      const dlong id = e*p_Np+n;
      s_q[n] = q[id];
    }
    
    barrier(localMemFence);

    for(int n=0;n<p_Np;++n;inner0){
        
      const dlong gid = e*p_Nvgeo;
      
      const dfloat drdx = vgeo[gid + p_RXID];
      const dfloat drdy = vgeo[gid + p_RYID];
      const dfloat dsdx = vgeo[gid + p_SXID];
      const dfloat dsdy = vgeo[gid + p_SYID];

      // compute 1D derivatives
      dfloat qr = 0, qs = 0;
      for(int i=0;i<p_Np;++i){
        qr += Dmatrices[n+i*p_Np+0*p_Np*p_Np]*s_q[i];
        qs += Dmatrices[n+i*p_Np+1*p_Np*p_Np]*s_q[i];
      }
      
      dfloat4 gradqn;
      gradqn.x = drdx*qr + dsdx*qs;
      gradqn.y = drdy*qr + dsdy*qs;
      gradqn.w = s_q[n];
      
      const dlong id = e*p_Np+n; 
      gradq[id] = gradqn;
    }
  }
}

#define drdx s_vgeo[es][p_RXID]
#define drdy s_vgeo[es][p_RYID]
#define dsdx s_vgeo[es][p_SXID]
#define dsdy s_vgeo[es][p_SYID]

kernel void ellipticGradientTri2D(const int Nelements,
                                  const dfloat * restrict vgeo,
                                  const dfloat * restrict const Dmatrices,
                                  const dfloat * restrict q,
                                  dfloat4 * restrict gradq){  
  
  // block partition of elements
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_vgeo[p_NblockV][p_Nvgeo];

    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          // prefetch q
          const int id = e*p_Np+n;
          s_q[e-eo][n] = q[id];
        }
        
        // coalesce volume geofac reads to shared
        int t = n + p_Np*(e-eo);
        while(t<p_Nvgeo*p_NblockV){
          if(eo*p_Nvgeo+t<Nelements*p_Nvgeo)
            s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
          t+=p_NblockV*p_Np;
        }
      }
    }
    
    barrier(localMemFence);

    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const int es = e-eo;

          // compute 1D derivatives
          dfloat qr = 0, qs = 0;

          occaUnroll(p_Np)
            for(int i=0;i<p_Np;++i) {
              dfloat drt = Dmatrices[n + i*p_Np + 0*p_Np*p_Np];
              dfloat dst = Dmatrices[n + i*p_Np + 1*p_Np*p_Np];
              dfloat qn  = s_q[es][i];

              qr += drt*qn;
              qs += dst*qn;
            }
          
          dfloat4 gradqn;
          gradqn.x = drdx*qr + dsdx*qs;
          gradqn.y = drdy*qr + dsdy*qs;
          gradqn.w = s_q[es][n];
          
          const int id = e*p_Np+n; 
          gradq[id] = gradqn;
        }
      }
    }
  }
}



 // // Optimized sizes for kernel 4-5
#if p_N==1
 #define p_NbV 10
 #define p_Nmt 1
 #endif

#if p_N==2
 #define p_NbV 4
 #define p_Nmt 2
#endif

#if p_N==3
 #define p_NbV 6
 #define p_Nmt 1
#endif

 #if p_N==4
  #define p_NbV 2
  #define p_Nmt 2
#endif

 #if p_N==5
 #define p_NbV 2
 #define p_Nmt 5
 #endif

#if p_N==6
 #define p_NbV 3
 #define p_Nmt 7
 #endif

#if p_N==7
  #define p_NbV 2
  #define p_Nmt 7
 #endif

#if p_N==8
 #define p_NbV 5
 #define p_Nmt 7
#endif

#if p_N==9
  #define p_NbV 5
  #define p_Nmt 7
 #endif

#if p_N==10
 #define p_NbV 4
 #define p_Nmt 6
#endif


// map multiple nodes to thread
kernel void ellipticPartialGradientTri2D(const dlong Nelements,
         const dlong offset,
         const dfloat * restrict vgeo,
         const dfloat * restrict Dmatrices, 
         const dfloat * restrict q,
              dfloat4 * restrict gradq){
  
  for(dlong eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);outer0){

    shared dfloat s_q[p_Nmt][p_NbV][p_Np];

    for(int es=0; es<p_NbV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        occaUnroll(p_Nmt)
        for(int em=0;em<p_Nmt;++em){    
          const dlong e = eo+es*p_Nmt + em; 
            if(e<Nelements){
              const dlong id = n + (e+offset)*p_Np;
              s_q[em][es][n] = q[id];
            }
          }  
        }
      }

    barrier(localMemFence);

    for(int es=0;es<p_NbV; ++es; inner1){
      for(int n=0;n<p_Np;++n;inner0){
        dfloat qr[p_Nmt], qs[p_Nmt];

        // hold geometric factors on register
        dfloat drdx2[p_Nmt], dsdx2[p_Nmt];
        dfloat drdy2[p_Nmt], dsdy2[p_Nmt];
        
        occaUnroll(p_Nmt)
        for(int em=0;em<p_Nmt;++em){ 
          const dlong e = eo+es*p_Nmt + em+offset; 
          qr[em] = 0.f;
          qs[em] = 0.f;
          //
          drdx2[em] = vgeo[p_Nvgeo*e+p_RXID];
          drdy2[em] = vgeo[p_Nvgeo*e+p_RYID];
          dsdx2[em] = vgeo[p_Nvgeo*e+p_SXID];
          dsdy2[em] = vgeo[p_Nvgeo*e+p_SYID];
        }

        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i){
          dfloat drt = Dmatrices[n + i*p_Np +0*p_Np*p_Np];
          dfloat dst = Dmatrices[n + i*p_Np +1*p_Np*p_Np];

          occaUnroll(p_Nmt)
          for(int em=0;em<p_Nmt;++em){ 
            dfloat qn = s_q[em][es][i];

            qr[em] += drt*qn;
            qs[em] += dst*qn;
          }
        }

        dfloat4 gradqn;

        occaUnroll(p_Nmt)
        for(int em=0;em<p_Nmt;++em){ 
         const dlong e  = eo+es*p_Nmt + em; 
         if(e<Nelements){ 
           const dlong id = (e+offset)*p_Np+n; 
           gradqn.x = drdx2[em]*qr[em] + dsdx2[em]*qs[em];
           gradqn.y = drdy2[em]*qr[em] + dsdy2[em]*qs[em];
           gradqn.w = s_q[em][es][n];

           gradq[id] = gradqn;
          }
        }
      }
    }
  }
}

