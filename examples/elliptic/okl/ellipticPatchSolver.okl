
// experimental overlapping patch solver
kernel void ellipticApproxBlockJacobiSolver(const dlong Nelements,
                                              const dlong  * restrict patchesIndex,
                                              const dfloat * restrict invAP,
                                              const dfloat * restrict invDegree,
                                              const dfloat * restrict q,
                                              dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(dlong e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(dlong e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];

          // patch matrices offset
          const dlong offset = patchesIndex[e]*p_Np*p_Np + n;
          dfloat res = 0.f;
          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np ]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}
