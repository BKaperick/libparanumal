#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))


// experimental overlapping patch solver
@kernel void ellipticPatchGather(const dlong Nelements,
                                @restrict const  dlong   *  EToE,
                                @restrict const  int   *  EToF,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Gq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockP;@outer(0)){

    for(dlong e=eo;e<eo+p_NblockP;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){

        if(e<Nelements){

          dfloat Gqn = 0;

          Gqn = q[p_patchNp*e+n];

          for(int f=0;f<p_Nfaces;++f){

            const dlong eP = EToE[e*p_Nfaces+f]; // load element e first
            const int   fP = EToF[e*p_Nfaces+f];

            if(eP>=0){
              Gqn += q[eP*p_patchNp+(fP+1)*p_Np+n];
            }
          }

          Gq[e*p_Np+n] = Gqn;
        }
      }
    }
  }
}

@kernel void ellipticFacePatchGather(const dlong Nelements,
                                    @restrict const  dlong  *  EToFPairs,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Gq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockP;@outer(0)){

    for(dlong e=eo;e<eo+p_NblockP;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){

        if(e<Nelements){

          dfloat Gqn = 0;

          for(int f=0;f<p_Nfaces;++f){
            const dlong fP = EToFPairs[p_Nfaces*e+f];

            if (fP >=0) {
              Gqn += q[fP*p_Np + n];
            }
          }

          Gq[e*p_Np+n] = Gqn;
        }
      }
    }
  }
}


