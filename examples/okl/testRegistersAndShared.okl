//for reg1-style @kernels, more @shared
//#define elPerBlock p_Np*2+7*p_gjNp
@kernel void testSharedRegisters_v0(const int Ntotal,
                                   const double * arrayIn,
                                   double * arrayOut){

	for(int n=0;n<256;++n;@outer(0)){
		#if (p_Nq == 6 || p_Nq==14)

		@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+2)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+2)^2;

		#else

		@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+1)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)^2;
		#endif	
		@exclusive double testReg[p_reg];

		for (int j=0; j<p_Nq; ++j; @inner(1)){
			for (int i=0; i<p_Nq; ++i; @inner(0)){
				#pragma unroll p_reg
				for (int k=0; k<p_reg; ++k){


					testReg[k] = arrayIn[n*elPerBlock + j*p_Nq*p_reg+i*p_reg+k];
				}
				int k= j*(p_Nq)+i;


				while (k<@sharedSz)
				{
					if (p_reg*p_Nq*p_Nq +n*elPerBlock + (p_Nq+1)*(p_Nq+1)*(p_Nq+1) + k <Ntotal){
						testShared[k] = arrayIn[n*elPerBlock+ p_reg*p_Nq*p_Nq+ k];
					}
					k += (p_Nq)*(p_Nq);
				}


			}
		}

		@barrier("local");
		for (int j=0; j<p_Nq; ++j; @inner(1)){
			for (int i=0; i<p_Nq; ++i; @inner(0)){
				#pragma unroll p_reg
				for (int k=0; k<p_reg; ++k){
					arrayOut[n*elPerBlock + j*p_Nq*p_reg + i*p_reg+k] = testReg[k];
				}

				int m= j*(p_Nq)+i;

				while (m<@sharedSz)
				{
					if (n*elPerBlock + p_reg*p_Nq*p_Nq+ m < Ntotal){
						arrayOut[n*elPerBlock + p_reg*p_Nq*p_Nq + m] = testShared[m];
					}
					m += p_Nq*p_Nq;
				}


				int p=p_reg*p_Nq*p_Nq + @sharedSz + j*(p_Nq)+i;
				while (p<elPerBlock)
				{
				//	arrayOut[p+n*elPerBlock] = arrayIn[p+n*elPerBlock];
arrayOut[p+n*elPerBlock] = 4.34;				
	p+=p_Nq*p_Nq;
				}
			}
		}


	}

}//n


//for reg1-style @kernels, more @shared
//#define elPerBlock p_Np*2+7*p_gjNp
@kernel void testSharedRegisters_v1(const int Ntotal,
                                   const double * arrayIn,
                                   double * arrayOut){

	for(int n=0;n<4192;++n;@outer(0)){
		#if (p_Nq == 6 || p_Nq==14)

		@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+2)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+2)^2;

		#else

		@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+1)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)^2;
		#endif	
		@exclusive double testReg[p_reg];

		for (int j=0; j<32; ++j; @inner(1)){
			for (int i=0; i<32; ++i; @inner(0)){
				#pragma unroll p_reg
				for (int k=0; k<p_reg; ++k){

					if (n*elPerBlock + j*p_Nq*p_reg+i*p_reg+k<Ntotal)
						testReg[k] = arrayIn[n*elPerBlock + j*p_Nq*p_reg+i*p_reg+k];
				}
				int k= j*(p_Nq)+i;


				while (k<@sharedSz)
				{
					if (p_reg*p_Nq*p_Nq +n*elPerBlock + (p_Nq+1)*(p_Nq+1)*(p_Nq+1) + k <Ntotal){
						testShared[k] = arrayIn[n*elPerBlock+ p_reg*p_Nq*p_Nq+ k];
					}
					k += 1024;
				}


			}
		}

		@barrier("local");
		for (int j=0; j<32; ++j; @inner(1)){
			for (int i=0; i<32; ++i; @inner(0)){
				#pragma unroll p_reg
				for (int k=0; k<p_reg; ++k){
					if (n*elPerBlock + j*p_Nq*p_reg + i*p_reg+k <Ntotal)
						arrayOut[n*elPerBlock + j*p_Nq*p_reg + i*p_reg+k] = testReg[k];
				}

				int m= j*(p_Nq)+i;

				while (m<@sharedSz)
				{
					if (n*elPerBlock + p_reg*p_Nq*p_Nq+ m < Ntotal){
						arrayOut[n*elPerBlock + p_reg*p_Nq*p_Nq + m] = testShared[m];
					}
					m += 1024;
				}


				int p=p_reg*p_Nq*p_Nq + @sharedSz + j*(p_Nq)+i;
				while (p<elPerBlock)
				{
					arrayOut[p+n*elPerBlock] = arrayIn[p+n*elPerBlock];
					p+=1024;
				}
			}
		}


	}

}//n


//for reg1-style @kernels, more @shared
//#define elPerBlock p_Np*2+7*p_gjNp
@kernel void testSharedRegisters_v2(const int Ntotal,
                                   const double * arrayIn,
                                   double * arrayOut){
	for(int n=0;n<256;++n;@outer(0)){
		#if (p_Nq == 6 || p_Nq==14)

		@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+2)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+2)+p_Nq*(p_Nq+1)+ 3*(p_Nq+2)^2;

		#else

	@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)*(p_Nq+1)];
		int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+1)+p_Nq*(p_Nq+1)+ 3*(p_Nq+1)^2;
//@shared double testShared[(p_Nq+1)*(p_Nq+1)*(p_Nq+1)];
  //            int @sharedSz = (p_Nq+1)*(p_Nq+1)*(p_Nq+1);	

	#endif	
		//@exclusive double testReg[p_reg];

		for (int j=0; j<p_Nq+1; ++j; @inner(1)){
			for (int i=0; i<p_Nq+1; ++i; @inner(0)){
			//	#pragma unroll p_reg
			//	for (int k=0; k<p_reg; ++k){

			//		if (n*elPerBlock + j*(p_Nq+1)*p_reg+i*p_reg+k<Ntotal)
			//			testReg[k] = arrayIn[n*elPerBlock + j*(p_Nq+1)*p_reg+i*p_reg+k];
			//	}
				int k= j*(p_Nq+1)+i;


				while (k<@sharedSz)
				{
		//			if (p_reg*p_Nq*p_Nq +n*elPerBlock + (p_Nq+1)*(p_Nq+1)*(p_Nq+1) + k <Ntotal){

if ( n*elPerBlock+k <Ntotal){
						testShared[k] = arrayIn[n*elPerBlock+ 0*(p_Nq+1)*(p_Nq+1)+ k];
					}
					k += (p_Nq+1)^2;
				}


			}
		}

		@barrier("local");
		for (int j=0; j<p_Nq+1; ++j; @inner(1)){
			for (int i=0; i<p_Nq+1; ++i; @inner(0)){
		//		#pragma unroll p_reg
		//		for (int k=0; k<p_reg; ++k){
		//			if (n*elPerBlock + j*(p_Nq+1)*p_reg + i*p_reg+k <Ntotal)
		//				arrayOut[n*elPerBlock + j*(p_Nq+1)*p_reg + i*p_reg+k] = testReg[k];
		//		}

				int m= j*(p_Nq+1)+i;

				while (m<@sharedSz)
				{
					if (n*elPerBlock + 0*(p_Nq+1)*(p_Nq+1)+ m < Ntotal){
						arrayOut[n*elPerBlock + 0*(p_Nq+1)*(p_Nq+1) + m] = testShared[m];
					}
					m += (p_Nq+1)^2;
				}


				int p=0*(p_Nq+1)*(p_Nq+1) + @sharedSz + j*((p_Nq+1))+i;
				while (p<elPerBlock)
				{
					arrayOut[p+n*elPerBlock] = arrayIn[p+n*elPerBlock];
					p+=(p_Nq+1)^2;
				}
			}
		}


	}
	
}//n
