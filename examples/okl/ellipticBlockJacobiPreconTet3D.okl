
// block Jacobi preconditioner with inverse of mass matrix
// (assumes mass matrix dominant)
@kernel void ellipticBlockJacobiPreconTet3D(const int Nelements,
             const dfloat invLambda,
             @restrict const  dfloat *  vgeo,
             @restrict const  dfloat *  B,
             @restrict const  dfloat *  q,
             @restrict dfloat *  Pq){  
  
  // block partition of elements
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    
    @shared dfloat s_q[p_NblockV][p_Np];
    @shared dfloat s_scale[p_NblockV];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const int e = es + eo;

        s_q[es][n] = 0;
        if(e<Nelements){
          // prefetch q
          const int id = e*p_Np+n;
          s_q[es][n] = q[id];

          if (n==0)
            s_scale[es] = invLambda/vgeo[e*p_Nvgeo+p_JID];
        }
      }
    }
    
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const int e = es + eo;

        if(e<Nelements){
          // compute 1D derivatives
          dfloat Bqn = 0;
          
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              Bqn += B[n+i*p_Np]*s_q[es][i];
            }
          
          const int id = e*p_Np+n; 
          Pq[id] = Bqn*s_scale[es];
        }
      }
    }
  }
}


// block Jacobi preconditioner with inverse of mass matrix
// (assumes mass matrix dominant)
@kernel void ellipticPartialBlockJacobiPreconTet3D(const int Nelements,
             @restrict const  int   *  elements,
             const dfloat invLambda,
             @restrict const  dfloat *  vgeo,
             @restrict const  dfloat *  B,
             @restrict const  dfloat *  q,
             @restrict dfloat *  Pq){  
  
  // block partition of elements
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    
    @shared dfloat s_q[p_NblockV][p_Np];
    @shared dfloat s_scale[p_NblockV];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const int e = es + eo;

        s_q[es][n] = 0;
        if(e<Nelements){
          const int element = elements[e];
          // prefetch q
          const int id = element*p_Np+n;
          s_q[es][n] = q[id];
 
          if (n==0)
            s_scale[es] = invLambda/vgeo[element*p_Nvgeo+p_JID];
        }
      }
    }
    
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        const int e = es + eo;

        if(e<Nelements){
          const int element = elements[e];
          // compute 1D derivatives
          dfloat Bqn = 0;
          
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              Bqn += B[n+i*p_Np]*s_q[es][i];
            }
          
          const int id = element*p_Np+n; 
          Pq[id] = Bqn*s_scale[es];
        }
      }
    }
  }
}
