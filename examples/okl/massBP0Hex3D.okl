#if p_gjNq==8 || p_gjNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#define p_Nq2 (p_Nq*p_Nq)
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)

@kernel void massPartialAxHex3D_v1(const int Nelements,
                                  @restrict const  int *  elementList,
                                  @restrict const  dfloat *  gjGeo,
                                  @restrict const  dfloat *  gjI,
                                  @restrict const  dfloat *  q,
                                  @restrict dfloat *  Mq){
                                  
                                  
	for(int e=0;e<Nelements;++e;@outer(0)){
	
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		
		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_Mq[p_Nq];
		
		@shared dfloat s_q1[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_q2[p_gjNq][p_gjNq+p_gjPad];
		
		@exclusive int emap;
		
		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
			
				emap = elementList[e];
				
				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];
					
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_Mq[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
			}
		}
		
		@barrier("local");
		
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
				
					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){
							tmp += s_I[k][c]*r_Mq[c];
						}
						r_q[k] = tmp;
					}
					
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						r_Mq[c] = 0;
					}
				}
			}
		}
		
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k){
		
			@barrier("local");
			
			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					if(a<p_Nq && b<p_Nq)
						s_q1[b][a] = r_q[k];
				}
			}
			
			@barrier("local");
			
			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_	Nq;++a){
							tmp += s_I[i][a]*s_q1[b][a];
						}
						s_q2[b][i] = tmp;
					}
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
				
					const dfloat r_GwJ = gjGeo[p_Nggeo*emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i + p_GWJID*p_gjNp];
					
					dfloat tmp = 0;
					
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b){
						tmp += s_I[j][b]*s_q2[b][i];
					}
					
					s_q1[j][i] = r_GwJ*tmp;
				}
			}
			
			@barrier("local");
			
			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					if(b<p_Nq){
						dfloat tmp = 0;
						
						#pragma unroll p_gjNq
						for(int j=0;j<p_gjNq;++j){
							tmp += s_I[j][b]*s_q1[j][i];
						}
						s_q2[b][i] = tmp;
					}
				}
			}
			
			@barrier("local");
			
			for(int b=0;b<p_gjNq;++b;@inner(1)){
				for(int a=0;a<p_gjNq;++a;@inner(0)){
					if(a<p_Nq && b<p_Nq){
					
						dfloat tmp = 0;
						
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*s_q2[b][i];
						}
						
						#pragma unroll p_Nq
						for(int c=0;c<p_Nq;++c){
							r_Mq[c] += s_I[k][c]*tmp;
						}
					}
				}
			}
		}
		
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						const int id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
						Mq[id] = r_Mq[c];
					}
				}
			}
		}
	}
}


@kernel void massPartialAxHex3D_v2(const int Nelements,
                                  @restrict const  int *  elementList,
                                  @restrict const  dfloat *  gjGeo,
                                  @restrict const  dfloat *  gjI,
                                  @restrict const  dfloat *  q,
                                  @restrict dfloat *  Mq){
                                  
                                  
	for(int e=0;e<Nelements;++e;@outer(0)){
	
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];
		
		@exclusive dfloat r_q[p_gjNq];
		
		@exclusive int emap;
		
		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
			
				emap = elementList[e];
				
				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];
					
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c)
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}
		
		@barrier("local");
		
		// transform in b
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];
						
					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}
		
		@barrier("local");
		
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){
				
					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];
						
					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}
		
		@barrier("local");
		
		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];
					
				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){
					// prefetch integration weights
					const int id = p_Nggeo*emap*p_gjNp
					                +k*p_gjNq*p_gjNq+j*p_gjNq+i+p_GWJID*p_gjNp;
					const dfloat r_GwJ = gjGeo[id];
					
					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c)
						tmp += s_I[k][c]*r_q[c];
						
					s_q[k][j][i] = r_GwJ*tmp; // ok since only this thread
				}
			}
		}
		
		@barrier("local");
		
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j)
					r_q[j] = s_q[k][j][i];
					
				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j)
						tmp += s_I[j][b]*r_q[j];
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}
		
		@barrier("local");
		
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];
						
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i)
							tmp += s_I[i][a]*r_q[i];
						s_q[k][b][a] = tmp; // ok since only this thread
					}
				}
			}
		}
		
		@barrier("local");
		
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k)
						r_q[k] = s_q[k][b][a];
						
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k)
							tmp += s_I[k][c]*r_q[k];
							
						Mq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
	}
}
