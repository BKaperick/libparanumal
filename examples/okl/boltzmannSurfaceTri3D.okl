
void flux(const dfloat nx, const dfloat ny, const dfloat nz,
	  const dfloat alpha, const dfloat beta,
	  @restrict const  dfloat *  dq,
	  @restrict dfloat *  fluxq){

  fluxq[0] = alpha*dq[0] - beta*(nx*dq[1] + ny*dq[2] + nz*dq[3]);

  fluxq[1] = alpha*dq[1] - beta*(nx*dq[0] + nx*p_sqrt2*dq[4] + ny*dq[7] + nz*dq[8]);
  fluxq[2] = alpha*dq[2] - beta*(ny*dq[0] + ny*p_sqrt2*dq[5] + nx*dq[7] + nz*dq[9]);
  fluxq[3] = alpha*dq[3] - beta*(nz*dq[0] + nz*p_sqrt2*dq[6] + nx*dq[8] + ny*dq[9]);

  fluxq[4] = alpha*dq[4] - beta*(p_sqrt2*nx*dq[1]);
  fluxq[5] = alpha*dq[5] - beta*(p_sqrt2*ny*dq[2]);
  fluxq[6] = alpha*dq[6] - beta*(p_sqrt2*nz*dq[3]);

  fluxq[7] = alpha*dq[7] - beta*(nx*dq[2]+ny*dq[1]);
  fluxq[8] = alpha*dq[8] - beta*(nx*dq[3]+nz*dq[1]);
  fluxq[9] = alpha*dq[9] - beta*(ny*dq[3]+nz*dq[2]);
}



// nodal DG lift
@kernel void boltzmannSurfaceTri3D(const int Nelements,
				  @restrict const  dfloat *  sgeo,
				  @restrict const  dfloat *  LIFTT,
				  @restrict const  int   *  vmapM,
				  @restrict const  int   *  vmapP,
				  const dfloat time,
				  @restrict const  dfloat *  x,
				  @restrict const  dfloat *  y,
				  @restrict const  dfloat *  z,
				  @restrict const  dfloat *  q,
				  @restrict dfloat *  rhsq){
  
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_dq[p_Nfields][p_NblockS][p_Nfp*p_Nfaces];

    // for all faces (global barrier at end of body of this loop)
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_Nmaxnodes;++n;@inner(0)){ // max(p_Np, p_Nfaces*p_Nfp)
	const int eM = eo + es;
	
	if(eM<Nelements && n<p_Nfp*p_Nfaces){
	  
	  // load surface geofactors for this face
	  const int sid = eM*p_Nsgeo*p_Nfp*p_Nfaces + n;

	  const dfloat nx = sgeo[sid+0*p_Nfp*p_Nfaces];
	  const dfloat ny = sgeo[sid+1*p_Nfp*p_Nfaces];
	  const dfloat nz = sgeo[sid+2*p_Nfp*p_Nfaces];
	  const dfloat sJ = sgeo[sid+3*p_Nfp*p_Nfaces];
	  const dfloat invJ = sgeo[sid+4*p_Nfp*p_Nfaces];
	  
	  // indices of negative and positive traces of face node
	  const int id  = eM*p_Nfp*p_Nfaces + n;
	  const int idM = vmapM[id];
	  const int idP = vmapP[id];
	  const int eP = idP/p_Np;
	  
	  const int vidM = eM*p_Np*p_Nfields + (idM%p_Np);
	  const int vidP = eP*p_Np*p_Nfields + (idP%p_Np);
	  
	  dfloat dq[p_Nfields], fluxq[p_Nfields];
	  
	  #pragma unroll p_Nfields
	    for(int fld=0;fld<p_Nfields;++fld){
	      const dfloat qM = q[vidM+fld*p_Np];
	      const dfloat qP = q[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
	      dq[fld] = qP-qM;
	    }
	  
	  // D = nx*A + ny*B + nz*C
	  // compute 0.5*[q] + 0.5*D*[q]/sqrt(RT)
	  const dfloat alpha = 0.5, beta = 0.5; // was 0.5*p_invsqrtRT
	  
	  flux(nx, ny, nz, alpha, beta, dq, fluxq);
	  
	  const dfloat one = 1.0, zero = 0.0;
	  
	  // compute D*(0.5*[q] + 0.5*D*[q])
	  flux(nx, ny, nz, zero, one, fluxq, dq);
	  
	  #pragma unroll p_Nfields
	    for(int fld=0;fld<p_Nfields;++fld){
	      s_dq[fld][es][n] =  invJ*sJ*dq[fld];
	    }
	}
      }
    }
    
    @barrier("local");
    
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_Nmaxnodes;++n;@inner(0)){ // max(p_Np, p_Nfaces*p_Nfp)
	  const int eM = eo + es;
	  const dfloat foo = 1.2;
	  if(eM<Nelements && n<p_Np){
	    
	    dfloat r_rhsq[p_Nfields];
	    
	    #pragma unroll p_Nfields
	      for(int fld=0;fld<p_Nfields;++fld){
		r_rhsq[fld] = rhsq[n + fld*p_Np + eM*p_Np*p_Nfields];
	      }
	    
	    for(int m=0;m<p_Nfaces*p_Nfp;++m){
	      // evaluate "flux" terms: (sJ/J)*(D+sigma*D*D)*(q^* - q^-)
	      
	      const dfloat sc = LIFTT[n+m*p_Np];
	      
	      #pragma unroll p_Nfields
		for(int fld=0;fld<p_Nfields;++fld){
		  r_rhsq[fld] += sc*s_dq[fld][es][m];  // 4 smem bytes per flop (2 TFLOPS limit)
		}
	    }
	    
	    #pragma unroll p_Nfields
	      for(int fld=0;fld<p_Nfields;++fld){
		rhsq[n + fld*p_Np + eM*p_Np*p_Nfields] = r_rhsq[fld];
	      }
	  }
      }
    }
  }
}

