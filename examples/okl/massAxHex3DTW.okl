
// reference @kernel; no unrolling anywhere and no padding, no const, no compiler variables
@kernel void massPartialAxHex3D_vBaseline(int Nelements,
					 int *  elementList,
					 dfloat * gjGeo,
					 dfloat *  gjI,
					 dfloat *  q,
					 dfloat *  Mq){
                                     
                                     
  for(int e=0;e<Nelements;++e;@outer(0)){
	
    int Nq = p_gjNq-1;
    int Nq2 = Nq*Nq;
    int Np = Nq*Nq2;

    @shared dfloat s_I[p_gjNq][p_gjNq];
		
    @shared dfloat s_q1[p_gjNq][p_gjNq];
    @shared dfloat s_q2[p_gjNq][p_gjNq];
		
    @exclusive int emap;
		
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;@inner(1)){
      for(int a=0;a<p_gjNq;++a;@inner(0)){
			
	emap = elementList[e];
				
	if(a<Nq)
	  s_I[b][a] = gjI[a+Nq*b];

	if(a<Nq && b<Nq){
	  for(int c=0;c<Nq;++c){
	    const int id = emap*Np + c*Nq2 + b*Nq + a;
	    Mq[id] = 0.0;
	  }
	}
      }
    }
		
    @barrier("local");
		
    //error starts here
    for(int k=0;k<p_gjNq;++k){
		
      @barrier("local");
			
      for(int b=0;b<p_gjNq;++b;@inner(1)){
	for(int a=0;a<p_gjNq;++a;@inner(0)){
	  
	  if(a<Nq && b<Nq){
	    dfloat tmp = 0;

	    // fetch straight from q
	    for(int c=0;c<p_Nq;++c){
	      tmp += s_I[k][c]*q[emap*Np+c*Nq2+b*Nq+a];
	    }
	    
	    s_q1[b][a] = tmp;
	  }
	}
      }
			
      @barrier("local");
			
      for(int b=0;b<p_gjNq;++b;@inner(1)){
	for(int i=0;i<p_gjNq;++i;@inner(0)){
	  if(b<Nq){
	    dfloat tmp = 0;
						
	    for(int a=0;a<p_	Nq;++a){
	      tmp += s_I[i][a]*s_q1[b][a];
	    }
	    s_q2[b][i] = tmp;
	  }
	}
      }
			
      @barrier("local");
			
      for(int j=0;j<p_gjNq;++j;@inner(1)){
	for(int i=0;i<p_gjNq;++i;@inner(0)){
				
	  dfloat r_GwJ = gjGeo[p_Nggeo*emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i + p_GWJID*p_gjNp];
					
	  dfloat tmp = 0;
					
	  for(int b=0;b<Nq;++b){
	    tmp += s_I[j][b]*s_q2[b][i];
	  }
					
	  s_q1[j][i] = r_GwJ*tmp;
	}
      }
			
      @barrier("local");
			
      for(int b=0;b<p_gjNq;++b;@inner(1)){
	for(int i=0;i<p_gjNq;++i;@inner(0)){
	  if(b<Nq){
	    dfloat tmp = 0;
						
						
	    for(int j=0;j<p_gjNq;++j){
	      tmp += s_I[j][b]*s_q1[j][i];
	    }
	    s_q2[b][i] = tmp;
	  }
	}
      }
			
      @barrier("local");
			
      for(int b=0;b<p_gjNq;++b;@inner(1)){
	for(int a=0;a<p_gjNq;++a;@inner(0)){
	  if(a<Nq && b<Nq){
					
	    dfloat tmp = 0;
	    for(int i=0;i<p_gjNq;++i){
	      tmp += s_I[i][a]*s_q2[b][i];
	    }
	    
	    // write straight to Mq
	    for(int c=0;c<Nq;++c){
	      const int id = emap*Np + c*Nq2 + b*Nq + a;
	      Mq[id] += s_I[k][c]*tmp;
	    }
	  }
	}
      }
    }
  }
}
