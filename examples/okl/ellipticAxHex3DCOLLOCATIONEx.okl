// hex @kernel for screened coulomb potential mat-vec
#define cubeThreads                             \
	for(int k=0; k<p_Nq; ++k; @inner(2))            \
		for(int j=0; j<p_Nq; ++j; @inner(1))          \
			for(int i=0; i<p_Nq; ++i; @inner(0))


#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

//baseline - as unoptimized as possible

@kernel void ellipticAxHex3D_Ref2D0(int Nelements,
                                   int *  elementList,
                                   dfloat * ggeo,
                                   dfloat *  D,
                                   dfloat lambda,
                                   dfloat *  q,
                                   dfloat *  Aq,
                                   dfloat * Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		//	@shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		
		//	@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				for (int k=0; k<p_Nq; k++){
				
					//		s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
			}
		}
		
		@barrier("local");
		
		
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*q[base + n*p_Nq*p_Nq];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}
		
		@barrier("local");
		
		// process k-slice (first r- and s-derivatives)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					dfloat G00 = ggeo[base+p_G00ID*p_Np];
					dfloat G01 = ggeo[base+p_G01ID*p_Np];
					dfloat G02 = ggeo[base+p_G02ID*p_Np];
					dfloat G11 = ggeo[base+p_G11ID*p_Np];
					dfloat G12 = ggeo[base+p_G12ID*p_Np];
					dfloat G22 = ggeo[base+p_G22ID*p_Np];
					dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
					
						qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np];
						qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					//	s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					
					Aqtemp[base + k*p_Nq*p_Nq] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}
		
		
		@barrier("local");
		
		// second derivatives
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*Aqtemp[k*p_Nq*p_Nq + j*p_Nq + emap*p_Np +n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
	}
	
} //e1c

// Ref0 + const variables
@kernel void ellipticAxHex3D_Ref2D1(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		//	@shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		
		//	@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				for (int k=0; k<p_Nq; k++){
				
					//		s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
<<<<<<< HEAD
					
=======
>>>>>>> master
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
			}
		}
		
		@barrier("local");
		
		
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*q[base + n*p_Nq*p_Nq];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}
		
		@barrier("local");
		
		// process k-slice (first r- and s-derivatives)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					dfloat G00 = ggeo[base+p_G00ID*p_Np];
					dfloat G01 = ggeo[base+p_G01ID*p_Np];
					dfloat G02 = ggeo[base+p_G02ID*p_Np];
					dfloat G11 = ggeo[base+p_G11ID*p_Np];
					dfloat G12 = ggeo[base+p_G12ID*p_Np];
					dfloat G22 = ggeo[base+p_G22ID*p_Np];
					dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
					
						qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np];
						qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					//	s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					
					Aqtemp[base + k*p_Nq*p_Nq] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}
		
		
		@barrier("local");
		
		// second derivatives
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				for(int k=0; k<p_Nq; ++k) {
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*Aqtemp[k*p_Nq*p_Nq + j*p_Nq + emap*p_Np +n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
<<<<<<< HEAD
		
=======
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
>>>>>>> master
	}
	
} //e1c

//Ref1 + unrolling
@kernel void ellipticAxHex3D_Ref2D2(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		//	@shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		
		//	@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					//		s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
<<<<<<< HEAD
					//			Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				//	s_D[j][i] = D[j*p_Nq+i];
=======
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
>>>>>>> master
				
			}
		}
		
		@barrier("local");
		
		
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*q[base + n*p_Nq*p_Nq];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}
		
		@barrier("local");
		
		// process k-slice (first r- and s-derivatives)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
					
						qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np];
						qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					//	s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					
					Aqtemp[base + k*p_Nq*p_Nq] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}
		
		
		@barrier("local");
		
		// second derivatives
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*Aqtemp[k*p_Nq*p_Nq + j*p_Nq + emap*p_Np +n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
<<<<<<< HEAD
=======
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
>>>>>>> master
	}
	
} //e1c

<<<<<<< HEAD
/*
=======

>>>>>>> master
//Ref1 + unrolling + k as external loop
@kernel void ellipticAxHex3D_Ref2D3(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		//	@shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		
		//	@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					//		s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
			}
		}
		
		@barrier("local");
		
		
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*q[base + n*p_Nq*p_Nq];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}
		
		@barrier("local");
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
					
						qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np];
						qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					//	s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					
					Aqtemp[base + k*p_Nq*p_Nq] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}
		
		
		@barrier("local");
		
		// second derivatives
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*Aqtemp[k*p_Nq*p_Nq + j*p_Nq + emap*p_Np +n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
<<<<<<< HEAD
		
=======
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
>>>>>>> master
	}
	
} //e1c

//Ref4 - stmpr and stmps as 2D @shared

@kernel void ellipticAxHex3D_Ref2D4(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		
		//	@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					//		s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
			}
		}
		
		@barrier("local");
		
		
		
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*q[base + n*p_Nq*p_Nq];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}
		
		@barrier("local");
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
					
						qr += s_D[i][n]*q[n + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np];
						qs += s_D[j][n]*q[i + n*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					
					
					s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
			
			
			
			@barrier("local");
			
			// second derivatives
			
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
<<<<<<< HEAD
		
=======
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
>>>>>>> master
	}
	
} //e1c

//Ref5 -- q in @shared

@kernel void ellipticAxHex3D_Ref2D5(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt, r_tmpt[p_Nq];
		
		//		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
				int emap = elementList[e];
				int base = i + j*p_Nq + emap*p_Np;
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					Aq[base + k*p_Nq*p_Nq] = 0.f;
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
			}
		}
		
		@barrier("local");
		
		
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					dfloat qtk = 0.f;
					int emap = elementList[e];
					int base = i + j*p_Nq + emap*p_Np;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][j][i];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
				
			}
			
			
			
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {
<<<<<<< HEAD
					
=======
						/*
							qr += s_D[i][n]*s_tmpq[k][j][n];
													qs += s_D[j][n]*s_tmpq[k][n][i];
													qt += s_D[k][n]*s_tmpq[n][j][i];
						*/
>>>>>>> master
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}
					base = i + j*p_Nq + emap*p_Np;
					// assumes w*J built into G entries
					
					
					s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt;
					
					
					//	s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];
					
					
					
					
					Aq[base + k*p_Nq*p_Nq] += GwJ*lambda*q[i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np ];
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						//s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
						Aq[base + n*p_Nq*p_Nq] +=s_D[k][n]*r_tmpt[k];
					}
				}
			}
			
			
			
			@barrier("local");
			
			// second derivatives
			
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					int emap = elementList[e];
					
					int base = i + j*p_Nq + emap*p_Np;
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						//s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
					
					Aq[base + k*p_Nq*p_Nq] +=  Aq1 + Aq2;
					
					//		s_Aq[k][j][i] +=  Aq1 + Aq2;
					
				}
			}
		}
		//	}//for k ()
		
<<<<<<< HEAD
		
=======
		/*		@barrier("local");
		
				// write result out (local node storage)
				for(int j=0; j<p_Nq; ++j; @inner(1)) {
					for(int i=0; i<p_Nq; ++i; @inner(0)) {
		
						for (int k=0; k<p_Nq; k++){
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
							Aq[base] = s_Aq[k][j][i];
						}
					}
				}*/
>>>>>>> master
	}
	
} //e1c

//eliminate global storage

//eliminate global storage
@kernel void ellipticAxHex3D_Ref2D6(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		@shared dfloat s_tmpr[p_Nq][p_Nq];
		@shared dfloat s_tmps[p_Nq][p_Nq];
		
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat  r_qt, r_tmpq[p_Nq];
		
		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				emap=elementList[e];
				
				const int base = i + j*p_Nq + emap*p_Np;
				
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
				
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k)
					r_tmpq[k] =0.0f;
			}
		}
		
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
		
			@barrier("local");
			
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					dfloat qr = 0.f, qs = 0.f, qt = 0.f;
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
						qt += s_D[k][n]*s_q[n][j][i];
					}//for
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					s_tmpr[j][i] = G00*qr + G01*qs + G02*qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*qt;
					r_qt         = G02*qr + G12*qs + G22*qt;
					
					r_tmpq[k] += lambda*GwJ*s_q[k][j][i];
					
				}//for
			}//for
			
			@barrier("local");
			
			// second derivatives
			
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
						r_tmpq[n] += s_D[k][n]*r_qt;
					}
					r_tmpq[k] += Aq1 + Aq2;
				}
			}
		}
		
		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					
					Aq[base] = r_tmpq[k];
				}
			}
		}
	}
	
} //e1c


//same as in Ref6 BUT WITH PADDING

@kernel void ellipticAxHex3D_Ref2D7(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
	
		@shared dfloat s_tmpr[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_tmps[p_Nq][p_Nq+p_gllPad];
		
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq+p_gllPad];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq+p_gllPad];
		
		@exclusive dfloat  r_qt, r_tmpq[p_Nq];
		
		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				emap=elementList[e];
				
				const int base = i + j*p_Nq + emap*p_Np;
				
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
				
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k)
					r_tmpq[k] =0.0f;
			}
		}
		
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
		
			@barrier("local");
			
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					dfloat qr = 0.f, qs = 0.f, qt = 0.f;
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
						qt += s_D[k][n]*s_q[n][j][i];
					}//for
					
					//		(k,j,i) -> i + j*p_Nq + k*p_Nq*p_Nq+emap*p_Np
					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
					
					s_tmpr[j][i] = G00*qr + G01*qs + G02*qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*qt;
					r_qt         = G02*qr + G12*qs + G22*qt;
					
					r_tmpq[k] += lambda*GwJ*s_q[k][j][i];
					
				}//for
			}//for
			
			@barrier("local");
			
			// second derivatives
			
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
						r_tmpq[n] += s_D[k][n]*r_qt;
					}
					r_tmpq[k] += Aq1 + Aq2;
				}
			}
		}
		
		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					
					Aq[base] = r_tmpq[k];
				}
			}
		}
	}
	
} //e1c


// add padding, and fetch pieces of q to registers


@kernel void ellipticAxHex3D_Ref2D8(const int Nelements,
                                   @restrict const  int *  elementList,
                                   @restrict const  dfloat *  ggeo,
                                   @restrict const  dfloat *  D,
                                   const dfloat lambda,
                                   @restrict const  dfloat *  q,
                                   @restrict dfloat *  Aq,
                                   @restrict dfloat *  Aqtemp){
                                   
	for(int e=0; e<Nelements; ++e; @outer(0)){
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmpt;
		@shared dfloat s_tmpr[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_tmps[p_Nq][p_Nq+p_gllPad];
		
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq+p_gllPad];
		//	@shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];
		
		@shared dfloat s_D[p_Nq][p_Nq+p_gllPad];
		
		@exclusive dfloat   r_q[p_Nq],  r_Aq[p_Nq];
		
		@exclusive int emap;
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				emap=elementList[e];
				
				const int base = i + j*p_Nq + emap*p_Np;
				
				#pragma unroll p_Nq
				for (int k=0; k<p_Nq; k++){
				
					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					
				}
				
				s_D[j][i] = D[j*p_Nq+i];
				
				
				
			}
		}
		
		
		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				emap = elementList[e];
				
				const int base = i + j*p_Nq + emap*p_Np;
				
				#pragma unroll p_Nq
				for(int k=0; k<p_Nq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}
				
				
			}
		}
		
		@barrier("local");
		#pragma unroll p_Nq
		for(int k=0; k<p_Nq; ++k) {
			@barrier("local");
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
					const int gbase = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					r_G00 = ggeo[gbase+p_G00ID*p_Np];
					r_G01 = ggeo[gbase+p_G01ID*p_Np];
					r_G02 = ggeo[gbase+p_G02ID*p_Np];
					r_G11 = ggeo[gbase+p_G11ID*p_Np];
					r_G12 = ggeo[gbase+p_G12ID*p_Np];
					r_G22 = ggeo[gbase+p_G22ID*p_Np];
					r_GwJ = ggeo[gbase+p_GWJID*p_Np];
					
					// share k-slice of q
					//		s_q[k][j][i] = r_q[k];
					
					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}
			
			@barrier("local");
			
			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
				
				
					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}
					
					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;
					
					r_Aq[k] += r_GwJ*lambda*r_q[k];
					
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}
			
			@barrier("local");
			
			// second derivatives
			for(int j=0; j<p_Nq; ++j; @inner(1)) {
				for(int i=0; i<p_Nq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;
					
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
					
					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}
		for(int j=0; j<p_Nq; ++j; @inner(1)) {
			for(int i=0; i<p_Nq; ++i; @inner(0)) {
			
				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					
					Aq[base] = r_Aq[k];
				}
			}
		}
		
	}//e
	
} //e1c


<<<<<<< HEAD
//very optimized version from tcew/CEEDBP3
=======
/*very optimized version from tcew/CEEDBP3*/
>>>>>>> master

@kernel void ellipticAxHex3D_Ref2D10(const int Nelements,
                                    @restrict const  int *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Aq,
                                    @restrict dfloat *  Aqtemp){
                                    
                                    
	for(int e=0; e<Nelements; ++e; @outer(0)){
		@exclusive int emap;
		@shared dfloat s_D[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_u[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_v[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_w[p_Nq][p_Nq+p_gllPad];
		
		@exclusive dfloat r_ut, r_GDut, r_Auk;
		dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		
		@exclusive dfloat r_u[p_Nq]; // register array to hold u(i,j,0:N) private to thread
		@exclusive dfloat r_Au[p_Nq];// array for results Au(i,j,0:N)
		
		// array of threads
		for(int j=0;j<p_Nq;++j;@inner(1)){
			for(int i=0;i<p_Nq;++i;@inner(0)){
				emap=elementList[e];
<<<<<<< HEAD
				//load D into local memory 
				// s_D[i][j] = d \phi_i at node j
				s_D[j][i] = D[p_Nq*j+i]; // D is column major
				
				// load pencil of u into register 
=======
				/* load D into local memory */
				// s_D[i][j] = d \phi_i at node j
				s_D[j][i] = D[p_Nq*j+i]; // D is column major
				
				/* load pencil of u into register */
>>>>>>> master
				const int base = i + j*p_Nq + emap*p_Np;
				for(int k = 0; k < p_Nq; k++) {
					//	unsigned int id = e*BSIZE+k*p_Nq*p_Nq+j*p_Nq+i;
					
					
					
					
					r_u[k] = q[base + k*p_Nq*p_Nq]; // prefetch operation
					
					r_Au[k] = 0.f; // zero the accumulator
				}
			}
		}
		
		// Layer by layer
		#pragma unroll p_Nq
		for(int k = 0;k < p_Nq; k++){
		
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					// prefetch geometric factors
					//	int id = e*Ngeo*BSIZE + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const int gbase = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					
					r_G00 = ggeo[gbase+p_G00ID*p_Np];
					r_G01 = ggeo[gbase+p_G01ID*p_Np];
					r_G02 = ggeo[gbase+p_G02ID*p_Np];
					r_G11 = ggeo[gbase+p_G11ID*p_Np];
					r_G12 = ggeo[gbase+p_G12ID*p_Np];
					r_G22 = ggeo[gbase+p_G22ID*p_Np];
					r_GwJ = ggeo[gbase+p_GWJID*p_Np];
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					// share u(:,:,k)
					s_u[j][i] = r_u[k];
					
					r_ut = 0;
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++) {
						r_ut += s_D[k][m]*r_u[m];
					}
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					dfloat ur = 0.f;
					dfloat us = 0.f;
					
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++) {
						ur += s_D[i][m]*s_u[j][m];
						us += s_D[j][m]*s_u[m][i];
					}
					
					s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_ut);
					s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_ut);
					
					// put this here for a performance bump
					r_GDut = (r_G02*ur + r_G12*us + r_G22*r_ut);
					
					r_Auk = r_GwJ*lambda*r_u[k];
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
				
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++){
						r_Auk   += s_D[m][j]*s_w[m][i];
						r_Au[m] += s_D[k][m]*r_GDut; // DT(m,k)*ut(i,j,k,e)
						r_Auk   += s_D[m][i]*s_v[j][m];
					}
					
					r_Au[k] += r_Auk;
				}
			}
		}
		
		// write out
		
		for(int j=0;j<p_Nq;++j;@inner(1)){
			for(int i=0;i<p_Nq;++i;@inner(0)){
				#pragma unroll p_Nq
				for(int k = 0; k < p_Nq; k++){
					int id = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[id] = r_Au[k];
				}
			}
		}
	}
}
<<<<<<< HEAD
*/

//this is shmem REd version
=======


/*this is shmem REd version*/
>>>>>>> master

@kernel void ellipticAxHex3D_Ref2D11(const int Nelements,
                                    @restrict const  int *  elementList,
                                    @restrict const  dfloat *  ggeo,
                                    @restrict const  dfloat *  D,
                                    const dfloat lambda,
                                    @restrict const  dfloat *  q,
                                    @restrict dfloat *  Aq,
                                    @restrict dfloat *  Aqtemp){
                                    
                                    
	for(int e=0; e<Nelements; ++e; @outer(0)){
		@exclusive int emap;
		@shared dfloat s_D[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_u[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_v[p_Nq][p_Nq+p_gllPad];
		@shared dfloat s_w[p_Nq][p_Nq+p_gllPad];
		
		@exclusive dfloat r_ut, r_GDut, r_Auk, r_uttwin, r_GDuttwin, r_Auktwin;
		dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_GwJtwin;
		//dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		@exclusive dfloat r_u[p_Nq]; // register array to hold u(i,j,0:N) private to thread
		@exclusive dfloat r_Au[p_Nq];// array for results Au(i,j,0:N)
		
		// array of threads
		for(int j=0;j<p_Nq;++j;@inner(1)){
			for(int i=0;i<p_Nq;++i;@inner(0)){
				emap=elementList[e];
<<<<<<< HEAD
				// load D into local memory
				// s_D[i][j] = d \phi_i at node j
				s_D[j][i] = D[p_Nq*j+i]; // D is column major
				
				// load pencil of u into register
=======
				/* load D into local memory */
				// s_D[i][j] = d \phi_i at node j
				s_D[j][i] = D[p_Nq*j+i]; // D is column major
				
				/* load pencil of u into register */
>>>>>>> master
				const int base = i + j*p_Nq + emap*p_Np;
				for(int k = 0; k < p_Nq; k++) {
					//	unsigned int id = e*BSIZE+k*p_Nq*p_Nq+j*p_Nq+i;
					
					r_u[k] = q[base + k*p_Nq*p_Nq]; // prefetch operation
					
					r_Au[k] = 0.f; // zero the accumulator
				}
			}
		}
		
		// Layer by layer
		#pragma unroll p_Nq
		for(int k = 0;k < p_Nq; k++){
		
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					// prefetch geometric factors
					//	int id = e*Ngeo*BSIZE + k*p_Nq*p_Nq + j*p_Nq + i;
					
					const int gbase = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					const int gbase2 = emap*p_Nggeo*p_Np + (p_Nq-k-1)*p_Nq*p_Nq + j*p_Nq + i;
					
					r_G00 = ggeo[gbase+p_G00ID*p_Np];
					r_G01 = ggeo[gbase+p_G01ID*p_Np];
					r_G02 = ggeo[gbase+p_G02ID*p_Np];
					r_G11 = ggeo[gbase+p_G11ID*p_Np];
					r_G12 = ggeo[gbase+p_G12ID*p_Np];
					r_G22 = ggeo[gbase+p_G22ID*p_Np];
					r_GwJ = ggeo[gbase+p_GWJID*p_Np];
					r_GwJtwin = ggeo[gbase2+p_GWJID*p_Np];
					
					
					
					
					
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					// share u(:,:,k)
					s_u[j][i] = r_u[k];
					
					r_ut = 0;
					
<<<<<<< HEAD
					#pragma unroll p_halfD
					for(int m = 0; m < p_halfD; m++) {
						dfloat shD = s_D[k][m];
						r_ut += shD*r_u[m];
						r_ut += -shD*r_u[p_Nq-m-1];
=======
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++) {
						dfloat shD = s_D[k][m];
						r_ut += shD*r_u[m];
						//		r_ut += -shD*r_u[p_Nq-m-1];
>>>>>>> master
					}
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
					dfloat ur = 0.f;
					dfloat us = 0.f;
					
					
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++) {
						dfloat shDim = s_D[i][m];
						dfloat shDjm = s_D[j][m];
						ur += shDim*s_u[j][m];
						us += shDjm*s_u[m][i];
						
						//	ur += -shDim*s_u[j][p_Nq-m-1];
						//us += -shDim*s_u[p_Nq-m-1][i];
					}
					
					s_w[j][i] = (r_G01*ur + r_G11*us + r_G12*r_ut);
					s_v[j][i] = (r_G00*ur + r_G01*us + r_G02*r_ut);
					r_GDut = (r_G02*ur + r_G12*us + r_G22*r_ut);
					
					r_Auk = r_GwJ*lambda*r_u[k];
					//	r_Auktwin =  r_GwJ*lambda*r_u[p_Nq-1-k];
					
				}
			}
			
			@barrier("local");
			
			for(int j=0;j<p_Nq;++j;@inner(1)){
				for(int i=0;i<p_Nq;++i;@inner(0)){
				
				
					#pragma unroll p_Nq
					for(int m = 0; m < p_Nq; m++){\
					
						dfloat shDmj = s_D[m][j];
						dfloat shDkm = s_D[k][m];
						dfloat shDmi = s_D[m][i];
						
						r_Auk   += shDmj*s_w[m][i];
						r_Au[m] += shDkm*r_GDut; // DT(m,k)*ut(i,j,k,e)
						r_Auk   += shDmi*s_v[j][m];
						
						//	r_Auktwin   += -shDmj*s_w[p_Nq-m-1][i];
						//	r_Au[p_Nq-1-m] += -shDkm*r_GDut; // DT(m,k)*ut(i,j,k,e)
						//r_Auktwin   += -shDmi*s_v[j][p_Nq-m-1];
						
					}
					
					r_Au[k] += r_Auk;
					//		r_Au[p_Nq-1-k] =  r_Auktwin;
				}
			}
		}
		
		// write out
		
		for(int j=0;j<p_Nq;++j;@inner(1)){
			for(int i=0;i<p_Nq;++i;@inner(0)){
				#pragma unroll p_Nq
				for(int k = 0; k < p_Nq; k++){
					int id = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[id] = r_Au[k];
					//		int id2 =  emap*p_Np +(p_Nq-k-1)*p_Nq*p_Nq+ j*p_Nq + i;
					//		Aq[id2] = r_Au[p_Nq-1-k];
				}
			}
		}
	}
	
}
/*
@kernel void ellipticAxHex3D_e0a(const int Nelements,
                                @restrict const  int *  elementList,
                                @restrict const  dfloat *  ggeo,
                                @restrict const  dfloat *  D,
                                const dfloat lambda,
                                @restrict const  dfloat *  q,
                                @restrict dfloat *  Aq){
<<<<<<< HEAD
                                
	for(int e=0; e<Nelements; ++e; @outer(0)) {
	
		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];
		
		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		
		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
		  
		  s_q[k][j][i] = q[base];
		  
		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}
		
		@barrier("local");
		
		cubeThreads {
		
		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  
		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];
		  
		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];
		  
		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];
		  
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;
		  
=======

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		@shared dfloat s_D[p_Nq][p_Nq];

		@exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(:,:,:,e) to @shared
		cubeThreads {
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;

		  s_q[k][j][i] = q[base];

		  if(k==0) // fetch D to @shared
		  s_D[j][i] = D[j*p_Nq+i];
		}

		@barrier("local");

		cubeThreads {

		  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  r_GwJ = ggeo[base+p_GWJID*p_Np];

		  r_G00 = ggeo[base+p_G00ID*p_Np];
		  r_G01 = ggeo[base+p_G01ID*p_Np];
		  r_G02 = ggeo[base+p_G02ID*p_Np];

		  r_G11 = ggeo[base+p_G11ID*p_Np];
		  r_G12 = ggeo[base+p_G12ID*p_Np];
		  r_G22 = ggeo[base+p_G22ID*p_Np];

		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

>>>>>>> master
		  for(int n=0; n<p_Nq; ++n) {
		  qr += s_D[i][n]*s_q[k][j][n];
			  qs += s_D[j][n]*s_q[k][n][i];
			  qt += s_D[k][n]*s_q[n][j][i];
		  }
<<<<<<< HEAD
		  
		  r_qr = qr; r_qs = qs; r_qt = qt;
		  
		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}
		
		// r term ----->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}
		
		@barrier("local");
		
=======

		  r_qr = qr; r_qs = qs; r_qt = qt;

		  r_Aq = r_GwJ*lambda*s_q[k][j][i];
		}

		// r term ----->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
		}

		@barrier("local");

>>>>>>> master
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][i]*s_q[k][j][n];
<<<<<<< HEAD
		  
		  r_Aq += tmp;
		}
		
		// s term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}
		
		@barrier("local");
		
=======

		  r_Aq += tmp;
		}

		// s term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
		}

		@barrier("local");

>>>>>>> master
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][j]*s_q[k][n][i];
<<<<<<< HEAD
		  
		  r_Aq += tmp;
		}
		
		// t term ---->
		@barrier("local");
		
		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}
		
		@barrier("local");
		
=======

		  r_Aq += tmp;
		}

		// t term ---->
		@barrier("local");

		cubeThreads {
		  s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
		}

		@barrier("local");

>>>>>>> master
		cubeThreads {
		  dfloat tmp = 0.f;
		  for(int n=0; n<p_Nq; ++n)
		  tmp += s_D[n][k]*s_q[n][j][i];
<<<<<<< HEAD
		  
		  r_Aq += tmp;
		  
=======

		  r_Aq += tmp;

>>>>>>> master
		  int base =  elementList[e]*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
		  Aq[base] = r_Aq;
		}
	}
}//e0a end
*/