
@kernel void ellipticCombinedUpdate(const int Ntotal,
				   const int degreeWeighted,
				   @restrict const  dfloat *  invDegree,
				   const dfloat alpha,
				   const dfloat beta,
				   @restrict const  dfloat *  Aw,
				   @restrict dfloat *  p,
				   @restrict dfloat *  r,
				   @restrict dfloat *  s,
				   @restrict dfloat *  w,
				   @restrict dfloat *  x,
				   @restrict dfloat *  z,
				   @restrict dfloat *  results){
   
  for(int b=0;b<(Ntotal+p_blockSize-1)/p_blockSize;++b;@outer(0)){

    @shared volatile dfloat s_rdotr[p_blockSize];
    @shared volatile dfloat s_rdotw[p_blockSize];
    
    for(int n=0;n<p_blockSize;++n;@inner(0)){
      const int id = n + b*p_blockSize;
      
      s_rdotr[n] = 0;
      s_rdotw[n] = 0;
      
      if(id<Ntotal){
	dfloat Awn = Aw[id];
	dfloat zn = z[id];
	dfloat sn = s[id];
	dfloat pn = p[id];
	dfloat xn = x[id];
	dfloat rn = r[id];
	dfloat wn = w[id];

	const dfloat weight = (degreeWeighted)?invDegree[id]:1.f;
	
	// z <= A*w + beta*z
	zn = beta*zn + Awn;

	// s <= w + beta*s
	sn = beta*sn + wn;

	// p <= r + beta*p
	pn = beta*pn + rn;
	
	// x <= x + alpha*p
	xn += alpha*pn;
	
	// r <= r - alpha*s
	rn -= alpha*sn;
	
	// w <= w - alpha*z
	wn -= alpha*zn;

	// copy into @shared
	s_rdotr[n] = rn*rn*weight;
	s_rdotw[n] = rn*wn*weight;

	// copy to global
	z[id] = zn;
	s[id] = sn;
	p[id] = pn;
	x[id] = xn;
	r[id] = rn;
	w[id] = wn;

      }
    }

    @barrier("local");
    
#if p_blockSize>512
    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<512) { s_rdotr[n] += s_rdotr[n+512]; s_rdotw[n] += s_rdotw[n+512]; }
    @barrier("local");
#endif
#if p_blockSize>256
    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<256) { s_rdotr[n] += s_rdotr[n+256]; s_rdotw[n] += s_rdotw[n+256]; }
    @barrier("local");
#endif

    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<128) { s_rdotr[n] += s_rdotr[n+128]; s_rdotw[n] += s_rdotw[n+128]; }
    @barrier("local");
    
    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n< 64) { s_rdotr[n] += s_rdotr[n+64]; s_rdotw[n] += s_rdotw[n+64]; }
    @barrier("local");

    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n< 32) { s_rdotr[n] += s_rdotr[n+32]; s_rdotw[n] += s_rdotw[n+32]; }
    
    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n< 16) { s_rdotr[n] += s_rdotr[n+16]; s_rdotw[n] += s_rdotw[n+16]; }
 
    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<  8) { s_rdotr[n] += s_rdotr[n+ 8]; s_rdotw[n] += s_rdotw[n+ 8]; }

    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<  4) { s_rdotr[n] += s_rdotr[n+ 4]; s_rdotw[n] += s_rdotw[n+ 4]; }

    for(int n=0;n<p_blockSize;++n;@inner(0))
      if(n<  2) { s_rdotr[n] += s_rdotr[n+ 2]; s_rdotw[n] += s_rdotw[n+ 2]; }

    for(int n=0;n<p_blockSize;++n;@inner(0)){
      if(n==0){ // nasty
	const dfloat rdotr = s_rdotr[0]+s_rdotr[1];
	const dfloat rdotw = s_rdotw[0]+s_rdotw[1];
	atomicAdd(results,   rdotr);
	atomicAdd(results+1, rdotw);
      }
    }
  }
}

