
@kernel void acousticsbbdgMRABPmlVolume3D(const int pmlNelements,
          @restrict const  int *  pmlElementIds,
          @restrict const  int *  pmlIds,
          @restrict const  dfloat *  vgeo,
          @restrict const  int *  D0ids,
          @restrict const  int *  D1ids,
          @restrict const  int *  D2ids,
          @restrict const  int *  D3ids,
          @restrict const  dfloat *  Dvals,
          @restrict const  dfloat *  pmlSigmaX,
          @restrict const  dfloat *  pmlSigmaY,
          @restrict const  dfloat *  pmlSigmaZ,
          @restrict const  dfloat *  cubInterp,
          @restrict const  dfloat *  cubProject,
          @restrict const  dfloat *  q,
          @restrict const  dfloat *  pmlq,
          @restrict dfloat *  rhsq,
          @restrict dfloat *  pmlrhsq,
          const int rhsShift){

  for(int eo=0;eo<pmlNelements;eo+=p_NblockCub;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockCub][p_cubNp];
    @shared dfloat s_v[p_NblockCub][p_cubNp];
    @shared dfloat s_w[p_NblockCub][p_cubNp];
    @shared dfloat s_p[p_NblockCub][p_Np];

    @shared dfloat s_px[p_NblockCub][p_cubNp];
    @shared dfloat s_py[p_NblockCub][p_cubNp];
    @shared dfloat s_pz[p_NblockCub][p_cubNp];

    @exclusive int e, pmlId;
    @exclusive dfloat r_u, r_v, r_w, r_px, r_py, r_pz;

    for(int es=0;es<p_NblockCub;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_cubNp;++n;@inner(0)){     // for all nodes in this element

        int et = eo+es; // element in block
        if(et<pmlNelements){
          e = pmlElementIds[et];
          pmlId = pmlIds[et];
        }
        if((et<pmlNelements)&&(n<p_Np)){
          const int id = p_Nfields*(pmlElementIds[et]*p_Np + n);
          s_u[es][n] = q[id+0];
          s_v[es][n] = q[id+1];
          s_w[es][n] = q[id+2];
          s_p[es][n] = q[id+3];

          const int pid = p_pmlNfields*(pmlId*p_Np + n);
          s_px[es][n] = pmlq[pid+0];
          s_py[es][n] = pmlq[pid+1];
          s_pz[es][n] = pmlq[pid+2];
        }
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockCub;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_cubNp;++n;@inner(0)){     // for all nodes in this element

        int et = eo+es; // element in block
        if((et<pmlNelements)&&(n<p_Np)){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat drdz = vgeo[e*p_Nvgeo + p_RZID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
          const dfloat dsdz = vgeo[e*p_Nvgeo + p_SZID];
          const dfloat dtdx = vgeo[e*p_Nvgeo + p_TXID];
          const dfloat dtdy = vgeo[e*p_Nvgeo + p_TYID];
          const dfloat dtdz = vgeo[e*p_Nvgeo + p_TZID];

          // compute 'r', 's',  and 't' derivatives of (q_m) at node n
          const int D0i1 = D0ids[n];
          const int D1i1 = D1ids[n];
          const int D2i1 = D2ids[n];
          const int D3i1 = D3ids[n];
          const dfloat Dval1 = Dvals[n];

          const int D0i2 = D0ids[n+p_Np];
          const int D1i2 = D1ids[n+p_Np];
          const int D2i2 = D2ids[n+p_Np];
          const int D3i2 = D3ids[n+p_Np];
          const dfloat Dval2 = Dvals[n+p_Np];

          const int D0i3 = D0ids[n+2*p_Np];
          const int D1i3 = D1ids[n+2*p_Np];
          const int D2i3 = D2ids[n+2*p_Np];
          const int D3i3 = D3ids[n+2*p_Np];
          const dfloat Dval3 = Dvals[n+2*p_Np];

          const int D0i4 = D0ids[n+3*p_Np];
          const int D1i4 = D1ids[n+3*p_Np];
          const int D2i4 = D2ids[n+3*p_Np];
          const int D3i4 = D3ids[n+3*p_Np];
          const dfloat Dval4 = Dvals[n+3*p_Np];

          const dfloat dudr = .5f*(Dval1*(s_u[es][D1i1] - s_u[es][D0i1]) +
                                   Dval2*(s_u[es][D1i2] - s_u[es][D0i2]) +
                                   Dval3*(s_u[es][D1i3] - s_u[es][D0i3]) +
                                   Dval4*(s_u[es][D1i4] - s_u[es][D0i4]));
          const dfloat duds = .5f*(Dval1*(s_u[es][D2i1] - s_u[es][D0i1]) +
                                   Dval2*(s_u[es][D2i2] - s_u[es][D0i2]) +
                                   Dval3*(s_u[es][D2i3] - s_u[es][D0i3]) +
                                   Dval4*(s_u[es][D2i4] - s_u[es][D0i4]));
          const dfloat dudt = .5f*(Dval1*(s_u[es][D3i1] - s_u[es][D0i1]) +
                                   Dval2*(s_u[es][D3i2] - s_u[es][D0i2]) +
                                   Dval3*(s_u[es][D3i3] - s_u[es][D0i3]) +
                                   Dval4*(s_u[es][D3i4] - s_u[es][D0i4]));

          const dfloat dvdr = .5f*(Dval1*(s_v[es][D1i1] - s_v[es][D0i1]) +
                                   Dval2*(s_v[es][D1i2] - s_v[es][D0i2]) +
                                   Dval3*(s_v[es][D1i3] - s_v[es][D0i3]) +
                                   Dval4*(s_v[es][D1i4] - s_v[es][D0i4]));
          const dfloat dvds = .5f*(Dval1*(s_v[es][D2i1] - s_v[es][D0i1]) +
                                   Dval2*(s_v[es][D2i2] - s_v[es][D0i2]) +
                                   Dval3*(s_v[es][D2i3] - s_v[es][D0i3]) +
                                   Dval4*(s_v[es][D2i4] - s_v[es][D0i4]));
          const dfloat dvdt = .5f*(Dval1*(s_v[es][D3i1] - s_v[es][D0i1]) +
                                   Dval2*(s_v[es][D3i2] - s_v[es][D0i2]) +
                                   Dval3*(s_v[es][D3i3] - s_v[es][D0i3]) +
                                   Dval4*(s_v[es][D3i4] - s_v[es][D0i4]));

          const dfloat dwdr = .5f*(Dval1*(s_w[es][D1i1] - s_w[es][D0i1]) +
                                   Dval2*(s_w[es][D1i2] - s_w[es][D0i2]) +
                                   Dval3*(s_w[es][D1i3] - s_w[es][D0i3]) +
                                   Dval4*(s_w[es][D1i4] - s_w[es][D0i4]));
          const dfloat dwds = .5f*(Dval1*(s_w[es][D2i1] - s_w[es][D0i1]) +
                                   Dval2*(s_w[es][D2i2] - s_w[es][D0i2]) +
                                   Dval3*(s_w[es][D2i3] - s_w[es][D0i3]) +
                                   Dval4*(s_w[es][D2i4] - s_w[es][D0i4]));
          const dfloat dwdt = .5f*(Dval1*(s_w[es][D3i1] - s_w[es][D0i1]) +
                                   Dval2*(s_w[es][D3i2] - s_w[es][D0i2]) +
                                   Dval3*(s_w[es][D3i3] - s_w[es][D0i3]) +
                                   Dval4*(s_w[es][D3i4] - s_w[es][D0i4]));

          const dfloat dpdr = .5f*(Dval1*(s_p[es][D1i1] - s_p[es][D0i1]) +
                                   Dval2*(s_p[es][D1i2] - s_p[es][D0i2]) +
                                   Dval3*(s_p[es][D1i3] - s_p[es][D0i3]) +
                                   Dval4*(s_p[es][D1i4] - s_p[es][D0i4]));
          const dfloat dpds = .5f*(Dval1*(s_p[es][D2i1] - s_p[es][D0i1]) +
                                   Dval2*(s_p[es][D2i2] - s_p[es][D0i2]) +
                                   Dval3*(s_p[es][D2i3] - s_p[es][D0i3]) +
                                   Dval4*(s_p[es][D2i4] - s_p[es][D0i4]));
          const dfloat dpdt = .5f*(Dval1*(s_p[es][D3i1] - s_p[es][D0i1]) +
                                   Dval2*(s_p[es][D3i2] - s_p[es][D0i2]) +
                                   Dval3*(s_p[es][D3i3] - s_p[es][D0i3]) +
                                   Dval4*(s_p[es][D3i4] - s_p[es][D0i4]));

          // chain rule
          const dfloat dudx = drdx*dudr + dsdx*duds + dtdx*dudt;
          const dfloat dvdy = drdy*dvdr + dsdy*dvds + dtdy*dvdt;
          const dfloat dwdz = drdz*dwdr + dsdz*dwds + dtdz*dwdt;
          const dfloat dpdx = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
          const dfloat dpdy = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
          const dfloat dpdz = drdz*dpdr + dsdz*dpds + dtdz*dpdt;

          // store acoustics rhs contributions from collocation differentiation
          const int id = p_Nfields*(e*p_Np + n);
          const int rhsId = 3*id + p_Nfields*rhsShift;
          const int pmlrhsId = 3*p_pmlNfields*(pmlId*p_Np + n) + p_pmlNfields*rhsShift;

          rhsq[rhsId+0] = -dpdx;
          rhsq[rhsId+1] = -dpdy;
          rhsq[rhsId+2] = -dpdz;

          pmlrhsq[pmlrhsId+0] = -dudx;
          pmlrhsq[pmlrhsId+1] = -dvdy;
          pmlrhsq[pmlrhsId+2] = -dwdz;
        }
      }
    }
    @barrier("local");

    //Interpolate to cubature nodes
    for(int es=0;es<p_NblockCub;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_cubNp;++n;@inner(0)){
        int et = eo+es; // element in block
        if(et<pmlNelements){
          // Prefetch sigmas
          const dfloat sigmax = pmlSigmaX[n + pmlId*p_cubNp];
          const dfloat sigmay = pmlSigmaY[n + pmlId*p_cubNp];
          const dfloat sigmaz = pmlSigmaZ[n + pmlId*p_cubNp];

          r_u = 0.f;
          r_v = 0.f;
          r_w = 0.f;
          r_px = 0.f;
          r_py = 0.f;
          r_pz = 0.f;
          for (int i=0;i<p_Np;++i){
            r_u += cubInterp[n + i*p_cubNp] * s_u[es][i];
            r_v += cubInterp[n + i*p_cubNp] * s_v[es][i];
            r_w += cubInterp[n + i*p_cubNp] * s_w[es][i];
            r_px += cubInterp[n + i*p_cubNp] * s_px[es][i];
            r_py += cubInterp[n + i*p_cubNp] * s_py[es][i];
            r_pz += cubInterp[n + i*p_cubNp] * s_pz[es][i];
          }
          r_u *= -sigmax;
          r_v *= -sigmay;
          r_w *= -sigmaz;
          r_px *= -sigmax;
          r_py *= -sigmay;
          r_pz *= -sigmaz;
        }
      }
    }
    @barrier("local");

    //write back to @shared
    for(int es=0;es<p_NblockCub;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_cubNp;++n;@inner(0)){
        int et = eo+es; // element in block
        if(et<pmlNelements){
          s_u[es][n] = r_u;
          s_v[es][n] = r_v;
          s_w[es][n] = r_w;
          s_px[es][n] = r_px;
          s_py[es][n] = r_py;
          s_pz[es][n] = r_pz;
        }
      }
    }
    @barrier("local");

    // Project result back down
    for(int es=0;es<p_NblockCub;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_cubNp;++n;@inner(0)){
        int et = eo+es; // element in block
        if((et<pmlNelements)&&(n<p_Np)){
          dfloat sigmaxu = 0.f;
          dfloat sigmayv = 0.f;
          dfloat sigmazw = 0.f;
          dfloat sigmaxpx = 0.f;
          dfloat sigmaypy = 0.f;
          dfloat sigmazpz = 0.f;
          for (int i=0;i<p_cubNp;++i){
            sigmaxu += cubProject[n + i*p_Np] * s_u[es][i];
            sigmayv += cubProject[n + i*p_Np] * s_v[es][i];
            sigmazw += cubProject[n + i*p_Np] * s_w[es][i];
            sigmaxpx += cubProject[n + i*p_Np] * s_px[es][i];
            sigmaypy += cubProject[n + i*p_Np] * s_py[es][i];
            sigmazpz += cubProject[n + i*p_Np] * s_pz[es][i];
          }

          const int id = p_Nfields*(e*p_Np + n);
          const int rhsId = 3*id + p_Nfields*rhsShift;
          const int pmlrhsId = 3*p_pmlNfields*(pmlId*p_Np + n) + p_pmlNfields*rhsShift;

          rhsq[rhsId+0] += sigmaxu;
          rhsq[rhsId+1] += sigmayv;
          rhsq[rhsId+2] += sigmazw;

          pmlrhsq[pmlrhsId+0] += sigmaxpx;
          pmlrhsq[pmlrhsId+1] += sigmaypy;
          pmlrhsq[pmlrhsId+2] += sigmazpz;
        }
      }
    }
  }
}
