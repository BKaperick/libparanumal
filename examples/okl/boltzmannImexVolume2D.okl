#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

//
@kernel void boltzmannNonPmlImexS1Volume2D(const int Nelements,
				    @restrict const  int *  elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    @restrict const  dfloat *  vgeo,
				    @restrict const  dfloat *  DrT,
				    @restrict const  dfloat *  DsT,
				    @restrict const  dfloat4 *  q,
				          @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][6][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];

	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;

	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // add mean flow forcing
	  rhsq2 += drampdt*p_q2bar;
	  rhsq3 += drampdt*p_q3bar;
	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

	  const int id = element*p_Np+n;	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*id] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*id+1] = tmp;
	}
      }
    }
  }
}











@kernel void boltzmannSplitPmlImexS1Volume2D(const int Nelements,
				      @restrict const  int *  elementIds,
				      const dfloat ramp,
				      @restrict const  dfloat *  vgeo,
				      @restrict const  dfloat *  sigmax,
				      @restrict const  dfloat *  sigmay,
				      @restrict const  dfloat *  DrT,
				      @restrict const  dfloat *  DsT,
				      @restrict const  dfloat4 *  q,
				      @restrict const  dfloat *  qx,
				      @restrict const  dfloat *  qy,
				      @restrict const  dfloat *  qnt,
				            @restrict dfloat *  rhsqx,
				            @restrict dfloat *  rhsqy,
				            @restrict dfloat *  rhsqnt
				      ){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][6][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];
	  const int id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;


	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];

	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

	  int base = element*p_Np*p_Nfields+n;
	  dfloat qx1 = qx[base+0*p_Np];
	  dfloat qx2 = qx[base+1*p_Np];
	  dfloat qx3 = qx[base+2*p_Np];
	  dfloat qx4 = qx[base+3*p_Np];
	  dfloat qx5 = qx[base+4*p_Np];
	  dfloat qx6 = qx[base+5*p_Np];

	  dfloat qy1 = qy[base+0*p_Np];
	  dfloat qy2 = qy[base+1*p_Np];
	  dfloat qy3 = qy[base+2*p_Np];
	  dfloat qy4 = qy[base+3*p_Np];
	  dfloat qy5 = qy[base+4*p_Np];
	  dfloat qy6 = qy[base+5*p_Np];

	  dfloat qnt4 = qnt[base+3*p_Np];
	  dfloat qnt5 = qnt[base+4*p_Np];
	  dfloat qnt6 = qnt[base+5*p_Np];
	  
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
	  // transport operator
	  dfloat rhsqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhsqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
	  dfloat rhsqx3 = -p_sqrtRT*(dq4dx);
	  dfloat rhsqx4 = -p_sqrtRT*(dq3dx);
	  dfloat rhsqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsqx6 = 0;

	  dfloat rhsqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhsqy2 = -p_sqrtRT*(dq4dy);	
	  dfloat rhsqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsqy4 = -p_sqrtRT*(dq2dy);		
	  dfloat rhsqy5 = 0;
	  dfloat rhsqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

#if 0
	  // BGK relaxation approximation to the Boltzmann collision operator
	  dfloat N4 = -p_tauInv*(s_q[es][3][n]-(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat N5 = -p_tauInv*(s_q[es][4][n]-(p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  dfloat N6 = -p_tauInv*(s_q[es][5][n]-(p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

	  rhsqx4 += 0.5f*N4; // split
	  rhsqx5 += 0.5f*N5;
	  rhsqx6 += 0.5f*N6;

	  rhsqy4 += 0.5f*N4; // split
	  rhsqy5 += 0.5f*N5;
	  rhsqy6 += 0.5f*N6;
#endif


	  // pml relaxation back to mean flow
	  rhsqx1 += -msigmaxe*(qx1);
	  rhsqx2 += -msigmaxe*(qx2);
	  rhsqx3 += -msigmaxe*(qx3);
	  rhsqx4 += -msigmaxe*(qx4) + 0.5f*msigmaxe*qnt4;
	  rhsqx5 += -msigmaxe*(qx5) + 0.5f*msigmaxe*qnt5;
	  rhsqx6 += -msigmaxe*(qx6) + 0.5f*msigmaxe*qnt6;

	  rhsqy1 += -msigmaye*(qy1);
	  rhsqy2 += -msigmaye*(qy2);
	  rhsqy3 += -msigmaye*(qy3);
	  rhsqy4 += -msigmaye*(qy4) + 0.5f*msigmaye*qnt4;
	  rhsqy5 += -msigmaye*(qy5) + 0.5f*msigmaye*qnt5;
	  rhsqy6 += -msigmaye*(qy6) + 0.5f*msigmaye*qnt6;
	  
	  rhsqx[base+0*p_Np] = rhsqx1;
	  rhsqx[base+1*p_Np] = rhsqx2;
	  rhsqx[base+2*p_Np] = rhsqx3;
	  rhsqx[base+3*p_Np] = rhsqx4;
	  rhsqx[base+4*p_Np] = rhsqx5;
	  rhsqx[base+5*p_Np] = rhsqx6;
	  
	  rhsqy[base+0*p_Np] = rhsqy1;
	  rhsqy[base+1*p_Np] = rhsqy2;
	  rhsqy[base+2*p_Np] = rhsqy3;
	  rhsqy[base+3*p_Np] = rhsqy4;
	  rhsqy[base+4*p_Np] = rhsqy5;
	  rhsqy[base+5*p_Np] = rhsqy6;

#if 0
	  rhsqnt[base+3*p_Np] = N4;
	  rhsqnt[base+4*p_Np] = N5;
	  rhsqnt[base+5*p_Np] = N6;
#endif	  
	}
      }
    }
  }
}







// // DEPRECATED
// @kernel void boltzmannSplitPmlImexS2Volume2D(const int Nelements,
// 				      @restrict const  int *  elementIds,
// 				      const dfloat ramp,
// 				      @restrict const  dfloat *  vgeo,
// 				      @restrict const  dfloat *  sigmax,
// 				      @restrict const  dfloat *  sigmay,
// 				      @restrict const  dfloat *  DrT,
// 				      @restrict const  dfloat *  DsT,
// 				      @restrict const  dfloat4 *  q,
// 				      @restrict const  dfloat *  qx,
// 				      @restrict const  dfloat *  qy,
// 				      @restrict const  dfloat *  qnt,
// 				            @restrict dfloat *  rhsqx,
// 				            @restrict dfloat *  rhsqy,
// 				            @restrict dfloat *  rhsqnt){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     @shared dfloat s_q[p_NblockV][6][p_Np];
//     @exclusive int element;

//     for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
//       for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];
      
   
// 	  const int id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;


// 	}
//       }
//     }

//     // make sure all node data is loaded into @shared
//     @barrier("local");

//     for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
//       for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  const dfloat sigmaxe = sigmax[element*p_Np+n];
// 	  const dfloat sigmaye = sigmay[element*p_Np+n];

// 	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
// 	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

// 	  int base = element*p_Np*p_Nfields+n;
// 	  dfloat qx1 = qx[base+0*p_Np];
// 	  dfloat qx2 = qx[base+1*p_Np];
// 	  dfloat qx3 = qx[base+2*p_Np];
// 	  dfloat qx4 = qx[base+3*p_Np];
// 	  dfloat qx5 = qx[base+4*p_Np];
// 	  dfloat qx6 = qx[base+5*p_Np];

// 	  dfloat qy1 = qy[base+0*p_Np];
// 	  dfloat qy2 = qy[base+1*p_Np];
// 	  dfloat qy3 = qy[base+2*p_Np];
// 	  dfloat qy4 = qy[base+3*p_Np];
// 	  dfloat qy5 = qy[base+4*p_Np];
// 	  dfloat qy6 = qy[base+5*p_Np];

// 	  dfloat qnt4 = qnt[base+3*p_Np];
// 	  dfloat qnt5 = qnt[base+4*p_Np];
// 	  dfloat qnt6 = qnt[base+5*p_Np];
	  
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  #pragma unroll p_Np
// 	  for(int i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
// 	  // transport operator
// 	  dfloat rhsqx1 = -p_sqrtRT*(dq2dx);
// 	  dfloat rhsqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
// 	  dfloat rhsqx3 = -p_sqrtRT*(dq4dx);
// 	  dfloat rhsqx4 = -p_sqrtRT*(dq3dx);
// 	  dfloat rhsqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhsqx6 = 0;

// 	  dfloat rhsqy1 = -p_sqrtRT*(dq3dy);
// 	  dfloat rhsqy2 = -p_sqrtRT*(dq4dy);	
// 	  dfloat rhsqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhsqy4 = -p_sqrtRT*(dq2dy);		
// 	  dfloat rhsqy5 = 0;
// 	  dfloat rhsqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  dfloat N4 =  p_tauInv * (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]);
// 	  dfloat N5 =  p_tauInv * (p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]) ;
// 	  dfloat N6 =  p_tauInv * (p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]) ;

// 	  rhsqx4 += 0.5f*N4; // split
// 	  rhsqx5 += 0.5f*N5;
// 	  rhsqx6 += 0.5f*N6;

// 	  rhsqy4 += 0.5f*N4; // split
// 	  rhsqy5 += 0.5f*N5;
// 	  rhsqy6 += 0.5f*N6;


// 	  // pml relaxation back to mean flow
// 	  rhsqx1 += -msigmaxe*(qx1);
// 	  rhsqx2 += -msigmaxe*(qx2);
// 	  rhsqx3 += -msigmaxe*(qx3);
// 	  rhsqx4 += -msigmaxe*(qx4) + 0.5f*msigmaxe*qnt4;
// 	  rhsqx5 += -msigmaxe*(qx5) + 0.5f*msigmaxe*qnt5;
// 	  rhsqx6 += -msigmaxe*(qx6) + 0.5f*msigmaxe*qnt6;

// 	  rhsqy1 += -msigmaye*(qy1);
// 	  rhsqy2 += -msigmaye*(qy2);
// 	  rhsqy3 += -msigmaye*(qy3);
// 	  rhsqy4 += -msigmaye*(qy4) + 0.5f*msigmaye*qnt4;
// 	  rhsqy5 += -msigmaye*(qy5) + 0.5f*msigmaye*qnt5;
// 	  rhsqy6 += -msigmaye*(qy6) + 0.5f*msigmaye*qnt6;
	  
// 	  rhsqx[base+0*p_Np] = rhsqx1;
// 	  rhsqx[base+1*p_Np] = rhsqx2;
// 	  rhsqx[base+2*p_Np] = rhsqx3;
// 	  rhsqx[base+3*p_Np] = rhsqx4;
// 	  rhsqx[base+4*p_Np] = rhsqx5;
// 	  rhsqx[base+5*p_Np] = rhsqx6;
	  
// 	  rhsqy[base+0*p_Np] = rhsqy1;
// 	  rhsqy[base+1*p_Np] = rhsqy2;
// 	  rhsqy[base+2*p_Np] = rhsqy3;
// 	  rhsqy[base+3*p_Np] = rhsqy4;
// 	  rhsqy[base+4*p_Np] = rhsqy5;
// 	  rhsqy[base+5*p_Np] = rhsqy6;


// 	  rhsqnt[base+3*p_Np] = N4;
// 	  rhsqnt[base+4*p_Np] = N5;
// 	  rhsqnt[base+5*p_Np] = N6;
  
// 	}
//       }
//     }
//   }
// }




// @kernel void boltzmannSplitPmlImexS2VolumeNonlinear2D(const int Nelements,
// 					     @restrict const  int *  elementIds,
// 					     @restrict const  dfloat  *  cubInterpT,
// 					     @restrict const  dfloat  *  cubProjectT,
// 					     @restrict const  dfloat4 *  q,
// 					           @restrict dfloat  *  qZx,
// 					           @restrict dfloat  *  qZy,
// 					           @restrict dfloat  *  qZnt){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     // @shared memory for q at nodes
//     @shared dfloat s_q[p_NblockV][3][p_Np];

//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     @shared dfloat s_cubN4[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6[p_NblockV][p_cubNp];

//     @exclusive int element;

//     for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
//       for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];
      
   
// 	  const int id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
	 
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
	  
// 	}
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_cubNp){
// 	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	   	    
// 	    #pragma unroll p_Np
// 	    for(int m=0;m<p_Np;++m){
// 	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
// 	      cubq1 += Icn*s_q[es][0][m];
// 	      cubq2 += Icn*s_q[es][1][m];
// 	      cubq3 += Icn*s_q[es][2][m];
	      
// 	    }
	    
// 	    // BGK relaxation approximation to the Boltzmann collision operator
// 	    s_cubN4[es][n] =  p_tauInv*   cubq2*cubq3/cubq1;
// 	    s_cubN5[es][n] =  p_tauInv*p_invsqrt2*cubq2*cubq2/cubq1;
// 	    s_cubN6[es][n] =  p_tauInv*p_invsqrt2*cubq3*cubq3/cubq1;
// 	  }
// 	}
//       }
//     }

//     // make sure all cubature node data is loaded into @shared
//     @barrier("local");
    
//     // partial projection to nodes from cubature-sub-group
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_Np){
// 	    int base = element*p_Np*p_Nfields+n;
	    
// 	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
// 	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

// 	    #pragma unroll p_cubNp

// 	    for(int i=0;i<p_cubNp;++i){
// 	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
// 	      N4 += Pnc*s_cubN4[es][i];
// 	      N5 += Pnc*s_cubN5[es][i];
// 	      N6 += Pnc*s_cubN6[es][i];
// 	    }
//       const int id1 = base + 0*p_Np;
//       const int id2 = base + 1*p_Np;
//       const int id3 = base + 2*p_Np; 
//       const int id4 = base + 3*p_Np;
//       const int id5 = base + 4*p_Np;
//       const int id6 = base + 5*p_Np; 
// 	 // OVER WRITE for LOW STORAGE 
       
// 	  qZx[id4]   += 0.5f*N4;
// 	  qZx[id5]   += 0.5f*N5;
// 	  qZx[id6]   += 0.5f*N6;
// 	  //
	      
// 	  qZy[id4]   += 0.5f*N4;
// 	  qZy[id5]   += 0.5f*N5;
// 	  qZy[id6]   += 0.5f*N6;
// 	  //
	  
// 	  qZnt[id1]  = 0.f;
// 	  qZnt[id2]  = 0.f;
// 	  qZnt[id3]  = 0.f;
// 	  qZnt[id4]  = N4;
// 	  qZnt[id5]  = N5;
// 	  qZnt[id6]  = N6;
// 	  }
// 	}
//       }
//     }
//   }
// }



// @kernel void boltzmannNonPmlImexS2Volume2D(const int Nelements,
// 				    @restrict const  int *  elementIds,
// 				    const dfloat ramp,
// 				    const dfloat drampdt,
// 				    @restrict const  dfloat *  vgeo,
// 				    @restrict const  dfloat *  DrT,
// 				    @restrict const  dfloat *  DsT,
// 				    @restrict const  dfloat4 *  q,
// 				          @restrict dfloat4 *  rhsq){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     @shared dfloat s_q[p_NblockV][6][p_Np];
//     @exclusive int element;

//     for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
//       for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

// 	int e = eo+es; // element in block

// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const int id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];

// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;

// 	}
//       }
//     }

//     // make sure all node data is loaded into @shared
//     @barrier("local");

//     for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
//       for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  #pragma unroll p_Np
// 	  for(int i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
// 	  // transport operator
// 	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
// 	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
// 	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
// 	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // BGK relaxation approximation to the Boltzmann collision operator (nonlinear term)
// 	  rhsq4 += p_tauInv  *  s_q[es][1][n] * s_q[es][2][n] / s_q[es][0][n]   ;
// 	  rhsq5 += p_tauInv  *  p_invsqrt2* s_q[es][1][n] * s_q[es][1][n] / s_q[es][0][n];
// 	  rhsq6 += p_tauInv  *  p_invsqrt2* s_q[es][2][n] * s_q[es][2][n] / s_q[es][0][n];
	  
// 	  // add mean flow forcing
// 	  rhsq2 += drampdt*p_q2bar;
// 	  rhsq3 += drampdt*p_q3bar;
// 	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
// 	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
// 	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

// 	  const int id = element*p_Np+n;	  
// 	  dfloat4 tmp;
// 	  tmp.x = rhsq1;
// 	  tmp.y = rhsq2;
// 	  tmp.z = rhsq3;
// 	  tmp.w = rhsq4;

// 	  rhsq[2*id] = tmp;

// 	  tmp.x = rhsq5;
// 	  tmp.y = rhsq6;
// 	  tmp.z = 0.f;
// 	  tmp.w = 0.f;

// 	  rhsq[2*id+1] = tmp;
// 	}
//       }
//     }
//   }
// }



// @kernel void boltzmannNonPmlImexS2VolumeNonlinear2D(const int Nelements,
// 					     @restrict const  int *  elementIds,
// 					     @restrict const  dfloat *  cubInterpT,
// 					     @restrict const  dfloat *  cubProjectT,
// 					     @restrict const  dfloat4 *  qin,
// 					           @restrict dfloat4 *  rhsq){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

//     // @shared memory for q at nodes
//     @shared dfloat s_q[p_NblockV][3][p_Np];

//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     @shared dfloat s_cubN4[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN5[p_NblockV][p_cubNp];
//     @shared dfloat s_cubN6[p_NblockV][p_cubNp];

//     @exclusive int element;

//     // prefetch q to @shared
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];
// 	  if(n<p_Np){
// 	    const int id = 2*(element*p_Np+n);
// 	    dfloat4 qan = qin[id];
	    	    
// 	    s_q[es][0][n] = qan.x;
// 	    s_q[es][1][n] = qan.y;
// 	    s_q[es][2][n] = qan.z;
	    
// 	  }
// 	}
//       }
//     }
    
//     // make sure all node data is loaded into @shared
//     @barrier("local");

//     // interpolate q to cubature
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_cubNp){
// 	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	    	    
// 	    #pragma unroll p_Np
// 	    for(int m=0;m<p_Np;++m){
// 	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
// 	      cubq1 += Icn*s_q[es][0][m];
// 	      cubq2 += Icn*s_q[es][1][m];
// 	      cubq3 += Icn*s_q[es][2][m];
// 	    }
	    
// 	    // BGK relaxation approximation to the Boltzmann collision operator
// 	    s_cubN4[es][n] = p_tauInv*            cubq2*cubq3/cubq1;
// 	    s_cubN5[es][n] = p_tauInv* p_invsqrt2*cubq2*cubq2/cubq1;
// 	    s_cubN6[es][n] = p_tauInv* p_invsqrt2*cubq3*cubq3/cubq1;
// 	  }
// 	}
//       }
//     }

//     // make sure all cubature node data is loaded into @shared
//     @barrier("local");
    
//     // partial projection to nodes from cubature-sub-group
//     for(int es=0;es<p_NblockV;++es;@inner(1)){
//       for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){     
	
// 	int e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_Np){
	    	    
// 	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
// 	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

// 	    #pragma unroll p_cubNp
// 	    for(int i=0;i<p_cubNp;++i){
// 	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
// 	      N4 += Pnc*s_cubN4[es][i];
// 	      N5 += Pnc*s_cubN5[es][i];
// 	      N6 += Pnc*s_cubN6[es][i];
// 	    }

// 	    int id      = 2*(element*p_Np + n);
        
//         dfloat4 temp; 

//         rhsq[id].w   += N4; 
//         rhsq[id+1].x += N5;
//         rhsq[id+1].y += N6;

//         // temp.x = 0.0; 
//         // temp.y = 0.0;
//         // temp.z = 0.0;
//         // temp.w = N4; 

//         // rhsq[id] += temp; 
        
//         // temp.x = N5;
//         // temp.y = N6;
//         // temp.z = 0.0; 
//         // temp.w = 0.0; 
     
//         // rhsq[id+1] += temp; 
	    
// 	  }
// 	}
//       }
//     }
//   }
// }
