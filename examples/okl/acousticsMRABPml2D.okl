

@kernel void acousticsMRABPml2D(const int pmlNelements,
             @restrict const  int    *  pmlElementList,
             @restrict const  int    *  pmlIds,
             @restrict const  dfloat  *  cubInterp,
             @restrict const  dfloat  *  cubProject,
             @restrict const  dfloat  *  pmlSigmaX,
             @restrict const  dfloat  *  pmlSigmaY,
             @restrict const  dfloat  *  q,
             @restrict const  dfloat  *  pmlq,
             @restrict dfloat *  rhsq,
             @restrict dfloat *  pmlrhsq,
             const int   rhsShift){

  // for all PML elements
  for(int el=0;el<pmlNelements;++el;@outer(0)){
    @shared dfloat s_u[p_cubNp], s_v[p_cubNp], s_p[p_cubNp];
    @shared dfloat s_utilde[p_cubNp], s_vtilde[p_cubNp], s_ptilde[p_cubNp];

    @exclusive dfloat r_u, r_v, r_p; 
    @exclusive dfloat r_utilde, r_vtilde, r_ptilde; 
    @exclusive dfloat r_rhsu, r_rhsv, r_rhsp;
    @exclusive dfloat r_rhsutilde, r_rhsvtilde, r_rhsptilde;
    @exclusive int e, pmlId;

    //fetch q and pmlq
    for(int n=0; n<p_maxCubNodes;++n;@inner(0)){  
      e = pmlElementList[el];
      pmlId = pmlIds[el];
      
      if (n < p_Np){
        const int base = p_Nfields*(e*p_Np + n);
        s_u[n] = q[base+0];
        s_v[n] = q[base+1];
        s_p[n] = q[base+2];

        const int pmlBase = p_pmlNfields*(pmlId*p_Np+n);
        s_utilde[n] = pmlq[pmlBase+0];
        s_vtilde[n] = pmlq[pmlBase+1];
        s_ptilde[n] = pmlq[pmlBase+2];
      }

      // Initialize register variables
      r_u = 0.f;
      r_v = 0.f;
      r_p = 0.f;
      r_utilde = 0.f;
      r_vtilde = 0.f;
      r_ptilde = 0.f;
    }
    @barrier("local");

    // Interpolate to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        const int pmlBase = pmlId*p_cubNp+n;
        const dfloat sigmax = pmlSigmaX[pmlBase];
        const dfloat sigmay = pmlSigmaY[pmlBase];

        #pragma unroll p_Np
        for (int i=0;i<p_Np;++i){
          r_u += cubInterp[n + i*p_cubNp] * s_u[i];
          r_v += cubInterp[n + i*p_cubNp] * s_v[i];
          r_p += cubInterp[n + i*p_cubNp] * s_p[i];
          r_utilde += cubInterp[n + i*p_cubNp] * s_utilde[i];
          r_vtilde += cubInterp[n + i*p_cubNp] * s_vtilde[i];
          r_ptilde += cubInterp[n + i*p_cubNp] * s_ptilde[i];
        }

        r_rhsu = -(sigmax-sigmay)*r_u - sigmay*(sigmay-sigmax)*r_utilde; // uhat
        r_rhsv = -(sigmay-sigmax)*r_v - sigmax*(sigmax-sigmay)*r_vtilde; // vhat
        r_rhsp = -(sigmax+sigmay)*r_p - sigmax*sigmay*r_ptilde;          // p

        // update for u~,v~, p~
        r_rhsutilde = r_u-sigmay*r_utilde;  // du~/dt = -sigmay*u~  + uhat
        r_rhsvtilde = r_v-sigmax*r_vtilde;  // dv~/dt = -sigmax*v~  + vhat
        r_rhsptilde = r_p;                  // dp~/dt = p
      }
    }
    @barrier("local");

    // Move temporary result back to @shared memory
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        s_u[n] = r_rhsu;
        s_v[n] = r_rhsv;
        s_p[n] = r_rhsp;
        s_utilde[n] = r_rhsutilde;
        s_vtilde[n] = r_rhsvtilde;
        s_ptilde[n] = r_rhsptilde;
      }
    }
    @barrier("local");

    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n < p_Np){
        dfloat rhsp = 0.f;
        dfloat rhsu = 0.f;
        dfloat rhsv = 0.f;
        dfloat rhsptilde = 0.f;
        dfloat rhsutilde = 0.f;
        dfloat rhsvtilde = 0.f;

        // Project rhs down
        #pragma unroll p_cubNp
        for (int i=0;i<p_cubNp;++i){
          rhsu += cubProject[n + i*p_Np] * s_u[i];
          rhsv += cubProject[n + i*p_Np] * s_v[i];
          rhsp += cubProject[n + i*p_Np] * s_p[i];
          rhsutilde += cubProject[n + i*p_Np] * s_utilde[i];
          rhsvtilde += cubProject[n + i*p_Np] * s_vtilde[i];
          rhsptilde += cubProject[n + i*p_Np] * s_ptilde[i];
        }

        // store acoustics rhs contributions from PML 
        const int rhsBase = 3*p_Nfields*(e*p_Np + n) + p_Nfields*rhsShift;
        rhsq[rhsBase+0] += rhsu;
        rhsq[rhsBase+1] += rhsv;
        rhsq[rhsBase+2] += rhsp;

        // store PML rhs
        const int pmlrhsBase = 3*p_pmlNfields*(pmlId*p_Np + n)  + p_pmlNfields*rhsShift;
        pmlrhsq[pmlrhsBase+0] = rhsutilde;
        pmlrhsq[pmlrhsBase+1] = rhsvtilde;
        pmlrhsq[pmlrhsBase+2] = rhsptilde;
      }
    }
  }
}


@kernel void acousticsMRABPml2D_wadg(const int pmlNelements,
             @restrict const  int    *  pmlElementList,
             @restrict const  int    *  pmlIds,
             @restrict const  dfloat  *  cubInterp,
             @restrict const  dfloat  *  cubProject,
             @restrict const  dfloat  *  c2,
             @restrict const  dfloat  *  pmlSigmaX,
             @restrict const  dfloat  *  pmlSigmaY,
             @restrict const  dfloat  *  q,
             @restrict const  dfloat  *  pmlq,
             @restrict dfloat *  rhsq,
             @restrict dfloat *  pmlrhsq,
             const int   rhsShift){

  // for all PML elements
  for(int el=0;el<pmlNelements;++el;@outer(0)){
    @shared dfloat s_u[p_cubNp], s_v[p_cubNp], s_p[p_cubNp];
    @shared dfloat s_utilde[p_cubNp], s_vtilde[p_cubNp], s_ptilde[p_cubNp];

    @exclusive dfloat r_u, r_v, r_p; 
    @exclusive dfloat r_utilde, r_vtilde, r_ptilde; 
    @exclusive dfloat r_rhsu, r_rhsv, r_rhsp;
    @exclusive dfloat r_rhsutilde, r_rhsvtilde, r_rhsptilde;
    @exclusive int e, pmlId;

    //fetch q and pmlq
    for(int n=0; n<p_maxCubNodes;++n;@inner(0)){  
      e = pmlElementList[el];
      pmlId = pmlIds[el];
      
      if (n < p_Np){
        const int base = p_Nfields*(e*p_Np + n);
        s_u[n] = q[base+0];
        s_v[n] = q[base+1];
        s_p[n] = q[base+2];

        const int pmlBase = p_pmlNfields*(pmlId*p_Np+n);
        s_utilde[n] = pmlq[pmlBase+0];
        s_vtilde[n] = pmlq[pmlBase+1];
        s_ptilde[n] = pmlq[pmlBase+2];
      }

      // Initialize register variables
      r_u = 0.f;
      r_v = 0.f;
      r_p = 0.f;
      r_utilde = 0.f;
      r_vtilde = 0.f;
      r_ptilde = 0.f;
    }
    @barrier("local");

    // Interpolate to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        const int pmlBase = pmlId*p_cubNp+n;

        const dfloat c2n = c2[n + e*p_cubNp];
        const dfloat sigmax = pmlSigmaX[pmlBase];
        const dfloat sigmay = pmlSigmaY[pmlBase];

        #pragma unroll p_Np
        for (int i=0;i<p_Np;++i){
          r_u += cubInterp[n + i*p_cubNp] * s_u[i];
          r_v += cubInterp[n + i*p_cubNp] * s_v[i];
          r_p += cubInterp[n + i*p_cubNp] * s_p[i];
          r_utilde += cubInterp[n + i*p_cubNp] * s_utilde[i];
          r_vtilde += cubInterp[n + i*p_cubNp] * s_vtilde[i];
          r_ptilde += cubInterp[n + i*p_cubNp] * s_ptilde[i];
        }

        r_rhsu = -(sigmax-sigmay)*r_u - sigmay*(sigmay-sigmax)*r_utilde; // uhat
        r_rhsv = -(sigmay-sigmax)*r_v - sigmax*(sigmax-sigmay)*r_vtilde; // vhat
        r_rhsp = (-(sigmax+sigmay)*r_p - sigmax*sigmay*r_ptilde)/c2n;          // p

        // update for u~,v~, p~
        r_rhsutilde = r_u-sigmay*r_utilde;  // du~/dt = -sigmay*u~  + uhat
        r_rhsvtilde = r_v-sigmax*r_vtilde;  // dv~/dt = -sigmax*v~  + vhat
        r_rhsptilde = r_p;                  // dp~/dt = p
      }
    }
    @barrier("local");

    // Move temporary result back to @shared memory
    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n<p_cubNp) {
        s_u[n] = r_rhsu;
        s_v[n] = r_rhsv;
        s_p[n] = r_rhsp;
        s_utilde[n] = r_rhsutilde;
        s_vtilde[n] = r_rhsvtilde;
        s_ptilde[n] = r_rhsptilde;
      }
    }
    @barrier("local");

    for(int n=0;n<p_maxCubNodes;++n;@inner(0)){
      if (n < p_Np){
        dfloat rhsp = 0.f;
        dfloat rhsu = 0.f;
        dfloat rhsv = 0.f;
        dfloat rhsptilde = 0.f;
        dfloat rhsutilde = 0.f;
        dfloat rhsvtilde = 0.f;

        // Project rhs down
        #pragma unroll p_cubNp
        for (int i=0;i<p_cubNp;++i){
          rhsu += cubProject[n + i*p_Np] * s_u[i];
          rhsv += cubProject[n + i*p_Np] * s_v[i];
          rhsp += cubProject[n + i*p_Np] * s_p[i];
          rhsutilde += cubProject[n + i*p_Np] * s_utilde[i];
          rhsvtilde += cubProject[n + i*p_Np] * s_vtilde[i];
          rhsptilde += cubProject[n + i*p_Np] * s_ptilde[i];
        }

        // store acoustics rhs contributions from PML 
        const int rhsBase = 3*p_Nfields*(e*p_Np + n) + p_Nfields*rhsShift;
        rhsq[rhsBase+0] += rhsu;
        rhsq[rhsBase+1] += rhsv;
        rhsq[rhsBase+2] += rhsp;

        // store PML rhs
        const int pmlrhsBase = 3*p_pmlNfields*(pmlId*p_Np + n)  + p_pmlNfields*rhsShift;
        pmlrhsq[pmlrhsBase+0] = rhsutilde;
        pmlrhsq[pmlrhsBase+1] = rhsvtilde;
        pmlrhsq[pmlrhsBase+2] = rhsptilde;
      }
    }
  }
}

