#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
@kernel void acousticsVolume2D_o0(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat *  q,
				     @restrict dfloat *  rhsq){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
	const int id = p_Nfields*(e*p_Np + i);
	const dfloat u = q[id+0], v = q[id+1], p = q[id+2];

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*u; duds += Dsni*u;
	dvdr += Drni*v; dvds += Dsni*v;
	dpdr += Drni*p;	dpds += Dsni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = p_Nfields*(e*p_Np + n);
      rhsq[id+0] = -dpdx;
      rhsq[id+1] = -dpdy;
      rhsq[id+2] = -dudx-dvdy;
    }
  }
}



// o1: float4s
@kernel void acousticsVolume2D_o1(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
	const int id = e*p_Np + i;
	const dfloat4 q4i = q4[id];
	const dfloat u = q4i.x, v = q4i.y, p = q4i.z;

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*u; duds += Dsni*u;
	dvdr += Drni*v; dvds += Dsni*v;
	dpdr += Drni*p;	dpds += Dsni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dudx-dvdy;
      rhsq4[id] = rhsq4n;
    }
  }
}



// o2: load q into @shared
@kernel void acousticsVolume2D_o2(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int e=0;e<Nelements;++e;@outer(0)){  // for all elements

    @shared dfloat s_u[p_Np], s_v[p_Np], s_p[p_Np];
    
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
      const int id = e*p_Np + n;
      const dfloat4 q4n = q4[id];
      s_u[n] = q4n.x;
      s_v[n] = q4n.y;
      s_p[n] = q4n.z;
    }

    // make sure all node data is loaded into @shared
    @barrier("local");
    
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(int i=0;i<p_Np;++i){
	// load data at node i of element e
 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*s_u[i]; duds += Dsni*s_u[i];
	dvdr += Drni*s_v[i]; dvds += Dsni*s_v[i];
	dpdr += Drni*s_p[i]; dpds += Dsni*s_p[i];
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const int id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dudx-dvdy;
      rhsq4[id] = rhsq4n;
    }
  }
}

// o3: multiple elements for each outer iteration
@kernel void acousticsVolume2D_o3(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;
	  
	  for(int i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o4: unroll 
@kernel void acousticsVolume2D_o4(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o5: DrT,Ds into @shared
@kernel void acousticsVolume2D_o5(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    @shared dfloat s_DrT[p_Np][p_Np];
    @shared dfloat s_DsT[p_Np][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	// prefetch DrT, Ds into @shared
	int t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  t += p_Np*p_NblockV;
	}
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = s_DrT[i][n];
	    const dfloat Dsni = s_DsT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; 
	    dvdr += Drni*s_v[es][i];
	    dpdr += Drni*s_p[es][i];

	    duds += Dsni*s_u[es][i];	    
	    dvds += Dsni*s_v[es][i];
	    dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}


// o6: vgeo in @shared
@kernel void acousticsVolume2D_o6(const int Nelements,
				     @restrict const  dfloat *  vgeo,
				     @restrict const  dfloat *  DrT,
				     @restrict const  dfloat *  DsT,
				     @restrict const  dfloat4 *  q4,
				     @restrict dfloat4 *  rhsq4){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_u[p_NblockV][p_Np];
    @shared dfloat s_v[p_NblockV][p_Np];
    @shared dfloat s_p[p_NblockV][p_Np];

    @shared dfloat s_DrT[p_Np][p_Np];
    @shared dfloat s_DsT[p_Np][p_Np];

    @shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	// prefetch DrT, Ds into @shared
	int t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];

	  t += p_Np*p_NblockV;
	}

	t = n+es*p_Np;
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<p_Nvgeo*Nelements)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t += p_Np*p_NblockV;
	}

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = s_vgeo[es][RXID];
	  const dfloat drdy = s_vgeo[es][RYID];
	  const dfloat dsdx = s_vgeo[es][SXID];
	  const dfloat dsdy = s_vgeo[es][SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni = s_DrT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; 
	    dvdr += Drni*s_v[es][i];
	    dpdr += Drni*s_p[es][i];
	  }
	  
	  #pragma unroll p_Np
	    for(int i=0;i<p_Np;++i){
	      
	      const dfloat Dsni = s_DsT[i][n];
	      
	      duds += Dsni*s_u[es][i];	    
	      dvds += Dsni*s_v[es][i];
	      dpds += Dsni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const int id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}



