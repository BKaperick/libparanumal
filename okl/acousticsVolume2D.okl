#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
kernel void acousticsVolume2D_o0(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict q,
				     dfloat * restrict rhsq){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
	const iint id = p_Nfields*(e*p_Np + i);
	const dfloat u = q[id+0], v = q[id+1], p = q[id+2];

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*u; duds += Dsni*u;
	dvdr += Drni*v; dvds += Dsni*v;
	dpdr += Drni*p;	dpds += Dsni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = p_Nfields*(e*p_Np + n);
      rhsq[id+0] = -dpdx;
      rhsq[id+1] = -dpdy;
      rhsq[id+2] = -dudx-dvdy;
    }
  }
}



// o1: float4s
kernel void acousticsVolume2D_o1(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
	const iint id = e*p_Np + i;
	const dfloat4 q4i = q4[id];
	const dfloat u = q4i.x, v = q4i.y, p = q4i.z;

 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*u; duds += Dsni*u;
	dvdr += Drni*v; dvds += Dsni*v;
	dpdr += Drni*p;	dpds += Dsni*p;
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dudx-dvdy;
      rhsq4[id] = rhsq4n;
    }
  }
}



// o2: load q into shared
kernel void acousticsVolume2D_o2(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

    shared dfloat s_u[p_Np], s_v[p_Np], s_p[p_Np];
    
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      const iint id = e*p_Np + n;
      const dfloat4 q4n = q4[id];
      s_u[n] = q4n.x;
      s_v[n] = q4n.y;
      s_p[n] = q4n.z;
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      // prefetch geometric factors (constant on triangle)
      const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
      const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
      const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
      const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
      
      // compute 'r' and 's' derivatives of (u,v,p) at node n
      dfloat dudr = 0, duds = 0;
      dfloat dvdr = 0, dvds = 0;
      dfloat dpdr = 0, dpds = 0;
      
      for(iint i=0;i<p_Np;++i){
	// load data at node i of element e
 	const dfloat Drni = DrT[n+i*p_Np];
	const dfloat Dsni = DsT[n+i*p_Np];

	// differentiate (u,v,p) with respect to 'r' and 's'
	dudr += Drni*s_u[i]; duds += Dsni*s_u[i];
	dvdr += Drni*s_v[i]; dvds += Dsni*s_v[i];
	dpdr += Drni*s_p[i]; dpds += Dsni*s_p[i];
      }

      // chain rule
      const dfloat dudx = drdx*dudr + dsdx*duds;
      const dfloat dvdy = drdy*dvdr + dsdy*dvds;
      const dfloat dpdx = drdx*dpdr + dsdx*dpds;
      const dfloat dpdy = drdy*dpdr + dsdy*dpds;
      
      // store acoustics rhs contributions from collocation differentiation
      const iint id = e*p_Np + n;
      dfloat4 rhsq4n;
      rhsq4n.x = -dpdx;
      rhsq4n.y = -dpdy;
      rhsq4n.z = -dudx-dvdy;
      rhsq4[id] = rhsq4n;
    }
  }
}

// o3: multiple elements for each outer iteration
kernel void acousticsVolume2D_o3(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;
	  
	  for(iint i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o4: unroll 
kernel void acousticsVolume2D_o4(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; duds += Dsni*s_u[es][i];
	    dvdr += Drni*s_v[es][i]; dvds += Dsni*s_v[es][i];
	    dpdr += Drni*s_p[es][i]; dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}

// o5: DrT,Ds into shared
kernel void acousticsVolume2D_o5(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    shared dfloat s_DrT[p_Np][p_Np];
    shared dfloat s_DsT[p_Np][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	// prefetch DrT, Ds into shared
	iint t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  t += p_Np*p_NblockV;
	}
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    // load data at node i of element e
	    const dfloat Drni = s_DrT[i][n];
	    const dfloat Dsni = s_DsT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; 
	    dvdr += Drni*s_v[es][i];
	    dpdr += Drni*s_p[es][i];

	    duds += Dsni*s_u[es][i];	    
	    dvds += Dsni*s_v[es][i];
	    dpds += Dsni*s_p[es][i];
	  }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}


// o6: vgeo in shared
kernel void acousticsVolume2D_o6(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat4 * restrict q4,
				     dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    shared dfloat s_DrT[p_Np][p_Np];
    shared dfloat s_DsT[p_Np][p_Np];

    shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	// prefetch DrT, Ds into shared
	iint t = n + es*p_Np;
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];

	  t += p_Np*p_NblockV;
	}

	t = n+es*p_Np;
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<p_Nvgeo*Nelements)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t += p_Np*p_NblockV;
	}

	iint e = eo+es; // element in block
	if(e<Nelements){
	  const iint id = e*p_Np + n;
	  const dfloat4 q4n = q4[id];
	  s_u[es][n] = q4n.x;
	  s_v[es][n] = q4n.y;
	  s_p[es][n] = q4n.z;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = s_vgeo[es][RXID];
	  const dfloat drdy = s_vgeo[es][RYID];
	  const dfloat dsdx = s_vgeo[es][SXID];
	  const dfloat dsdy = s_vgeo[es][SYID];
	  
	  // compute 'r' and 's' derivatives of (u,v,p) at node n
	  dfloat dudr = 0, duds = 0;
	  dfloat dvdr = 0, dvds = 0;
	  dfloat dpdr = 0, dpds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = s_DrT[i][n];
	    
	    // differentiate (u,v,p) with respect to 'r' and 's'
	    dudr += Drni*s_u[es][i]; 
	    dvdr += Drni*s_v[es][i];
	    dpdr += Drni*s_p[es][i];
	  }
	  
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      
	      const dfloat Dsni = s_DsT[i][n];
	      
	      duds += Dsni*s_u[es][i];	    
	      dvds += Dsni*s_v[es][i];
	      dpds += Dsni*s_p[es][i];
	    }

	  // chain rule
	  const dfloat dudx = drdx*dudr + dsdx*duds;
	  const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	  const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	  const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	  
	  // store acoustics rhs contributions from collocation differentiation
	  const iint id = e*p_Np + n;
	  dfloat4 rhsq4n;
	  rhsq4n.x = -dpdx;
	  rhsq4n.y = -dpdy;
	  rhsq4n.z = -dudx-dvdy;
	  rhsq4[id] = rhsq4n;
	}
      }
    }
  }
}



