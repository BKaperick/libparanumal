// surface kernel, play with different implementations
// Base implementation


kernel void insSubCycleCubatureSurface2D_v0(
					    iint Nelements,
					    dfloat * sgeo,
					    dfloat * intInterpT, // interpolate to integration nodes
					    dfloat * intLIFTT, // lift from integration to interpolation nodes
					    iint   * vmapM,
					    iint   * vmapP,
					    iint   * EToB,
					    dfloat time,
					    dfloat * intx, // integration nodes
					    dfloat * inty,
					    dfloat * U,
					    dfloat * V,
					    dfloat * Ud,
					    dfloat * Vd,
					    dfloat * rhsU,
					    dfloat * rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          iint face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          iint sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          //occaUnroll(p_Nfp)
	  for(iint m=0;m<p_Nfp;++m){
	    dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

	    iint id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
	    iint idM = vmapM[id];
	    iint idP = vmapP[id];
	    //
	    iUM  += iInm*U[idM];
	    iVM  += iInm*V[idM];
	    iUdM += iInm*Ud[idM];
	    iVdM += iInm*Vd[idM];

	    iUP  += iInm*U[idP];
	    iVP  += iInm*V[idP];
	    iUdP += iInm*Ud[idP];
	    iVdP += iInm*Vd[idP];
	  }

          // apply boundary conditions
          iint bc = EToB[face+p_Nfaces*e];

          if(bc>0){
            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          }


          // Find max normal velocity on the face
          dfloat unm   = occaFabs(nx*iUM + ny*iVM);
          dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
          dfloat unmax = (unm > unp) ? unm : unp;

          // evaluate "flux" terms: LLF
          dfloat sc = invJ * sJ ;

          s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

          s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<p_Np){
          iint id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id];
          dfloat rhsv = rhsV[id];

          //occaUnroll(p_intNfpNfaces)
          for(iint m=0;m<p_intNfpNfaces;++m){
	    // RefMassMatrix^{-1}*cInterp^t*cWeight
            dfloat L = intLIFTT[n+m*p_Np];

            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

          rhsU[id] = rhsu;  // 
          rhsV[id] = rhsv;  //  
        }
      }
    }
  }
}




// Add shared memory for global read
kernel void insSubCycleCubatureSurface2D_v1(
					    iint Nelements,
					    dfloat * sgeo,
					    dfloat * intInterpT, // interpolate to integration nodes
					    dfloat * intLIFTT, // lift from integration to interpolation nodes
					    iint   * vmapM,
					    iint   * vmapP,
					    iint   * EToB,
					    dfloat time,
					    dfloat * intx, // integration nodes
					    dfloat * inty,
					    dfloat * U,
					    dfloat * V,
					    dfloat * Ud,
					    dfloat * Vd,
					    dfloat * rhsU,
					    dfloat * rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];


    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          iint id  = e*p_Nfp*p_Nfaces + n;

          iint idM = vmapM[id];
          iint idP = vmapP[id];

          if(idP<0) idP = idM;
	  // load negative and positive trace node values of velocity
	  s_UM[n] = U[idM];
	  s_VM[n] = V[idM];
	  s_UP[n] = U[idP];
	  s_VP[n] = V[idP];

	  s_UdM[n] = Ud[idM];
	  s_VdM[n] = Vd[idM];
	  s_UdP[n] = Ud[idP];
	  s_VdP[n] = Vd[idP];

	}
      }
    }

    barrier(localMemFence);

  
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
	if(n<(p_Nfaces*p_intNfp)){

	  iint face = n/p_intNfp; // find face that owns this integration node

	  // load surface geofactors for this face
	  iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	  dfloat nx   = sgeo[sid+p_NXID];
	  dfloat ny   = sgeo[sid+p_NYID];
	  dfloat sJ   = sgeo[sid+p_SJID];
	  dfloat invJ = sgeo[sid+p_IJID];

	  dfloat iUM  = 0.f, iVM  = 0.f;
	  dfloat iUP  = 0.f, iVP  = 0.f;
	  dfloat iUdM = 0.f, iVdM = 0.f;
	  dfloat iUdP = 0.f, iVdP = 0.f;

	  // local block interpolation (face nodes to integration nodes)
	  //occaUnroll(p_Nfp)
	  for(iint m=0;m<p_Nfp;++m){
	    dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	    iint fm = face*p_Nfp+m;

	    iUM  += iInm*s_UM[fm];
	    iVM  += iInm*s_VM[fm];
	    iUdM += iInm*s_UdM[fm];
	    iVdM += iInm*s_VdM[fm];

	    iUP  += iInm*s_UP[fm];
	    iVP  += iInm*s_VP[fm];
	    iUdP += iInm*s_UdP[fm];
	    iVdP += iInm*s_VdP[fm];
	  }

	  // apply boundary conditions
	  iint bc = EToB[face+p_Nfaces*e];

	  if(bc>0){
	    insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	  }


	  // Find max normal velocity on the face
	  dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	  dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	  dfloat unmax = (unm > unp) ? unm : unp;

	  // evaluate "flux" terms: LLF
	  dfloat sc = invJ * sJ ;

	  s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

	  s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
	}
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
	if(n<p_Np){
	  iint id = n + p_Np*e;
	  // prefetch volume rhs
	  dfloat rhsu = 0.f;
	  dfloat rhsv = 0.f;

	  //occaUnroll(p_intNfpNfaces)
	  for(iint m=0;m<p_intNfpNfaces;++m){
            // RefMassMatrix^{-1}*cInterp^t*cWeight
	    dfloat L = intLIFTT[n+m*p_Np];

	    rhsu += L*s_iFluxU[m];
	    rhsv += L*s_iFluxV[m];
	  }

	  rhsU[id] = rhsu;  // 
	  rhsV[id] = rhsv;  //  
	}
      }
    }
  }
}



// Add const and loop unrolling
kernel void insSubCycleCubatureSurface2D_v2(
					    const iint Nelements,
					    const dfloat * restrict sgeo,
					    const dfloat * restrict intInterpT, // interpolate to integration nodes
					    const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					    const iint   * restrict vmapM,
					    const iint   * restrict vmapP,
					    const iint   * restrict EToB,
					    const dfloat time,
					    const dfloat * restrict intx, // integration nodes
					    const dfloat * restrict inty,
					    const dfloat * restrict U,
					    const dfloat * restrict V,
					    const dfloat * restrict Ud,
					    const dfloat * restrict Vd,
					    dfloat * restrict rhsU,
					    dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    //


    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          const iint id  = e*p_Nfp*p_Nfaces + n;

          iint idM = vmapM[id];
          iint idP = vmapP[id];

          if(idP<0) idP = idM;
	  // load negative and positive trace node values of velocity
	  s_UM[n] = U[idM];
	  s_VM[n] = V[idM];
	  s_UP[n] = U[idP];
	  s_VP[n] = V[idP];

	  s_UdM[n] = Ud[idM];
	  s_VdM[n] = Vd[idM];
	  s_UdP[n] = Ud[idP];
	  s_VdP[n] = Vd[idP];

	}
      }
    }

    barrier(localMemFence);

  
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

      if(e<Nelements){
	if(n<(p_Nfaces*p_intNfp)){

	  const iint face = n/p_intNfp; // find face that owns this integration node

	  // load surface geofactors for this face
	  const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	  const dfloat nx   = sgeo[sid+p_NXID];
	  const dfloat ny   = sgeo[sid+p_NYID];
	  const dfloat sJ   = sgeo[sid+p_SJID];
	  const dfloat invJ = sgeo[sid+p_IJID];

	  dfloat iUM  = 0.f, iVM  = 0.f;
	  dfloat iUP  = 0.f, iVP  = 0.f;
	  dfloat iUdM = 0.f, iVdM = 0.f;
	  dfloat iUdP = 0.f, iVdP = 0.f;

	  // local block interpolation (face nodes to integration nodes)
	  occaUnroll(p_Nfp)
	    for(iint m=0;m<p_Nfp;++m){
	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	      const iint fm = face*p_Nfp+m;

	      iUM  += iInm*s_UM[fm];
	      iVM  += iInm*s_VM[fm];
	      iUdM += iInm*s_UdM[fm];
	      iVdM += iInm*s_VdM[fm];

	      iUP  += iInm*s_UP[fm];
	      iVP  += iInm*s_VP[fm];
	      iUdP += iInm*s_UdP[fm];
	      iVdP += iInm*s_VdP[fm];
	    }

	  // apply boundary conditions
	  const iint bc = EToB[face+p_Nfaces*e];

	  if(bc>0){
	    insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	  }


	  // Find max normal velocity on the face
	  const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	  const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	  const dfloat unmax = (unm > unp) ? unm : unp;

	  // evaluate "flux" terms: LLF
	  const dfloat sc = invJ * sJ ;

	  s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				 +ny*(iVP*iUdP + iVM*iUdM) 
				 +unmax*(iUdM-iUdP) ));

	  s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				 + ny*(iVP*iVdP + iVM*iVdM) 
				 + unmax*(iVdM-iVdP) ));
	}
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      if(e<Nelements){
	if(n<p_Np){
	  const iint id = n + p_Np*e;
	  // prefetch volume rhs
	  dfloat rhsu = 0.f;
	  dfloat rhsv = 0.f;

	  occaUnroll(p_intNfpNfaces)
            for(iint m=0;m<p_intNfpNfaces;++m){
	      // RefMassMatrix^{-1}*cInterp^t*cWeight
              const dfloat L = intLIFTT[n+m*p_Np];

              rhsu += L*s_iFluxU[m];
              rhsv += L*s_iFluxV[m];
            }

	  rhsU[id] += rhsu;  // 
	  rhsV[id] += rhsv;  //  
	}
      }
    }
  }
}




// Optimized sizes for kernel 3
#if p_N==1
#define p_cubNblockS 14
#endif

#if p_N==2
#define p_cubNblockS 8
#endif

#if p_N==3
#define p_cubNblockS 7
#endif

#if p_N==4
#define p_cubNblockS 6
#endif

#if p_N==5
#define p_cubNblockS 6
#endif

#if p_N==6
#define p_cubNblockS 7
#endif

#if p_N==7
#define p_cubNblockS 7
#endif

#if p_N==8
#define p_cubNblockS 6
#endif

#if p_N==9
#define p_cubNblockS 4
#endif

#if p_N==10
#define p_cubNblockS 5
#endif



// Add multiple element per threadblock 
kernel void insSubCycleCubatureSurface2D_v3(const iint Nelements,
					    const dfloat * restrict sgeo,
					    const dfloat * restrict intInterpT, // interpolate to integration nodes
					    const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					    const iint   * restrict vmapM,
					    const iint   * restrict vmapP,
					    const iint   * restrict EToB,
					    const dfloat time,
					    const dfloat * restrict intx, // integration nodes
					    const dfloat * restrict inty,
					    const dfloat * restrict U,
					    const dfloat * restrict V,
					    const dfloat * restrict Ud,
					    const dfloat * restrict Vd,
					    dfloat * restrict rhsU,
					    dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const iint id  = e*p_Nfp*p_Nfaces + n;

	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM;
	    // load negative and positive trace node values of velocity
	    s_UM[es][n] = U[idM];
	    s_VM[es][n] = V[idM];
	    s_UP[es][n] = U[idP];
	    s_VP[es][n] = V[idP];

	    s_UdM[es][n] = Ud[idM];
	    s_VdM[es][n] = Vd[idM];
	    s_UdP[es][n] = Ud[idP];
	    s_VdP[es][n] = Vd[idP];

	  }
	}
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const iint face = n/p_intNfp; // find face that owns this integration node

	    // load surface geofactors for this face
	    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];

	    dfloat iUM  = 0.f, iVM  = 0.f;
	    dfloat iUP  = 0.f, iVP  = 0.f;
	    dfloat iUdM = 0.f, iVdM = 0.f;
	    dfloat iUdP = 0.f, iVdP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    occaUnroll(p_Nfp)
	      for(iint m=0;m<p_Nfp;++m){
		const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
		const iint fm = face*p_Nfp+m;

		iUM  += iInm*s_UM[es][fm];
		iVM  += iInm*s_VM[es][fm];
		iUdM += iInm*s_UdM[es][fm];
		iVdM += iInm*s_VdM[es][fm];

		iUP  += iInm*s_UP[es][fm];
		iVP  += iInm*s_VP[es][fm];
		iUdP += iInm*s_UdP[es][fm];
		iVdP += iInm*s_VdP[es][fm];
	      }

	    // apply boundary conditions
	    iint bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    }


	    // Find max normal velocity on the face
	    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	    dfloat unmax = (unm > unp) ? unm : unp;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ;

	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				       +ny*(iVP*iUdP + iVM*iUdM) 
				       +unmax*(iUdM-iUdP) ));

	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
				       + ny*(iVP*iVdP + iVM*iVdM) 
				       + unmax*(iVdM-iVdP) ));
	  }
	}
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        const iint e = eo + es;

        if(e<Nelements){
          if(n<p_Np){
            iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
	      for(int m=0;m<p_intNfpNfaces;++m){
		// RefMassMatrix^{-1}*cInterp^t*cWeight
		const dfloat L = intLIFTT[n+m*p_Np];

		rhsu += L*s_iFluxU[es][m];
		rhsv += L*s_iFluxV[es][m];
	      }

            rhsU[id] = rhsu;  // 
            rhsV[id] = rhsv;  //  
          }
        }
      }
    }
  }

}


// Optimized sizes for kernel 3
#if p_N==1
#define p_NblockS1 14
#endif

#if p_N==2
#define p_NblockS1 16
#endif

#if p_N==3
#define p_NblockS1 16
#endif

#if p_N==4
#define p_NblockS1 14
#endif

#if p_N==5
#define p_NblockS1 13
#endif

#if p_N==6
#define p_NblockS1 13
#endif

#if p_N==7
#define p_NblockS1 8
#endif

#if p_N==8
#define p_NblockS1 7
#endif

#if p_N==9
#define p_NblockS1 5
#endif

#if p_N==10
#define p_NblockS1 5
#endif


// Use less shared memory by factor 2
kernel void insSubCycleCubatureSurface2D_v4(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS1;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_NblockS1][p_intNfpNfaces];
    shared dfloat s_V[p_NblockS1][p_intNfpNfaces];
    shared dfloat s_Ud[p_NblockS1][p_NfacesNfp];
    shared dfloat s_Vd[p_NblockS1][p_NfacesNfp];

   #define s_iFluxU s_U
   #define s_iFluxV s_V
  
    exclusive dfloat r_iUM,  r_iUP;
    exclusive dfloat r_iVM,  r_iVP;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    // Loop for minus traces //
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            const iint idM = vmapM[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
            s_Ud[es][n] = Ud[idM];
            s_Vd[es][n] = Vd[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            r_iUM  = 0.f;
            r_iVM  = 0.f;
            r_iUdM = 0.f;
            r_iVdM = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;

                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
                r_iUdM += iInm*s_Ud[es][fm];
                r_iVdM += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);

    // Loop for positive traces 
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            const iint idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
            s_Ud[es][n] = Ud[idP];
            s_Vd[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;

                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
                r_iUdP += iInm*s_Ud[es][fm];
                r_iVdP += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);


    // Use traces to compuite and store flux 
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS1;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}





// Optimized sizes for kernel 3
#if p_N==1
#define p_NblockS2 14
#endif

#if p_N==2
#define p_NblockS2 16
#endif

#if p_N==3
#define p_NblockS2 16
#endif

#if p_N==4
#define p_NblockS2 14
#endif

#if p_N==5
#define p_NblockS2 13
#endif

#if p_N==6
#define p_NblockS2 13
#endif

#if p_N==7
#define p_NblockS2 8
#endif

#if p_N==8
#define p_NblockS2 7
#endif

#if p_N==9
#define p_NblockS2 5
#endif

#if p_N==10
#define p_NblockS2 5
#endif


// Use less shared memory by factor 4
kernel void insSubCycleCubatureSurface2D_v5(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS2;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_NblockS2][p_intNfpNfaces];
    shared dfloat s_V[p_NblockS2][p_intNfpNfaces];
    
   	#define s_iFluxU s_U
   	#define s_iFluxV s_V
  
    exclusive dfloat r_iUM,  r_iUP;
    exclusive dfloat r_iVM,  r_iVP;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    exclusive iint idM, idP; 

    //Loop for minus traces //
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            idM = vmapM[id];
            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node
            r_iUM  = 0.f;
            r_iVM  = 0.f;        
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;
                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);



    //Loop for minus traces //
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // load negative and positive trace node values of velocity
            s_U[es][n] = Ud[idM];
            s_V[es][n] = Vd[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node
            r_iUdM = 0.f;
            r_iVdM = 0.f;
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;
                r_iUdM += iInm*s_U[es][fm];
                r_iVdM += iInm*s_V[es][fm];
              }
          }
        }
      }
    }

    barrier(localMemFence);

    // Loop for positive traces //
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            
            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;
                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
              }
          }
        }
      }
    }

     barrier(localMemFence);

    // Loop for positive traces //
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            s_U[es][n] = Ud[idP];
            s_V[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;
                r_iUdP += iInm*s_U[es][fm];
                r_iVdP += iInm*s_V[es][fm];
              }
          }
        }
      }
    }


    barrier(localMemFence);


    // Use traces to compuite and store flux //
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS2;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}



// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS4 8
#define p_NnodesS4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Multiple nodes per thread// use less shared memory by factor 4 
kernel void insSubCycleCubatureSurface2D_v6(const iint Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const iint   * restrict vmapM,
              const iint   * restrict vmapP,
              const iint   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

     exclusive iint idM[p_NnodesS4], idP[p_NnodesS4];
    exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em]];
              s_V[em][es][n] = U[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iUP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em]];
              s_V[em][es][n] = Ud[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iUdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

      // Loop for positive traces
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = V[idM[em]];
              s_V[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iVM[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Vd[idM[em]];
              s_V[em][es][n] = Vd[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iVdM[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // Use traces to compuite and store flux
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        occaUnroll(p_NnodesS4)
        for (int em=0;em<p_NnodesS4;++em){
          const iint e = em*p_NblockS4 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const iint id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const iint e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const iint id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}










/*

// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS3 7
#endif

#if p_N==2
#define p_NblockS3 8
#endif

#if p_N==3
#define p_NblockS3 7
#endif

#if p_N==4
#define p_NblockS3 9
#endif

#if p_N==5
#define p_NblockS3 6
#endif

#if p_N==6
#define p_NblockS3 7
#endif

#if p_N==7
#define p_NblockS3 7
#endif

#if p_N==8
#define p_NblockS3 7
#endif

#if p_N==9
#define p_NblockS3 4
#endif

#if p_N==10
#define p_NblockS3 4
#endif


// Use shmem for interp and geo and less shared memeory for factor 2
kernel void insSubCycleCubatureSurface2D_v6(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS3;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_NblockS3][p_intNfpNfaces];
    shared dfloat s_V[p_NblockS3][p_intNfpNfaces];
    shared dfloat s_Ud[p_NblockS3][p_NfacesNfp];
    shared dfloat s_Vd[p_NblockS3][p_NfacesNfp];
    
    // Load geo and shared memory to
    shared dfloat s_sgeo[p_NblockS3][p_Nfaces][p_Nsgeo];
    shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];

   #define s_iFluxU s_U // Reuse shemem array
   #define s_iFluxV s_V
  
    exclusive dfloat r_iUM,  r_iUP;
    exclusive dfloat r_iVM,  r_iVP;
    exclusive dfloat r_iUdM, r_iUdP;
    exclusive dfloat r_iVdM, r_iVdP;

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
          if(e<Nelements){
            if(n<p_Np ){
              iint m = n + p_Np*es;
            // oad surface geofacs for all faces of all elements in block(s)
              while(m<p_NblockS3*p_Nfaces*p_Nsgeo){
                const iint id = eo*p_Nfaces*p_Nsgeo+ m;
                s_sgeo[0][0][m] = sgeo[id];
                m+=p_Np*p_NblockS3;
             }
              if (es==0) {
                for(iint m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
                  s_intInterpT[m] = intInterpT[m];
                }
             }
            }
      
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            const iint idM = vmapM[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idM];
            s_V[es][n] = V[idM];
            s_Ud[es][n] = Ud[idM];
            s_Vd[es][n] = Vd[idM];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            r_iUM  = 0.f;
            r_iVM  = 0.f;
            r_iUdM = 0.f;
            r_iVdM = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;

                r_iUM  += iInm*s_U[es][fm];
                r_iVM  += iInm*s_V[es][fm];
                r_iUdM += iInm*s_Ud[es][fm];
                r_iVdM += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);

    // Loop for positive traces
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_Nfp)){
            // indices of negative and positive traces of face node
            const iint id  = e*p_Nfp*p_Nfaces + n;
            const iint idP = vmapP[id];

            // load negative and positive trace node values of velocity
            s_U[es][n] = U[idP];
            s_V[es][n] = V[idP];
            s_Ud[es][n] = Ud[idP];
            s_Vd[es][n] = Vd[idP];
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            r_iUP  = 0.f;
            r_iVP  = 0.f;
            r_iUdP = 0.f;
            r_iVdP = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
              for(iint m=0;m<p_Nfp;++m){
                const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
                const iint fm = face*p_Nfp+m;

                r_iUP  += iInm*s_U[es][fm];
                r_iVP  += iInm*s_V[es][fm];
                r_iUdP += iInm*s_Ud[es][fm];
                r_iVdP += iInm*s_Vd[es][fm];
              }
          }
        }
      }
    }
    barrier(localMemFence);


    // Use traces to compuite and store flux //
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        const iint e = eo + es;
        if(e<Nelements){
          if(n<(p_Nfaces*p_intNfp)){
            const iint face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const dfloat nx   = s_sgeo[es][face][p_NXID];
            const dfloat ny   = s_sgeo[es][face][p_NYID];
            const dfloat sJ   = s_sgeo[es][face][p_SJID];
            const dfloat invJ = s_sgeo[es][face][p_IJID];
            
            // apply boundary conditions
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP, &r_iVdP);
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM + ny*r_iVM);
            const dfloat unp   = occaFabs(nx*r_iUP + ny*r_iVP);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ ;

            // bad notation here //
            s_iFluxU[es][n] = sc*(nx*(r_iUP*r_iUdP + r_iUM*r_iUdM) 
                             +ny*(r_iVP*r_iUdP + r_iVM*r_iUdM) 
                             +unmax*(r_iUdM-r_iUdP));

            s_iFluxV[es][n] = sc*(nx*(r_iUP*r_iVdP + r_iUM*r_iVdM) 
                            + ny*(r_iVP*r_iVdP + r_iVM*r_iVdM) 
                            + unmax*(r_iVdM-r_iVdP));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            const iint id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
              for(int m=0;m<p_intNfpNfaces;++m){
                const dfloat L = intLIFTT[n+m*p_Np];
                rhsu += L*s_U[es][m];
                rhsv += L*s_V[es][m];
              }

            rhsU[id] = rhsu;
            rhsV[id] = rhsv; 
          }
        }
      }
    }


  #undef s_iFluxU
  #undef s_iFluxV   
  }
}









































// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS4 8
#define p_NnodesS5S4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Multiple nodes per thread// use less shared memory by factor 2 
// fetch (or not)  geo and interp into shared
kernel void insSubCycleCubatureSurface2D_v7(const iint Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const iint   * restrict vmapM,
              const iint   * restrict vmapP,
              const iint   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    
    shared dfloat s_Ud[p_NnodesS4][p_NblockS4][p_NfacesNfp];
    shared dfloat s_Vd[p_NnodesS4][p_NblockS4][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

    // shared dfloat s_sgeo[p_NnodesS4][p_NblockS4][p_Nfaces][p_Nsgeo];
    // shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        occaUnroll(p_NnodesS4)
     for(iint em=0;em<p_NnodesS4;++em){ 
                
      const iint e   = eo + es*p_NnodesS4 + em; 
      const iint id  = e*p_NfacesNfp + n;

       // if(e<Nelements && n<p_Np ){
       //    iint m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS4*p_Nfaces*p_Nsgeo*p_NnodesS4){
       //      const iint id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS4;
       //   }
     
       //    if (es==0 && em==0) {
       //      for(iint m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }

      if(e<Nelements && n<p_NfacesNfp ){
        iint idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idM];
        s_V[em][es][n]  = V[idM];
        s_Ud[em][es][n] = Ud[idM];
        s_Vd[em][es][n] = Vd[idM];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            // const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS4)
              for(iint em=0;em<p_NnodesS4;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);



    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      occaUnroll(p_NnodesS4)
      for(iint em=0;em<p_NnodesS4;++em){           
       const iint e   = eo + es*p_NnodesS4 + em; 
       const iint id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        iint idP = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP];
        s_V[em][es][n]  = V[idP];
        s_Ud[em][es][n] = Ud[idP];
        s_Vd[em][es][n] = Vd[idP];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            // const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS4)
              for(iint em=0;em<p_NnodesS4;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);


     // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp;       
          occaUnroll(p_NnodesS4)
          for(iint em=0;em<p_NnodesS4;++em){
            const iint e   = eo + es*p_NnodesS4 + em; 
            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ = s_sgeo[em][es][face][p_IJID];

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];  

        
            const iint bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        dfloat rhsu[p_NnodesS4], rhsv[p_NnodesS4];

        if(n<p_Np){
          occaUnroll(p_NnodesS4)
         for(iint em=0;em<p_NnodesS4;++em){
			const iint e = eo+es*p_NnodesS4+em;
			const iint id = e*p_Np+n;
			rhsu[em] = rhsU[id];
			rhsv[em] = rhsV[id];
          }
        //
          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        occaUnroll(p_NnodesS4)
       for(iint em=0;em<p_NnodesS4;++em){
        iint e = eo+es*p_NnodesS4+em;
          if(e<Nelements){
            const iint id = e*p_Np+n;
            rhsU[id]   = rhsu[em]; // note  change in sign
            rhsV[id]   = rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}







// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS5 8
#define p_NnodesS5 4
#endif

#if p_N==2
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==3
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==4
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==5
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==6
#define p_NblockS5 4
#define p_NnodesS5 5
#endif

#if p_N==7
#define p_NblockS5 5
#define p_NnodesS5 2
#endif

#if p_N==8
#define p_NblockS5 1
#define p_NnodesS5 4
#endif

#if p_N==9
#define p_NblockS5 3
#define p_NnodesS5 2
#endif

#if p_N==10
#define p_NblockS5 2
#define p_NnodesS5 3
#endif



// add "restrict to p_Np thread"  to kernel 5
kernel void insSubCycleCubatureSurface2D_v8(const iint Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const iint   * restrict vmapM,
                                            const iint   * restrict vmapP,
                                            const iint   * restrict EToB,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                            dfloat * restrict rhsU,
                                            dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblocksS5*p_NnodesS5;outer0){

    // shared storage for flux terms
    shared dfloat s_U[p_NnodesS5][p_NblocksS5][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS5][p_NblocksS5][p_intNfpNfaces];
    shared dfloat s_Ud[p_NnodesS5][p_NblocksS5][p_NfacesNfp];
    shared dfloat s_Vd[p_NnodesS5][p_NblocksS5][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

   //shared dfloat s_sgeo[p_NnodesS5][p_NblocksS5][p_Nfaces][p_Nsgeo];
   //shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    for (int es=0;es<p_NblocksS5;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;
       // if(e<Nelements){
       //    iint m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS4*p_Nfaces*p_Nsgeo*p_NnodesS4){
       //      const iint id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS4;
       //   }
     
       //    if (es==0 && em==0) {
       //      for(iint m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }
        
        occaUnroll(p_NnodesS5)
        for (int em=0;em<p_NnodesS5;++em){
          const int e = em*p_NblocksS5 + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + m;

              const iint idM = vmapM[id];
              // load negative and positive trace node values of velocity
              s_U[em][es][m] = U[idM];
              s_V[em][es][m] = V[idM];
              s_Ud[em][es][m] = Ud[idM];
              s_Vd[em][es][m] = Vd[idM];
            }
          }
        }
      }
    }

    barrier(localMemFence);







    for (int es=0;es<p_NblocksS5;++es;inner1){
      for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
        int m = n + p_Np*es;        
        occaUnroll(p_NnodesS5)
        for (int em=0;em<p_NnodesS5;++em){
          const int e = em*p_NblocksS5 + es + eo;
          if(e<Nelements){
            for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
              // indices of negative and positive traces of face node
              const iint id  = e*p_Nfp*p_Nfaces + m;
              const iint idP = vmapP[id];
              // load negative and positive trace node values of velocity
              s_U[em][es][m] = U[idP];
              s_V[em][es][m] = V[idP];
              s_Ud[em][es][m] = Ud[idP];
              s_Vd[em][es][m] = Vd[idP];
            }
          }
        }
      }
    }

    barrier(localMemFence);






    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblocksS5;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){ 
        
        dfloat iUM [p_NnodesS5], iVM [p_NnodesS5];
        dfloat iUP [p_NnodesS5], iVP [p_NnodesS5];
        dfloat iUdM[p_NnodesS5], iVdM[p_NnodesS5];
        dfloat iUdP[p_NnodesS5], iVdP[p_NnodesS5];

        for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

          occaUnroll(p_NnodesS5)
          for (int et=0;et<p_NnodesS5;++et){
            iUM [et] = 0.f, iVM [et] = 0.f;
            iUP [et] = 0.f, iVP [et] = 0.f;
            iUdM[et] = 0.f, iVdM[et] = 0.f;
            iUdP[et] = 0.f, iVdP[et] = 0.f;
          }
      
          const iint face = m/p_intNfp; // find face that owns this integration node
          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
            for(iint k=0;k<p_Nfp;++k){
              const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
              const iint fm = face*p_Nfp+k;

              occaUnroll(p_NnodesS5)
              for (int et=0;et<p_NnodesS5;++et){

                iUM [et] += iInm* s_UM[et][es][fm];
                iVM [et] += iInm* s_VM[et][es][fm];
                iUdM[et] += iInm*s_UdM[et][es][fm];
                iVdM[et] += iInm*s_VdM[et][es][fm];

                iUP [et] += iInm* s_UP[et][es][fm];
                iVP [et] += iInm* s_VP[et][es][fm];
                iUdP[et] += iInm*s_UdP[et][es][fm];
                iVdP[et] += iInm*s_VdP[et][es][fm];
              }
            }

          occaUnroll(p_NnodesS5)
          for (int et=0;et<p_NnodesS5;++et){
            const int e = et*p_NblocksS5 + es + eo;
            if (e<Nelements) {
              // load surface geofactors for this face
              const dfloat nx   = s_sgeo[et][es][face][p_NXID];
              const dfloat ny   = s_sgeo[et][es][face][p_NYID];
              const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
              const dfloat invJ = s_sgeo[et][es][face][p_IJID];

              // apply boundary conditions
              const iint bc = EToB[face+p_Nfaces*e];
              if(bc>0){
                insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
              }

              // Find max normal velocity on the face
              const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
              const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);    
              const dfloat unmax = (unm > unp) ? unm : unp;

              // evaluate "flux" terms: LLF
              const dfloat sc = 0.5f*invJ*sJ ;

              s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et]) 
                                   +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et]) 
                                   +unmax*(iUdM[et]-iUdP[et]));

              s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et]) 
                                  + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et]) 
                                  + unmax*(iVdM[et]-iVdP[et]));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblocksS5;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        
        dfloat rhsu[p_NnodesS5];
        dfloat rhsv[p_NnodesS5];
        
        occaUnroll(p_NnodesS5)
        for (int et=0;et<p_NnodesS5;++et){
          rhsu[et] = 0;
          rhsv[et] = 0;
        }
        
        occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_NnodesS5)
            for (int et=0;et<p_NnodesS5;++et){
              rhsu[et] += L*s_iFluxU[et][es][m];
              rhsv[et] += L*s_iFluxV[et][es][m];
            }
          }
        
        occaUnroll(p_NnodesS5)
        for (int et=0;et<p_NnodesS5;++et){
          const int e = et*p_NblocksS5 + es + eo;
          if(e<Nelements){
            const iint id = n + p_Np*e;
            rhsU[id] += rhsu[et];
            rhsV[id] += rhsv[et];
          }
        }
      }
    }
  }
}


























/*


// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS3 10
#define p_NnodesS3 2
#endif

#if p_N==2
#define p_NblockS3 8
#define p_NnodesS3 2
#endif

#if p_N==3
#define p_NblockS3 7
#define p_NnodesS3 2
#endif

#if p_N==4
#define p_NblockS3 3
#define p_NnodesS3 3
#endif

#if p_N==5
#define p_NblockS3 1
#define p_NnodesS3 3
#endif

#if p_N==6
#define p_NblockS3 2
#define p_NnodesS3 2
#endif

#if p_N==7
#define p_NblockS3 5
#define p_NnodesS3 2
#endif

#if p_N==8
#define p_NblockS3 4
#define p_NnodesS3 3
#endif

#if p_N==9
#define p_NblockS3 1
#define p_NnodesS3 3
#endif

#if p_N==10
#define p_NblockS3 7
#define p_NnodesS3 2
#endif


// Based on 4; Add multiple nodes // use all shared memory
kernel void insSubCycleCubatureSurface2D_v6(const iint Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const iint   * restrict vmapM,
              const iint   * restrict vmapP,
              const iint   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=(p_NblockS3*p_NnodesS3);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    
    shared dfloat s_Ud[p_NnodesS3][p_NblockS3][p_NfacesNfp];
    shared dfloat s_Vd[p_NnodesS3][p_NblockS3][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
    exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
    exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
    exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];


//     shared dfloat s_sgeo[p_NnodesS3][p_NblockS3][p_Nfaces][p_Nsgeo];
//     shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        occaUnroll(p_NnodesS3)
     for(iint em=0;em<p_NnodesS3;++em){ 
                
      const iint e   = eo + es*p_NnodesS3 + em; 
      const iint id  = e*p_NfacesNfp + n;

       // if(e<Nelements && n<p_Np ){
       //    iint m = n + p_Np*es;
       //    // oad surface geofacs for all faces of all elements in block(s)
       //    while(m<p_NblockS3*p_Nfaces*p_Nsgeo*p_NnodesS3){
       //      const iint id = eo*p_Nfaces*p_Nsgeo+ m;
       //       s_sgeo[0][0][0][m] = sgeo[id];
       //       m+=p_Np*p_NblockS3;
       //   }
          
       //    if (es==0 && em==0) {
       //      for(iint m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
       //      s_intInterpT[m] = intInterpT[m];
       //      }
       //    }
       //  }

      if(e<Nelements && n<p_NfacesNfp ){
        iint idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idM];
        s_V[em][es][n]  = V[idM];
        s_Ud[em][es][n] = Ud[idM];
        s_Vd[em][es][n] = Vd[idM];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS3)
            for(iint em=0;em<p_NnodesS3;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS3)
              for(iint em=0;em<p_NnodesS3;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);



    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      occaUnroll(p_NnodesS3)
      for(iint em=0;em<p_NnodesS3;++em){           
       const iint e   = eo + es*p_NnodesS3 + em; 
       const iint id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        iint idP = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP];
        s_V[em][es][n]  = V[idP];
        s_Ud[em][es][n] = Ud[idP];
        s_Vd[em][es][n] = Vd[idP];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS3)
            for(iint em=0;em<p_NnodesS3;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS3)
              for(iint em=0;em<p_NnodesS3;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);


     // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp;       
          occaUnroll(p_NnodesS3)
          for(iint em=0;em<p_NnodesS3;++em){
            const iint e   = eo + es*p_NnodesS3 + em; 

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];


            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ   = s_sgeo[em][es][face][p_IJID];
        
            const iint bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS3;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        dfloat rhsu[p_NnodesS3], rhsv[p_NnodesS3];

        if(n<p_Np){
          occaUnroll(p_NnodesS3)
         for(iint em=0;em<p_NnodesS3;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_NnodesS3)
            for(iint em=0;em<p_NnodesS3;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        occaUnroll(p_NnodesS3)
       for(iint em=0;em<p_NnodesS3;++em){
        iint e = eo+es*p_NnodesS3+em;
          if(e<Nelements){
            const iint id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}



// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS4 8
#define p_NnodesS4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Based on 4; Add multiple nodes // use all shared memory

kernel void insSubCycleCubatureSurface2D_v7(const iint Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const iint   * restrict vmapM,
              const iint   * restrict vmapP,
              const iint   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat2 * restrict UM,
              const dfloat2 * restrict UP,
              const dfloat2 * restrict UdM,
              const dfloat2 * restrict UdP,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    
    shared dfloat s_Ud[p_NnodesS4][p_NblockS4][p_NfacesNfp];
    shared dfloat s_Vd[p_NnodesS4][p_NblockS4][p_NfacesNfp];

    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];
    
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        occaUnroll(p_NnodesS4)
     for(iint em=0;em<p_NnodesS4;++em){ 
                
      const iint e   = eo + es*p_NnodesS4 + em; 
      const iint id  = e*p_NfacesNfp + n;

      if(e<Nelements && n<p_NfacesNfp ){
        //iint idM = vmapM[id];
        // //load negative and positive trace node values of velocity
        // s_U[em][es][n]  = U[idM];
        // s_V[em][es][n]  = V[idM];
        // s_Ud[em][es][n] = Ud[idM];
        // s_Vd[em][es][n] = Vd[idM];
        dfloat2 um  = UM[id];
        dfloat2 udm = UdM[id];

        s_U[em][es][n]  = um.x;
        s_V[em][es][n]  = um.y;
        s_Ud[em][es][n] = udm.x;
        s_Vd[em][es][n] = udm.y;


        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;  
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS4)
              for(iint em=0;em<p_NnodesS4;++em){
              r_iUM [em] += iInm*s_U[em][es][fm];
              r_iVM [em] += iInm*s_V[em][es][fm];
              r_iUdM[em] += iInm*s_Ud[em][es][fm];
              r_iVdM[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);



    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      occaUnroll(p_NnodesS4)
      for(iint em=0;em<p_NnodesS4;++em){           
       const iint e   = eo + es*p_NnodesS4 + em; 
       const iint id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        // iint idP = vmapP[id];
        // // //load negative and positive trace node values of velocity
        // s_U[em][es][n]  = U[idP];
        // s_V[em][es][n]  = V[idP];
        // s_Ud[em][es][n] = Ud[idP];
        // s_Vd[em][es][n] = Vd[idP];

        dfloat2 up  = UP[id];
        dfloat2 udp = UdP[id];

        s_U[em][es][n]  = up.x;
        s_V[em][es][n]  = up.y;
        s_Ud[em][es][n] = udp.x;
        s_Vd[em][es][n] = udp.y;
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;  
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS4)
              for(iint em=0;em<p_NnodesS4;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
              r_iUdP[em] += iInm*s_Ud[em][es][fm];
              r_iVdP[em] += iInm*s_Vd[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);


     // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp;       
          occaUnroll(p_NnodesS4)
          for(iint em=0;em<p_NnodesS4;++em){
            const iint e   = eo + es*p_NnodesS4 + em; 

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];
       
            const iint bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS4;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        dfloat rhsu[p_NnodesS4], rhsv[p_NnodesS4];

        if(n<p_Np){
          occaUnroll(p_NnodesS4)
         for(iint em=0;em<p_NnodesS4;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_NnodesS4)
            for(iint em=0;em<p_NnodesS4;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        occaUnroll(p_NnodesS4)
       for(iint em=0;em<p_NnodesS4;++em){
        iint e = eo+es*p_NnodesS4+em;
          if(e<Nelements){
            const iint id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}


// Based on 4; Add multiple nodes // use all shared memory

kernel void insSubCycleCubatureSurface2D_v8(const iint Nelements,
              const dfloat * restrict sgeo,
              const dfloat * restrict intInterpT, // interpolate to integration nodes
              const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
              const iint   * restrict vmapM,
              const iint   * restrict vmapP,
              const iint   * restrict EToB,
              const dfloat time,
              const dfloat * restrict intx, // integration nodes
              const dfloat * restrict inty,
              const dfloat * restrict U,
              const dfloat * restrict V,
              const dfloat * restrict Ud,
              const dfloat * restrict Vd,
              dfloat * restrict rhsU,
              dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=(p_NblockS5*p_NnodesS5);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

    exclusive iint idM[p_NnodesS5], idP[p_NnodesS5]; 


//     shared dfloat s_sgeo[p_NnodesS5][p_NblockS5][p_Nfaces][p_Nsgeo];
//     shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

      occaUnroll(p_NnodesS5)
        for(iint em=0;em<p_NnodesS5;++em){ 
                
        const iint e   = eo + es*p_NnodesS5 + em; 
        const iint id  = e*p_NfacesNfp + n;

        if(e<Nelements && n<p_NfacesNfp ){
          idM[em] = vmapM[id];
          // //load negative and positive trace node values of velocity
          s_U[em][es][n]  = U[idM[em]];
          s_V[em][es][n]  = V[idM[em]];
          }        
       }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS5)
            for(iint em=0;em<p_NnodesS5;++em){
              r_iUM [em] = 0.f;  
              r_iVM [em] = 0.f;          
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS5)
              for(iint em=0;em<p_NnodesS5;++em){
              r_iUM[em] += iInm*s_U[em][es][fm];
              r_iVM[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
  
    barrier(localMemFence);

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        occaUnroll(p_NnodesS5)
     for(iint em=0;em<p_NnodesS5;++em){ 
                
      const iint e   = eo + es*p_NnodesS5 + em; 
      const iint id  = e*p_NfacesNfp + n;

      if(e<Nelements && n<p_NfacesNfp ){
        s_U[em][es][n]  = Ud[idM[em]];
        s_V[em][es][n]  = Vd[idM[em]];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS5)
            for(iint em=0;em<p_NnodesS5;++em){
              r_iUdM[em] = 0.f; 
              r_iVdM[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS5)
              for(iint em=0;em<p_NnodesS5;++em){
              r_iUdM[em] += iInm*s_U[em][es][fm];
              r_iVdM[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    


    barrier(localMemFence);




    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      occaUnroll(p_NnodesS5)
      for(iint em=0;em<p_NnodesS5;++em){           
       const iint e   = eo + es*p_NnodesS5 + em; 
       const iint id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        idP[em] = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = U[idP[em]];
        s_V[em][es][n]  = V[idP[em]];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS5)
            for(iint em=0;em<p_NnodesS5;++em){
              r_iUP [em] = 0.f;  
              r_iVP [em] = 0.f;            
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS5)
              for(iint em=0;em<p_NnodesS5;++em){
              r_iUP [em] += iInm*s_U[em][es][fm];
              r_iVP [em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);



     // for all face nodes of all elements
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
      occaUnroll(p_NnodesS5)
      for(iint em=0;em<p_NnodesS5;++em){           
       const iint e   = eo + es*p_NnodesS5 + em; 
       const iint id  = e*p_NfacesNfp + n;
      if(e<Nelements && n<p_NfacesNfp ){
        //idP[em] = vmapP[id];
        // //load negative and positive trace node values of velocity
        s_U[em][es][n]  = Ud[idP[em]];
        s_V[em][es][n]  = Vd[idP[em]];
        }        
     }
    }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
           const iint face = n/p_intNfp;       
            occaUnroll(p_NnodesS5)
            for(iint em=0;em<p_NnodesS5;++em){
              r_iUdP[em] = 0.f; 
              r_iVdP[em] = 0.f;              
            }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(iint m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
            const iint fm = face*p_Nfp + m;
            occaUnroll(p_NnodesS5)
              for(iint em=0;em<p_NnodesS5;++em){
              r_iUdP[em] += iInm*s_U[em][es][fm];
              r_iVdP[em] += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    
    barrier(localMemFence);


     // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          const iint face = n/p_intNfp;       
          occaUnroll(p_NnodesS5)
          for(iint em=0;em<p_NnodesS5;++em){
            const iint e   = eo + es*p_NnodesS5 + em; 

            // load surface geofactors for this face
            const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];


            // const dfloat nx   = s_sgeo[em][es][face][p_NXID];
            // const dfloat ny   = s_sgeo[em][es][face][p_NYID];
            // const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
            // const dfloat invJ   = s_sgeo[em][es][face][p_IJID];
        
            const iint bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
            // }

            const dfloat sc = sJ*invJ; 
            //Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                   +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                   +unmax*(r_iUdM[em]- r_iUdP[em]) ));

            s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                   +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                   +unmax*(r_iVdM[em]-r_iVdP[em]) ));
           }
        }
      }
    }

    barrier(localMemeFence);
    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS5;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        dfloat rhsu[p_NnodesS5], rhsv[p_NnodesS5];

        if(n<p_Np){
          occaUnroll(p_NnodesS5)
         for(iint em=0;em<p_NnodesS5;++em){
          rhsu[em] = 0.f;
          rhsv[em] = 0.f;
          }
        //
          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            occaUnroll(p_NnodesS5)
            for(iint em=0;em<p_NnodesS5;++em){
              rhsu[em] += L*s_iFluxU[em][es][m];
              rhsv[em] += L*s_iFluxV[em][es][m];
           }
         }

        occaUnroll(p_NnodesS5)
       for(iint em=0;em<p_NnodesS5;++em){
        iint e = eo+es*p_NnodesS5+em;
          if(e<Nelements){
            const iint id = e*p_Np+n;
            rhsU[id]   += rhsu[em]; // note  change in sign
            rhsV[id]   += rhsv[em];    

           }
        }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV   

  }

}



