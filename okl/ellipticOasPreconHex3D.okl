     
#define cubeTheadsP \
  for(iint k=0;k<p_NqP;++k;inner2) \
    for(iint j=0;j<p_NqP;++j;inner1) \
      for(iint i=0;i<p_NqP;++i;inner0) 

// q  \in  Nq x Nq x Nq x Nelements
// Pq \in  NqPx NqPx NqPx Nelements

//                        |         | 
// form invP, P wrt   o x x x x x x x x o
//                        |         |

kernel void ellipticOasPreconHex3D(const iint Nelements,
				   const iint   * restrict faceNodesP,
				   const dfloat * restrict invP,
				   const dfloat * restrict P,
				   const dfloat * restrict diagInvOp,
				   const dfloat * restrict q,
				   const dfloat * restrict Pq){

  for(iint e=0;e<Nelements;++e;outer0){

    shared dfloat s_q[p_NqP][p_NqP][p_NqP], s_P[p_NqP][p_NqP], s_invP[p_NqP][p_NqP];
    exclusive dfloat r_tmp, r_diagInvOp;
    
    cubeThreadsP{
      iint n=i+p_NqP*j+p_NqP*p_NqP*k;
      if(n<p_Np){
	// coalesce reads from p_Nq x p_Nq x p_Nq storage
	iint ip = n%p_Nq;
	iint jp = (n/p_Nq)%p_Nq;
	iint kp = (n/(p_Nq*p_Nq));
	s_q[kp+1][jp+1][ip+1] = q[n+e*p_Np];
      }

      r_diagInvOp = diagInvOp[n+e*p_NpP];
      
      while(n<p_Nfaces*p_Nfp){
	s_q[0][0][faceNodesP[n]] = q[vmapPP[n+e*p_Nfaces*p_Nfp]];
	n += p_NpP;
      }

      if(k==0) s_P[j][i]    = P[i+p_NqP*j];
      if(k==1) s_invP[j][i] = invP[i+p_NqP*j];
    }
    
    barrier(localMemFence);

    // r-transform
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_Pinv[i][n]*s_q[k][j][n];

      r_tmp = tmp
    }

    barrier(localMemFence);

    cubeThreadsP{
      s_q[k][j][i] = r_tmp;
    }

    // s-transform
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_Pinv[j][n]*s_q[k][n][i];
      
      r_tmp = tmp
    }

    barrier(localMemFence);

    cubeThreadsP{
      s_q[k][j][i] = r_tmp;
    }

    barrier(localMemFence);

    // t-transform and inverse
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_Pinv[k][n]*s_q[n][j][i];

      // diagonal inverse
      r_tmp = r_diagInvOP*tmp;
    }

    barrier(localMemFence);

    cubeThreadsP{
      s_q[k][j][i] = r_tmp*r_diagInvOp;
    }

    barrier(localMemFence);

    // t-transform back
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_P[k][n]*s_q[n][j][i];
      
      r_tmp = tmp;
    }

    barrier(localMemFence);
    
    cubeThreadsP{
      s_q[k][j][i] = r_tmp;
    }

    barrier(localMemFence);
    
    // s-transform back
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_P[j][n]*s_q[k][n][i];
      
      r_tmp = tmp
    }

    barrier(localMemFence);
    
    cubeThreadsP{
      s_q[k][j][i] = r_tmp;
    }

    // r-transform back
    cubeThreadsP{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_NqP;++n)
	tmp += s_P[i][n]*s_q[k][j][n];
      
      const iint id=i+p_NqP*j+p_NqP*p_NqP*k + p_NpP*e;
      Pq[id] = tmp;
    }
  }
}
					
  
