#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
kernel void acousticsVolume2D(const iint Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict DrT,
				     const dfloat * restrict DsT,
				     const dfloat * restrict q,
				     dfloat * restrict rhsq){
  
	for(iint e=0;e<Nelements;++e;outer0){  // for all elements
  	for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	      
	    // compute 'r' and 's' derivatives of (u,v,p) at node n
	    dfloat dudr = 0, duds = 0;
	    dfloat dvdr = 0, dvds = 0;
	    dfloat dpdr = 0, dpds = 0;
	      
	    for(iint i=0;i<p_Np;++i){
				// load data at node i of element e
				const iint id = p_Nfields*(e*p_Np + i);
				const dfloat u = q[id+0], v = q[id+1], p = q[id+2];

			 	const dfloat Drni = DrT[n+i*p_Np];
				const dfloat Dsni = DsT[n+i*p_Np];

				// differentiate (u,v,p) with respect to 'r' and 's'
				dudr += Drni*u; duds += Dsni*u;
				dvdr += Drni*v; dvds += Dsni*v;
				dpdr += Drni*p;	dpds += Dsni*p;
      }

	    // chain rule
	    const dfloat dudx = drdx*dudr + dsdx*duds;
	    const dfloat dvdy = drdy*dvdr + dsdy*dvds;
	    const dfloat dpdx = drdx*dpdr + dsdx*dpds;
	    const dfloat dpdy = drdy*dpdr + dsdy*dpds;
	      
	    // store acoustics rhs contributions from collocation differentiation
	    const iint id = p_Nfields*(e*p_Np + n);
	    rhsq[id+0] = -dpdx;
	    rhsq[id+1] = -dpdy;
	    rhsq[id+2] = -dudx-dvdy;
    }
	}
}


kernel void acousticsVolume2Dbbdg(const iint Nelements,
					const dfloat * restrict vgeo,
					const iint * restrict D1ids,
					const iint * restrict D2ids,
					const iint * restrict D3ids,
					const dfloat * restrict Dvals,		
					const dfloat * restrict q,
					dfloat * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

				iint e = eo+es; // element in block

				if(e<Nelements){
				  const iint id = p_Nfields*(e*p_Np + n);
		  	  s_u[es][n] = q[id+0];
		  	  s_v[es][n] = q[id+1];
		  	  s_p[es][n] = q[id+2];
				}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
				iint e = eo+es; // element in block
				if(e<Nelements){
				  
				  // prefetch geometric factors (constant on triangle)
				  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
				  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
				  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
				  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

				  // compute 'r' and 's' derivatives of (q_m) at node n
				  const iint D1i1 = D1ids[n];
				  const iint D2i1 = D2ids[n];
				  const iint D3i1 = D3ids[n];
				  const dfloat Dval1 = Dvals[n];
				  
				  const iint D1i2 = D1ids[n+p_Np];
				  const iint D2i2 = D2ids[n+p_Np];
				  const iint D3i2 = D3ids[n+p_Np];
				  const dfloat Dval2 = Dvals[n+p_Np];

				  const iint D1i3 = D1ids[n+2*p_Np];
				  const iint D2i3 = D2ids[n+2*p_Np];
				  const iint D3i3 = D3ids[n+2*p_Np];	  
				  const dfloat Dval3 = Dvals[n+2*p_Np];

				  const dfloat dudr = .5f*(Dval1*(s_u[es][D2i1] - s_u[es][D1i1]) +
							    Dval2*(s_u[es][D2i2] - s_u[es][D1i2]) +
							    Dval3*(s_u[es][D2i3] - s_u[es][D1i3]));
				  const dfloat duds = .5f*(Dval1*(s_u[es][D3i1] - s_u[es][D1i1]) +
							    Dval2*(s_u[es][D3i2] - s_u[es][D1i2]) +
							    Dval3*(s_u[es][D3i3] - s_u[es][D1i3]));
				  
				  const dfloat dvdr = .5f*(Dval1*(s_v[es][D2i1] - s_v[es][D1i1]) +
							    Dval2*(s_v[es][D2i2] - s_v[es][D1i2]) +
							    Dval3*(s_v[es][D2i3] - s_v[es][D1i3]));
				  const dfloat dvds = .5f*(Dval1*(s_v[es][D3i1] - s_v[es][D1i1]) +
							    Dval2*(s_v[es][D3i2] - s_v[es][D1i2]) +
							    Dval3*(s_v[es][D3i3] - s_v[es][D1i3]));
				  
				  const dfloat dpdr = .5f*(Dval1*(s_p[es][D2i1] - s_p[es][D1i1]) +
							    Dval2*(s_p[es][D2i2] - s_p[es][D1i2]) +
							    Dval3*(s_p[es][D2i3] - s_p[es][D1i3]));
				  const dfloat dpds = .5f*(Dval1*(s_p[es][D3i1] - s_p[es][D1i1]) +
							    Dval2*(s_p[es][D3i2] - s_p[es][D1i2]) +
							    Dval3*(s_p[es][D3i3] - s_p[es][D1i3]));

				  // chain rule
				  dfloat dudx = drdx*dudr + dsdx*duds;
				  dfloat dvdy = drdy*dvdr + dsdy*dvds;
				  dfloat dpdx = drdx*dpdr + dsdx*dpds;
				  dfloat dpdy = drdy*dpdr + dsdy*dpds;
				  
				  const iint id = p_Nfields*(e*p_Np + n);
	  			rhsq[id+0] = -dpdx;
	  			rhsq[id+1] = -dpdy;
	  			rhsq[id+2] = -dudx-dvdy;
				}
      }
    }
  }
}
