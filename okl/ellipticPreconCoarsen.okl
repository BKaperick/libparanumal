kernel void ellipticPreconCoarsen_v0(const iint Nelements,
				     const dfloat * restrict invDegree,
				     const dfloat * restrict V1,
				     const dfloat * restrict qN,
				     dfloat * restrict q1){

  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Nverts;++n;inner0){
      dfloat tmp = 0;
      for(iint i=0;i<p_Np;++i){
	tmp += V1[n*p_Np + i]*qN[e*p_Np+i];
      }
      q1[e*p_Nverts+n] = tmp; // *invDegree[e*p_Nverts+n];
    }
  }
}


kernel void ellipticPreconCoarsen(const iint Nelements,
				  const dfloat * restrict V1,
				  const dfloat * restrict qN,
				  dfloat * restrict q1){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_qN[p_NblockV][p_Np];
    shared dfloat s_V1[p_Nverts][p_Np];
    
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Nverts;++n;inner0){
      	iint t = n + es*p_Nverts;

      	while(t<p_Np*p_NblockV){
      	  if(eo*p_Np + t<Nelements*p_Np)
      	    s_qN[0][t] = qN[eo*p_Np+t];
      	  t += p_Nverts*p_NblockV;
      	}
      	
      	t = n + es*p_Nverts;
      	
      	while(t<p_Np*p_Nverts){
      	  s_V1[0][t] = V1[t];
      	  t += p_Nverts*p_NblockV;
      	}
      }
    }

    barrier(localMemFence);
    
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Nverts;++n;inner0){
      	const iint e = eo + es;
      	if(e<Nelements){
      	  dfloat tmp = 0;
      	  occaUnroll(p_Np)
      	    for(iint i=0;i<p_Np;++i){
      	      tmp += s_V1[n][i]*s_qN[es][i]; // bank conflict ?
      	    }
      	  q1[e*p_Nverts+n] = tmp; // *invDegree[e*p_Nverts+n];
      	}
      }
    }
  }
}


#if 0
kernel void ellipticPreconCoarsenQuad2D(const iint Nelements,
					const dfloat * restrict R,
					const dfloat * restrict qN,
					dfloat * restrict q1){
  
  
  for(iint e=0;e<Nelements;++e;outer0){
    shared dfloat s_qNN[p_Nq][p_Nq];
    shared dfloat s_q1N[p_Nq1][p_Nq];
    shared dfloat s_q11[p_Nq1][p_Nq1];

    // prefetch to shared
    
    for(iint j=0;j<p_Nq;++j;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	s_qNN[j][i] = qN[i+j*p_Nq+e*p_Nq*p_Nq];
      }
    }

    barrier(localMemFence);

    // coarsen in j index
    
    for(iint j=0;j<p_Nq;++j;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	if(j<2){
	  dfloat res = 0;
	  for(iint m=0;m<p_Nq;++m)
	    res += R[j*p_Nq + m]*s_qN[m][i];
	  s_q1N[j][i] = res;
	}
      }
    }

    barrier(localMemFence);

    // coarsen in i index
    
    for(iint j=0;j<p_Nq;++j;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	if(j<2 && i<2){
	  dfloat rtmp = 0;
	  for(iint m=0;m<p_Nq;++m)
	    rtmp += R[i*p_Nq + m]*s_qN[j][m];
	  s_q11[j][i] = rtmp;
	}
      }
    }

    barrier(localMemFence);

    // collect writes
    for(iint j=0;j<p_Nq;++j;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	const iint id = i + j*p_Nq;
	if(id<p_Nq1*p_Nq1){
	  q1[id + p_Nq1*p_Nq1*e] = s_q11[0][id];
	}
      }
    }
    
  }
}
#endif
