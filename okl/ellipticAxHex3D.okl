
// hex kernel for screened coulomb potential mat-vec
#define cubeThreads				\
  for(iint k=0; k<p_Nq; ++k; inner2)		\
    for(iint j=0; j<p_Nq; ++j; inner1)		\
      for(iint i=0; i<p_Nq; ++i; inner0)


// cube thread version
kernel void ellipticAxHex3D_e0(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    
    // prefetch q(:,:,:,e) to shared
    cubeThreads{
      const iint base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np; 
      
      s_q[k][j][i] = q[base];
      
      if(k==0) // fetch D to shared
	s_D[j][i] = D[j*p_Nq+i];
    }
      
    barrier(localMemFence);

    cubeThreads{
      
      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];
      
      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;
      
      for(iint n=0; n<p_Nq; ++n){
	qr += s_D[i][n]*s_q[k][j][n];
	qs += s_D[j][n]*s_q[k][n][i];
	qt += s_D[k][n]*s_q[n][j][i];
      }
      
      r_qr = qr; r_qs = qs; r_qt = qt;
      
      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      iint base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}



// i-j sliced version
kernel void ellipticAxHex3D_e1(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
      
    // prefetch q(i,j,:,e) to register array
    for(iint es=0; es<p_NblockV; ++es; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  const iint e = eo + es;

	  if(e<Nelements){
	    const iint base = i + j*p_Nq + e*p_Np; 
	    
	    for(iint k=0;k<p_Nq;++k){
	      r_q[k] = q[base + k*p_Nq*p_Nq];
	      r_Aq[k] = 0.f;
	    }
	  }
	  
	  if(es==0) // fetch D to shared
	    s_D[j][i] = D[j*p_Nq+i];
	  
	}
      }
    }
      
    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
	
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      // share k-slice of q 
	      s_q[es][j][i] = r_q[k];
	      
	      // hide shared latency behind t-derivative
	      dfloat qtk = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qtk += s_D[k][n]*r_q[n];
	      }
	      r_qt = qtk;
	      
	    }
	  }
	}
      }

      barrier(localMemFence);

      // process k-slice (first r- and s-derivatives)
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){
	      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qr += s_D[i][n]*s_q[es][j][n];
		qs += s_D[j][n]*s_q[es][n][i];
	      }

	      // assumes w*J built into G entries
	      s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
	      s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
	      r_tmpt           = G02*qr + G12*qs + G22*r_qt;

	      r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
	      for(iint n=0;n<p_Nq;++n){
		r_Aq[n] += s_D[k][n]*r_tmpt;
	      }
#endif
	    }
	  }
	}
      }
    
      barrier(localMemFence);

      // second derivatives
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      dfloat Aq1 = 0.0f, Aq2 = 0.0f;

	      for(iint n=0;n<p_Nq;++n){
		Aq1 += s_D[n][i]*s_tmpr[es][j][n];
		Aq2 += s_D[n][j]*s_tmps[es][n][i];
	      }
#if 1
	      r_Aq[k] +=  Aq1 + Aq2;
#endif  
	    }
	  }
	}
      }
    }

    // write result out (local node storage)
    for(iint es=0;es<p_NblockV;++es;inner2){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){
	  const iint e = eo + es;
	  if(e<Nelements){
	    iint base = e*p_Np + j*p_Nq + i;
	    for(iint k=0;k<p_Nq;++k){
	      Aq[base] = r_Aq[k];
	      base+=p_Nq*p_Nq;
	    }
	  }
	}
      }
    }
  }
}


/*
  I = interp;
  D = diff and interp;
  
  qr_{kji} =  I_{jb} D_{ia} I_{kc} q_{cba};
  qs_{kji} =  D_{jb} I_{ia} I_{kc} q_{cba};
  qt_{kji} =  I_{jb} I_{ia} D_{kc} q_{cba};
  
  w*J*G*grad q = WJG*[qr;qs;qt];
  
  lap_{cba} = 
  I_{ck} I_{bj} D_{ai} qr_{kji} + 
  I_{ck} D_{bj} I_{ai} qs_{kji} + 
  D_{ck} I_{bj} I_{ai} qt_{kji} ;
*/

/* note that the gggeo must be the geometric factors at the p_gNp integration nodes */
kernel void ellipticAxHex3D_e2(const int Nelements,
			       const dfloat * restrict gggeo, 
			       const dfloat * restrict gD,
			       const dfloat * restrict gI,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){  

  for(int e=0;e<Nelements;++e;outer0){

#define p_gNq (p_Nq+1)
#define p_gNp (p_gNq*p_gNq*p_gNq)
#define p_Nq2 (p_Nq*p_Nq)

    shared dfloat s_D[p_gNq][p_Nq];
    shared dfloat s_I[p_gNq][p_Nq];

    exclusive dfloat r_Iq[p_gNq], r_Dq[p_gNq], r_lapq[p_Nq];

    shared dfloat s_Ixxq[p_Nq][p_Nq],  s_Dxxq[p_Nq][p_Nq];
    shared dfloat s_IxDq[p_Nq][p_gNq], s_IxIq[p_Nq][p_gNq], s_DxIq[p_Nq][p_gNq];
    shared dfloat s_qr[p_gNq][p_gNq], s_qs[p_gNq][p_gNq], s_qt[p_gNq][p_gNq];
    shared dfloat s_Dqr[p_gNq][p_Nq], s_Iqs[p_gNq][p_Nq], s_Iqt[p_gNq][p_Nq];
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	int t = a + b*p_gNq;
	if(t<p_gNq*p_Nq){
	  s_D[0][t] = gD[t];
	  s_I[0][t] = gI[t];
	}
	
	for(int k=0;k<p_gNq;++k){
	  r_Iq[k] = 0;
	  r_Dq[k] = 0;
	}

	for(int c=0;c<p_Nq;++c){
	  r_lapq[c] = 0;
	}
      }
    }

    barrier(localMemFence);

    //  interpolate and differentiate in 't'
    for(int c=0;c<p_Nq;++c){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  if(a<p_Nq && b<p_Nq){
	    const dfloat qcba = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
	    for(int k=0;k<p_gNq;++k){
	      // I_{kc} q_{cba}
	      r_Iq[k] += s_I[k][c]*qcba;
	      r_Dq[k] += s_D[k][c]*qcba;
	    }
	  }
	}
      }
    }

    // scan through k slices
    for(int k=0;k<p_gNq;++k){

      barrier(localMemFence);

      // prefetch slice
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  
	  if(a<p_Nq && b<p_Nq){
	    s_Ixxq[b][a] = r_Iq[k];
	    s_Dxxq[b][a] = r_Dq[k];
	  }
	}
      }

      barrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_gNq;++b;inner1){
	for(int i=0;i<p_gNq;++i;inner0){

	  if(b<p_Nq){
	    dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	    
	    for(int a=0;a<p_Nq;++a){
	      IxDq += s_D[i][a]*s_Ixxq[b][a];
	      IxIq += s_I[i][a]*s_Ixxq[b][a];
	      DxIq += s_I[i][a]*s_Dxxq[b][a];
	    }

	    s_IxDq[b][i] = IxDq;
	    s_IxIq[b][i] = IxIq;
	    s_DxIq[b][i] = DxIq;
	  }
	}
      }
      
      barrier(localMemFence);

      for(int j=0;j<p_gNq;++j;inner1){
	for(int i=0;i<p_gNq;++i;inner0){

	  const iint base = e*p_Nggeo*p_gNp + k*p_gNq*p_gNq + j*p_gNq + i;
	  
	  // assumes w*J built into G entries
	  //	  const dfloat r_GwJ = gggeo[base+p_GWJID*p_gNp];
	  
	  const dfloat r_G00 = gggeo[base+p_G00ID*p_gNp];
	  const dfloat r_G01 = gggeo[base+p_G01ID*p_gNp];
	  const dfloat r_G02 = gggeo[base+p_G02ID*p_gNp];
	  
	  const dfloat r_G11 = gggeo[base+p_G11ID*p_gNp];
	  const dfloat r_G12 = gggeo[base+p_G12ID*p_gNp];
	  const dfloat r_G22 = gggeo[base+p_G22ID*p_gNp];
	  
	  dfloat qr = 0, qs = 0, qt = 0;

	  // interpolate and differentiate in 's' direction
	  for(int n=0;n<p_Nq;++n){
	    qr += s_I[j][n]*s_IxDq[n][i];
	    qs += s_D[j][n]*s_IxIq[n][i];
	    qt += s_I[j][n]*s_DxIq[n][i];
	  }

	  // apply chain rule
	  s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
	  s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
	  s_qt[j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
	}
      }

      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r' 
      for(int j=0;j<p_gNq;++j;inner1){
	for(int a=0;a<p_gNq;++a;inner0){

	  if(a<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int i=0;i<p_gNq;++i){
	      tmpr += s_D[i][a]*s_qr[j][i];
	      tmps += s_I[i][a]*s_qs[j][i];
	      tmpt += s_I[i][a]*s_qt[j][i];
	    }

	    s_Dqr[j][a] = tmpr;
	    s_Iqs[j][a] = tmps;
	    s_Iqt[j][a] = tmpt;
	  }
	}
      }

      barrier(localMemFence);

      // transpose differentiate and interpolate in 's' 
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){

	  if(b<p_Nq && a<p_Nq) {
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int j=0;j<p_gNq;++j){
	      tmpr += s_I[j][b]*s_Dqr[j][a];
	      tmps += s_D[j][b]*s_Iqs[j][a];
	      tmpt += s_I[j][b]*s_Iqt[j][a];
	    }

	    // transpose differentiate and interpolate in 't'
	    for(int c=0;c<p_Nq;++c){
	      r_lapq[c] += s_I[k][c]*(tmpr+tmps);
	      r_lapq[c] += s_D[k][c]*tmpt;
	    }
	  }
	}
      }
    }

    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	
	if(a<p_Nq && b<p_Nq){ // bad 
	  for(int c=0;c<p_Nq;++c){
	    Aq[e*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
	  }
	}
      }
    }
  }
}
	  
