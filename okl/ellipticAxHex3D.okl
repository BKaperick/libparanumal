
// hex kernel for screened coulomb potential mat-vec
#define cubeThreads				\
  for(iint k=0; k<p_Nq; ++k; inner2)		\
    for(iint j=0; j<p_Nq; ++j; inner1)		\
      for(iint i=0; i<p_Nq; ++i; inner0)


// cube thread version
kernel void ellipticAxHex3D_e0(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    
    // prefetch q(:,:,:,e) to shared
    cubeThreads{
      const iint base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np; 
      
      s_q[k][j][i] = q[base];
      
      if(k==0) // fetch D to shared
	s_D[j][i] = D[j*p_Nq+i];
    }
      
    barrier(localMemFence);

    cubeThreads{
      
      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];
      
      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;
      
      for(iint n=0; n<p_Nq; ++n){
	qr += s_D[i][n]*s_q[k][j][n];
	qs += s_D[j][n]*s_q[k][n][i];
	qt += s_D[k][n]*s_q[n][j][i];
      }
      
      r_qr = qr; r_qs = qs; r_qt = qt;
      
      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      iint base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}



// i-j sliced version
kernel void ellipticAxHex3D_e1(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
      
    // prefetch q(i,j,:,e) to register array
    for(iint es=0; es<p_NblockV; ++es; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  const iint e = eo + es;

	  if(e<Nelements){
	    const iint base = i + j*p_Nq + e*p_Np; 
	    
	    for(iint k=0;k<p_Nq;++k){
	      r_q[k] = q[base + k*p_Nq*p_Nq];
	      r_Aq[k] = 0.f;
	    }
	  }
	  
	  if(es==0) // fetch D to shared
	    s_D[j][i] = D[j*p_Nq+i];
	  
	}
      }
    }
      
    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
	
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      // share k-slice of q 
	      s_q[es][j][i] = r_q[k];
	      
	      // hide shared latency behind t-derivative
	      dfloat qtk = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qtk += s_D[k][n]*r_q[n];
	      }
	      r_qt = qtk;
	      
	    }
	  }
	}
      }

      barrier(localMemFence);

      // process k-slice (first r- and s-derivatives)
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){
	      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qr += s_D[i][n]*s_q[es][j][n];
		qs += s_D[j][n]*s_q[es][n][i];
	      }

	      // assumes w*J built into G entries
	      s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
	      s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
	      r_tmpt           = G02*qr + G12*qs + G22*r_qt;

	      r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
	      for(iint n=0;n<p_Nq;++n){
		r_Aq[n] += s_D[k][n]*r_tmpt;
	      }
#endif
	    }
	  }
	}
      }
    
      barrier(localMemFence);

      // second derivatives
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      dfloat Aq1 = 0.0f, Aq2 = 0.0f;

	      for(iint n=0;n<p_Nq;++n){
		Aq1 += s_D[n][i]*s_tmpr[es][j][n];
		Aq2 += s_D[n][j]*s_tmps[es][n][i];
	      }
#if 1
	      r_Aq[k] +=  Aq1 + Aq2;
#endif  
	    }
	  }
	}
      }
    }

    // write result out (local node storage)
    for(iint es=0;es<p_NblockV;++es;inner2){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){
	  const iint e = eo + es;
	  if(e<Nelements){
	    iint base = e*p_Np + j*p_Nq + i;
	    for(iint k=0;k<p_Nq;++k){
	      Aq[base] = r_Aq[k];
	      base+=p_Nq*p_Nq;
	    }
	  }
	}
      }
    }
  }
}


/*
  I = interp;
  D = diff and interp;
  
  qr_{kji} =  I_{jb} D_{ia} I_{kc} q_{cba};
  qs_{kji} =  D_{jb} I_{ia} I_{kc} q_{cba};
  qt_{kji} =  I_{jb} I_{ia} D_{kc} q_{cba};
  
  w*J*G*grad q = WJG*[qr;qs;qt];
  
  lap_{cba} = 
  I_{ck} I_{bj} D_{ai} qr_{kji} + 
  I_{ck} D_{bj} I_{ai} qs_{kji} + 
  D_{ck} I_{bj} I_{ai} qt_{kji} ;
*/

#define p_gNq (p_Nq+1)
#define p_gNp (p_gNq*p_gNq*p_gNq)
#define p_Nq2 (p_Nq*p_Nq)
//#define p_NblockG (2)

#if ((p_NblockG*p_gNq*p_gNq)<=32)
#define optBarrier(op) 
#else
#define optBarrier(op)  \
   barrier(op)
#endif

/* note that the gggeo must be the geometric factors at the p_gNp integration nodes */
kernel void ellipticAxHex3D_e2(const int Nelements,
			       const dfloat * restrict gggeo, 
			       const dfloat * restrict gD,
			       const dfloat * restrict gI,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){  

  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_gNq][p_Nq];
    shared dfloat s_I[p_gNq][p_Nq];

    exclusive dfloat r_Iq[p_gNq], r_Dq[p_gNq], r_lapq[p_Nq];

    shared dfloat s_Ixxq[p_Nq][p_Nq],  s_Dxxq[p_Nq][p_Nq];
    shared dfloat s_IxDq[p_Nq][p_gNq], s_IxIq[p_Nq][p_gNq], s_DxIq[p_Nq][p_gNq];
    shared dfloat s_qr[p_gNq][p_gNq], s_qs[p_gNq][p_gNq], s_qt[p_gNq][p_gNq];
    shared dfloat s_Dqr[p_gNq][p_Nq], s_Iqs[p_gNq][p_Nq], s_Iqt[p_gNq][p_Nq];
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	int t = a + b*p_gNq;
	if(t<p_gNq*p_Nq){
	  s_D[0][t] = gD[t];
	  s_I[0][t] = gI[t];
	}
	
	for(int k=0;k<p_gNq;++k){
	  r_Iq[k] = 0;
	  r_Dq[k] = 0;
	}

	for(int c=0;c<p_Nq;++c){
	  r_lapq[c] = 0;
	}
      }
    }

    barrier(localMemFence);

    //  interpolate and differentiate in 't'
    for(int c=0;c<p_Nq;++c){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  if(a<p_Nq && b<p_Nq){
	    const dfloat qcba = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
	    for(int k=0;k<p_gNq;++k){
	      // I_{kc} q_{cba}
	      r_Iq[k] += s_I[k][c]*qcba;
	      r_Dq[k] += s_D[k][c]*qcba;
	    }
	  }
	}
      }
    }

    // scan through k slices
    for(int k=0;k<p_gNq;++k){

      barrier(localMemFence);

      // prefetch slice
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  
	  if(a<p_Nq && b<p_Nq){
	    s_Ixxq[b][a] = r_Iq[k];
	    s_Dxxq[b][a] = r_Dq[k];
	  }
	}
      }

      barrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_gNq;++b;inner1){
	for(int i=0;i<p_gNq;++i;inner0){

	  if(b<p_Nq){
	    dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	    
	    for(int a=0;a<p_Nq;++a){
	      IxDq += s_D[i][a]*s_Ixxq[b][a];
	      IxIq += s_I[i][a]*s_Ixxq[b][a];
	      DxIq += s_I[i][a]*s_Dxxq[b][a];
	    }

	    s_IxDq[b][i] = IxDq;
	    s_IxIq[b][i] = IxIq;
	    s_DxIq[b][i] = DxIq;
	  }
	}
      }
      
      barrier(localMemFence);

      for(int j=0;j<p_gNq;++j;inner1){
	for(int i=0;i<p_gNq;++i;inner0){

	  const iint base = e*p_Nggeo*p_gNp + k*p_gNq*p_gNq + j*p_gNq + i;
	  
	  // assumes w*J built into G entries
	  //	  const dfloat r_GwJ = gggeo[base+p_GWJID*p_gNp];
	  
	  const dfloat r_G00 = gggeo[base+p_G00ID*p_gNp];
	  const dfloat r_G01 = gggeo[base+p_G01ID*p_gNp];
	  const dfloat r_G02 = gggeo[base+p_G02ID*p_gNp];
	  
	  const dfloat r_G11 = gggeo[base+p_G11ID*p_gNp];
	  const dfloat r_G12 = gggeo[base+p_G12ID*p_gNp];
	  const dfloat r_G22 = gggeo[base+p_G22ID*p_gNp];
	  
	  dfloat qr = 0, qs = 0, qt = 0;

	  // interpolate and differentiate in 's' direction
	  for(int n=0;n<p_Nq;++n){
	    qr += s_I[j][n]*s_IxDq[n][i];
	    qs += s_D[j][n]*s_IxIq[n][i];
	    qt += s_I[j][n]*s_DxIq[n][i];
	  }

	  // apply chain rule
	  s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
	  s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
	  s_qt[j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
	}
      }
      
      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r' 
      for(int j=0;j<p_gNq;++j;inner1){
	for(int a=0;a<p_gNq;++a;inner0){

	  if(a<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int i=0;i<p_gNq;++i){
	      tmpr += s_D[i][a]*s_qr[j][i];
	      tmps += s_I[i][a]*s_qs[j][i];
	      tmpt += s_I[i][a]*s_qt[j][i];
	    }

	    s_Dqr[j][a] = tmpr;
	    s_Iqs[j][a] = tmps;
	    s_Iqt[j][a] = tmpt;
	  }
	}
      }

      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 's' 
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){

	  if(b<p_Nq && a<p_Nq) {
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int j=0;j<p_gNq;++j){
	      tmpr += s_I[j][b]*s_Dqr[j][a];
	      tmps += s_D[j][b]*s_Iqs[j][a];
	      tmpt += s_I[j][b]*s_Iqt[j][a];
	    }

	    // transpose differentiate and interpolate in 't'
	    for(int c=0;c<p_Nq;++c){
	      r_lapq[c] += s_I[k][c]*(tmpr+tmps);
	      r_lapq[c] += s_D[k][c]*tmpt;
	    }
	  }
	}
      }
    }

    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	
	if(a<p_Nq && b<p_Nq){ // bad 
	  for(int c=0;c<p_Nq;++c){
	    Aq[e*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
	  }
	}
      }
    }
  }
}
	  
/* note that the gggeo must be the geometric factors at the p_gNp integration nodes */
kernel void ellipticAxHex3D_e3(const int Nelements,
			       const dfloat * restrict gggeo, 
			       const dfloat * restrict gD,
			       const dfloat * restrict gI,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){  
  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
    shared dfloat s_D[p_gNq][p_Nq];
    shared dfloat s_I[p_gNq][p_Nq];

    exclusive dfloat r_Iq[p_gNq], r_Dq[p_gNq], r_lapq[p_Nq];
    //    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
    
    shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq],  s_Dxxq[p_NblockG][p_Nq][p_Nq];
    shared dfloat s_IxDq[p_NblockG][p_Nq][p_gNq], s_IxIq[p_NblockG][p_Nq][p_gNq], s_DxIq[p_NblockG][p_Nq][p_gNq];
    shared dfloat s_qr[p_NblockG][p_gNq][p_gNq], s_qs[p_NblockG][p_gNq][p_gNq], s_qt[p_NblockG][p_gNq][p_gNq];
    shared dfloat s_Dqr[p_NblockG][p_gNq][p_Nq], s_Iqs[p_NblockG][p_gNq][p_Nq], s_Iqt[p_NblockG][p_gNq][p_Nq];

    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  int t = a + b*p_gNq + es*p_gNq*p_gNq;
	  if(t<p_gNq*p_Nq){
	    s_D[0][t] = gD[t];
	    s_I[0][t] = gI[t];
	  }
	  
	  for(int k=0;k<p_gNq;++k){
	    r_Iq[k] = 0;
	    r_Dq[k] = 0;
	  }
	  
	  for(int c=0;c<p_Nq;++c){
	    r_lapq[c] = 0;
	  }
	}
      }
    }

    barrier(localMemFence);
    
    //  interpolate and differentiate in 't'

    for(int c=0;c<p_Nq;++c){
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    int t = a + b*p_gNq;
	    if(t<p_Nq*p_Nq){ // a<p_Nq && b<p_Nq){
	      int e = eo+es;
	      if(e<Nelements){
		const dfloat qcba = q[e*p_Np+c*p_Nq2+t];

		occaUnroll(p_gNq)
		  for(int k=0;k<p_gNq;++k){
		    // I_{kc} q_{cba}
		    r_Iq[k] += s_I[k][c]*qcba;
		    r_Dq[k] += s_D[k][c]*qcba;
		  }
	      }
	    }
	  }
	}
      }
    }


    // scan through k slices
    for(int k=0;k<p_gNq;++k){

      barrier(localMemFence);

      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){

	    int t = a+b*p_gNq;
	    if(t<p_Nq*p_Nq){
	      s_Ixxq[es][0][t] = r_Iq[k];
	      s_Dxxq[es][0][t] = r_Dq[k];
	    }
	  }
	}
      }

      barrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int i=0;i<p_gNq;++i;inner0){
	    
	    if(b<p_Nq){
	      dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	      
	      occaUnroll(p_Nq)
		for(int a=0;a<p_Nq;++a){
		  IxDq += s_D[i][a]*s_Ixxq[es][b][a];
		  IxIq += s_I[i][a]*s_Ixxq[es][b][a];
		  DxIq += s_I[i][a]*s_Dxxq[es][b][a];
		}
	      
	      s_IxDq[es][b][i] = IxDq;
	      s_IxIq[es][b][i] = IxIq;
	      s_DxIq[es][b][i] = DxIq;
	    }
	  }
	}
      }

      barrier(localMemFence);

      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gNq;++j;inner1){
	  for(int i=0;i<p_gNq;++i;inner0){
	    
	    int e = eo+es;
	    if(e<Nelements){

	      dfloat qr = 0, qs = 0, qt = 0;
	    
	      // interpolate and differentiate in 's' direction
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
		  qr += s_I[j][n]*s_IxDq[es][n][i];
		  qs += s_D[j][n]*s_IxIq[es][n][i];
		  qt += s_I[j][n]*s_DxIq[es][n][i];
		}

	      const iint base = e*p_Nggeo*p_gNp + k*p_gNq*p_gNq + j*p_gNq + i;
	      
	      // assumes w*J built into G entries
	      //	  const dfloat r_GwJ = gggeo[base+p_GWJID*p_gNp];
	      dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
	      r_G00 = gggeo[base+p_G00ID*p_gNp];
	      r_G01 = gggeo[base+p_G01ID*p_gNp];
	      r_G02 = gggeo[base+p_G02ID*p_gNp];
	      
	      r_G11 = gggeo[base+p_G11ID*p_gNp];
	      r_G12 = gggeo[base+p_G12ID*p_gNp];
	      r_G22 = gggeo[base+p_G22ID*p_gNp];
	      
	      // apply chain rule
	      s_qr[es][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
	      s_qs[es][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
	      s_qt[es][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
	    }
	  }
	}
      }

      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gNq;++j;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    
	    if(a<p_Nq){
	      dfloat tmpr = 0, tmps = 0, tmpt = 0;
	      occaUnroll(p_gNq)
		for(int i=0;i<p_gNq;++i){
		  tmpr += s_D[i][a]*s_qr[es][j][i];
		  tmps += s_I[i][a]*s_qs[es][j][i];
		  tmpt += s_I[i][a]*s_qt[es][j][i];
		}
	      
	      s_Dqr[es][j][a] = tmpr;
	      s_Iqs[es][j][a] = tmps;
	      s_Iqt[es][j][a] = tmpt;
	    }
	  }
	}
      }

      barrier(localMemFence);

      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    int t = a+p_gNq*b;
	    int ta = t%p_Nq; // need to know a,b for contiguous threads
	    int tb = t/p_Nq;
	    if(t<p_Nq*p_Nq){
	      dfloat tmpr = 0, tmps = 0, tmpt = 0;

	      occaUnroll(p_gNq)
		for(int j=0;j<p_gNq;++j){
		  tmpr += s_I[j][tb]*s_Dqr[es][j][ta];
		  tmps += s_D[j][tb]*s_Iqs[es][j][ta];
		  tmpt += s_I[j][tb]*s_Iqt[es][j][ta];
		}
	      
	      // transpose differentiate and interpolate in 't'
	      occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){
		  r_lapq[c] += s_I[k][c]*(tmpr+tmps);
		  r_lapq[c] += s_D[k][c]*tmpt;
		}
	    }
	  }
	}
      }
    }
    
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  int t = a+b*p_gNq;
	  if(t<p_Nq*p_Nq){
	    int e = eo+es;
	    if(e<Nelements){
	      for(int c=0;c<p_Nq;++c){
		Aq[e*p_Np + c*p_Nq2 + t] = r_lapq[c];
	      }
	    }
	  }
	}
      }
    }
  }
}

/* note that the gggeo must be the geometric factors at the p_gNp integration nodes */
kernel void ellipticPartialAxHex3D_e3(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gggeo, 
				      const dfloat * restrict gD,
				      const dfloat * restrict gI,
				      const dfloat   lambda,
				      const dfloat * restrict q,
				      dfloat * restrict Aq){  
  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
    volatile shared dfloat s_D[p_gNq][p_Nq];
    volatile shared dfloat s_I[p_gNq][p_Nq];

#if 1
    exclusive dfloat r_lapq[p_Nq];
#endif

    volatile shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq],  s_Dxxq[p_NblockG][p_Nq][p_Nq];
    volatile shared dfloat s_IxDq[p_NblockG][p_Nq][p_gNq], s_IxIq[p_NblockG][p_Nq][p_gNq], s_DxIq[p_NblockG][p_Nq][p_gNq];
    volatile shared dfloat s_qr[p_NblockG][p_gNq][p_gNq], s_qs[p_NblockG][p_gNq][p_gNq], s_qt[p_NblockG][p_gNq][p_gNq];
    volatile shared dfloat s_Dqr[p_NblockG][p_gNq][p_Nq], s_Iqs[p_NblockG][p_gNq][p_Nq], s_Iqt[p_NblockG][p_gNq][p_Nq];

    exclusive iint emap;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
    
    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  int t = a + b*p_gNq + es*p_gNq*p_gNq;
	  if(t<p_gNq*p_Nq){
	    s_D[0][t] = gD[t];
	    s_I[0][t] = gI[t];
	  }
	  
	  int e = eo+es;
	  if(e<Nelements)
	    emap = elementList[e];
	  else
	    emap = -999999;

#if 0
	  if(e<Nelements){
	    t = a+b*p_gNq;
	    while(t<p_Np){
	      Aq[emap*p_Np+t] = 0;
	      t+=p_gNq*p_gNq;
	    }
	  }
#else	  
	  for(int c=0;c<p_Nq;++c){
	    r_lapq[c] = 0;
	  }
#endif
	}
      }
    }

    // scan through k slices
    occaUnroll(p_gNq)
    for(int k=0;k<p_gNq;++k){

      optBarrier(localMemFence);
      
      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    int e = eo+es;
	    if(e<Nelements){

	      const iint base = emap*p_Nggeo*p_gNp + k*p_gNq*p_gNq + b*p_gNq + a;
	      
	      // assumes w*J built into G entries
	      //	  const dfloat r_GwJ = gggeo[base+p_GWJID*p_gNp];
	      //dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
	      r_G00 = gggeo[base+p_G00ID*p_gNp];
	      r_G01 = gggeo[base+p_G01ID*p_gNp];
	      r_G02 = gggeo[base+p_G02ID*p_gNp];
	      
	      r_G11 = gggeo[base+p_G11ID*p_gNp];
	      r_G12 = gggeo[base+p_G12ID*p_gNp];
	      r_G22 = gggeo[base+p_G22ID*p_gNp];

	      int t = a+b*p_gNq;
	      if(t<p_Nq*p_Nq){
		
		dfloat Iqk = 0, Dqk = 0;
		
		// puts more data in flight
		for(int c=0;c<p_Nq;++c){
		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+t];
		  // I_{kc} q_{cba}
		  Iqk += s_I[k][c]*qcba;
		  Dqk += s_D[k][c]*qcba;
		}
		s_Ixxq[es][0][t] = Iqk;
		s_Dxxq[es][0][t] = Dqk;
	      }
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int i=0;i<p_gNq;++i;inner0){
	    
	    if(es+eo<Nelements){

	      if(b<p_Nq){
		dfloat IxDq= 0, IxIq = 0, DxIq = 0;
		
		occaUnroll(p_Nq)
		  for(int a=0;a<p_Nq;++a){
		    IxDq += s_D[i][a]*s_Ixxq[es][b][a];
		    IxIq += s_I[i][a]*s_Ixxq[es][b][a];
		    DxIq += s_I[i][a]*s_Dxxq[es][b][a];
		  }
		
		s_IxDq[es][b][i] = IxDq;
		s_IxIq[es][b][i] = IxIq;
		s_DxIq[es][b][i] = DxIq;
	      }
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gNq;++j;inner1){
	  for(int i=0;i<p_gNq;++i;inner0){
	    
	    int e = eo+es;
	    if(e<Nelements){

	      dfloat qr = 0, qs = 0, qt = 0;
	    
	      // interpolate and differentiate in 's' direction
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
		  qr += s_I[j][n]*s_IxDq[es][n][i];
		  qs += s_D[j][n]*s_IxIq[es][n][i];
		  qt += s_I[j][n]*s_DxIq[es][n][i];
		}

	      // apply chain rule (notice the swtich of indices in i,j)
	      s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
	      s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
	      s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gNq;++j;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    
	    if(a<p_Nq){
	      dfloat tmpr = 0, tmps = 0, tmpt = 0;
	      occaUnroll(p_gNq)
		for(int i=0;i<p_gNq;++i){
		  tmpr += s_D[i][a]*s_qr[es][i][j];
		  tmps += s_I[i][a]*s_qs[es][i][j];
		  tmpt += s_I[i][a]*s_qt[es][i][j];
		}
	      
	      s_Dqr[es][j][a] = tmpr;
	      s_Iqs[es][j][a] = tmps;
	      s_Iqt[es][j][a] = tmpt;
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gNq;++b;inner1){
	  for(int a=0;a<p_gNq;++a;inner0){
	    const int e = eo+es;
	    if(e<Nelements){
	      if(a<p_Nq && b<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0;
		
		occaUnroll(p_gNq)
		  for(int j=0;j<p_gNq;++j){
		    tmpr += s_I[j][b]*s_Dqr[es][j][a];
		    tmps += s_D[j][b]*s_Iqs[es][j][a];
		    tmpt += s_I[j][b]*s_Iqt[es][j][a];
		  }
		
	      // transpose differentiate and interpolate in 't'
		occaUnroll(p_Nq)
		  for(int c=0;c<p_Nq;++c){
#if 1
		    r_lapq[c] += s_I[k][c]*(tmpr+tmps);
		    r_lapq[c] += s_D[k][c]*tmpt;
#else
		    Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] += s_I[k][c]*(tmpr+tmps) + s_D[k][c]*tmpt;
#endif
		  }
	      }
	    }
	  }
	}
      }
    }
    
#if 1
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  
	  if(a<p_Nq && b<p_Nq){
	    const int e = eo+es;
	    if(e<Nelements){
	      for(int c=0;c<p_Nq;++c){
		Aq[emap*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
	      }
	    }
	  }
	}
      }
    }
#endif
  }
}
	  


#if 0
/* note that the gggeo must be the geometric factors at the p_gNp integration nodes */
kernel void ellipticPartialAxHex3D_e4(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gggeo, 
				      const dfloat * restrict gD,
				      const dfloat * restrict gI,
				      const dfloat   lambda,
				      const dfloat * restrict q,
				      dfloat * restrict Aq){  
  
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_gNq][p_Nq];
    shared dfloat s_I[p_gNq][p_Nq];

    shared dfloat s_DT[p_Nq][p_gNq];
    shared dfloat s_IT[p_Nq][p_gNq];

    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_qr[p_gNq][p_gNq][p_gNq];
    shared dfloat s_qs[p_gNq][p_gNq][p_gNq];
    shared dfloat s_qt[p_gNq][p_gNq][p_gNq];

    shared dfloat s_qr2[p_Nq][p_gNq][p_gNq];
    shared dfloat s_qs2[p_Nq][p_gNq][p_gNq];
    shared dfloat s_qt2[p_Nq][p_gNq][p_gNq];
    
    exclusive iint emap;
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	int t = a + p_gNq*b;
	if(t<p_gNq*p_Nq){
	  s_D[0][t] = gD[t];
	  s_I[0][t] = gI[t];
	  s_DT[0][t] = gD[t];
	  s_IT[0][t] = gI[t];
	}
	
	emap = elementList[e];

	// coalesce reads (up to alignment)
	while(t<p_Np){ 
	  s_q[0][0][t] = q[emap*p_Np + t];
	  t+=p_gNq*p_gNq;
	}
      }
    }
    
    barrier(localMemFence);

    for(int c=0;c<p_Nq;++c){
      // interpolate in 'r'
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  if(b<p_Nq){	
	    dfloat resD = 0, resI = 0;
	    
	    occaUnroll(p_Nq)
	      for(int i=0;i<p_Nq;++i){
		resD += s_DT[i][a]*s_q[c][b][i];
		resI += s_IT[i][a]*s_q[c][b][i];
	      }
	    
	    s_qr[0][b][a] = resD;
	    s_qs[0][b][a] = resI;
	  }
	}
      }
      
      barrier(localMemFence);

      // interpolate in 's'
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  
	  dfloat resID = 0, resDI = 0, resII = 0;
	  
	  occaUnroll(p_Nq)
	    for(int j=0;j<p_Nq;++j){
	      resID += s_IT[j][b]*s_qr[0][j][a];
	      resII += s_IT[j][b]*s_qs[0][j][a];
	      resDI += s_DT[j][b]*s_qs[0][j][a];
	    }
	  
	  s_qr2[c][b][a] = resID;
	  s_qs2[c][b][a] = resDI;
	  s_qt2[c][b][a] = resII;
	}
      }
    }
    
    barrier(localMemFence);

    // interpolate in 't'
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	for(int c=0;c<p_gNq;++c){

	  const iint base = emap*p_Nggeo*p_gNp + c*p_gNq*p_gNq + b*p_gNq + a;
	  
	  dfloat resIID = 0, resIDI = 0, resDII = 0;
	  
	  occaUnroll(p_Nq)
	    for(int k=0;k<p_Nq;++k){

	      resIID += s_I[c][k]*s_qr2[k][b][a];
	      resIDI += s_I[c][k]*s_qs2[k][b][a];
	      resDII += s_D[c][k]*s_qt2[k][b][a];
	    }
	  
	  const dfloat r_G00 = gggeo[base+p_G00ID*p_gNp];
	  const dfloat r_G01 = gggeo[base+p_G01ID*p_gNp];
	  const dfloat r_G02 = gggeo[base+p_G02ID*p_gNp];
	  
	  const dfloat r_G11 = gggeo[base+p_G11ID*p_gNp];
	  const dfloat r_G12 = gggeo[base+p_G12ID*p_gNp];
	  const dfloat r_G22 = gggeo[base+p_G22ID*p_gNp];
	  
	  // apply chain rule
	  s_qr[c][b][a] = r_G00*resIID + r_G01*resIDI + r_G02*resDII;
	  s_qs[c][b][a] = r_G01*resIID + r_G11*resIDI + r_G12*resDII;
	  s_qt[c][b][a] = r_G02*resIID + r_G12*resIDI + r_G22*resDII;
	  
	}
      }
    }

    barrier(localMemFence);

    // interpolate in 't'
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	for(int c=0;c<p_Nq;++c){
	  dfloat resr = 0, ress = 0, rest = 0;
	  
	  occaUnroll(p_gNq)
	    for(int k=0;k<p_gNq;++k){
	      resr += s_I[k][c]*s_qr[k][b][a];
	      ress += s_I[k][c]*s_qs[k][b][a];
	      rest += s_D[k][c]*s_qt[k][b][a];
	    }
	  
	  s_qr2[c][b][a] = resr;
	  s_qs2[c][b][a] = ress;
	  s_qt2[c][b][a] = rest;
	}
      }
    }

    barrier(localMemFence);

    for(int c=0;c<p_Nq;++c){
      
      // interpolate in 's'
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  if(b<p_Nq){
	    
	    dfloat resr = 0, ress = 0, rest = 0;
	    
	    occaUnroll(p_gNq)
	      for(int j=0;j<p_gNq;++j){
		resr += s_I[j][b]*s_qr2[c][j][a];
		rest += s_I[j][b]*s_qt2[c][j][a];
		ress += s_D[j][b]*s_qs2[c][j][a];
	      }
	    s_qr[0][b][a] = resr;
	    s_qs[0][b][a] = ress;
	    s_qt[0][b][a] = rest;
	  }
	}
      }
      
      barrier(localMemFence);
      
      // interpolate in 'r'
      for(int b=0;b<p_gNq;++b;inner1){
	for(int a=0;a<p_gNq;++a;inner0){
	  
	  if(b<p_Nq && a<p_Nq){
	    
	    dfloat resr = 0, ress = 0, rest = 0;
	    
	    occaUnroll(p_gNq)
	      for(int i=0;i<p_gNq;++i){
		resr += s_D[i][a]*s_qr[0][b][i];
		ress += s_I[i][a]*s_qs[0][b][i];
		rest += s_I[i][a]*s_qt[0][b][i];
	      }
	    
	    s_q[0][0][a+b*p_Nq+c*p_Nq*p_Nq] = resr+ress+rest;
	  }
	}
      }
    }
    
    barrier(localMemFence);
    
    for(int b=0;b<p_gNq;++b;inner1){
      for(int a=0;a<p_gNq;++a;inner0){
	iint t = a+b*p_gNq;
	while(t<p_Np){ 
	  Aq[emap*p_Np + t] = s_q[0][0][t];
	  t+=p_gNq*p_gNq;
	} 
      }	
    }
  }
}

#endif
