
// hex kernel for screened coulomb potential mat-vec
#define cubeThreads				\
  for(iint k=0; k<p_Nq; ++k; inner2)		\
    for(iint j=0; j<p_Nq; ++j; inner1)		\
      for(iint i=0; i<p_Nq; ++i; inner0)


// cube thread version
kernel void ellipticAxHex3D_e0(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    
    // prefetch q(:,:,:,e) to shared
    cubeThreads{
      const iint base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np; 
      
      s_q[k][j][i] = q[base];
      
      if(k==0) // fetch D to shared
	s_D[j][i] = D[j*p_Nq+i];
    }
      
    barrier(localMemFence);

    cubeThreads{
      
      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];
      
      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;
      
      for(iint n=0; n<p_Nq; ++n){
	qr += s_D[i][n]*s_q[k][j][n];
	qs += s_D[j][n]*s_q[k][n][i];
	qt += s_D[k][n]*s_q[n][j][i];
      }
      
      r_qr = qr; r_qs = qs; r_qt = qt;
      
      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      iint base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}



// i-j sliced version
kernel void ellipticAxHex3D_e1(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
      
    // prefetch q(i,j,:,e) to register array
    for(iint es=0; es<p_NblockV; ++es; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  const iint e = eo + es;

	  if(e<Nelements){
	    const iint base = i + j*p_Nq + e*p_Np; 
	    
	    for(iint k=0;k<p_Nq;++k){
	      r_q[k] = q[base + k*p_Nq*p_Nq];
	      r_Aq[k] = 0.f;
	    }
	  }
	  
	  if(es==0) // fetch D to shared
	    s_D[j][i] = D[j*p_Nq+i];
	  
	}
      }
    }
      
    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
	
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      // share k-slice of q 
	      s_q[es][j][i] = r_q[k];
	      
	      // hide shared latency behind t-derivative
	      dfloat qtk = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qtk += s_D[k][n]*r_q[n];
	      }
	      r_qt = qtk;
	      
	    }
	  }
	}
      }

      barrier(localMemFence);

      // process k-slice (first r- and s-derivatives)
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){
	      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qr += s_D[i][n]*s_q[es][j][n];
		qs += s_D[j][n]*s_q[es][n][i];
	      }

	      // assumes w*J built into G entries
	      s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
	      s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
	      r_tmpt           = G02*qr + G12*qs + G22*r_qt;

	      r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
	      for(iint n=0;n<p_Nq;++n){
		r_Aq[n] += s_D[k][n]*r_tmpt;
	      }
#endif
	    }
	  }
	}
      }
    
      barrier(localMemFence);

      // second derivatives
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      dfloat Aq1 = 0.0f, Aq2 = 0.0f;

	      for(iint n=0;n<p_Nq;++n){
		Aq1 += s_D[n][i]*s_tmpr[es][j][n];
		Aq2 += s_D[n][j]*s_tmps[es][n][i];
	      }
#if 1
	      r_Aq[k] +=  Aq1 + Aq2;
#endif  
	    }
	  }
	}
      }
    }

    // write result out (local node storage)
    for(iint es=0;es<p_NblockV;++es;inner2){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){
	  const iint e = eo + es;
	  if(e<Nelements){
	    iint base = e*p_Np + j*p_Nq + i;
	    for(iint k=0;k<p_Nq;++k){
	      Aq[base] = r_Aq[k];
	      base+=p_Nq*p_Nq;
	    }
	  }
	}
      }
    }
  }
}

