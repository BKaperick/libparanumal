
#if 0
__constant__ dfloat c_D[10][9] = { 
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9}	
};

__constant__ dfloat c_I[10][9] = { 
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},
  {.1, .2, .3, .4, .5, .6, .7, .8, .9},	
  {.1, .2, .3, .4, .5, .6, .7, .8, .9}		
};
#endif

// hex kernel for screened coulomb potential mat-vec
#define cubeThreads				\
  for(iint k=0; k<p_Nq; ++k; inner2)		\
    for(iint j=0; j<p_Nq; ++j; inner1)		\
      for(iint i=0; i<p_Nq; ++i; inner0)


// cube thread version
kernel void ellipticAxHex3D_e0(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_qr, r_qs, r_qt, r_Aq;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
    
    // prefetch q(:,:,:,e) to shared
    cubeThreads{
      const iint base = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np; 
      
      s_q[k][j][i] = q[base];
      
      if(k==0) // fetch D to shared
	s_D[j][i] = D[j*p_Nq+i];
    }
      
    barrier(localMemFence);

    cubeThreads{
      
      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

      // assumes w*J built into G entries
      r_GwJ = ggeo[base+p_GWJID*p_Np];

      r_G00 = ggeo[base+p_G00ID*p_Np];
      r_G01 = ggeo[base+p_G01ID*p_Np];
      r_G02 = ggeo[base+p_G02ID*p_Np];
      
      r_G11 = ggeo[base+p_G11ID*p_Np];
      r_G12 = ggeo[base+p_G12ID*p_Np];
      r_G22 = ggeo[base+p_G22ID*p_Np];

      dfloat qr = 0.f, qs = 0.f, qt = 0.f;
      
      for(iint n=0; n<p_Nq; ++n){
	qr += s_D[i][n]*s_q[k][j][n];
	qs += s_D[j][n]*s_q[k][n][i];
	qt += s_D[k][n]*s_q[n][j][i];
      }
      
      r_qr = qr; r_qs = qs; r_qt = qt;
      
      r_Aq = r_GwJ*lambda*s_q[k][j][i];
    }

    // r term ----->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G00*r_qr + r_G01*r_qs + r_G02*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][i]*s_q[k][j][n];

      r_Aq += tmp;
    }

    // s term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G01*r_qr + r_G11*r_qs + r_G12*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][j]*s_q[k][n][i];

      r_Aq += tmp;
    }

    // t term ---->
    barrier(localMemFence);

    cubeThreads{
      s_q[k][j][i] = r_G02*r_qr + r_G12*r_qs + r_G22*r_qt;
    }
    
    barrier(localMemFence);

    cubeThreads{
      dfloat tmp = 0.f;
      for(iint n=0;n<p_Nq;++n)
	tmp += s_D[n][k]*s_q[n][j][i];

      r_Aq += tmp;

      iint base = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
      Aq[base] = r_Aq;
    }
  }
}



// i-j sliced version
kernel void ellipticAxHex3D_e1(const iint     Nelements,
			       const dfloat * restrict ggeo,
			       const dfloat * restrict D,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_tmpr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_tmps[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_q[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
      
    // prefetch q(i,j,:,e) to register array
    for(iint es=0; es<p_NblockV; ++es; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  const iint e = eo + es;

	  if(e<Nelements){
	    const iint base = i + j*p_Nq + e*p_Np; 
	    
	    for(iint k=0;k<p_Nq;++k){
	      r_q[k] = q[base + k*p_Nq*p_Nq];
	      r_Aq[k] = 0.f;
	    }
	  }
	  
	  if(es==0) // fetch D to shared
	    s_D[j][i] = D[j*p_Nq+i];
	  
	}
      }
    }
      
    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
	
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      // share k-slice of q 
	      s_q[es][j][i] = r_q[k];
	      
	      // hide shared latency behind t-derivative
	      dfloat qtk = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qtk += s_D[k][n]*r_q[n];
	      }
	      r_qt = qtk;
	      
	    }
	  }
	}
      }

      barrier(localMemFence);

      // process k-slice (first r- and s-derivatives)
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){
	      const iint base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0;n<p_Nq;++n){
		qr += s_D[i][n]*s_q[es][j][n];
		qs += s_D[j][n]*s_q[es][n][i];
	      }

	      // assumes w*J built into G entries
	      s_tmpr[es][j][i] = G00*qr + G01*qs + G02*r_qt;
	      s_tmps[es][j][i] = G01*qr + G11*qs + G12*r_qt;
	      r_tmpt           = G02*qr + G12*qs + G22*r_qt;

	      r_Aq[k] += GwJ*lambda*r_q[k];

#if 1
	      for(iint n=0;n<p_Nq;++n){
		r_Aq[n] += s_D[k][n]*r_tmpt;
	      }
#endif
	    }
	  }
	}
      }
    
      barrier(localMemFence);

      // second derivatives
      for(iint es=0;es<p_NblockV;++es;inner2){
	for(iint j=0;j<p_Nq;++j;inner1){
	  for(iint i=0;i<p_Nq;++i;inner0){
	    const iint e = eo + es;
	    if(e<Nelements){

	      dfloat Aq1 = 0.0f, Aq2 = 0.0f;

	      for(iint n=0;n<p_Nq;++n){
		Aq1 += s_D[n][i]*s_tmpr[es][j][n];
		Aq2 += s_D[n][j]*s_tmps[es][n][i];
	      }
#if 1
	      r_Aq[k] +=  Aq1 + Aq2;
#endif  
	    }
	  }
	}
      }
    }

    // write result out (local node storage)
    for(iint es=0;es<p_NblockV;++es;inner2){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){
	  const iint e = eo + es;
	  if(e<Nelements){
	    iint base = e*p_Np + j*p_Nq + i;
	    for(iint k=0;k<p_Nq;++k){
	      Aq[base] = r_Aq[k];
	      base+=p_Nq*p_Nq;
	    }
	  }
	}
      }
    }
  }
}


/*
  I = interp;
  D = diff and interp;
  
  qr_{kji} =  I_{jb} D_{ia} I_{kc} q_{cba};
  qs_{kji} =  D_{jb} I_{ia} I_{kc} q_{cba};
  qt_{kji} =  I_{jb} I_{ia} D_{kc} q_{cba};
  
  w*J*G*grad q = WJG*[qr;qs;qt];
  
  lap_{cba} = 
  I_{ck} I_{bj} D_{ai} qr_{kji} + 
  I_{ck} D_{bj} I_{ai} qs_{kji} + 
  D_{ck} I_{bj} I_{ai} qt_{kji} ;
*/

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

#if ((p_NblockG*p_gjNq*p_gjNq)<=32)
#define optBarrier(op) 
#else
#define optBarrier(op) barrier(op)
#endif


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticAxHex3D_e2(const int Nelements,
			       const dfloat * restrict gjGeo, 
			       const dfloat * restrict gjD,
			       const dfloat * restrict gjI,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){  

  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_gjNq][p_Nq];
    shared dfloat s_I[p_gjNq][p_Nq];

    exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];

    shared dfloat s_Ixxq[p_Nq][p_Nq],  s_Dxxq[p_Nq][p_Nq];
    shared dfloat s_IxDq[p_Nq][p_gjNq], s_IxIq[p_Nq][p_gjNq], s_DxIq[p_Nq][p_gjNq];
    shared dfloat s_qr[p_gjNq][p_gjNq], s_qs[p_gjNq][p_gjNq], s_qt[p_gjNq][p_gjNq];
    shared dfloat s_Dqr[p_gjNq][p_Nq], s_Iqs[p_gjNq][p_Nq], s_Iqt[p_gjNq][p_Nq];
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	int t = a + b*p_gjNq;
	if(t<p_gjNq*p_Nq){
	  s_D[0][t] = gjD[t];
	  s_I[0][t] = gjI[t];
	}
	
	for(int k=0;k<p_gjNq;++k){
	  r_Iq[k] = 0;
	  r_Dq[k] = 0;
	}

	for(int c=0;c<p_Nq;++c){
	  r_lapq[c] = 0;
	}
      }
    }

    barrier(localMemFence);

    //  interpolate and differentiate in 't'
    for(int c=0;c<p_Nq;++c){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  if(a<p_Nq && b<p_Nq){
	    const dfloat qcba = q[e*p_Np+c*p_Nq2+b*p_Nq+a];
	    for(int k=0;k<p_gjNq;++k){
	      // I_{kc} q_{cba}
	      r_Iq[k] += s_I[k][c]*qcba;
	      r_Dq[k] += s_D[k][c]*qcba;
	    }
	  }
	}
      }
    }

    // scan through k slices
    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      // prefetch slice
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  
	  if(a<p_Nq && b<p_Nq){
	    s_Ixxq[b][a] = r_Iq[k];
	    s_Dxxq[b][a] = r_Dq[k];
	  }
	}
      }

      barrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){

	  if(b<p_Nq){
	    dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	    
	    for(int a=0;a<p_Nq;++a){
	      IxDq += s_D[i][a]*s_Ixxq[b][a];
	      IxIq += s_I[i][a]*s_Ixxq[b][a];
	      DxIq += s_I[i][a]*s_Dxxq[b][a];
	    }

	    s_IxDq[b][i] = IxDq;
	    s_IxIq[b][i] = IxIq;
	    s_DxIq[b][i] = DxIq;
	  }
	}
      }
      
      barrier(localMemFence);

      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){

	  const iint base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  
	  // assumes w*J built into G entries
	  //	  const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
	  
	  const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	  const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	  const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	  
	  const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	  const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	  const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];
	  
	  dfloat qr = 0, qs = 0, qt = 0;

	  // interpolate and differentiate in 's' direction
	  for(int n=0;n<p_Nq;++n){
	    qr += s_I[j][n]*s_IxDq[n][i];
	    qs += s_D[j][n]*s_IxIq[n][i];
	    qt += s_I[j][n]*s_DxIq[n][i];
	  }

	  // apply chain rule
	  s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
	  s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
	  s_qt[j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
	}
      }
      
      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r' 
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){

	  if(a<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int i=0;i<p_gjNq;++i){
	      tmpr += s_D[i][a]*s_qr[j][i];
	      tmps += s_I[i][a]*s_qs[j][i];
	      tmpt += s_I[i][a]*s_qt[j][i];
	    }

	    s_Dqr[j][a] = tmpr;
	    s_Iqs[j][a] = tmps;
	    s_Iqt[j][a] = tmpt;
	  }
	}
      }

      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 's' 
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){

	  if(b<p_Nq && a<p_Nq) {
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    for(int j=0;j<p_gjNq;++j){
	      tmpr += s_I[j][b]*s_Dqr[j][a];
	      tmps += s_D[j][b]*s_Iqs[j][a];
	      tmpt += s_I[j][b]*s_Iqt[j][a];
	    }

	    // transpose differentiate and interpolate in 't'
	    for(int c=0;c<p_Nq;++c){
	      r_lapq[c] += s_I[k][c]*(tmpr+tmps);
	      r_lapq[c] += s_D[k][c]*tmpt;
	    }
	  }
	}
      }
    }

    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	
	if(a<p_Nq && b<p_Nq){ // bad 
	  for(int c=0;c<p_Nq;++c){
	    Aq[e*p_Np + c*p_Nq2 + b*p_Nq + a] = r_lapq[c];
	  }
	}
      }
    }
  }
}
	  
/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticAxHex3D_e3(const int Nelements,
			       const dfloat * restrict gjGeo, 
			       const dfloat * restrict gjD,
			       const dfloat * restrict gjI,
			       const dfloat   lambda,
			       const dfloat * restrict q,
			       dfloat * restrict Aq){  
  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
    shared dfloat s_D[p_gjNq][p_Nq];
    shared dfloat s_I[p_gjNq][p_Nq];

    exclusive dfloat r_Iq[p_gjNq], r_Dq[p_gjNq], r_lapq[p_Nq];
    //    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
    
    shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq],  s_Dxxq[p_NblockG][p_Nq][p_Nq];
    shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq], s_IxIq[p_NblockG][p_Nq][p_gjNq], s_DxIq[p_NblockG][p_Nq][p_gjNq];
    shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq], s_qs[p_NblockG][p_gjNq][p_gjNq], s_qt[p_NblockG][p_gjNq][p_gjNq];
    shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq], s_Iqs[p_NblockG][p_gjNq][p_Nq], s_Iqt[p_NblockG][p_gjNq][p_Nq];

    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
	  if(t<p_gjNq*p_Nq){
	    s_D[0][t] = gjD[t];
	    s_I[0][t] = gjI[t];
	  }
	  
	  for(int k=0;k<p_gjNq;++k){
	    r_Iq[k] = 0;
	    r_Dq[k] = 0;
	  }
	  
	  for(int c=0;c<p_Nq;++c){
	    r_lapq[c] = 0;
	  }
	}
      }
    }

    barrier(localMemFence);
    
    //  interpolate and differentiate in 't'

    for(int c=0;c<p_Nq;++c){
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    int t = a + b*p_gjNq;
	    if(t<p_Nq*p_Nq){ // a<p_Nq && b<p_Nq){
	      int e = eo+es;
	      if(e<Nelements){
		const dfloat qcba = q[e*p_Np+c*p_Nq2+t];

		occaUnroll(p_gjNq)
		  for(int k=0;k<p_gjNq;++k){
		    // I_{kc} q_{cba}
		    r_Iq[k] += s_I[k][c]*qcba;
		    r_Dq[k] += s_D[k][c]*qcba;
		  }
	      }
	    }
	  }
	}
      }
    }


    // scan through k slices
    for(int k=0;k<p_gjNq;++k){

      barrier(localMemFence);

      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){

	    int t = a+b*p_gjNq;
	    if(t<p_Nq*p_Nq){
	      s_Ixxq[es][0][t] = r_Iq[k];
	      s_Dxxq[es][0][t] = r_Dq[k];
	    }
	  }
	}
      }

      barrier(localMemFence);

      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	    
	    if(b<p_Nq){
	      dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	      
	      occaUnroll(p_Nq)
		for(int a=0;a<p_Nq;++a){
		  IxDq += s_D[i][a]*s_Ixxq[es][b][a];
		  IxIq += s_I[i][a]*s_Ixxq[es][b][a];
		  DxIq += s_I[i][a]*s_Dxxq[es][b][a];
		}
	      
	      s_IxDq[es][b][i] = IxDq;
	      s_IxIq[es][b][i] = IxIq;
	      s_DxIq[es][b][i] = DxIq;
	    }
	  }
	}
      }

      barrier(localMemFence);

      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	    
	    int e = eo+es;
	    if(e<Nelements){

	      dfloat qr = 0, qs = 0, qt = 0;
	    
	      // interpolate and differentiate in 's' direction
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
		  qr += s_I[j][n]*s_IxDq[es][n][i];
		  qs += s_D[j][n]*s_IxIq[es][n][i];
		  qt += s_I[j][n]*s_DxIq[es][n][i];
		}

	      const iint base = e*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
	      
	      // assumes w*J built into G entries
	      //	      dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
	      dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
	      r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	      r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	      r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	      
	      r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	      r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	      r_G22 = gjGeo[base+p_G22ID*p_gjNp];
	      
	      // apply chain rule
	      s_qr[es][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
	      s_qs[es][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
	      s_qt[es][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
	    }
	  }
	}
      }

      barrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    
	    if(a<p_Nq){
	      dfloat tmpr = 0, tmps = 0, tmpt = 0;
	      occaUnroll(p_gjNq)
		for(int i=0;i<p_gjNq;++i){
		  tmpr += s_D[i][a]*s_qr[es][j][i];
		  tmps += s_I[i][a]*s_qs[es][j][i];
		  tmpt += s_I[i][a]*s_qt[es][j][i];
		}
	      
	      s_Dqr[es][j][a] = tmpr;
	      s_Iqs[es][j][a] = tmps;
	      s_Iqt[es][j][a] = tmpt;
	    }
	  }
	}
      }

      barrier(localMemFence);

      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    int t = a+p_gjNq*b;
	    int ta = t%p_Nq; // need to know a,b for contiguous threads
	    int tb = t/p_Nq;
	    if(t<p_Nq*p_Nq){
	      dfloat tmpr = 0, tmps = 0, tmpt = 0;

	      occaUnroll(p_gjNq)
		for(int j=0;j<p_gjNq;++j){
		  tmpr += s_I[j][tb]*s_Dqr[es][j][ta];
		  tmps += s_D[j][tb]*s_Iqs[es][j][ta];
		  tmpt += s_I[j][tb]*s_Iqt[es][j][ta];
		}
	      
	      // transpose differentiate and interpolate in 't'
	      occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){
		  r_lapq[c] += s_I[k][c]*(tmpr+tmps);
		  r_lapq[c] += s_D[k][c]*tmpt;
		}
	    }
	  }
	}
      }
    }
    
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  int t = a+b*p_gjNq;
	  if(t<p_Nq*p_Nq){
	    int e = eo+es;
	    if(e<Nelements){
	      for(int c=0;c<p_Nq;++c){
		Aq[e*p_Np + c*p_Nq2 + t] = r_lapq[c];
	      }
	    }
	  }
	}
      }
    }
  }
}

#define p_Nthreads  (p_NblockG*p_gjNq*p_gjNq)

#define allThreads				\
  for(int es=0;es<p_NblockG;++es;inner2)	\
    for(int b=0;b<p_gjNq;++b;inner1)		\
      for(int a=0;a<p_gjNq;++a;inner0)			


#if p_gNq==8 || p_gNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxHex3D_e3(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gjGeo, 
				      const dfloat * restrict gjD,
				      const dfloat * restrict gjI,
				      const dfloat   lambda,
				      const dfloat * restrict q,
				      dfloat * restrict Aq,
				      dfloat * restrict qAq){  

  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
     shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
     shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

     shared dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
     shared dfloat s_IT[p_Nq][p_gjNq+p_gllPad];
    
    exclusive dfloat r_q[p_Nq];
    exclusive dfloat r_lapq[p_Nq];

     shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
     shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
     shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
     shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
     shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
     shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
     shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
     shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
     shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
     shared dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
     shared dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];
#else
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
#endif

     shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    
    exclusive iint emap;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;	      
    
    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
	  
	  if(t<p_gjNq*p_Nq){
	    const iint tb = t/p_Nq;
	    const iint ta = t%p_Nq;
#if 1
	    s_D[tb][ta] = gjD[t];
	    s_I[tb][ta] = gjI[t];
	    s_DT[ta][tb] = gjD[t];
	    s_IT[ta][tb] = gjI[t];
#endif

	  }

	  for(int c=0;c<p_Nq;++c){
	    r_q[c] = 0;
	    r_lapq[c] = 0;
	  }

	  int e = eo+es;
	  if(e<Nelements){
	    emap = elementList[e];

	    if(a<p_Nq && b<p_Nq){

	      occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){
		  r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
		}
	    }

	  }
	  else
	    emap = -999999;
	  
	}
      }
    }
    
    // scan through k slices

    for(int k=0;k<p_gjNq;++k){
	
      optBarrier(localMemFence);
      
      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){

	    if(eo+es<Nelements){

	      const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

	      r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
	      r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	      r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	      r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	      
	      // assumes w*J built into G entries
	      //dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;

	      if(a<p_Nq && b<p_Nq){
		
		dfloat Iqk = 0, Dqk = 0;
		
		// puts more data in flight
		for(int c=0;c<p_Nq;++c){
		  const dfloat qcba = r_q[c]; 
		  //		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
		  // I_{kc} q_{cba}
#if 1
		  Iqk += s_I[k][c]*qcba;
		  Dqk += s_D[k][c]*qcba;
#else
		  Iqk += c_I[k][c]*qcba;
		  Dqk += c_D[k][c]*qcba;
#endif
		}
		s_Ixxq[es][b][a] = Iqk;
		s_Dxxq[es][b][a] = Dqk;
	      }
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	      
	    if(es+eo<Nelements){

	      if(b<p_Nq){
		dfloat IxDq= 0, IxIq = 0, DxIq = 0;
		  
		//		occaUnroll(p_Nq)
		  for(int a=0;a<p_Nq;++a){
#if 1
		    const dfloat Iia = s_I[i][a];
		    const dfloat Dia = s_D[i][a];
		    const dfloat Ixxqba = s_Ixxq[es][b][a];
		    IxDq += Dia*Ixxqba;
		    IxIq += Iia*Ixxqba;
		    DxIq += Iia*s_Dxxq[es][b][a];
#else
		    IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
		    IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
		    DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
		  }
		  
		s_IxDq[es][b][i] = IxDq;
		s_IxIq[es][b][i] = IxIq;
		s_DxIq[es][b][i] = DxIq;
	      }
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	      
	    if(eo+es<Nelements){

      
	      dfloat qr = 0, qs = 0, qt = 0, qI = 0;
		
	      // interpolate and differentiate in 's' direction
	      //	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
#if 0
		  const dfloat Ijn = s_I[j][n];
		  const dfloat Djn = s_D[j][n];
		  qr += Ijn*s_IxDq[es][n][i];
		  qt += Ijn*s_DxIq[es][n][i];
		  qI += Ijn*s_IxIq[es][n][i];
		  qs += Djn*s_IxIq[es][n][i];
		  
#else
		  const dfloat Ijn = s_IT[n][j];
		  const dfloat Djn = s_DT[n][j];
		  const dfloat IxIqni = s_IxIq[es][n][i];
		  qr += Ijn*s_IxDq[es][n][i];
		  qt += Ijn*s_DxIq[es][n][i];
		  qI += Ijn*IxIqni;
		  qs += Djn*IxIqni;

#endif
		}

	      const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
	      
	      r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	      r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	      r_G22 = gjGeo[base+p_G22ID*p_gjNp];
	      
	      // apply chain rule (notice the swtich of indices in i,j)
	      s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
	      s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
	      s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
	      s_qI[es][i][j] = r_GwJ*qI*lambda;
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	      
	    if(eo+es<Nelements){
	      if(a<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
		//		occaUnroll(p_gjNq)
		  for(int i=0;i<p_gjNq;++i){
#if 1
		    const dfloat Iia = s_I[i][a];
		    const dfloat Dia = s_D[i][a];
		    tmpr += Dia*s_qr[es][i][j];
		    tmps += Iia*s_qs[es][i][j];
		    tmpt += Iia*s_qt[es][i][j];
		    tmpI += Iia*s_qI[es][i][j];
#else
		    tmpr += s_DT[a][i]*s_qr[es][i][j];
		    tmps += s_IT[a][i]*s_qs[es][i][j];
		    tmpt += s_IT[a][i]*s_qt[es][i][j];
		    tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
		  }
		

		s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
		s_Iqs[es][j][a] = tmps;
		s_Iqt[es][j][a] = tmpt;
	      }
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    if(eo+es<Nelements){
	      if(a<p_Nq && b<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0;
		
		//		occaUnroll(p_gjNq)
		  for(int j=0;j<p_gjNq;++j){
#if 1
		    const dfloat Ijb = s_I[j][b];
		    const dfloat Djb = s_D[j][b];

		    tmpr += Ijb*s_Dqr[es][j][a];
		    tmps += Djb*s_Iqs[es][j][a];
		    tmpt += Ijb*s_Iqt[es][j][a];

#else
		    tmpr += s_IT[b][j]*s_Dqr[es][j][a];
		    tmps += s_DT[b][j]*s_Iqs[es][j][a];
		    tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
		  }
		
		// transpose differentiate and interpolate in 't'
		  tmpr += tmps; // blend r and s
		  //		  occaUnroll(p_Nq)
		  for(int c=0;c<p_Nq;++c){
#if 1
		    r_lapq[c] += s_I[k][c]*tmpr;
		    r_lapq[c] += s_D[k][c]*tmpt;
#else
		    r_lapq[c] += c_I[k][c]*tmpr;
		    r_lapq[c] += c_D[k][c]*tmpt;
#endif
		  }
	      }
	    }
	  }
	}
      }
    }
  
    optBarrier(localMemFence);
    
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){

	  dfloat r_qAq = 0;

	  if(a<p_Nq && b<p_Nq){
	    if(eo+es<Nelements){
	      occaUnroll(p_Nq)
	      for(int c=0;c<p_Nq;++c){
		const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
		Aq[id] = r_lapq[c];
	      }
	    }
	  }
	}
      }
    }
  }
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxReductionHex3D_e3(const iint Nelements,
					       const iint * restrict elementList,
					       const dfloat * restrict gjGeo, 
					       const dfloat * restrict gjD,
					       const dfloat * restrict gjI,
					       const dfloat   lambda,
					       const dfloat * restrict q,
					       dfloat * restrict Aq,
					       dfloat * restrict qAq){  
  
  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
    volatile shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
    volatile shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
#if 0
    volatile shared dfloat s_DT[p_Nq][p_gjNq];
    volatile shared dfloat s_IT[p_Nq][p_gjNq];
#endif
    
    exclusive dfloat r_q[p_Nq];
    exclusive dfloat r_lapq[p_Nq];

    volatile shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
    volatile shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
    volatile shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    //    volatile shared dfloat s_Dqr[p_NblockG][p_Nq][p_gjNq], s_Iqs[p_NblockG][p_Nq][p_gjNq], s_Iqt[p_NblockG][p_Nq][p_gjNq];
#if 1
    volatile shared dfloat s_red[p_NblockG*p_gjNq*p_gjNq];
#endif
    volatile shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

#if 1
#define s_Dqr s_IxDq
#define s_Iqs s_IxIq
#define s_Iqt s_DxIq
    //#define s_red s_qr[0][0]

#endif
    
    exclusive iint emap, thread;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;	      
    
    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
	  
	  if(t<p_gjNq*p_Nq){
	    const iint tb = t/p_Nq;
	    const iint ta = t%p_Nq;
	    s_D[tb][ta] = gjD[t];
	    s_I[tb][ta] = gjI[t];
#if 0
	    s_DT[0][t] = gjD[t];
	    s_IT[0][t] = gjI[t];
#endif
	  }

	  for(int c=0;c<p_Nq;++c){
	    r_q[c] = 0;
	    r_lapq[c] = 0;
	  }

	  int e = eo+es;
	  if(e<Nelements){
	    emap = elementList[e];
#if 1
	    if(a<p_Nq && b<p_Nq){
	      for(int c=0;c<p_Nq;++c){
		r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
	      }
	    }
#endif
	  }
	  else
	    emap = -999999;
	  
	}
      }
    }
    
    // scan through k slices

    //    occaUnroll(p_gjNq)
    for(int k=0;k<p_gjNq;++k){
	
      optBarrier(localMemFence);
      
      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    if(eo+es<Nelements){
		
	      // assumes w*J built into G entries
	      //dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
	      const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

	      r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

	      r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	      r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	      r_G02 = gjGeo[base+p_G02ID*p_gjNp];
		
	      r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	      r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	      r_G22 = gjGeo[base+p_G22ID*p_gjNp];
		
	      if(a<p_Nq && b<p_Nq){
		
		dfloat Iqk = 0, Dqk = 0;
		
		// puts more data in flight
		for(int c=0;c<p_Nq;++c){
		  const dfloat qcba = r_q[c]; 
		  //		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
		  // I_{kc} q_{cba}
#if 1
		  Iqk += s_I[k][c]*qcba;
		  Dqk += s_D[k][c]*qcba;
#else
		  Iqk += c_I[k][c]*qcba;
		  Dqk += c_D[k][c]*qcba;
#endif
		}
		s_Ixxq[es][b][a] = Iqk;
		s_Dxxq[es][b][a] = Dqk;
	      }
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	      
	    if(es+eo<Nelements){
		
	      if(b<p_Nq){
		dfloat IxDq= 0, IxIq = 0, DxIq = 0;
		  
		occaUnroll(p_Nq)
		  for(int a=0;a<p_Nq;++a){
#if 1
		    IxDq += s_D[i][a]*s_Ixxq[es][b][a];
		    IxIq += s_I[i][a]*s_Ixxq[es][b][a];
		    DxIq += s_I[i][a]*s_Dxxq[es][b][a];
#else
		    IxDq += s_DT[a][i]*s_Ixxq[es][b][a];
		    IxIq += s_IT[a][i]*s_Ixxq[es][b][a];
		    DxIq += s_IT[a][i]*s_Dxxq[es][b][a];
#endif
		  }
		  
		s_IxDq[es][b][i] = IxDq;
		s_IxIq[es][b][i] = IxIq;
		s_DxIq[es][b][i] = DxIq;
	      }
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	      
	    if(eo+es<Nelements){
		
	      dfloat qr = 0, qs = 0, qt = 0, qI = 0;
		
	      // interpolate and differentiate in 's' direction
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
#if 1
		  qr += s_I[j][n]*s_IxDq[es][n][i];
		  qt += s_I[j][n]*s_DxIq[es][n][i];
		  qI += s_I[j][n]*s_IxIq[es][n][i];
		  qs += s_D[j][n]*s_IxIq[es][n][i];

#else
		  qr += s_IT[n][j]*s_IxDq[es][n][i];
		  qt += s_IT[n][j]*s_DxIq[es][n][i];
		  qI += s_IT[n][j]*s_IxIq[es][n][i];
		  qs += s_DT[n][j]*s_IxIq[es][n][i];

#endif
		}
		
		
	      // apply chain rule (notice the swtich of indices in i,j)
	      s_qr[es][i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
	      s_qs[es][i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
	      s_qt[es][i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
	      s_qI[es][i][j] = r_GwJ*qI*lambda;
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	      
	    if(eo+es<Nelements){
	      if(a<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
		occaUnroll(p_gjNq)
		  for(int i=0;i<p_gjNq;++i){
#if 1
		    tmpr += s_D[i][a]*s_qr[es][i][j];
		    tmps += s_I[i][a]*s_qs[es][i][j];
		    tmpt += s_I[i][a]*s_qt[es][i][j];
		    tmpI += s_I[i][a]*s_qI[es][i][j];
#else
		    tmpr += s_DT[a][i]*s_qr[es][i][j];
		    tmps += s_IT[a][i]*s_qs[es][i][j];
		    tmpt += s_IT[a][i]*s_qt[es][i][j];
		    tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
		  }
		
		s_Dqr[es][a][j] = tmpr+tmpI; // blend lambda term in here
		s_Iqs[es][a][j] = tmps;
		s_Iqt[es][a][j] = tmpt;
	      }
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    if(eo+es<Nelements){
	      if(a<p_Nq && b<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0;
		
		occaUnroll(p_gjNq)
		  for(int j=0;j<p_gjNq;++j){
#if 1
		    tmpr += s_I[j][b]*s_Dqr[es][a][j];
		    tmps += s_D[j][b]*s_Iqs[es][a][j];
		    tmpt += s_I[j][b]*s_Iqt[es][a][j];
#else
		    tmpr += s_IT[b][j]*s_Dqr[es][a][j];
		    tmps += s_DT[b][j]*s_Iqs[es][a][j];
		    tmpt += s_IT[b][j]*s_Iqt[es][a][j];
#endif
		  }
		
		// transpose differentiate and interpolate in 't'
		tmpr += tmps; // blend r and s
		occaUnroll(p_Nq)
		  for(int c=0;c<p_Nq;++c){
#if 1
		    r_lapq[c] += s_I[k][c]*tmpr;
		    r_lapq[c] += s_D[k][c]*tmpt;
#else
		    r_lapq[c] += c_I[k][c]*tmpr;
		    r_lapq[c] += c_D[k][c]*tmpt;
#endif
		  }
	      }
	    }
	  }
	}
      }
    }
  
    optBarrier(localMemFence);
    
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){

	  dfloat r_qAq = 0;

	  if(a<p_Nq && b<p_Nq){
	    if(eo+es<Nelements){
	      for(int c=0;c<p_Nq;++c){
		const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
		Aq[id] = r_lapq[c];
		#if 0  
		r_qAq += r_q[c]*r_lapq[c]; // should buffer q ?
		#endif
		//r_qAq += q[id]*r_lapq[c]; // should buffer q ?
	      }
	    }
	  }
#if 0
	  thread =  a + b*p_gjNq + es*p_gjNq*p_gjNq;
	  s_red[thread] = r_qAq;
#endif
	}
      }
    }

#if 0
    optBarrier(localMemFence);
    
#if (p_Nthreads>512)
    allThreads
      if(thread+512<p_Nthreads && thread<512)
	s_red[thread] += s_red[thread+512];
#endif
    
#if (p_Nthreads>256)
    optBarrier(localMemFence);
    allThreads 
      if(thread+256<p_Nthreads && thread<256)
	s_red[thread] += s_red[thread+256];
#endif
    
#if (p_Nthreads>128)
    optBarrier(localMemFence);
    allThreads 
      if(thread+128<p_Nthreads && thread<128)
	s_red[thread] += s_red[thread+128];
#endif

#if (p_Nthreads>64)
    optBarrier(localMemFence);
    allThreads
      if(thread+64<p_Nthreads && thread<64)
	s_red[thread] += s_red[thread+64];
#endif

#if (p_Nthreads>32)
    optBarrier(localMemFence);
    allThreads
      if(thread+32<p_Nthreads && thread<32) 
	s_red[thread] += s_red[thread+32];
#endif

#if (p_Nthreads>16)
    allThreads  
      if(thread+16<p_Nthreads && thread<16)
	s_red[thread] += s_red[thread+16];
#endif

#if (p_Nthreads>8)
    allThreads
      if(thread+8<p_Nthreads && thread<8)
	s_red[thread] += s_red[thread+8];
#endif

#if (p_Nthreads>4)
    allThreads  
      if(thread+4<p_Nthreads && thread<4) 
	s_red[thread] += s_red[thread+4];
#endif

#if (p_Nthreads>2)
    allThreads
      if(thread+2<p_Nthreads && thread<2)
	s_red[thread] += s_red[thread+2];
#endif

#if (p_Nthreads>1)
    allThreads 
      if(thread+1<p_Nthreads && thread==0)
	s_red[thread] += s_red[thread+1];
#endif
    allThreads 
      if(thread==0){
	const dfloat r_qAq = s_red[0];
	atomicAdd(qAq, r_qAq);
      }
#endif
  }
#undef s_Dqr
#undef s_Iqs
#undef s_Iqt
}


/* note that the gjGeo must be the geometric factors at the p_gjNp integration nodes */
kernel void ellipticPartialAxHex3D_e5(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gjGeo, 
				      const dfloat * restrict gjD,
				      const dfloat * restrict gjI,
				      const dfloat   lambda,
				      const dfloat * restrict q,
				      dfloat * restrict Aq,
				      dfloat * restrict qAq){  

  
  for(int eo=0;eo<Nelements;eo+=p_NblockG;outer0){
    
    volatile shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
    volatile shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

    volatile shared dfloat s_DT[p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_IT[p_Nq][p_gjNq+p_gllPad];
    
    exclusive dfloat r_q[p_Nq];
    exclusive dfloat r_lapq[p_Nq];

    volatile shared dfloat s_Ixxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
    volatile shared dfloat s_Dxxq[p_NblockG][p_Nq][p_Nq+p_gllPad];
    volatile shared dfloat s_IxDq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_IxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_DxIq[p_NblockG][p_Nq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qr[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qs[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    volatile shared dfloat s_qt[p_NblockG][p_gjNq][p_gjNq+p_gjPad];

    volatile shared dfloat s_Dqr[p_NblockG][p_gjNq][p_Nq+p_gllPad];
    volatile shared dfloat s_Iqs[p_NblockG][p_gjNq][p_Nq+p_gllPad];
    volatile shared dfloat s_Iqt[p_NblockG][p_gjNq][p_Nq+p_gllPad];

    volatile shared dfloat s_qI[p_NblockG][p_gjNq][p_gjNq+p_gjPad];
    
    exclusive iint emap;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;	      
    
    // prefetch D and I matrices and zero register storage
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  int t = a + b*p_gjNq + es*p_gjNq*p_gjNq;
	  
	  if(t<p_gjNq*p_Nq){
	    const iint tb = t/p_Nq;
	    const iint ta = t%p_Nq;
#if 1
	    s_D[tb][ta] = gjD[t];
	    s_I[tb][ta] = gjI[t];
	    s_DT[ta][tb] = gjD[t];
	    s_IT[ta][tb] = gjI[t];
#endif

	  }

	  for(int c=0;c<p_Nq;++c){
	    r_q[c] = 0;
	    r_lapq[c] = 0;
	  }

	  int e = eo+es;
	  if(e<Nelements){
	    emap = elementList[e];

	    if(a<p_Nq && b<p_Nq){

	      occaUnroll(p_Nq)
		for(int c=0;c<p_Nq;++c){
		  r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
		}
	    }

	  }
	  else
	    emap = -999999;
	  
	}
      }
    }
    
    // scan through k slices
    for(int k=0;k<p_gjNq;++k){
	
      optBarrier(localMemFence);
      
      // prefetch slice
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    if(eo+es<Nelements){
		
	      // assumes w*J built into G entries
	      //dfloat	 r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;	      
	      const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;

	      r_GwJ = gjGeo[base+p_GWJID*p_gjNp];

	      r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	      r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	      r_G02 = gjGeo[base+p_G02ID*p_gjNp];
		
	      r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	      r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	      r_G22 = gjGeo[base+p_G22ID*p_gjNp];

	      if(a<p_Nq && b<p_Nq){
		
		dfloat Iqk = 0, Dqk = 0;
		
		// puts more data in flight
		for(int c=0;c<p_Nq;++c){
		  const dfloat qcba = r_q[c]; 
		  //		  const dfloat qcba = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
		  // I_{kc} q_{cba}
#if 1
		  Iqk += s_I[k][c]*qcba;
		  Dqk += s_D[k][c]*qcba;
#else
		  Iqk += c_I[k][c]*qcba;
		  Dqk += c_D[k][c]*qcba;
#endif
		}
		s_Ixxq[es][b][a] = Iqk;
		s_Dxxq[es][b][a] = Dqk;
	      }
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // interpolate and differentiate in 'r' direction
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int i=0;i<p_gjNq;++i;inner0){
	      
	    if(es+eo<Nelements){
	      
	      dfloat IIIq = 0, IIDq= 0, IDIq = 0, DIIq = 0;

	      for(int b=0;b<p_Nq;++b){
		const dfloat Ijb = s_I[j][b];
		const dfloat Djb = s_D[j][b];
		for(int a=0;a<p_Nq;++a){
		  const dfloat qba = s_Ixxq[es][b][a];
		  const dfloat Iia = s_I[i][a];
		  const dfloat Dia = s_D[i][a];
		  IIIq += Iia*Ijb*qba;
		  IIDq += Dia*Ijb*qba;
		  IDIq += Iia*Djb*qba;
		  DIIq += Iia*Ijb*s_Dxxq[es][b][a];
		}
	      }
	      
	      // apply chain rule (notice the swtich of indices in i,j)
	      s_qr[es][i][j] = r_G00*IIDq + r_G01*IDIq + r_G02*DIIq;
	      s_qs[es][i][j] = r_G01*IIDq + r_G11*IDIq + r_G12*DIIq;
	      s_qt[es][i][j] = r_G02*IIDq + r_G12*IDIq + r_G22*DIIq;
	      s_qI[es][i][j] = r_GwJ*IIIq*lambda;
	    }
	  }
	}
      }
	
      optBarrier(localMemFence);
	
      // transpose differentiate and interpolate in 'r'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int j=0;j<p_gjNq;++j;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	      
	    if(eo+es<Nelements){
	      if(a<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
		//		occaUnroll(p_gjNq)
		  for(int i=0;i<p_gjNq;++i){
#if 1
		    tmpr += s_D[i][a]*s_qr[es][i][j];
		    tmps += s_I[i][a]*s_qs[es][i][j];
		    tmpt += s_I[i][a]*s_qt[es][i][j];
		    tmpI += s_I[i][a]*s_qI[es][i][j];
#else
		    tmpr += s_DT[a][i]*s_qr[es][i][j];
		    tmps += s_IT[a][i]*s_qs[es][i][j];
		    tmpt += s_IT[a][i]*s_qt[es][i][j];
		    tmpI += s_IT[a][i]*s_qI[es][i][j];
#endif
		  }
		
		s_Dqr[es][j][a] = tmpr+tmpI; // blend lambda term in here
		s_Iqs[es][j][a] = tmps;
		s_Iqt[es][j][a] = tmpt;
	      }
	    }
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 's'
      for(int es=0;es<p_NblockG;++es;inner2){
	for(int b=0;b<p_gjNq;++b;inner1){
	  for(int a=0;a<p_gjNq;++a;inner0){
	    if(eo+es<Nelements){
	      if(a<p_Nq && b<p_Nq){
		dfloat tmpr = 0, tmps = 0, tmpt = 0;
		
		//		occaUnroll(p_gjNq)
		  for(int j=0;j<p_gjNq;++j){
#if 1
		    tmpr += s_I[j][b]*s_Dqr[es][j][a];
		    tmps += s_D[j][b]*s_Iqs[es][j][a];
		    tmpt += s_I[j][b]*s_Iqt[es][j][a];
#else
		    tmpr += s_IT[b][j]*s_Dqr[es][j][a];
		    tmps += s_DT[b][j]*s_Iqs[es][j][a];
		    tmpt += s_IT[b][j]*s_Iqt[es][j][a];
#endif
		  }
		
		// transpose differentiate and interpolate in 't'
		  tmpr += tmps; // blend r and s
		  occaUnroll(p_Nq)
		  for(int c=0;c<p_Nq;++c){
#if 1
		    r_lapq[c] += s_I[k][c]*tmpr;
		    r_lapq[c] += s_D[k][c]*tmpt;
#else
		    r_lapq[c] += c_I[k][c]*tmpr;
		    r_lapq[c] += c_D[k][c]*tmpt;
#endif
		  }
	      }
	    }
	  }
	}
      }
    }
  
    optBarrier(localMemFence);
    
    for(int es=0;es<p_NblockG;++es;inner2){
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){

	  dfloat r_qAq = 0;

	  if(a<p_Nq && b<p_Nq){
	    if(eo+es<Nelements){
	      occaUnroll(p_Nq)
	      for(int c=0;c<p_Nq;++c){
		const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
		Aq[id] = r_lapq[c];
	      }
	    }
	  }
	}
      }
    }
  }
}


kernel void ellipticPartialAxHex3D_e6(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gjGeo, 
				      const dfloat * restrict gjD,
				      const dfloat * restrict gjI,
				      const dfloat   lambda,
				      dfloat * restrict q,
				      dfloat * restrict Aq,
				      dfloat * restrict qAq){  

  
  for(int e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive dfloat r_q[p_Nq];
    exclusive dfloat r_lapq[p_Nq];

    shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
    shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

    shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
    shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
    shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

    shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
    shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
    shared dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];

    shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];

    shared dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];

    exclusive iint emap, ta, tb;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;	      
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	const int t = a + p_gjNq*b;
	
	if(a<p_Nq && b<p_gjNq){
	  s_D[b][a] = gjD[b*p_Nq+a];
	  s_I[b][a] = gjI[b*p_Nq+a];
	}
	
	for(int c=0;c<p_Nq;++c){
	  //	  r_q[c] = 0;
	  r_lapq[c] = 0;
	}
	
	emap = elementList[e];
	
	if(a<p_Nq && b<p_Nq){
	  
	  occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
	    }
	}
      }
    }
    
    // scan through k slices

    for(int k=0;k<p_gjNq;++k){
	
      optBarrier(localMemFence);
      
      // prefetch slice
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  
	  const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
	  r_GwJ = gjGeo[base+p_GWJID*p_gjNp]; 
	  r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	  r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	  r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	  
	  r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	  r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	  r_G22 = gjGeo[base+p_G22ID*p_gjNp];	  
	  // assumes w*J built into G entries
	  
	  if(a<p_Nq && b<p_Nq){
	    
	    dfloat Iqk = 0, Dqk = 0;
	    
	    // puts more data in flight
	    for(int c=0;c<p_Nq;++c){
	      const dfloat qcba = r_q[c]; 
	      Iqk += s_I[k][c]*qcba;
	      Dqk += s_D[k][c]*qcba;
	    }
	    s_Ixxq[b][a] = Iqk;
	    s_Dxxq[b][a] = Dqk;
	  }
	}
      }
	
      optBarrier(localMemFence);
      
      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){
 
	  if(b<p_Nq){

	    dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	    
	    occaUnroll(p_Nq)
	    for(int a=0;a<p_Nq;++a){
	      const dfloat Iia = s_I[i][a];
	      const dfloat Ixxqba = s_Ixxq[b][a];
	      IxIq += Iia*Ixxqba;
	      DxIq += Iia*s_Dxxq[b][a];
	    }

	    occaUnroll(p_Nq)
	    for(int a=0;a<p_Nq;++a){
	      const dfloat Dia = s_D[i][a];
	      const dfloat Ixxqba = s_Ixxq[b][a];
	      IxDq += Dia*Ixxqba;
	    }
	    
	    s_IxDq[b][i] = IxDq;
	    s_IxIq[b][i] = IxIq;
	    s_DxIq[b][i] = DxIq;
	  }
	}
      }
	
      optBarrier(localMemFence);
      
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){
	  
	  dfloat qr = 0, qs = 0, qt = 0, qI = 0;
	  
	  // interpolate and differentiate in 's' direction
	  occaUnroll(p_Nq)
	    for(int b=0;b<p_Nq;++b){
	      const dfloat Ijn = s_I[j][b];
	      qr += Ijn*s_IxDq[b][i];
	      qt += Ijn*s_DxIq[b][i];
	      qI += Ijn*s_IxIq[b][i];
	    }
		
	  occaUnroll(p_Nq)
	    for(int b=0;b<p_Nq;++b){
	      const dfloat Djn = s_D[j][b];
	      qs += Djn*s_IxIq[b][i];
	    }	 
	  
	  // apply chain rule (notice the swtich of indices in i,j)
	  s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
	  s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
	  s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
	  s_qI[i][j] = r_GwJ*qI*lambda;
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 'r'
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  
	  if(a<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;
	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Iia = s_I[i][a];
		tmps += Iia*s_qs[i][j];
		tmpt += Iia*s_qt[i][j];
		tmpI += Iia*s_qI[i][j];
	      }

	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Dia = s_D[i][a];
		tmpr += Dia*s_qr[i][j];
	      }
	    
	    s_Dqr[j][a] = tmpr+tmpI; // blend lambda term in here
	    s_Iqs[j][a] = tmps;
	    s_Iqt[j][a] = tmpt;
	  }
	}
      }
      
      optBarrier(localMemFence);
      
      // transpose differentiate and interpolate in 's'
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  if(a<p_Nq && b<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    
	    occaUnroll(p_gjNq)
	      for(int j=0;j<p_gjNq;++j){
		const dfloat Ijb = s_I[j][b];
		
		tmpr += Ijb*s_Dqr[j][a];
		tmpt += Ijb*s_Iqt[j][a];
	      }


	    occaUnroll(p_gjNq)
	      for(int j=0;j<p_gjNq;++j){
		const dfloat Djb = s_D[j][b];
		
		tmps += Djb*s_Iqs[j][a];
	      }
	    
	    // transpose differentiate and interpolate in 't'
	    tmpr += tmps; // blend r and s
	    occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      r_lapq[c] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
	    }
	  }
	}
      }
    }
    
    //    optBarrier(localMemFence);
    
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	
	dfloat r_qAq = 0;
	
	if(a<p_Nq && b<p_Nq){
	  occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	      Aq[id] = r_lapq[c];
	    }
	}
      }
    }
  }
}


kernel void ellipticPartialAxHex3D_e7(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gjGeo, 
				      const dfloat * restrict gjD,
				      const dfloat * restrict gjI,
				      const dfloat   lambda,
				      const dfloat * restrict q,
				      dfloat * restrict gradq,
				      dfloat * restrict Aq){

  // split into gradient then divergence to reduce register and shared memory pressure
  
  // gradient
  for(int e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

    exclusive dfloat r_q[p_Nq];

    shared dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
    shared dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];

    shared dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
    shared dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
    shared dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];

    exclusive iint emap;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;	      
    
    // prefetch D and I matrices and zero register storage
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	const int t = a + p_gjNq*b;
	
	if(a<p_Nq && b<p_gjNq){
	  s_D[b][a] = gjD[b*p_Nq+a];
	  s_I[b][a] = gjI[b*p_Nq+a];
	}
	
	emap = elementList[e];
	
	if(a<p_Nq && b<p_Nq){
	  
	  occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      r_q[c] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
	    }
	}
      }
    }
    
    // scan through k slices

    for(int k=0;k<p_gjNq;++k){
	
      optBarrier(localMemFence);
      
      // prefetch slice
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  
	  const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + b*p_gjNq + a;
	  r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
	  r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	  r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	  r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	  
	  r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	  r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	  r_G22 = gjGeo[base+p_G22ID*p_gjNp];	  
	  // assumes w*J built into G entries
	  
	  if(a<p_Nq && b<p_Nq){
	    
	    dfloat Iqk = 0, Dqk = 0;
	    
	    occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      const dfloat qcba = r_q[c]; 
	      Iqk += s_I[k][c]*qcba;
	      Dqk += s_D[k][c]*qcba;
	    }
	    s_Ixxq[b][a] = Iqk;
	    s_Dxxq[b][a] = Dqk;
	  }
	}
      }
	
      optBarrier(localMemFence);
      
      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){
 
	  if(b<p_Nq){

	    dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	    
	    occaUnroll(p_Nq)
	    for(int a=0;a<p_Nq;++a){
	      const dfloat Iia = s_I[i][a];
	      const dfloat Dia = s_D[i][a];
	      const dfloat Ixxqba = s_Ixxq[b][a];
	      IxDq += Dia*Ixxqba;
	      IxIq += Iia*Ixxqba;
	      DxIq += Iia*s_Dxxq[b][a];
	    }
	    
	    s_IxDq[b][i] = IxDq;
	    s_IxIq[b][i] = IxIq;
	    s_DxIq[b][i] = DxIq;
	  }
	}
      }
	
      optBarrier(localMemFence);
      
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){
	  
	  dfloat qr = 0, qs = 0, qt = 0, qI = 0;
	  
	  // interpolate and differentiate in 's' direction
	  occaUnroll(p_Nq)
	    for(int n=0;n<p_Nq;++n){
	      const dfloat Ijn = s_I[j][n];
	      const dfloat Djn = s_D[j][n];
	      qr += Ijn*s_IxDq[n][i];
	      qt += Ijn*s_DxIq[n][i];
	      qI += Ijn*s_IxIq[n][i];
	      qs += Djn*s_IxIq[n][i];
	    }	 
	  
	  // apply chain rule (notice the swtich of indices in i,j)
	  // should bundle these
	  const iint base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  gradq[base+0*p_gjNq2] = r_G00*qr + r_G01*qs + r_G02*qt;
	  gradq[base+1*p_gjNq2] = r_G01*qr + r_G11*qs + r_G12*qt;
	  gradq[base+2*p_gjNq2] = r_G02*qr + r_G12*qs + r_G22*qt;
	  gradq[base+3*p_gjNq2] = r_GwJ*qI*lambda;
	}
      }
    }
  }

  // divergence
  for(int e=0;e<Nelements;++e;outer0){      
    
    shared dfloat s_D[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
    
    exclusive dfloat r_lapq[p_Nq];

    shared dfloat s_qtmp[p_gjNq][p_gjNq+p_gjPad];
    
    shared dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
    shared dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];
    
    exclusive iint emap;
  
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	if(a<p_Nq && b<p_gjNq){
	  s_D[b][a] = gjD[b*p_Nq+a];
	  s_I[b][a] = gjI[b*p_Nq+a];
	}
      }

      for(int c=0;c<p_Nq;++c){
	r_lapq[c] = 0.f;
      }

      emap = elementList[e];
    }

    for(int k=0;k<p_gjNq;++k){

      // 1.
      optBarrier(localMemFence);      

      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){	
	  // should bundle these
	  const iint base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  s_qtmp[i][j] = gradq[base+0*p_gjNq2];
	}
      }
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 'r'
      for(int a=0;a<p_gjNq;++a;inner1){	
	for(int j=0;j<p_gjNq;++j;inner0){
	  
	  if(a<p_Nq){
	    dfloat tmpr = 0;
	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Dia = s_D[i][a];
		tmpr += Dia*s_qtmp[i][j];
	      }
	    
	    s_Dqr[j][a] = tmpr; 
	  }
	}
      }

      // 2.
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){	
	  // should bundle these
	  const iint base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  s_qtmp[i][j] = gradq[base+1*p_gjNq2];
	}
      }
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 'r'
      for(int a=0;a<p_gjNq;++a;inner1){	
	for(int j=0;j<p_gjNq;++j;inner0){
	  
	  if(a<p_Nq){
	    dfloat tmps = 0;
	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Iia = s_I[i][a];
		tmps += Iia*s_qtmp[i][j];
	      }
	    
	    s_Iqs[j][a] = tmps;
	  }
	}
      }

      optBarrier(localMemFence);

      // 3.
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){	
	  // should bundle these
	  const iint base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  s_qtmp[i][j] = gradq[base+2*p_gjNq2];
	}
      }
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 'r'
      for(int a=0;a<p_gjNq;++a;inner1){	
	for(int j=0;j<p_gjNq;++j;inner0){
	  
	  if(a<p_Nq){
	    dfloat tmpt = 0;
	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Iia = s_I[i][a];
		tmpt += Iia*s_qtmp[i][j];
	      }
	    
	    s_Iqt[j][a] = tmpt;
	  }
	}
      }

      
      optBarrier(localMemFence);

      // 4.
      for(int j=0;j<p_gjNq;++j;inner1){
	for(int i=0;i<p_gjNq;++i;inner0){	
	  // should bundle these
	  const iint base = e*p_gjNp*4 + 4*k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  s_qtmp[i][j] = gradq[base+3*p_gjNq2];
	}
      }
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 'r'
      for(int a=0;a<p_gjNq;++a;inner1){	
	for(int j=0;j<p_gjNq;++j;inner0){
	  
	  if(a<p_Nq){
	    dfloat tmpI = 0;
	    occaUnroll(p_gjNq)
	      for(int i=0;i<p_gjNq;++i){
		const dfloat Iia = s_I[i][a];
		tmpI += Iia*s_qtmp[i][j];
	      }
	    
	    s_Dqr[j][a] += tmpI; // blend lambda term in here
	  }
	}
      }
      
      
      optBarrier(localMemFence);

      // transpose differentiate and interpolate in 's'
      for(int b=0;b<p_gjNq;++b;inner1){
	for(int a=0;a<p_gjNq;++a;inner0){
	  if(a<p_Nq && b<p_Nq){
	    dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    
	    occaUnroll(p_gjNq)
	      for(int j=0;j<p_gjNq;++j){
	      const dfloat Ijb = s_I[j][b];
	      const dfloat Djb = s_D[j][b];
	      
	      tmpr += Ijb*s_Dqr[j][a];
	      tmps += Djb*s_Iqs[j][a];
	      tmpt += Ijb*s_Iqt[j][a];
	    }
	    
	    // transpose differentiate and interpolate in 't'
	    tmpr += tmps; // blend r and s
	    occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      r_lapq[c] += s_I[k][c]*tmpr;
	      r_lapq[c] += s_D[k][c]*tmpt;
	    }
	  }
	}
      }
    }
    
    //    optBarrier(localMemFence);
    
    for(int b=0;b<p_gjNq;++b;inner1){
      for(int a=0;a<p_gjNq;++a;inner0){
	
	if(a<p_Nq && b<p_Nq){
	  occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
	      const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a;
	      Aq[id] = r_lapq[c];
	    }
	}
      }
    }
  }
}

// ONLY CPU

kernel void ellipticPartialAxHex3D_e8(const iint Nelements,
				      const iint * restrict elementList,
				      const dfloat * restrict gjGeo, 
				      const dfloat * restrict gjD,
				      const dfloat * restrict gjI,
				      const dfloat   lambda,
				      dfloat * restrict q,
				      dfloat * restrict Aq,
				      dfloat * restrict qAq){  

  dfloat s_D[p_gjNq][p_Nq+p_gllPad];
  dfloat s_I[p_gjNq][p_Nq+p_gllPad];
  
  for(int b=0;b<p_gjNq;++b){
    for(int a=0;a<p_Nq;++a){
      s_D[b][a] = gjD[b*p_Nq+a];
      s_I[b][a] = gjI[b*p_Nq+a];
    }
  }

  dfloat r_q[p_Nq][p_Nq][p_Nq];
  dfloat r_lapq[p_Nq][p_Nq][p_Nq];
  
  dfloat s_Ixxq[p_Nq][p_Nq+p_gllPad];
  dfloat s_Dxxq[p_Nq][p_Nq+p_gllPad];
  
  dfloat s_IxDq[p_Nq][p_gjNq+p_gjPad];
  dfloat s_IxIq[p_Nq][p_gjNq+p_gjPad];
  dfloat s_DxIq[p_Nq][p_gjNq+p_gjPad];
  
  dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
  dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
  dfloat s_qt[p_gjNq][p_gjNq+p_gjPad];
  
  dfloat s_Dqr[p_gjNq][p_Nq+p_gllPad];
  dfloat s_Iqs[p_gjNq][p_Nq+p_gllPad];
  dfloat s_Iqt[p_gjNq][p_Nq+p_gllPad];
  
  dfloat s_qI[p_gjNq][p_gjNq+p_gjPad];
  
  for(int e=0;e<Nelements;++e){
    
    const iint emap = elementList[e];
    
    // prefetch D and I matrices and zero register storage
    for(int c=0;c<p_Nq;++c){
      for(int b=0;b<p_Nq;++b){
	for(int a=0;a<p_Nq;++a){
	  r_lapq[c][b][a] = 0;
	  r_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
	}
      }
    }
    
    // scan through k slices

    for(int k=0;k<p_gjNq;++k){
	
      // prefetch slice
      for(int b=0;b<p_Nq;++b){
	for(int a=0;a<p_Nq;++a){
	  
	  // assumes w*J built into G entries
	  
	  dfloat Iqk = 0, Dqk = 0;
	  
	  // puts more data in flight
	  for(int c=0;c<p_Nq;++c){
	    const dfloat qcba =  r_q[c][b][a]; 
	    Iqk += s_I[k][c]*qcba;
	    Dqk += s_D[k][c]*qcba;
	  }
	  s_Ixxq[b][a] = Iqk;
	  s_Dxxq[b][a] = Dqk;
	}
      }
      
      // interpolate and differentiate in 'r' direction
      for(int b=0;b<p_Nq;++b){
	for(int i=0;i<p_gjNq;++i){
	  
	  dfloat IxDq= 0, IxIq = 0, DxIq = 0;
	  
	  for(int a=0;a<p_Nq;++a){
	    const dfloat Iia = s_I[i][a];
	    const dfloat Ixxqba = s_Ixxq[b][a];
	    IxIq += Iia*Ixxqba;
	    DxIq += Iia*s_Dxxq[b][a];
	  }
	  
	  for(int a=0;a<p_Nq;++a){
	    const dfloat Dia = s_D[i][a];
	    const dfloat Ixxqba = s_Ixxq[b][a];
	    IxDq += Dia*Ixxqba;
	  }
	  
	  s_IxDq[b][i] = IxDq;
	  s_IxIq[b][i] = IxIq;
	  s_DxIq[b][i] = DxIq;
	}
      }
      
      for(int j=0;j<p_gjNq;++j){
	for(int i=0;i<p_gjNq;++i){
	  
	  dfloat qr = 0, qs = 0, qt = 0, qI = 0;
	  
	  // interpolate and differentiate in 's' direction
	  for(int b=0;b<p_Nq;++b){
	    const dfloat Ijn = s_I[j][b];
	    qr += Ijn*s_IxDq[b][i];
	    qt += Ijn*s_DxIq[b][i];
	    qI += Ijn*s_IxIq[b][i];
	  }
	  
	  for(int b=0;b<p_Nq;++b){
	    const dfloat Djn = s_D[j][b];
	    qs += Djn*s_IxIq[b][i];
	  }	 
	  
	  const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
	  const dfloat r_GwJ = gjGeo[base+p_GWJID*p_gjNp]; 
	  const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
	  const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
	  const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];
	  
	  const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
	  const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];
	  const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];	  
	  
	  // apply chain rule (notice the swtich of indices in i,j)
	  s_qr[i][j] = r_G00*qr + r_G01*qs + r_G02*qt;
	  s_qs[i][j] = r_G01*qr + r_G11*qs + r_G12*qt;
	  s_qt[i][j] = r_G02*qr + r_G12*qs + r_G22*qt;
	  s_qI[i][j] = r_GwJ*qI*lambda;
	}
      }
      
      // transpose differentiate and interpolate in 'r'
      for(int j=0;j<p_gjNq;++j){
	for(int a=0;a<p_Nq;++a){
	  
	  dfloat tmpr = 0, tmps = 0, tmpt = 0, tmpI = 0;

	  for(int i=0;i<p_gjNq;++i){
	    const dfloat Iia = s_I[i][a];
	    tmps += Iia*s_qs[i][j];
	    tmpt += Iia*s_qt[i][j];
	    tmpI += Iia*s_qI[i][j];
	  }
	  
	  for(int i=0;i<p_gjNq;++i){
	    const dfloat Dia = s_D[i][a];
	    tmpr += Dia*s_qr[i][j];
	  }
	  
	  s_Dqr[j][a] = tmpr+tmpI; // blend lambda term in here
	  s_Iqs[j][a] = tmps;
	  s_Iqt[j][a] = tmpt;
	}
      }
      
      // transpose differentiate and interpolate in 's'
      for(int b=0;b<p_Nq;++b){
	for(int a=0;a<p_Nq;++a){

	  dfloat tmpr = 0, tmps = 0, tmpt = 0;
	    
	  for(int j=0;j<p_gjNq;++j){
	    const dfloat Ijb = s_I[j][b];
	    
	    tmpr += Ijb*s_Dqr[j][a];
	    tmpt += Ijb*s_Iqt[j][a];
	  }
	  
	  for(int j=0;j<p_gjNq;++j){
	    const dfloat Djb = s_D[j][b];
	    
	    tmps += Djb*s_Iqs[j][a];
	  }
	  
	  // transpose differentiate and interpolate in 't'
	  tmpr += tmps; // blend r and s

	  for(int c=0;c<p_Nq;++c){
	    r_lapq[c][b][a] += s_I[k][c]*tmpr + s_D[k][c]*tmpt;
	  }
	}
      }
    }

    for(int c=0;c<p_Nq;++c){    
      for(int b=0;b<p_Nq;++b){
	for(int a=0;a<p_Nq;++a){
	  const iint id = emap*p_Np + c*p_Nq2 + b*p_Nq + a  +1;
	  Aq[id] = r_lapq[c][b][a];
	}
      }
    }
  }
}

