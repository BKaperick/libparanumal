// compute div(NU)  = div(uxu) in collocation way
kernel void multiFluidInsLevelSetTransportCubatureVolume2D(const int Nelements,
                                                          const dfloat * restrict vgeo,
                                                          const dfloat * restrict cubDrWT,
                                                          const dfloat * restrict cubDsWT,
                                                          const dfloat * restrict cubInterpT,
                                                          const int offset,
                                                          const dfloat * restrict U,
                                                          const dfloat * restrict V,
                                                          const dfloat * restrict Phi, 
                                                                dfloat * restrict rhsPhi){

  for(int eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_NblockV][p_Np];
    shared dfloat s_V[p_NblockV][p_Np];
    shared dfloat s_Phi[p_NblockV][p_Np];
    //
    shared dfloat s_cFr[p_NblockV][p_cubNp];
    shared dfloat s_cFs[p_NblockV][p_cubNp];
    
    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){  // for all nodes in this element
      	int e = eo+es; // element in block
      	if(e<Nelements && n<p_Np){
        	  const int id = (e+offset)*p_Np+n;
        	  s_U[es][n] = U[id];
        	  s_V[es][n] = V[id];
            s_Phi[es][n] = Phi[e*p_Np + n];
        } 
      }
    }

    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
      	int e = eo+es; // element in block
      	if(e<Nelements && n<p_cubNp){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat cu = 0.f, cv = 0.f, cphi = 0.f;
          occaUnroll(p_Np)
          for(int m=0;m<p_Np;++m){
            dfloat cI = cubInterpT[n+m*p_cubNp];
            cu    += cI*s_U[es][m];
            cv    += cI*s_V[es][m];
            cphi  += cI*s_Phi[es][m]; 
          }
          s_cFr[es][n] = cphi*(drdx*cu + drdy*cv);
          s_cFs[es][n] = cphi*(dsdx*cu + dsdy*cv);
      	 }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
      	int e = eo+es; 
      	if(e<Nelements && n<p_Np){	  	  
      	  // compute 'r' and 's' derivatives of (q_m) at node n
      	  dfloat dfdr = 0.f, dfds = 0.f; 
      	  occaUnroll(p_cubNp)
      	    for(int m=0;m<p_cubNp;++m){
              dfdr += cubDrWT[n+m*p_Np]*s_cFr[es][m];
              dfds += cubDsWT[n+m*p_Np]*s_cFs[es][m];
      	    }
      	  // Update
      	  rhsPhi[e*p_Np+n] = (dfdr + dfds); // note  change in sign	  
      	}
      }
    }

  }
}



kernel void multiFluidInsLevelSetTransportCubatureSurface2D(const int Nelements,
                                                            const dfloat * restrict sgeo,
                                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                                            const int   * restrict vmapM,
                                                            const int   * restrict vmapP,
                                                            const int   * restrict EToB,
                                                            const dfloat time,
                                                            const dfloat * restrict intx, 
                                                            const dfloat * restrict inty,
                                                            const int offset,
                                                            const dfloat * restrict U,
                                                            const dfloat * restrict V,
                                                            const dfloat * restrict Phi,
                                                                  dfloat * restrict rhsPhi){

  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];
    //
    shared dfloat s_PhiM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_PhiP[p_cubNblockS][p_NfacesNfp];
    //
    shared dfloat s_fluxPhi[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        int e = eo + es;
        if(e<Nelements && n<(p_Nfaces*p_Nfp)){
          const int id  = e*p_Nfp*p_Nfaces + n;
          int idM = vmapM[id]+offset*p_Np;
          int idP = vmapP[id]+offset*p_Np;

          if(idP<0) idP = idM; // if bc !=0 force it

          // load negative and positive trace node values of velocity
          s_UM[es][n] = U[idM];
          s_VM[es][n] = V[idM];
          s_UP[es][n] = U[idP];
          s_VP[es][n] = V[idP];
          //
          s_PhiM[es][n] = Phi[idM - offset*p_Np];
          s_PhiP[es][n] = Phi[idP - offset*p_Np];
      }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        int e = eo + es;
        if(e<Nelements && n<(p_Nfaces*p_intNfp)){
            const int face = n/p_intNfp; // find face that owns this integration node

            // load surface geofactors for this face
            const int sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            dfloat um    = 0.f, vm    = 0.f;
            dfloat up    = 0.f, vp    = 0.f;
            dfloat phim  = 0.f, phip  = 0.f;

            // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
            for(int m=0;m<p_Nfp;++m){
              const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
              const int fm = face*p_Nfp+m;
              um += iInm*s_UM[es][fm];
              vm += iInm*s_VM[es][fm];
              //
              up += iInm*s_UP[es][fm];
              vp += iInm*s_VP[es][fm];
              //
              phim += iInm*s_PhiM[es][fm];
              phip += iInm*s_PhiP[es][fm];

            }

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              phip = phim; 
              //insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp],inty[n+e*p_Nfaces*p_intNfp] , nx, ny, iUM,iVM, &iUP, &iVP);
            }

            // Find max normal velocity on the face
            dfloat unM   = occaFabs(nx*um + ny*vm);
            dfloat unP   = occaFabs(nx*up + ny*vp);    
            dfloat unMax = (unM > unP) ? unM : unP;

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;  // notice sign changes in flux because of weak form
            s_fluxPhi[es][n] = -sc*(.5f*(nx*(up*phip + um*phim) + ny*(vp*phip + vm*phim) 
                                           + unMax*(phim-phip) ));
          }
      }
    }

    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        const int e = eo + es;
        if(e<Nelements && n<p_Np ){
            int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhs = rhsPhi[id];
            occaUnroll(p_intNfp*p_Nfaces)
            for(int m=0;m<(p_intNfp*p_Nfaces);++m){
              rhs += intLIFTT[n+m*p_Np]*s_fluxPhi[es][m];
            }
            rhsPhi[id] = rhs;
          }
      }
    }
  }
}



kernel void multiFluidInsLevelSetTransportLSERKUpdate2D(const int Nelements,
                                                        const dfloat dt,  
                                                        const dfloat rka,
                                                        const dfloat rkb,
                                                        const dfloat * restrict rhsPhi,
                                                              dfloat * restrict resPhi,
                                                              dfloat * restrict Phi){
  // Low storage Runge Kutta time step update
  for(int e=0;e<Nelements;++e;outer0){

    for(int n=0;n<p_Np;++n;inner0){
      const int id = n + e*p_Np;
        
        dfloat r_resphi = resPhi[id];
        dfloat r_rhsphi = rhsPhi[id]; 
        dfloat r_phi    = Phi[id];
        //
        r_resphi = rka*r_resphi + dt*r_rhsphi;
        r_phi   += rkb*r_resphi;
        
        //
        resPhi[id] = r_resphi;
        Phi[id]    = r_phi;
    }
  }
}



