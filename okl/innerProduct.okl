
kernel void innerProduct(const iint N,
			 const dfloat * restrict w,
			 const dfloat * restrict x,
			 dfloat * restrict wx){
  

  for(iint b=0;b<(N+p_blockSize-1)/p_blockSize;++b;outer0){
    
    volatile shared dfloat s_wx[p_blockSize];

    for(iint t=0;t<p_blockSize;++t;inner0){
      const iint id = t + b*p_blockSize;
      s_wx[t] = (id<N) ? (w[id]*x[id]) : 0.f;
    }

    barrier(localMemFence);

#if p_blockSize>512
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<512) s_wx[t] += s_wx[t+512];
    barrier(localMemFence);
#endif

#if p_blockSize>256
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<256) s_wx[t] += s_wx[t+256];
    barrier(localMemFence);
#endif

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<128) s_wx[t] += s_wx[t+128];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 64) s_wx[t] += s_wx[t+ 64];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 32) s_wx[t] += s_wx[t+ 32];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 16) s_wx[t] += s_wx[t+ 16];
    //    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  8) s_wx[t] += s_wx[t+  8];
    //    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  4) s_wx[t] += s_wx[t+  4];
    //    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  2) s_wx[t] += s_wx[t+  2];
    //    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  1) wx[b] = s_wx[0] + s_wx[1];
  }
}

kernel void innerProductAtomic(const iint N,
			       const iint Nblocks,
			       const dfloat * restrict w,
			       const dfloat * restrict x,
			       dfloat * restrict wx){
  

  for(iint b=0;b<Nblocks;++b;outer0){
    
    volatile shared dfloat s_wx[p_blockSize];

    for(iint t=0;t<p_blockSize;++t;inner0){
      iint id = t + b*p_blockSize;
      dfloat tmp  = 0;
      while(id<N){
	tmp += w[id]*x[id];
	id += Nblocks*p_blockSize;
      }
      s_wx[t] = tmp;
    }

    barrier(localMemFence);

#if p_blockSize>512
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<512) s_wx[t] += s_wx[t+512];
    barrier(localMemFence);
#endif

#if p_blockSize>256
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<256) s_wx[t] += s_wx[t+256];
    barrier(localMemFence);
#endif

    for(iint t=0;t<p_blockSize;++t;inner0) if(t<128) s_wx[t] += s_wx[t+128];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 64) s_wx[t] += s_wx[t+ 64];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 32) s_wx[t] += s_wx[t+ 32];
    barrier(localMemFence);

    for(iint t=0;t<p_blockSize;++t;inner0) if(t< 16) s_wx[t] += s_wx[t+ 16];
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  8) s_wx[t] += s_wx[t+  8];
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  4) s_wx[t] += s_wx[t+  4];
    for(iint t=0;t<p_blockSize;++t;inner0) if(t<  2) s_wx[t] += s_wx[t+  2];

    for(iint t=0;t<p_blockSize;++t;inner0)
      if(t<  1){
	dfloat res = s_wx[0]+s_wx[1];
	atomicAdd(wx,res);
      }

  }
}


