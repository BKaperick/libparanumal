// Compute Gradient in Strong Form
@kernel void insGradientTri2D(const dlong Nelements,
                             @restrict const  dfloat *  vgeo,
                             @restrict const  dfloat *  DrT,
                             @restrict const  dfloat *  DsT,
                             @restrict const  dfloat *  P,
                                   @restrict dfloat *  Px,
                                   @restrict dfloat *  Py){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    // for all elements
    @shared dfloat s_P[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          s_P[es][n]  = P[n + e*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dpdr  = 0.f, dpds  = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];

              dpdr  += Drni*s_P[es][i];
              dpds  += Dsni*s_P[es][i];
            }

          const dlong id = e*p_Np+n;
          Px[id] = drdx*dpdr + dsdx*dpds;
          Py[id] = drdy*dpdr + dsdy*dpds;
        }
      }
    }
  }
}

// Compute Gradient in Strong Form
@kernel void insGradientVolumeTri2D(const dlong Nelements,
                                   @restrict const  dfloat *  vgeo,
                                   @restrict const  dfloat *  DrT,
                                   @restrict const  dfloat *  DsT,
                                   const dlong offset,
                                   @restrict const  dfloat *  P,
                                         @restrict dfloat *  Px,
                                         @restrict dfloat *  Py){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    // for all elements
    @shared dfloat s_P[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          s_P[es][n]  = P[n + (e+offset)*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dpdr  = 0.f, dpds  = 0.f;
          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];

              dpdr  += Drni*s_P[es][i];
              dpds  += Dsni*s_P[es][i];
            }

          const dlong id = (e+offset)*p_Np+n;
          Px[id] = drdx*dpdr + dsdx*dpds;
          Py[id] = drdy*dpdr + dsdy*dpds;
        }
      }
    }
  }
}

@kernel void insGradientSurfaceTri2D(const dlong Nelements,
                                    @restrict const  dfloat *  sgeo,
                                    @restrict const  dfloat *  LIFTT,
                                    @restrict const  dlong  *  vmapM,
                                    @restrict const  dlong  *  vmapP,
                                    @restrict const  int    *  EToB,
                                    @restrict const  dfloat *  x,
                                    @restrict const  dfloat *  y,
                                    const dfloat time,
                                    const dfloat dt,
                                    const dfloat c0,
                                    const dfloat c1,
                                    const dfloat c2,
                                    const int index,
                                    const dlong offset,
                                    const int solverID,
                                    @restrict const  dfloat *  POld,
                                    @restrict const  dfloat *  P,
                                          @restrict dfloat *  Px,
                                          @restrict dfloat *  Py){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;@outer(0)){

    @shared dfloat s_fluxPx[p_NblockS][p_Nfp*p_Nfaces];
    @shared dfloat s_fluxPy[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){ // maxNodes = max(Nfp*Nfaces,Np)
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            const int face = n/p_Nfp;
            // load surface geofactors for this face
            const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            const dlong id = e*p_Nfp*p_Nfaces + n;
            dlong idM, idP;
            if(solverID == 1){ //no offset
              idM = vmapM[id];
              idP = vmapP[id];
            } else {
              idM = vmapM[id]+p_Np*index*offset;
              idP = vmapP[id]+p_Np*index*offset;
            }
            const dfloat PM = P[idM];
                  dfloat PP = P[idP];

            // apply boundary condition
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              idM = vmapM[id];
              insPressureDirichletConditions2D(bc, time, x[idM], y[idM], nx, ny, PM, &PP);
              if(solverID==1){ // Pressure Increament Gradient
                PP = PM;
              }
              PP = 2.f*PP - PM; //Strong form BCs
            }

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;

            // Centered flux for pr p*-p = 0.5(PP-PM) // Central Flux
            s_fluxPx[es][n]  = sc*(.5f*nx*(PP-PM));
            s_fluxPy[es][n]  = sc*(.5f*ny*(PP-PM));
          }
        }
      }
    }

    // wait for all flux functions are written to @shared
    @barrier("local");

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodes;++n;@inner(0)){
        const dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            dlong id;
            if (solverID==1) { //no offset
              id = e*p_Np + n;
            } else {
              id = (e+index*offset)*p_Np + n;
            }

            dfloat px  = Px[id];
            dfloat py  = Py[id];
            // Lift
            #pragma unroll p_NfacesNfp
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                const dfloat L = LIFTT[n+m*p_Np];
                px += L*s_fluxPx[es][m];
                py += L*s_fluxPy[es][m];
              }
            //  rhsu = grad(p) // Note that multiplied with M^-1
            Px[id] = px;
            Py[id] = py;
          }
        }
      }
    }
  }
}

