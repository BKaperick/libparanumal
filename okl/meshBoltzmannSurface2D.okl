#define dfloat8 float8

void boundaryConditions2D(int bc, dfloat t, dfloat x, dfloat y,
                          dfloat q1M, dfloat q2M, dfloat q3M,
                          dfloat q4M, dfloat q5M, dfloat q6M,
                          dfloat *q1P, dfloat *q2P, dfloat *q3P,
                          dfloat *q4P, dfloat *q5P, dfloat *q6P){

  if(bc==1){ // wall
    *q1P = q1M; 
    *q2P = -q2M;
    *q3P = -q3M;
    *q4P = q4M;
    *q5P = q5M;
    *q6P = q6M;
  }
  if(bc==2){ // parabolic inflow
    // specify parabolic velocity
    *q1P = q1M;
    *q2P = (1.f-y*y)*q1M/p_sqrtRT; 
    *q3P = p_q3bar;
    *q4P = q4M;
    *q5P = q5M;
    *q6P = q6M;
  }
   if(bc==3){ // outflow
     // only specify density (specifies pressure since p = rho*RT)
     *q1P = p_q1bar;
     *q2P = q2M;
     *q3P = q3M;
     *q4P = q4M;
     *q5P = q5M;
     *q6P = q6M;
   }
}

kernel void meshBoltzmannSurface2D(const int Nelements,
				   const dfloat * restrict sgeo,
				   const dfloat * restrict LIFTT,
				   const int   * restrict vmapM,
				   const int   * restrict vmapP,
				   const int   * restrict EToB,
				   const dfloat time,
				   const dfloat * restrict x,
				   const dfloat * restrict y,
				   const dfloat4 * restrict q,
				   dfloat4       * restrict rhsq){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxq[p_NblockS][p_Nfields][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_Nfp*p_Nfaces){
	    // find face that owns this node
	    int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    int sid = p_Nsgeo*(e*p_Nfaces+face);
	    dfloat nx = sgeo[sid+0];
	    dfloat ny = sgeo[sid+1];
	    dfloat sJ = sgeo[sid+2];
	    dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
	  
	    // load negative and positive trace node values of q
	    dfloat4 qMa = q[2*idM], qMb = q[2*idM+1];
	    dfloat4 qPa = q[2*idP], qPb = q[2*idP+1];
	    dfloat q1M = qMa.x, q2M = qMa.y, q3M = qMa.z, q4M = qMa.w, q5M = qMb.x, q6M = qMb.y;
	    dfloat q1P = qPa.x, q2P = qPa.y, q3P = qPa.z, q4P = qPa.w, q5P = qPb.x, q6P = qPb.y;
	    
	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM],
				   q1M, q2M, q3M, q4M, q5M, q6M,
				   &q1P, &q2P, &q3P, &q4P, &q5P, &q6P);
	    
	    // compute (q^* - q^-)
	    dfloat dq1S, dq2S, dq3S, dq4S, dq5S, dq6S;
	    
	    dq1S = 0.5f*(q1P-q1M) + p_sqrtRT*p_Lambda2*(-nx*(q2P-q2M)-ny*(q3P-q3M));   
	    dq2S = 0.5f*(q2P-q2M) + p_sqrtRT*p_Lambda2*(-nx*(q1P-q1M+p_sqrt2*(q5P-q5M))-ny*(q4P-q4M));		    
	    dq3S = 0.5f*(q3P-q3M) + p_sqrtRT*p_Lambda2*(-nx*(q4P-q4M)-ny*(q1P-q1M+p_sqrt2*(q6P-q6M)));
	    
	    dq4S = 0.5f*(q4P-q4M) + p_sqrtRT*p_Lambda2*(-nx*(q3P-q3M)-ny*(q2P-q2M));
	    dq5S = 0.5f*(q5P-q5M) + p_sqrtRT*p_Lambda2*(-nx*p_sqrt2*(q2P-q2M));
	    dq6S = 0.5f*(q6P-q6M) + p_sqrtRT*p_Lambda2*(-ny*p_sqrt2*(q3P-q3M));          

	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    s_fluxq[es][0][n] = invJ*sJ*p_sqrtRT*(-nx*dq2S-ny*dq3S);
	    s_fluxq[es][1][n] = invJ*sJ*p_sqrtRT*(-nx*(dq1S+p_sqrt2*dq5S)-ny*dq4S);
	    s_fluxq[es][2][n] = invJ*sJ*p_sqrtRT*(-nx*dq4S-ny*(dq1S+p_sqrt2*dq6S));
	    s_fluxq[es][3][n] = invJ*sJ*p_sqrtRT*(-nx*dq3S-ny*dq2S);
	    s_fluxq[es][4][n] = invJ*sJ*p_sqrtRT*(-nx*p_sqrt2*dq2S);
	    s_fluxq[es][5][n] = invJ*sJ*p_sqrtRT*(-ny*p_sqrt2*dq3S);

	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    int id = p_Np*e + n;
	    
	    // load RHS
	    dfloat4 rhsqna = rhsq[2*id];
	    dfloat4 rhsqnb = rhsq[2*id+1];

	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_NfacesNfp)
	      for(int m=0;m<p_NfacesNfp;++m){
		dfloat L = LIFTT[n+m*p_Np];
		rhsqna.x += L*s_fluxq[es][0][m];
		rhsqna.y += L*s_fluxq[es][1][m];
		rhsqna.z += L*s_fluxq[es][2][m];
		rhsqna.w += L*s_fluxq[es][3][m];
		rhsqnb.x += L*s_fluxq[es][4][m];
		rhsqnb.y += L*s_fluxq[es][5][m];
	      }
	  
	    // store incremented rhs
	    rhsq[2*id] = rhsqna;
	    rhsq[2*id+1] = rhsqnb;
	  }
	}
      }
    }
  }
}
