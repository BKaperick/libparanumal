
// block Jacobi preconditioner with inverse of mass matrix
// (assumes mass matrix dominant)
kernel void ellipticBlockJacobiPreconTri2D(const int Nelements,
                                           const dfloat invLambda,
                                           const dfloat * restrict vgeo,
                                           const dfloat * restrict B,
                                           const dfloat * restrict q,
                                           dfloat * restrict Pq){  
  
  // block partition of elements
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_scale[p_NblockV];
    
    for(int es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = es + eo;

        s_q[es][n] = 0;
        if(e<Nelements){
          // prefetch q
          const int id = e*p_Np+n;
          s_q[es][n] = q[id];
          
          if (n==0)
            s_scale[es] = invLambda/vgeo[e*p_Nvgeo+p_JID];
        }
      }
    }
    
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = es + eo;

        if(e<Nelements){
          // compute 1D derivatives
          dfloat Bqn = 0;
          
          occaUnroll(p_Np)
            for(int i=0;i<p_Np;++i){
              Bqn += B[n+i*p_Np]*s_q[es][i];
            }
          
          const int id = e*p_Np+n; 
          Pq[id] = Bqn*s_scale[es];
        }
      }
    }
  }
}

// block Jacobi preconditioner with inverse of mass matrix
// (assumes mass matrix dominant)
kernel void ellipticPartialBlockJacobiPreconTri2D(const int Nelements,
                                                 const int   * restrict elements,
                                                 const dfloat invLambda,
                                                 const dfloat * restrict vgeo,
                                                 const dfloat * restrict B,
                                                 const dfloat * restrict q,
                                                 dfloat * restrict Pq){  
  
  // block partition of elements
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_scale[p_NblockV];
    
    for(int es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = es + eo;

        s_q[es][n] = 0;
        if(e<Nelements){
          const int element = elements[e];
          // prefetch q
          const int id = element*p_Np+n;
          s_q[es][n] = q[id];
 
          if (n==0)
            s_scale[es] = invLambda/vgeo[element*p_Nvgeo+p_JID];
        }
      }
    }
    
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int e = es + eo;

        if(e<Nelements){
          const int element = elements[e];
          // compute 1D derivatives
          dfloat Bqn = 0;
          
          occaUnroll(p_Np)
            for(int i=0;i<p_Np;++i){
              Bqn += B[n+i*p_Np]*s_q[es][i];
            }
          
          const int id = element*p_Np+n; 
          Pq[id] = Bqn*s_scale[es];
        }
      }
    }
  }
}
