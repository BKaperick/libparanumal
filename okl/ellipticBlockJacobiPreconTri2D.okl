
// block Jacobi preconditioner with inverse of mass matrix
// (assumes mass matrix dominant)
kernel void ellipticBlockJacobiPreconTri2D(const int Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict const B,
					   const dfloat * restrict q,
					   dfloat * restrict Pq){  
  
  // block partition of elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_IJ[p_NblockV];
    
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	const iint e = es + eo;
	if(e<Nelements){
	  // prefetch q
	  const iint id = e*p_Np+n;
	  s_q[es][n] = q[id];
	}
	iint t = n + p_Np*es;
	if(t<p_NblockV && (t+eo)<Nelements){
	  s_IJ[t] = vgeo[(eo+t)*p_Nvgeo+p_IJID];
	}
      }
    }
    
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	const iint e = es + eo;

	if(e<Nelements){
	  // compute 1D derivatives
	  dfloat Bqn = 0;
	  
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      Bqn += B[n+i*p_Np]*s_q[es][i];
	    }
	  
	  const iint id = e*p_Np+n; 
	  Pq[id] = s_IJ[es]*Bqn;
	}
      }
    }
  }
}
