
occaKernel void ellipticCGLocalPatchTri2D(const iint Nelements,
                                      const iint * restrict vmapM,
                                      const dfloat lambda,
                                      const dfloat tau,
                                      const dfloat * restrict vgeo,
                                      const dfloat * restrict sgeo,
                                      const iint   * restrict EToB,
                                      const dfloat * restrict DrT,
                                      const dfloat * restrict DsT,
                                      const dfloat * restrict LIFTT,
                                      const dfloat * restrict MM,
                                      const dfloat * restrict invDegree,
                                      const dfloat * restrict q,
                                            dfloat * restrict Sq,
                                      const dfloat TOL) {

  for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_x[p_Np];
    shared  dfloat s_r[p_Np];
    shared  dfloat s_p[p_Np];
    shared  dfloat s_Ap[p_Np];

    shared dfloat s_xy[p_Np];

    shared dfloat s_rdotr, s_rdotr1, s_pAp, s_alpha, s_beta;

    shared  dfloat s_dpdx[p_Np];
    shared  dfloat s_dpdy[p_Np];
    shared  dfloat s_lapq[p_Np];
    shared  dfloat s_nxdq[p_NfacesNfp];
    shared  dfloat s_nydq[p_NfacesNfp];
    shared  dfloat s_lapflux[p_NfacesNfp];
    shared  dfloat s_Lnxdq[p_Np];
    shared  dfloat s_Lnydq[p_Np];
    //exclusive iint idM, bc;
    //exclusive dfloat nx, ny, sJ, invJ, hinv;
    //exclusive dfloat drdx, drdy, dsdx, dsdy, J;

    //fetch q into rhs
    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np) {
        s_r[n] = q[e*p_Np+n];
        s_p[n] = q[e*p_Np+n];
        s_x[n] = 0.;
      }
    }

    barrier(localMemFence);

    // sanity check
    /*---------------------Local Inner product -----------------*/
    for(int n=0;n<p_Nmax;++n;inner0) if(n<p_Np) s_xy[n] = s_r[n]*s_r[n];
    barrier(localMemFence);

    #if p_Np>256
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
    barrier(localMemFence);
    #endif

    #if p_Np>128
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
    barrier(localMemFence);
    #endif

    #if p_Np>64
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
    barrier(localMemFence);
    #endif

    #if p_Np>32
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
    barrier(localMemFence);
    #endif

    #if p_Np>16
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
        barrier(localMemFence);
    #endif

    #if p_Np>8
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
        barrier(localMemFence);
    #endif

    #if p_Np>4
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
        barrier(localMemFence);
    #endif

    #if p_Np>2
    for(iint n=0;n<p_Nmax;++n;inner0) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
        barrier(localMemFence);
    #endif

    for(iint n=0;n<p_Nmax;++n;inner0) 
      if((n< 1)&&(n+1<p_Np)) {
        s_rdotr = s_xy[0] + s_xy[1];
      }
    barrier(localMemFence);

    /*---------------------End Local Inner product -----------------*/    

    if (s_rdotr<TOL*TOL) {
      for(int n=0;n<p_Nmax;++n;inner0) {
        if(n<p_Np) {
          Sq[e*p_Np+n] = invDegree[e]*s_r[n];
        }
        return;
      }
    }
    
    //do an inner CG solve
    while(s_rdotr>TOL*TOL) {

      /*---------------------Local Ax operator -----------------*/
      for(iint n=0;n<p_Nmax;++n;inner0){
        if (n<p_Np) {
          const iint gid = e*p_Nvgeo;
          const dfloat drdx = vgeo[gid + p_RXID];
          const dfloat drdy = vgeo[gid + p_RYID];
          const dfloat dsdx = vgeo[gid + p_SXID];
          const dfloat dsdy = vgeo[gid + p_SYID];
          
          // compute 1D derivatives
          dfloat qr = 0, qs = 0;
          for(iint i=0;i<p_Np;++i){
            qr += DrT[n+i*p_Np]*s_p[i];
            qs += DsT[n+i*p_Np]*s_p[i];
          }
          
          s_dpdx[n] = drdx*qr + dsdx*qs;
          s_dpdy[n] = drdy*qr + dsdy*qs;
        }
      }
      
      barrier(localMemFence);

      // TW      
      for(int n=0;n<p_Nmax;++n;inner0){
        
        if(n<p_Np){
          s_lapq[n] = lambda*s_p[n];
        }
        
        if(n<p_NfacesNfp){
          const iint id  = n + e*p_Nfaces*p_Nfp;
          const iint idM = vmapM[id]%p_Np; //local id
          
          // find face that owns this node
          const iint face = n/p_Nfp;
          
          // load surface geofactors for this face
          const iint sid = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];
          const dfloat hinv = sgeo[sid+p_IHID];
          const iint bc = EToB[face+p_Nfaces*e];
          
          const dfloat qM = s_p[idM];
          const dfloat qxM = s_dpdx[idM];
          const dfloat qyM = s_dpdy[idM];
          
          dfloat qP = 0.;
          dfloat qxP = 0.;
          dfloat qyP = 0.;
          
          if(bc>0) {
            ellipticHomogeneousBC2D(bc, qM, qxM, qyM, qP, qxP, qyP);
            qP = 2*qP - qM;
            qxP = 2*qxP - qxM;
            qyP = 2*qyP - qyM;
          }
          
          const dfloat dq = qP - qM;
          
          s_nxdq[n]    = 0.5*sJ*invJ*nx*dq;
          s_nydq[n]    = 0.5*sJ*invJ*ny*dq;
          s_lapflux[n] = 0.5*sJ*invJ*(-nx*(qxP-qxM)-ny*(qyP-qyM)-tau*hinv*dq);
        }
      }
      
      barrier(localMemFence);
      // TW2
      
      // dqdx += LIFT*(sJ/J)*nx*dq
      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_Np){
          const int gid = e*p_Nvgeo;
          const dfloat drdx = vgeo[gid + p_RXID];
          const dfloat drdy = vgeo[gid + p_RYID];
          const dfloat dsdx = vgeo[gid + p_SXID];
          const dfloat dsdy = vgeo[gid + p_SYID];
          
          dfloat Lnxdq = 0;
          dfloat Lnydq = 0;

          //occaUnroll(p_NfacesNfp)
          for(iint i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
          }

          dfloat dqdx = s_dpdx[n] + Lnxdq;
          dfloat dqdy = s_dpdy[n] + Lnydq;
          s_dpdx[n] = drdx*dqdx + drdy*dqdy; // abuse of notation
          s_dpdy[n] = dsdx*dqdx + dsdy*dqdy;

          s_Lnxdq[n] = Lnxdq;
          s_Lnydq[n] = Lnydq;
        }
      }

      // TW3
      barrier(localMemFence);

      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_NfacesNfp){
          const iint id  = n + e*p_Nfaces*p_Nfp;
          const iint idM = vmapM[id]%p_Np; //local id

          const iint face = n/p_Nfp;
          const iint sid = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[idM]+ny*s_Lnydq[idM]);
        }

        if(n<p_Np){
          dfloat lapr = 0, laps = 0;

          //occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dpdx[i];
            laps += DsT[n+i*p_Np]*s_dpdy[i];
          }

          s_lapq[n] -= (lapr+laps);
        }
        
      }

      // TW4
      barrier(localMemFence);

      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_Np){
          dfloat lap = 0;

          // lift remaining surface terms
          //occaUnroll(p_NfacesNfp)
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }

          s_lapq[n] += lap;
        }
      }

      // TW5
      barrier(localMemFence);

      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_Np){
          const int gid = e*p_Nvgeo;
          const dfloat J = vgeo[gid + p_JID];

          dfloat Mlapq = 0;

          // multiply by mass matrix
          //occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }
          s_Ap[n] = J*Mlapq;
        }
      }
      barrier(localMemFence);

      /*---------------------p.Ap -----------------*/
      for(int n=0;n<p_Nmax;++n;inner0) if(n<p_Np) s_xy[n] = s_p[n]*s_Ap[n];
      barrier(localMemFence);

#if p_Np>256
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
      barrier(localMemFence);
#endif

#if p_Np>128
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
      barrier(localMemFence);
#endif

#if p_Np>64
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
      barrier(localMemFence);
#endif

#if p_Np>32
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
      barrier(localMemFence);
#endif

#if p_Np>16
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
      barrier(localMemFence);
#endif

#if p_Np>8
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
      barrier(localMemFence);
#endif

#if p_Np>4
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
      barrier(localMemFence);
#endif

#if p_Np>2
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
      barrier(localMemFence);
#endif

      for(iint n=0;n<p_Nmax;++n;inner0) 
        if((n< 1)&&(n+1<p_Np)) {
          s_pAp = s_xy[0] + s_xy[1];
          s_alpha = s_rdotr/s_pAp;
        }
      barrier(localMemFence);
      /*---------------------End p.Ap -----------------*/    

      /*--------------------- x += alpha*p -----------------*/    
      /*--------------------- r -= alpha*Ap -----------------*/    
      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_Np) {
          s_x[n] += s_alpha* s_p[n];
          s_r[n] -= s_alpha*s_Ap[n];
        } 
      } 
      barrier(localMemFence);

      /*---------------------r.r -----------------*/
      for(int n=0;n<p_Nmax;++n;inner0) if(n<p_Np) s_xy[n] = s_r[n]*s_r[n];
      barrier(localMemFence);

#if p_Np>256
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 256)&&(n+256<p_Np)) s_xy[n] += s_xy[n+256];
      barrier(localMemFence);
#endif

#if p_Np>128
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 128)&&(n+128<p_Np)) s_xy[n] += s_xy[n+128];
      barrier(localMemFence);
#endif
    
#if p_Np>64
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 64)&&(n+64<p_Np)) s_xy[n] += s_xy[n+ 64];
      barrier(localMemFence);
#endif

#if p_Np>32
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 32)&&(n+32<p_Np)) s_xy[n] += s_xy[n+ 32];
      barrier(localMemFence);
#endif

#if p_Np>16
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 16)&&(n+16<p_Np)) s_xy[n] += s_xy[n+ 16];
          barrier(localMemFence);
#endif

#if p_Np>8
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 8)&&(n+8<p_Np)) s_xy[n] += s_xy[n+ 8];
          barrier(localMemFence);
#endif

#if p_Np>4
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 4)&&(n+4<p_Np)) s_xy[n] += s_xy[n+ 4];
          barrier(localMemFence);
#endif

#if p_Np>2
      for(iint n=0;n<p_Nmax;++n;inner0) if((n< 2)&&(n+2<p_Np)) s_xy[n] += s_xy[n+ 2];
          barrier(localMemFence);
#endif
    
      for(iint n=0;n<p_Nmax;++n;inner0) 
        if((n< 1)&&(n+1<p_Np)) {
          s_rdotr1 = s_xy[0] + s_xy[1];
          s_beta = s_rdotr1/s_rdotr;
        }
      barrier(localMemFence);
      /*---------------------End r.r -----------------*/    

      for(iint n=0;n<p_Nmax;++n;inner0) 
        if(s_rdotr1 < TOL*TOL) break;

      //precon would go here
    
      /*--------------------- p = beta*p + r -----------------*/    
      for(int n=0;n<p_Nmax;++n;inner0){
        if(n<p_Np) s_p[n] = s_beta*s_p[n]+s_r[n];
        if(n==0) s_rdotr = s_rdotr1;
      } 
      barrier(localMemFence);

    }
    
    for(int n=0;n<p_Nmax;++n;inner0) {
      if(n<p_Np) {
        Sq[e*p_Np+n] = invDegree[e]*s_x[n];
      }
    }


  }
}

