

#define DENSITY_SHIFT 0



// Fully Explicit Scheme Uses Clasical half Half Splitting
kernel void boltzmannRelaxationCub2D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat * restrict cubInterpT,
					     const dfloat * restrict cubProjectT,
					     const dfloat4 * restrict q,
					           dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][6][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];

    exclusive iint element;

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    dfloat4 qan = q[2*id];
	    dfloat4 qbn = q[2*id+1];
	    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    
	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	    dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
	    
	    for(iint m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1 += Icn*s_q[es][0][m];
	      cubq2 += Icn*s_q[es][1][m];
	      cubq3 += Icn*s_q[es][2][m];
	      cubq4 += Icn*s_q[es][3][m];
	      cubq5 += Icn*s_q[es][4][m];
	      cubq6 += Icn*s_q[es][5][m];
	    }
	    //
	    #if DENSITY_SHIFT
	    dfloat delta  = 1e-2;
	    dfloat icubq1 = 1.f/occaSqrt(cubq1*cubq1+delta*delta);
	    #else
        dfloat icubq1 = 1.f/cubq1;
        #endif


	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN4[es][n] = -p_tauInv*(cubq4-(           cubq2*cubq3*icubq1));
	    s_cubN5[es][n] = -p_tauInv*(cubq5-(p_invsqrt2*cubq2*cubq2*icubq1));
	    s_cubN6[es][n] = -p_tauInv*(cubq6-(p_invsqrt2*cubq3*cubq3*icubq1));
	  }
	}
      }
    }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    
	    // use temporaries for part sums for N4,N5,N6 because of exclusives
	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N4 += Pnc*s_cubN4[es][i];
	      N5 += Pnc*s_cubN5[es][i];
	      N6 += Pnc*s_cubN6[es][i];
	    }
	    
	    dfloat4 rhsqa,rhsqb;
	    rhsqa.x = 0;
	    rhsqa.y = 0;
	    rhsqa.z = 0;
	    rhsqa.w = N4;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = 0;
	    rhsqb.w = 0;
	
	    rhsq[2*id]   += rhsqa; 
	    rhsq[2*id+1] += rhsqb; 
	    
	  }
	}
      }
    }
  }
}



// Fully Explicit Scheme Uses Clasical half Half Splitting
kernel void boltzmannPmlRelaxationCub2D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat * restrict cubInterpT,
					     const dfloat * restrict cubProjectT, 
					     const dfloat4 * restrict q,
					           dfloat4 * restrict rhsq,
					           dfloat * restrict rhspmlqx,
					           dfloat * restrict rhspmlqy){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][6][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];

    exclusive iint element;

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    dfloat4 qan = q[2*id];
	    dfloat4 qbn = q[2*id+1];
	    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    
	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
	    dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
	    
	    for(iint m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1 += Icn*s_q[es][0][m];
	      cubq2 += Icn*s_q[es][1][m];
	      cubq3 += Icn*s_q[es][2][m];
	      cubq4 += Icn*s_q[es][3][m];
	      cubq5 += Icn*s_q[es][4][m];
	      cubq6 += Icn*s_q[es][5][m];
	    }
	    
	    #if DENSITY_SHIFT
	    dfloat delta  = 1e-2;
	    dfloat icubq1 = 1.f/occaSqrt(cubq1*cubq1+delta*delta);
	    #else
        dfloat icubq1 = 1.f/cubq1;
        #endif
	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN4[es][n] = -p_tauInv*(cubq4-(           cubq2*cubq3*icubq1));
	    s_cubN5[es][n] = -p_tauInv*(cubq5-(p_invsqrt2*cubq2*cubq2*icubq1));
	    s_cubN6[es][n] = -p_tauInv*(cubq6-(p_invsqrt2*cubq3*cubq3*icubq1));
	  }
	}
      }
    }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    
	    // use temporaries for part sums for N4,N5,N6 because of exclusives
	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N4 += Pnc*s_cubN4[es][i];
	      N5 += Pnc*s_cubN5[es][i];
	      N6 += Pnc*s_cubN6[es][i];
	    }
	    
	    dfloat4 rhsqa,rhsqb;
	    rhsqa.x = 0.f;
	    rhsqa.y = 0.f;
	    rhsqa.z = 0.f;
	    rhsqa.w = N4;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = 0.f;
	    rhsqb.w = 0.f;
	
	    rhsq[2*id]   += rhsqa; 
	    rhsq[2*id+1] += rhsqb;  
	    
	  }
	}
      }
    }
  }
}










kernel void boltzmannSARelaxationCub2D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat * restrict cubInterpT,
					     const dfloat * restrict cubProjectT,
					     const dfloat4 * restrict q,
					           dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][3][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];

    exclusive iint element;

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    dfloat4 qan = q[2*id];
	    	    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;   
	    for(iint m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1 += Icn*s_q[es][0][m];
	      cubq2 += Icn*s_q[es][1][m];
	      cubq3 += Icn*s_q[es][2][m];
	    }

	    #if DENSITY_SHIFT
	    dfloat delta  = 1e-2;
	    dfloat icubq1 = 1.f/occaSqrt(cubq1*cubq1+delta*delta);
	    #else
        dfloat icubq1 = 1.f/cubq1;
        #endif
	    // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN4[es][n] = p_tauInv* cubq2*cubq3*icubq1;
	    s_cubN5[es][n] = p_tauInv*p_invsqrt2*cubq2*cubq2*icubq1;
	    s_cubN6[es][n] = p_tauInv*p_invsqrt2*cubq3*cubq3*icubq1;

	  }
	}
      }
    }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    
	    // use temporaries for part sums for N4,N5,N6 because of exclusives
	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N4 += Pnc*s_cubN4[es][i];
	      N5 += Pnc*s_cubN5[es][i];
	      N6 += Pnc*s_cubN6[es][i];
	    }

	    dfloat4 rhsqa,rhsqb;
	    rhsqa.x = 0;
	    rhsqa.y = 0;
	    rhsqa.z = 0;
	    rhsqa.w = N4;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = 0;
	    rhsqb.w = 0;
	
	    rhsq[2*id]   += rhsqa; 
	    rhsq[2*id+1] += rhsqb; 
	    
	  }
	}
      }
    }
  }
}







// Semi Analytic  Scheme Collects all N(q) in qx
kernel void boltzmannSAPmlRelaxationCub2D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat ramp,
					     const dfloat * restrict cubInterpT,
					     const dfloat * restrict cubProjectT,
					     const dfloat4 * restrict q,
					     const dfloat * restrict pmlqx,
					     const dfloat * restrict pmlqy,
					           dfloat4 * restrict rhsq, 
					     const dfloat * restrict rhspmlqx,
					     const dfloat * restrict rhspmlqy){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][6][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];
    //
    
    exclusive iint element;

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  if(n<p_Np){
	    const iint id = element*p_Np+n;
	    dfloat4 qan = q[2*id];
	    dfloat4 qbn = q[2*id+1];
	    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;

	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){
	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;	    
	    for(iint m=0;m<p_Np;++m){
	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
	      cubq1 += Icn*s_q[es][0][m];
	      cubq2 += Icn*s_q[es][1][m];
	      cubq3 += Icn*s_q[es][2][m];
	      
	    }

	     #if DENSITY_SHIFT
	     dfloat delta  = 1e-2;
	     dfloat icubq1 = 1.f/occaSqrt(cubq1*cubq1+delta*delta);
	     #else
        dfloat icubq1  = 1.f/cubq1;
         #endif
	    
	   // BGK relaxation approximation to the Boltzmann collision operator
	    s_cubN4[es][n] = p_tauInv*cubq2*cubq3*icubq1;
	    s_cubN5[es][n] = p_tauInv*p_invsqrt2*cubq2*cubq2*icubq1;
	    s_cubN6[es][n] = p_tauInv*p_invsqrt2*cubq3*cubq3*icubq1;

	  }
	}
      }
    }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const iint id = 2*(element*p_Np+n);
	    
	    // use temporaries for part sums for N4,N5,N6 because of exclusives
	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N4 += Pnc*s_cubN4[es][i];
	      N5 += Pnc*s_cubN5[es][i];
	      N6 += Pnc*s_cubN6[es][i];
	    }
	    
	    dfloat4 rhsqa,rhsqb;
	    rhsqa.x = 0;
	    rhsqa.y = 0;
	    rhsqa.z = 0;
	    rhsqa.w = N4;
	    //
	    rhsqb.x = N5;
	    rhsqb.y = N6;
	    rhsqb.z = 0;
	    rhsqb.w = 0;
	
	    rhsq[id]   += rhsqa; 
	    rhsq[id+1] += rhsqb;      
	  }
	}
      }
    }
  }
}


