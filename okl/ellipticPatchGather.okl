#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))


// experimental overlapping patch solver
kernel void ellipticPatchGather(const dlong Nelements,
                                const dlong   * restrict EToE,
                                const int   * restrict EToF,
                                const dfloat * restrict q,
                                dfloat * restrict Gq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    for(dlong e=eo;e<eo+p_NblockP;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        if(e<Nelements){

          dfloat Gqn = 0;

          Gqn = q[p_patchNp*e+n];

          for(int f=0;f<p_Nfaces;++f){

            const dlong eP = EToE[e*p_Nfaces+f]; // load element e first
            const int   fP = EToF[e*p_Nfaces+f];

            if(eP>=0){
              Gqn += q[eP*p_patchNp+(fP+1)*p_Np+n];
            }
          }

          Gq[e*p_Np+n] = Gqn;
        }
      }
    }
  }
}

kernel void ellipticFacePatchGather(const dlong Nelements,
                                    const dlong  * restrict EToFPairs,
                                    const dfloat * restrict q,
                                    dfloat * restrict Gq){

  // assume one patch per outer iteration (tune later)
  for(dlong eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    for(dlong e=eo;e<eo+p_NblockP;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){

        if(e<Nelements){

          dfloat Gqn = 0;

          for(int f=0;f<p_Nfaces;++f){
            const dlong fP = EToFPairs[p_Nfaces*e+f];

            if (fP >=0) {
              Gqn += q[fP*p_Np + n];
            }
          }

          Gq[e*p_Np+n] = Gqn;
        }
      }
    }
  }
}


