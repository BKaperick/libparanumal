#define p_half 0.5f

void boundaryConditions3D(int bc, dfloat time, 
			  dfloat x, dfloat y, dfloat z, 
			  dfloat uM, dfloat vM, dfloat wM, dfloat pM,
			  dfloat *uP, dfloat *vP, dfloat *wP, dfloat *pP){
  
  if(bc==1){
    // assert Neumann for pressure and no penetration for velocity
    *uP = -uM;
    *vP = -vM;
    *wP = -wM;
    *pP = pM;
  }
  if(bc==2){
    dfloat dx = 1.f/occaSqrt(2.f);
    dfloat dy = 1.f/occaSqrt(2.f);
    dfloat dz = 0;
    dfloat omega = 10.f*M_PI;
    dfloat wave = occaCos(omega*(time-(x*dx+y*dy+z*dz)));
    dfloat uI = dx*wave;
    dfloat vI = dy*wave;
    dfloat wI = dz*wave;
    dfloat pI = wave;
    
    // scattered field wall
    *uP = -uM -2.f*uI;
    *vP = -vM -2.f*vI;
    *wP = -wM -2.f*wI;
    *pP = pM;
  }
}

// function to compute surface contributions 
// for nodal DG acoustics right hand side
kernel void acousticsSurfaceHex3D(const int Nelements,
				  const dfloat * restrict sgeo,
				  const dfloat * restrict LIFTT,
				  const int   * restrict vmapM,
				  const int   * restrict vmapP,
				  const int   * restrict EToB,
				  const dfloat time,
				  const dfloat * restrict x,
				  const dfloat * restrict y,
				  const dfloat * restrict z,
				  const dfloat * restrict q,
				  dfloat       * restrict rhsq){
  
  // for all elements
  for(int e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_Nfp*p_Nfaces];
    shared dfloat s_fluxw[p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
      if(n<p_Nfp*p_Nfaces){
	// find face that owns this node
	int face = n/p_Nfp;

	// load surface geofactors for this face
	const int base = p_Nsgeo*(p_Nfaces*p_Nfp*e + n);
	dfloat nx = sgeo[base+0];
	dfloat ny = sgeo[base+1];
	dfloat nz = sgeo[base+2];
	dfloat sJ = sgeo[base+3];
	dfloat invJ = sgeo[base+4];

	// indices of negative and positive traces of face node
	int id  = e*p_Nfp*p_Nfaces + n;
	int idM = vmapM[id];
	int idP = vmapP[id];

	if(idP<0) idP = idM;
	int qidM = idM*p_Nfields, qidP = idP*p_Nfields;
	
	// load negative and positive trace node values of q
	dfloat uM = q[qidM+0], vM = q[qidM+1], wM = q[qidM+2], pM = q[qidM+3];
	dfloat uP = q[qidP+0], vP = q[qidP+1], wP = q[qidP+2], pP = q[qidP+3];
	
	// apply boundary condition
	int bc = EToB[face+p_Nfaces*e];
	if(bc>0)
	  boundaryConditions3D(bc, time, x[idM], y[idM], z[idM], uM, vM, wM, pM, &uP, &vP, &wP, &pP);
	
	// compute (q^* - q^-)
	dfloat duS = p_half*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	dfloat dvS = p_half*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	dfloat dwS = p_half*(wP-wM) + p_Lambda2*(-nz)*(pP-pM);
	dfloat dpS = p_half*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM)-nz*(wP-wM));

	// evaluate "flux" terms: (sJ/J)*(A*nx+B*ny+C*nz)*(q^* - q^-)
	s_fluxu[n] = invJ*sJ*(-nx*dpS);
	s_fluxv[n] = invJ*sJ*(-ny*dpS);
	s_fluxw[n] = invJ*sJ*(-nz*dpS);
	s_fluxp[n] = invJ*sJ*(-nx*duS-ny*dvS-nz*dwS);
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element 
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
	int id = p_Nfields*(p_Np*e + n);

	// load rhs data from volume fluxes
	dfloat rhsu = rhsq[id];
	dfloat rhsv = rhsq[id+1];
	dfloat rhsw = rhsq[id+2];
	dfloat rhsp = rhsq[id+3];
      
	// rhs += LIFT*((sJ/J)*(A*nx+B*ny+C*nz)*(q^* - q^-))
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  dfloat L = LIFTT[n+m*p_Np];
	  rhsu += L*s_fluxu[m];
	  rhsv += L*s_fluxv[m];
	  rhsw += L*s_fluxw[m];
	  rhsp += L*s_fluxp[m];
	}

	// store incremented rhs
	rhsq[id]   = rhsu;
	rhsq[id+1] = rhsv;
	rhsq[id+2] = rhsw;
	rhsq[id+3] = rhsp;
      }
    }
  }
}
