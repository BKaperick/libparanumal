// Compute Gradient in Strong Form
kernel void insGradientVolumeQuad2D(const dlong Nelements,
                                    const dfloat * restrict vgeo,
                                    const dfloat * restrict D,
                                    const dlong offset,
                                    const dfloat * restrict P,
                                          dfloat * restrict Px,
                                          dfloat * restrict Py){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_P[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            s_P[es][j][i]  = P[id];

            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

            // compute 'r' and 's' derivatives of (q_m) at node n
            dfloat dpdr  = 0.f, dpds  = 0.f;

            occaUnroll(p_Nq)
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[i][n];
                const dfloat Ds = s_D[j][n];

                dpdr += Dr*s_P[es][j][n];
                dpds += Ds*s_P[es][n][i];
              }

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            Px[id] = drdx*dpdr + dsdx*dpds;
            Py[id] = drdy*dpdr + dsdy*dpds;
          }
        }
      }
    }
  }  
}

// taken from the lines if(solverID==1){ ..  }
#if 0
   /* dfloat PPo = 0.f; */                                              \
   /* dfloat to  = time-dt; */                                          \
   /* insGradientBoundaryConditions2D(bc,to, x[idM], y[idM], nx, ny, PM, &PPo); */  \
   /* PP = PP-c0*PPo; */                                                \
#endif

#define surfaceTerms(sk,face,i, j)                                      \
{                                                                       \
  dlong idM, idP;                                                       \
  if(solverID == 1){                                                    \
    idM = vmapM[sk];                                                    \
    idP = vmapP[sk];                                                    \
  } else {                                                              \
    idM = vmapM[sk]+p_Np*index*offset;                                  \
    idP = vmapP[sk]+p_Np*index*offset;                                  \
  }                                                                     \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat  PM = P[idM];                                            \
        dfloat  PP = P[idP];                                            \
                                                                        \
  int bc = EToB[face+p_Nfaces*e];                                       \
  if(bc>0) {                                                            \
    idM = vmapM[sk];                                                    \
    insPressureDirichletConditions2D(bc, time, x[idM], y[idM], nx, ny, PM, &PP);\
    if(solverID==1){                                                    \
      PP = PM;                                                          \
    }                                                                   \
    PP = 2.f*PP - PM;                                                   \
  }                                                                     \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxPx[es][j][i]  = sc*(.5f*nx*(PP-PM));                            \
  s_fluxPy[es][j][i]  = sc*(.5f*ny*(PP-PM));                            \
}

kernel void insGradientSurfaceQuad2D(const dlong Nelements,
                                     const dfloat * restrict sgeo,
                                     const dlong  * restrict vmapM,
                                     const dlong  * restrict vmapP,
                                     const int   * restrict EToB,
                                     const dfloat * restrict x,
                                     const dfloat * restrict y,
                                     const dfloat time,
                                     const dfloat dt,
                                     const dfloat c0,
                                     const dfloat c1,
                                     const dfloat c2,
                                     const int index,
                                     const dlong offset,
                                     const int solverID,
                                     const dfloat * restrict POld,
                                     const dfloat * restrict P,
                                           dfloat * restrict Px,
                                           dfloat * restrict Py){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxPx[p_NblockS][p_Nq][p_Nq];
    shared dfloat s_fluxPy[p_NblockS][p_Nq][p_Nq];

    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          s_fluxPx[es][j][i] = 0.;
          s_fluxPy[es][j][i] = 0.;
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 2
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i;
          dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + i;

          surfaceTerms(sk0,0,i,0     );
          surfaceTerms(sk2,2,i,p_Nq-1);
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + j;
          dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + j;

          surfaceTerms(sk1,1,p_Nq-1,j);
          surfaceTerms(sk3,3,0     ,j);
        }
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            dlong id;
            if (solverID==1) { //no offset
              id = e*p_Np + j*p_Nq + i;
            } else {
              id = (e+index*offset)*p_Np + j*p_Nq + i;
            }

            Px[id] += s_fluxPx[es][j][i];
            Py[id] += s_fluxPy[es][j][i];
          }
        }
      }
    }
  }
}

