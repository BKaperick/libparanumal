
kernel void acousticsUpdate3D_o1(const iint Nelements,
            const iint * restrict Elements,
			      const dfloat dt,	
			      const dfloat rka,
			      const dfloat rkb,
			      const dfloat * restrict rhsq,
			      dfloat * restrict resq,
			      dfloat * restrict q){
				  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<4;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o2(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<10;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o3(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<20;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o4(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<35;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o5(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<56;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o6(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<84;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o7(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<120;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

kernel void acousticsUpdate3D_o8(const iint Nelements,
            const iint * restrict Elements,
            const dfloat dt,  
            const dfloat rka,
            const dfloat rkb,
            const dfloat * restrict rhsq,
            dfloat * restrict resq,
            dfloat * restrict q){
          
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){
    for (iint n=0;n<165;n++;inner0) {  
      const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (iint fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}


kernel void acousticsUpdate3D_wadg_o1(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp1];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp1; ++n; inner0){  
      if (n < 4){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp1;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<4;++i){
        val += cubInterp[n + i*p_cubNp1] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp1;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp1;++n;inner0){
      if (n < 4){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp1;++i){
          rhsp += cubProject[n + i*4] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o2(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp2];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp2; ++n; inner0){  
      if (n < 10){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp2;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<10;++i){
        val += cubInterp[n + i*p_cubNp2] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp2;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp2;++n;inner0){
      if (n < 10){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp2;++i){
          rhsp += cubProject[n + i*10] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o3(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp3];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp3; ++n; inner0){  
      if (n < 20){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp3;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<20;++i){
        val += cubInterp[n + i*p_cubNp3] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp3;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp3;++n;inner0){
      if (n < 20){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp3;++i){
          rhsp += cubProject[n + i*20] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o4(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp4];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp4; ++n; inner0){  
      if (n < 35){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp4;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<35;++i){
        val += cubInterp[n + i*p_cubNp4] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp4;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp4;++n;inner0){
      if (n < 35){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp4;++i){
          rhsp += cubProject[n + i*35] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o5(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp5];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp5; ++n; inner0){  
      if (n < 56){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp5;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<56;++i){
        val += cubInterp[n + i*p_cubNp5] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp5;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp5;++n;inner0){
      if (n < 56){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp5;++i){
          rhsp += cubProject[n + i*56] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o6(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp6];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp6; ++n; inner0){  
      if (n < 84){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp6;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<84;++i){
        val += cubInterp[n + i*p_cubNp6] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp6;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp6;++n;inner0){
      if (n < 84){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp6;++i){
          rhsp += cubProject[n + i*84] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o7(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp7];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp7; ++n; inner0){  
      if (n < 120){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp7;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<120;++i){
        val += cubInterp[n + i*p_cubNp7] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp7;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp7;++n;inner0){
      if (n < 120){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp7;++i){
          rhsp += cubProject[n + i*120] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

kernel void acousticsUpdate3D_wadg_o8(const iint Nelements,
           const iint * restrict Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat * restrict rhsq,
           dfloat * restrict resq,
           dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_p[p_cubNp8];
    exclusive dfloat r_p;

    for(iint n=0; n < p_cubNp8; ++n; inner0){  
      if (n < 165){
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(iint n=0;n<p_cubNp8;++n;inner0){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<165;++i){
        val += cubInterp[n + i*p_cubNp8] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_cubNp8;++n;inner0){
      s_p[n] = r_p;
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(iint n=0;n<p_cubNp8;++n;inner0){
      if (n < 165){
        // Extract velocity rhs
        const iint id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp8;++i){
          rhsp += cubProject[n + i*165] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}
