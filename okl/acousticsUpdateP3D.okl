
@kernel void acousticsUpdateP3D(const int Nelements,
            @restrict const  int *  Elements,
			      const dfloat dt,	
			      const dfloat rka,
			      const dfloat rkb,
			      @restrict const  dfloat *  rhsq,
			      @restrict dfloat *  resq,
			      @restrict dfloat *  q){
				  
  // Low storage Runge Kutta time step update
  for(int et=0;et<Nelements;++et;@outer(0)){
    for (int n=0;n<p_Np;n++;@inner(0)) {  
      const int id = p_Nfields*(Elements[et]*p_NpMax + n);
      for (int fld=0;fld<p_Nfields;fld++) {
        dfloat resqn = resq[id+fld];
        resqn = rka*resqn + dt*rhsq[id+fld];
        resq[id+fld] = resqn;
        q[id+fld] += rkb*resqn;
      }
    }
  }
}

@kernel void acousticsUpdateP3D_wadg(const int Nelements,
           @restrict const  int *  Elements,
           const dfloat dt, 
           const dfloat rka,
           const dfloat rkb,
           @restrict const  dfloat *  cubInterp,
           @restrict const  dfloat *  cubProject,
           @restrict const  dfloat *  c2,
           @restrict const  dfloat *  rhsq,
           @restrict dfloat *  resq,
           @restrict dfloat *  q){
  
  // Low storage Runge Kutta time step update
  for(int et=0;et<Nelements;++et;@outer(0)){  // for all elements
    @shared dfloat s_p[p_cubNp];
    @exclusive dfloat r_p;

    for(int n=0; n < p_cubNp; ++n; @inner(0)){  
      if (n < p_Np){
        const int id = p_Nfields*(Elements[et]*p_NpMax + n);
        s_p[n] = rhsq[id + 3]; // extract pressure rhs
      }
      // Initialize register variable
      r_p = 0.f;
    }
    @barrier("local");

    // Interpolate rhs to cubature nodes
    for(int n=0;n<p_cubNp;++n;@inner(0)){
      // Prefetch value of c2
      const dfloat c2n = c2[n + Elements[et]*p_cubNpMax];
      
      dfloat val = 0.f;
      for (int i=0;i<p_Np;++i){
        val += cubInterp[n + i*p_cubNp] * s_p[i];
      }

      // Multiply result by wavespeed c2 at cubature node
      r_p = val * c2n;
    }
    @barrier("local");

    // Move temporary result back to @shared memory
    for(int n=0;n<p_cubNp;++n;@inner(0)){
      s_p[n] = r_p;
    }
    @barrier("local");
    
    // Increment solution, project result back down
    for(int n=0;n<p_cubNp;++n;@inner(0)){
      if (n < p_Np){
        // Extract velocity rhs
        const int id = p_Nfields*(Elements[et]*p_NpMax + n);
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[id + 0];
        rhsqn[1] = rhsq[id + 1];
        rhsqn[2] = rhsq[id + 2];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        for (int i=0;i<p_cubNp;++i){
          rhsp += cubProject[n + i*p_Np] * s_p[i];
        }
        //rhsqn[2] = rhsq[id + 2];
        rhsqn[3] = rhsp;

        // Increment solutions
        for (int fld = 0; fld < p_Nfields; ++fld){ 
          dfloat resqn = resq[id + fld];
          resqn = rka*resqn + dt*rhsqn[fld];
          resq[id + fld] = resqn;
          q[id + fld] += rkb*resqn;
        }
      }      
    }
  }
}

