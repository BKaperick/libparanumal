//
#define UXID 0
#define UYID 1
#define PRID 2

#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3  
#define  JID 4
#define JWID 5

/* offsets for nx, ny, sJ, 1/J */
#define NXID 0  
#define NYID 1  
#define SJID 2  
#define IJID 3  
#define WSJID 4
#define IHID 5



// void boundaryConditionsIpdg2D(const iint bc,
// 			                           const dfloat  t,    const dfloat  x, const dfloat  y,
// 			                           const dfloat  nx,   
// 			                           const dfloat  ny,
// 			                                 dfloat * restrict prB, 
// 			                                 dfloat * restrict prnB){

//    dfloat nu   = 1.0f/1.0f;
//    dfloat lambda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

//   if(bc==1){ // Wall 
//     // enforce del P/ dn = nx*dp/dx + ny/dp/dy
//     *prnB = nx*(-lambda*occaExp(2.0f*lambda*x)) + 0.f; 
//   }
//   if(bc==2){ // Inflow // for Kowansny use definition of del(p)/dn
//     *prnB = nx*(-lambda*occaExp(2.0f*lambda*x)) + 0.f; 
//   }
//   if(bc==3){ // Outflow
//   // Enforce P at outflow, Drichlet for pressure 
//   	 *prB = 0.5f*(1.0f - occaExp(2.0f*lambda*x)); 
//   }
// }

// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcing2D(const iint Nelements,
																		const dfloat * restrict vgeo,
																		const dfloat * restrict MM,
																	  const dfloat dt,
												            const dfloat g0,
																		      dfloat * restrict U){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
   // Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_U[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id  = e*p_Np+n;
					s_U[es][n]     = U[id];         
				}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
   // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
			iint e = eo+es; // element in block
			if(e<Nelements){	
			 const dfloat J    = vgeo[e*p_Nvgeo +  JID];  
				dfloat rhs = 0.f; 
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat mm = MM[n+i*p_Np];
					rhs += J*mm*s_U[es][i];	
				}
				const iint id = e*p_Np+n;
				// U[id] = J* p_nu*g0*p_idt*rhs; 
				U[id] = g0*p_idt*rhs; 
	     }
      }
    }
 }
}




// // Actually solves for Pr increamnet not presssure
// kernel void insPoissonRhsIpdgBC2D(  const iint Nelements,
// 				                            const dfloat * restrict sgeo,
// 				                            const dfloat * restrict vgeo,
// 																    const dfloat * restrict DrT,
// 																    const dfloat * restrict DsT,
// 																    const dfloat * restrict FMMT,
// 				                            const iint   * restrict vmapM,
// 				                            const iint   * restrict vmapP,
// 				                            const iint   * restrict EToB,
// 				                            const dfloat time,
// 				                            const dfloat dt, 
// 				                            const dfloat tau,
// 				     										    const dfloat * restrict x,
// 				    									      const dfloat * restrict y,
// 				     										    const dfloat * restrict Pr,
// 				                                  dfloat * restrict rhsPr
// 				                                  ){
// for(int e=0;e<Nelements;++e;outer0){
// 	// shared storage for flux terms
// 	  shared  dfloat s_prB[p_Nfp*p_Nfaces];
// 	  shared  dfloat s_prnB[p_Nfp*p_Nfaces];
//     shared  dfloat s_nxprB[p_Nfp*p_Nfaces];
//     shared  dfloat s_nyprB[p_Nfp*p_Nfaces];
//     //
//     shared  dfloat s_Lpr[p_Np];
// 	  shared  dfloat s_Lprn[p_Np];
// 	  shared  dfloat s_Lnxpr[p_Np];
// 	  shared  dfloat s_Lnypr[p_Np];
	 
//    for(iint n=0;n<p_maxNodes;++n;inner0){
// 	      if(n<p_Nfp*p_Nfaces){
// 	      	// Find face index and bc type
// 					 iint face     = n/p_Nfp;
// 					 iint bc       = EToB[face+p_Nfaces*e];
// 					  //
// 					  s_prB[n]      = 0.f;
// 						s_prnB[n]     = 0.f;
// 						s_nxprB[n]    = 0.f;
// 						s_nyprB[n]    = 0.f;
// 					  //
// 	        if(bc){ 
// 						//
// 						const iint id  = n + e*p_Nfaces*p_Nfp;
// 						const iint idM = vmapM[id];										
//             // load surface geofactors for this face
// 						iint sid    = p_Nsgeo*(e*p_Nfaces+face);
// 						dfloat nx   = sgeo[sid+p_NXID];
// 						dfloat ny   = sgeo[sid+p_NYID];
// 						dfloat sJ   = sgeo[sid+p_SJID];
// 						dfloat hinv = sgeo[sid+p_IHID];
// 						//
// 						dfloat prp  = 0.f; 
//             dfloat prpo = 0.f;     
//             // Initialize external Neumann for pr
//             dfloat  prnp = 0.f, prnpo = 0.f;
//            // Pressure BC at t^(n+1)
//            boundaryConditionsIpdg2D(bc, time, x[idM], y[idM], nx, ny, 
//             	                       &prp, &prnp);
//            // Pressure BC at t^n
//            dfloat timeo = time-dt;  
//            boundaryConditionsIpdg2D(bc, timeo, x[idM], y[idM], nx, ny, 
//             	                      &prpo, &prnpo);
           
//             // No that if Pressure BC is not time dependent, all homogenoues bcs
//             prp  -= prpo; // increment in pressure bc
//             prnp -= prnpo;         
// 					 // Hold RHS information and multiply with sJ
// 						s_prB[n]      = sJ*prp*hinv*tau; // stabilization term
// 						s_prnB[n]     = sJ*prnp;          // external neumann data
// 						s_nxprB[n]    = sJ*nx*prp;        
// 						s_nyprB[n]    = sJ*ny*prp;
//     		}
//   		}
// 		}

// 		barrier(localMemFence);

//    for(int n=0;n<p_Nmax;++n;inner0){
//       if(n<p_Np){
// 	      dfloat prb = 0.f,  prnb =0.f;
// 	      dfloat nxpr = 0.f, nypr =0.f;  
// 		    // lift remaining surface terms
// 		    occaUnroll(p_NfacesNfp)
// 		    for(int i=0;i<p_NfacesNfp;++i){
// 		    	 const dfloat FM = FMMT[n+i*p_Np];
// 		       prb   += FM*s_prB[i];
// 		       prnb  += FM*s_prnB[i];
//            nxpr  += FM*s_nxprB[i];
// 		       nypr  += FM*s_nyprB[i];
// 		     }	
// 				s_Lpr[n]      = prb;
// 				s_Lprn[n]     = prnb;
// 				s_Lnxpr[n]    = nxpr;
// 		    s_Lnypr[n]    = nypr;
// 	      }
// 	    } 

// 	     barrier(localMemFence);
   

//    // n . grad P
//    for(int n=0;n<p_Nmax;++n;inner0){
//       if(n<p_Np){
// 				const int gid = e*p_Nvgeo;
// 				const dfloat drdx = vgeo[gid + p_RXID];
// 				const dfloat drdy = vgeo[gid + p_RYID];
// 				const dfloat dsdx = vgeo[gid + p_SXID];
// 				const dfloat dsdy = vgeo[gid + p_SYID];
// 				//
//         dfloat drnxpr= 0.f, drnypr= 0.f;
//         dfloat dsnxpr= 0.f, dsnypr= 0.f;
// 		    // lift remaining surface terms
// 		    occaUnroll(p_Np)
// 		    for(int i=0;i<p_Np;++i){
// 		    	const dfloat Drni = DrT[i+n*p_Np]; // Take transpose was DrT[n+i*p_Np]
// 					const dfloat Dsni = DsT[i+n*p_Np]; // Take transpose was DsT[i+n*p_Np]

// 					drnxpr += Drni*s_Lnxpr[n];
// 					dsnxpr += Dsni*s_Lnxpr[n];
// 					//
// 					drnypr += Drni*s_Lnypr[n];
// 					dsnypr += Dsni*s_Lnypr[n];
// 				}

//         dfloat dndpr = (drdx*drnxpr + dsdx*dsnxpr + drdy*drnypr + dsdy*dsnypr);
//         const iint id = e*p_Np+n;
// 				rhsPr[id] +=  s_Lpr[n] + s_Lprn[n] - dndpr;
// 			}

//    }

//   }
// }








// kernel void insPoissonRhsSurface2D(const iint Nelements,
// 		         const dfloat dt,
// 	           const dfloat g0,
// 				     const dfloat * restrict sgeo,
// 				     const dfloat * restrict FMMT,
// 				     const iint   * restrict vmapM,
// 				     const iint   * restrict vmapP,
// 				     const iint   * restrict EToB,
// 				     const dfloat time,
// 				     const dfloat * restrict x,
// 				     const dfloat * restrict y,
// 				     const dfloat * restrict Ux,
// 				     const dfloat * restrict Uy,
// 				           dfloat * restrict rhsPr){ 
//   // for all elements
//   for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

//     shared dfloat s_fluxU[p_NblockS][p_Nfp*p_Nfaces];
//      // for all face nodes of all elements
//     for(iint es=0;es<p_NblockS;++es;inner1){
//       for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
// 	   iint e = eo + es;
// 	    if(e<Nelements){
// 	      if(n<p_Nfp*p_Nfaces){
// 		    // find face that owns this node
// 		    iint face = n/p_Nfp;
// 		    // load surface geofactors for this face
// 		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
// 		    dfloat nx   = sgeo[sid+NXID];
// 		    dfloat ny   = sgeo[sid+NYID];
// 		    dfloat sJ   = sgeo[sid+SJID];		   
// 		    // indices of negative and positive traces of face node
// 		    iint id  = e*p_Nfp*p_Nfaces + n;
// 		    iint idM = vmapM[id];
// 		    iint idP = vmapP[id];

// 		   if(idP<0) idP = idM;
		  
// 				// load negative and positive trace node values of q
// 				dfloat  uxm = Ux[idM];
// 				dfloat  uxp = Ux[idP];
// 				//
// 				dfloat  uym = Uy[idM];
// 				dfloat  uyp = Uy[idP];
		   
// 		    // apply boundary condition
// 		    iint bc = EToB[face+p_Nfaces*e];
// 		    // if(bc>0)
// 		      // boundaryConditionsRhs2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym,&uxp, &uyp);

// 		    // !!!!!!!!!!! Use just Central Flux, may change !!!!!!!!!!!
// 					s_fluxU[es][n] = 0.5f*sJ*(nx*(uxp-uxm) + ny*(uyp-uym)); // Multiplied with mass matrix no invJ
//        	 }
//     		}
// 			}
// 		}
    
   
//     // wait for all shared memory writes of the previous inner loop to complete
//     barrier(localMemFence);

//     // for each node in the element
//     for(iint es=0;es<p_NblockS;++es;inner1){
// 			for(iint n=0;n<p_maxNodes;++n;inner0){
// 				iint e = eo + es;
// 					if(e<Nelements){
// 						if(n<p_Np){
// 							iint id = e*p_Np + n;

// 							dfloat rhspr = rhsPr[id];
// 							// Lift
// 							occaUnroll(p_NfacesNfp)
// 							for(int m=0;m<p_Nfaces*p_Nfp;++m){
// 								dfloat FM = FMMT[n+m*p_Np];
// 								rhspr    += FM*s_fluxU[es][m];
// 					}
//           //  rhsu = -grad(p) 
// 					rhsPr[id] = g0*p_idt*rhspr; 
// 				  }
// 				}
//       }
//     }
//   }


// }





			




