kernel void insPoissonRhsCurlSS2D(const iint Nelements,
        const iint offset, 
        const dfloat * restrict vgeo,
        const dfloat * restrict DrT,
        const dfloat * restrict DsT,
        const dfloat * restrict U,
        const dfloat * restrict V,
              dfloat * restrict WX,
              dfloat * restrict WY){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    // for all elements
    shared dfloat s_U[p_NblockV][p_Np];
    shared dfloat s_V[p_NblockV][p_Np];
    shared dfloat s_Wz[p_NblockV][p_Np];

    exclusive dfloat drdx=0.f, dsdx=0.f; 
    exclusive dfloat drdy=0.f, dsdy=0.f;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
          s_U[es][n]  = U[n + (e+offset)*p_Np];
          s_V[es][n]  = V[n + (e+offset)*p_Np];
          // prefetch geometric factors (constant on triangle)
          drdx = vgeo[e*p_Nvgeo + p_RXID];
          drdy = vgeo[e*p_Nvgeo + p_RYID];
          dsdx = vgeo[e*p_Nvgeo + p_SXID];
          dsdy = vgeo[e*p_Nvgeo + p_SYID];
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
          dfloat dudr  = 0.f, duds  = 0.f;
          dfloat dvdr  = 0.f, dvds  = 0.f;
          occaUnroll(p_Np)
            for(iint i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];
              //
              dudr  += Drni*s_U[es][i];
              duds  += Dsni*s_U[es][i];
              dvdr  += Drni*s_V[es][i];
              dvds  += Dsni*s_V[es][i];
            }
          // curl(U,V) = dv/dx- du/dy
          s_Wz[es][n] = (drdx*dvdr + dsdx*dvds) - (drdy*dudr + dsdy*duds);              
        }
      }
    }

    
    barrier(localMemFence);

     // curl(Wz) = dWz/dy i - dWz/dx j 
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
          dfloat dwzdr  = 0.f, dwzds  = 0.f;
          occaUnroll(p_Np)
            for(iint i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];
              //
              dwzdr  += Drni*s_Wz[es][i];
              dwzds  += Dsni*s_Wz[es][i];
            }         
           const iint id = n + e*p_Np;
           WX[id] =   drdy*dwzdr + dsdy*dwzds;
           WY[id] = -(drdx*dwzdr + dsdx*dwzds);             
        }
      }
    }

  }
}


kernel void insPoissonRhsNeumann2D(const iint Nelements,
          const iint index,
          const iint offset,
          const dfloat dt,
          const dfloat a0,
          const dfloat a1,
          const dfloat a2,
          const dfloat * restrict sgeo,
          const dfloat * restrict LIFTT,
          const iint   * restrict vmapM,
          const iint   * restrict vmapP,
          const iint   * restrict EToB,
          const dfloat time,
          const dfloat * restrict x,
          const dfloat * restrict y,
          const dfloat * restrict NU,
          const dfloat * restrict NV,
          const dfloat * restrict WX,
          const dfloat * restrict WY,
                dfloat * restrict WN,
                dfloat * restrict rhsP){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxP[p_NblockS][p_Nfp*p_Nfaces];
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
          // find face that owns this node
            iint face = n/p_Nfp;

            s_fluxP[es][n] = 0.f; // Initiliaze all rhs to zero

            // get boundary condition type
            iint bc = EToB[face+p_Nfaces*e];

            if((bc==1) || (bc==2)){ // Pressure Neumann 
              // load surface geofactors for this face
              iint sid    = p_Nsgeo*(e*p_Nfaces+face);
              dfloat nx   = sgeo[sid+p_NXID];
              dfloat ny   = sgeo[sid+p_NYID];
              dfloat sJ   = sgeo[sid+p_SJID];
              dfloat invJ = sgeo[sid+p_IJID];

              // indices of negative and positive traces of face node
              iint id  = e*p_Nfp*p_Nfaces + n;

              //hard coded for 3 stages
              const int index0 = (index+0)%3; //current time step
              const int index1 = (index+2)%3; //back one step
              const int index2 = (index+1)%3; //back two steps

              const iint idm  = vmapM[id]; 

              const iint idv0 = idm + index0*offset*p_Np;
              const iint idv1 = idm + index1*offset*p_Np;
              const iint idv2 = idm + index2*offset*p_Np;
              
              //
              const iint idf0 = id + index0*offset*p_Nfp*p_Nfaces;
              const iint idf1 = id + index1*offset*p_Nfp*p_Nfaces;
              const iint idf2 = id + index2*offset*p_Nfp*p_Nfaces;

              //compute new normal of curl field
              dfloat wn0 = nx*WX[idm] + ny*WY[idm];
              
              WN[idf0]   = wn0; // Update Normal of worticity, just for consistency
              dfloat wn1 = WN[idf1]; // read tn-1
              dfloat wn2 = WN[idf2]; // read tn-2

              dfloat dpdt = 0.f; 

              insPoissonNeumannTimeDerivative2D(bc, time, x[idm], y[idm],&dpdt);
             
              const dfloat sc = invJ*sJ ; // multiplied with M^-1
              s_fluxP[es][n] = -sc*(  nx*( dpdt + a0*NU[idv0] + a1*NU[idv1] + a2*NU[idv2])
                                    + ny*( dpdt + a0*NV[idv0] + a1*NV[idv1] + a2*NV[idv2]) 
                                    + p_nu*( a0*wn0 + a1*wn1 + a2*wn2)
                                   );
            }
         }
        }
      }
    }


    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            dfloat rhsp = 0.f;
            // Lift
            occaUnroll(p_NfacesNfp)
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];
                rhsp  += L*s_fluxP[es][m];  
              }
       
            rhsP[n + e*p_Np] = rhsp;
          }
        }
      }
    }


  }
}


// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcingSS2D(const iint Nelements,
                                     const dfloat dt,
                                     const dfloat g0,
                                     const dfloat * restrict vgeo,
                                     const dfloat * restrict MM,
                                     const dfloat * restrict divU,
                                           dfloat * restrict rhsU){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_rhs[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
          const iint id = e*p_Np+n;
          const dfloat J = vgeo[e*p_Nvgeo + p_JID];
          s_rhs[es][n] = J*(-g0/dt* divU[id] + rhsU[id]);
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
          dfloat rhsu = 0.f;
          occaUnroll(p_Np)
          for(iint i=0;i<p_Np;++i){
            const dfloat M = MM[n+i*p_Np];
            rhsu += M*s_rhs[es][i];
          }

          const iint id = e*p_Np+n;
          rhsU[id] = rhsu;
        }
      }
    }

  }
}



// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcing2D(const iint Nelements,
				   const dfloat * restrict vgeo,
				   const dfloat * restrict MM,
				   const dfloat dt,
				   const dfloat g0,
				    dfloat * restrict rhs){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_rhs[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){
      	  const iint id = e*p_Np+n;
      	  s_rhs[es][n] = rhs[id];
      	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){
      	  const dfloat J = vgeo[e*p_Nvgeo + p_JID];
      	  dfloat rhsn = 0.f;

          occaUnroll(p_Np)
    	    for(iint i=0;i<p_Np;++i){
    	      const dfloat M = MM[n+i*p_Np];
    	      rhsn += M*s_rhs[es][i];
    	    }

          const iint id = e*p_Np+n;
      	  rhs[id] = -J*g0*rhsn/dt;
      	}
      }
    }
  }
}




kernel void insPoissonUpdate2D(const iint Nelements,
                               const dfloat dt,
                               const dfloat g0,
                               const dfloat * restrict Px,
                               const dfloat * restrict Py,
                                    dfloat * restrict Ut,
                                    dfloat * restrict Vt){

  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint id  = n + e*p_Np;
      // // Update Velocity u = u - dt/g0 * grad(Pr)
      Ut[id] -= dt*Px[id]/g0;
      Vt[id] -= dt*Py[id]/g0;
    }
  }
}


// Actually solves for Pr increamnet not presssure
kernel void insPoissonRhsIpdgBC2D(const int Nelements,
            const iint pressure_solve,
            const iint * restrict vmapM,
            const iint * restrict vmapP,
            const dfloat tau,
            const dfloat time,
            const dfloat dt,
            const dfloat * restrict x,
            const dfloat * restrict y,
            const dfloat * restrict vgeo,
            const dfloat * restrict sgeo,
            const iint   * restrict EToB,
            const dfloat * restrict DrT,
            const dfloat * restrict DsT,
            const dfloat * restrict LIFTT,
            const dfloat * restrict MM,
                  dfloat * restrict rhsP){
  for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dpdx[p_Np];
    shared  dfloat s_dpdy[p_Np];
    shared  dfloat s_lapp[p_Np];

    shared  dfloat s_nxdp[p_NfacesNfp];
    shared  dfloat s_nydp[p_NfacesNfp];

    shared  dfloat s_lappflux[p_NfacesNfp];
    shared  dfloat s_Lnxdp[p_Np];
    shared  dfloat s_Lnydp[p_Np];

    exclusive iint idM, bcsum;
    exclusive dfloat nx, ny, sJ, invJ, hinv;
    
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id];          
     
        const iint face = n/p_Nfp;
        dfloat dpdxP=0, dpdyP=0, pP=0;        
        // load surface geofactors for this face
        iint sid = p_Nsgeo*(e*p_Nfaces+face);
        nx = sgeo[sid+p_NXID];
        ny = sgeo[sid+p_NYID];
        sJ = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*e];
        if(bc>0) {
          insPoissonBoundaryConditions2D(bc,time, dt, x[idM], y[idM], nx, ny, &pP, &dpdxP, &dpdyP);
          if(pressure_solve==0){ // if the pressure increment is in use
            dfloat pPm1, dpdxPm1, dpdyPm1;
            insPoissonBoundaryConditions2D(bc,time-dt, dt, x[idM], y[idM], nx, ny, &pPm1, &dpdxPm1, &dpdyPm1);
            pP = pP - pPm1;
            dpdxP = dpdxP - dpdxPm1;
            dpdyP = dpdyP - dpdyPm1;
          }
        }
        const dfloat dp = pP;
        const dfloat hlf = 1.0f;

        s_nxdp[n] = hlf*sJ*invJ*nx*dp;
        s_nydp[n] = hlf*sJ*invJ*ny*dp;

        s_lappflux[n] = hlf*sJ*invJ*(-nx*(dpdxP)-ny*(dpdyP) -tau*hinv*dp);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        const int gid = e*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdp = 0;
        dfloat Lnydp = 0;

        occaUnroll(p_NfacesNfp)
          for(iint i=0;i<p_NfacesNfp;++i){
            Lnxdp += LIFTT[n+i*p_Np]*s_nxdp[i];
            Lnydp += LIFTT[n+i*p_Np]*s_nydp[i];
          }

        dfloat dpdx = Lnxdp;
        dfloat dpdy = Lnydp;

        s_dpdx[n] = drdx*dpdx + drdy*dpdy; // abuse of notation
        s_dpdy[n] = dsdx*dpdx + dsdy*dpdy;

        s_Lnxdp[n] = Lnxdp;
        s_Lnydp[n] = Lnydp;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        iint id = idM%p_Np;
        s_lappflux[n] += sJ*invJ*(nx*s_Lnxdp[id]+ny*s_Lnydp[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i) {
          lapr += DrT[n+i*p_Np]*s_dpdx[i];
          laps += DsT[n+i*p_Np]*s_dpdy[i];
        }

        s_lapp[n] = -(lapr+laps);
      }

    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        dfloat lap = 0;
        // lift remaining surface terms
        occaUnroll(p_NfacesNfp)
        for(int i=0;i<p_NfacesNfp;++i){
          lap += LIFTT[n+i*p_Np]*s_lappflux[i];
        }
        s_lapp[n] += lap;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        const dfloat J = vgeo[e*p_Nvgeo + p_JID];

        dfloat Mlapp = 0;

        // multiply by mass matrix
        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i){
          Mlapp += MM[n+i*p_Np]*s_lapp[i];
        }

        const iint id = e*p_Np+n;
        rhsP[id] -=  J*Mlapp;
      }
    }

  }
}

//RHS contributions for continuous solver
kernel void insPoissonRhsBC2D(const int Nelements,
                              const iint pressure_solve,
                              const dfloat * restrict ggeo,
                              const dfloat * restrict sgeo,
                              const dfloat * restrict SrrT,
                              const dfloat * restrict SrsT,
                              const dfloat * restrict SsrT,
                              const dfloat * restrict SssT,
                              const dfloat * restrict MM,
                              const iint   * restrict vmapM,
                              const dfloat * restrict sMT,
                              const dfloat time,
                              const dfloat dt,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const int    * restrict mapB,
                              dfloat  * restrict rhsP){
  
  for(iint e=0;e<Nelements;e++;outer0){
    shared dfloat s_q[p_Np];
    shared dfloat s_ndq[p_Nfp*p_Nfaces];

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        s_q[n] = 0.;
      }
      if(n<p_NfacesNfp){
        s_ndq[n] = 0.;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        const iint idM = vmapM[id];          
        const iint nid = idM%p_Np; 

        const iint face = n/p_Nfp;

        dfloat dpdxP=0, dpdyP=0, pP=0;
        
        // load surface geofactors for this face
        const iint sid = p_Nsgeo*(e*p_Nfaces+face);
        const dfloat nx = sgeo[sid+p_NXID];
        const dfloat ny = sgeo[sid+p_NYID];
        const dfloat sJ = sgeo[sid+p_SJID];

        const int bc = mapB[idM];
        if(bc>0) {
          insPoissonBoundaryConditions2D(bc,time, dt, x[idM], y[idM], nx, ny, &pP, &dpdxP, &dpdyP);
          if(pressure_solve==0){ // if the pressure increment is in use
            dfloat pPm1, dpdxPm1, dpdyPm1;
            insPoissonBoundaryConditions2D(bc,time-dt, dt, x[idM], y[idM], nx, ny, &pPm1, &dpdxPm1, &dpdyPm1);
            pP = pP - pPm1;
            dpdxP = dpdxP - dpdxPm1;
            dpdyP = dpdyP - dpdyPm1;
          }
        } 

        s_q[nid] = pP;
        s_ndq[n] = sJ*(nx*dpdxP + ny*dpdyP);
      }
    }

    barrier(localMemFence);
    
    for(int n=0;n<p_maxNodes;++n;inner0){ 
      if(n<p_Np){
        //volume Dirichlet data
        const iint id = n + e*p_Np;
        const iint gid = e*p_Nggeo;
        const dfloat Grr = ggeo[gid + p_G00ID];
        const dfloat Grs = ggeo[gid + p_G01ID];
        const dfloat Gss = ggeo[gid + p_G11ID];
        const dfloat J   = ggeo[gid + p_GWJID];

        dfloat qrr = 0.;
        dfloat qrs = 0.;
        dfloat qsr = 0.;
        dfloat qss = 0.;
        dfloat qM = 0.;

        occaUnroll(p_Np)
          for (int k=0;k<p_Np;k++) {
            qrr += SrrT[n+k*p_Np]*s_q[k];
            qrs += SrsT[n+k*p_Np]*s_q[k];
            qsr += SsrT[n+k*p_Np]*s_q[k];
            qss += SssT[n+k*p_Np]*s_q[k];
            qM  += MM[n+k*p_Np]*s_q[k];
          }

        dfloat Lndq = 0;            
        // surface mass * surface terms
        occaUnroll(p_NfacesNfp)
          for(int i=0;i<p_NfacesNfp;++i){
            Lndq += sMT[n+i*p_Np]*s_ndq[i];
          }

        rhsP[id] -= Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss - Lndq;
      }
    }
  }
}

kernel void insPoissonAddBCKernel(const int Nelements,
                              const int pressure_solve,
                              const dfloat time,
                              const dfloat dt,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const int    * restrict mapB,
                              dfloat  * restrict p){
  
  for(iint e=0;e<Nelements;e++;outer0){
    for(int n=0;n<p_Np;++n;inner0){
      const iint id = n+e*p_Np;
      const int bc = mapB[n+e*p_Np];

      dfloat dpdxP=0, dpdyP=0, pP=0;

      if(bc>0) {
        insPoissonBoundaryConditions2D(bc,time, dt, x[idM], y[idM], nx, ny, &pP, &dpdxP, &dpdyP);
        if(pressure_solve==0){ // if the pressure increment is in use
          dfloat pPm1, dpdxPm1, dpdyPm1;
          insPoissonBoundaryConditions2D(bc,time-dt, dt, x[idM], y[idM], nx, ny, &pPm1, &dpdxPm1, &dpdyPm1);
          pP = pP - pPm1;
          dpdxP = dpdxP - dpdxPm1;
          dpdyP = dpdyP - dpdyPm1;
        }
        p[id] += pP;
      }    
    }
  }
}



// kernel void insPoissonRhsForcingSS2D(const iint Nelements,
//         const dfloat dt,
//         const dfloat g0, 
//         const dfloat * restrict vgeo,
//         const dfloat * restrict DrT,
//         const dfloat * restrict DsT,
//         const dfloat * restrict MM,
//         const dfloat * restrict Ut,
//         const dfloat * restrict Vt,
//               dfloat * restrict rhsP){

//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
//     // for all elements
//     shared dfloat s_U[p_NblockV][p_Np];
//     shared dfloat s_V[p_NblockV][p_Np];
//     shared dfloat s_rhsP[p_NblockV][p_Np];
    
//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
//         iint e = eo+es; // element in block
//         if(e<Nelements){
//           s_U[es][n]  = Ut[n + e*p_Np];
//           s_V[es][n]  = Vt[n + e*p_Np];
//         }
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
//         iint e = eo+es; // element in block
//         if(e<Nelements){
          
//           // prefetch geometric factors (constant on triangle)
//           const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//           const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//           const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//           const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

//           const dfloat J    = vgeo[e*p_Nvgeo + p_JID];

//           dfloat dudr  = 0.f, duds  = 0.f;
//           dfloat dvdr  = 0.f, dvds  = 0.f;
//           occaUnroll(p_Np)
//             for(iint i=0;i<p_Np;++i){
//               const dfloat Drni = DrT[n+i*p_Np];
//               const dfloat Dsni = DsT[n+i*p_Np];
//               //
//               dudr  += Drni*s_U[es][i];
//               duds  += Dsni*s_U[es][i];
//               dvdr  += Drni*s_V[es][i];
//               dvds  += Dsni*s_V[es][i];
//             }
//           //
//           dfloat divu = (drdx*dudr + dsdx*duds) + (drdy*dvdr + dsdy*dvds); 
//          // read previosuly computed artifical Neumann data
//           dfloat rhsNeumann = rhsP[e*p_Np +n];  

//           s_rhsP[es][n] = J*(-g0/dt*divu + rhsNeumann); 
//         }
//       }
//     }

//      // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     // Multiply with Mass Matrix
//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
//         iint e = eo+es; // element in block
//         if(e<Nelements){
//           dfloat rhsp = 0.f;
//           occaUnroll(p_Np)
//           for(iint i=0;i<p_Np;++i){
//             const dfloat M = MM[n+i*p_Np];
//             rhsp += M*s_rhsP[es][i];
//           }

//           const iint id = e*p_Np+n;
//           rhsP[id] = rhsp;
//         }
//       }
//     }

//   }
// }

