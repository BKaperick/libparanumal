//
#define UXID 0
#define UYID 1

#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3  
#define  JID 4
#define JWID 5

/* offsets for nx, ny, sJ, 1/J */
#define NXID 0  
#define NYID 1  
#define SJID 2  
#define IJID 3  
#define WSJID 4
#define IHID 5



void boundaryConditionsIpdg2D(const iint bc,
			                           const dfloat  t,    const dfloat  x, const dfloat  y,
			                           const dfloat  nx,   
			                           const dfloat  ny,
			                                 dfloat * restrict prB, 
			                                 dfloat * restrict prnB){

	 dfloat nu   = 1.0/40.0;
   dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

  if(bc==1){ // Wall 
    // enforce del P/ dn = nx*dp/dx + ny/dp/dy
    *prnB = nx*(-lamda*occaExp(2.0f*lamda*x)) + 0.f; 
  }
  if(bc==2){ // Inflow
    *prnB = nx*(-lamda*occaExp(2.0f*lamda*x)) + 0.f; 
  }
  if(bc==3){ // Outflow
  // Enforce P at outflow, Drichlet for pressure 
  	 *prB = 0.5f*(1.0f - occaExp(2.0f*lamda*x)); 
  }
   
   if(bc==4){ // Slip
    

  }

}

void boundaryConditionsRhs2D(const iint bc,
			              const dfloat  t,    const dfloat  x, const dfloat  y,
			              const dfloat  nx,   const dfloat  ny,
			              const dfloat  uxM,  const dfloat  uyM,
			                    dfloat * restrict uxB, dfloat * restrict uyB){

  if(bc==1){ // Wall 
    *uxB = 0.f; 
    *uyB = 0.f;
  }
  if(bc==2){ // Inflow
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
  if(bc==3){ // Outflow 
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;
  	//
    *uxB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uyB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
}


// Computes volume contribution of div(UI)
kernel void insPoissonRhsVolume2D(const iint Nelements,
																		const dfloat * restrict vgeo,
																		const dfloat * restrict DrT,
																		const dfloat * restrict DsT,
																		const dfloat * restrict MM, 
																		const dfloat * restrict U,
																		      dfloat * restrict rhsPr){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
   // Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_Ux[p_NblockV][p_Np];
   shared dfloat s_Uy[p_NblockV][p_Np];
   shared dfloat s_FU[p_NblockV][p_Np];
   // Hold Pressure on Shared
   shared dfloat s_Pr[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id = e*p_Np+n;
					const dfloat ux = U[id + UXID*p_NtotalDofs];
					const dfloat uy = U[id + UYID*p_NtotalDofs];
					//
					s_Ux[es][n] = ux;
					s_Uy[es][n] = uy;          
				}
      }
    }

     // Make sure all node data is loaded into shared
    barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
			iint e = eo+es; // element in block
			if(e<Nelements){	  
			  // prefetch geometric factors (constant on triangle)
			  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
			  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
			  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
			  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
			   const dfloat J   = vgeo[e*p_Nvgeo +  JID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
				dfloat duxdr = 0.f, duxds = 0.f; 
				dfloat duydr = 0.f, duyds = 0.f; 
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat Drni = DrT[n+i*p_Np];
					const dfloat Dsni = DsT[n+i*p_Np];
					// 
					duxdr += Drni*s_Ux[es][i];
					duxds += Dsni*s_Ux[es][i];
					duydr += Drni*s_Uy[es][i];
					duyds += Dsni*s_Uy[es][i];
				}
				// chain rule
        dfloat duxdx   = drdx*duxdr + dsdx*duxds;
        dfloat duydy   = drdy*duydr + dsdy*duyds;
        // To be mutiplied with Mass Matrix
        s_FU[es][n]    = J*(duxdx + duydy);
	 
	     }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
   // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
			iint e = eo+es; // element in block
			if(e<Nelements){	  
				dfloat fu = 0.f; 
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat mm = MM[n+i*p_Np];
				  // 
					fu += mm*s_FU[es][i];	
				}
				const iint id = e*p_Np+n;
				// rhsU = - grad P
				rhsPr[id] = fu ; 
        
	 
	     }
      }
    }
 }
}




kernel void insPoissonRhsSurface2D(const iint Nelements,
		         const dfloat dt,
	           const dfloat g0,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict FMMT,
				     const iint   * restrict vmapM,
				     const iint   * restrict vmapP,
				     const iint   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat * restrict U,
				           dfloat * restrict rhsPr){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    shared dfloat s_fluxU[p_NblockS][p_Nfp*p_Nfaces];
     // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	   iint e = eo + es;
	    if(e<Nelements){
	      if(n<p_Nfp*p_Nfaces){
		    // find face that owns this node
		    iint face = n/p_Nfp;
		    // load surface geofactors for this face
		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
		    dfloat nx   = sgeo[sid+NXID];
		    dfloat ny   = sgeo[sid+NYID];
		    dfloat sJ   = sgeo[sid+SJID];
		    //dfloat invJ = sgeo[sid+3];
		   
		    // indices of negative and positive traces of face node
		    iint id  = e*p_Nfp*p_Nfaces + n;
		    iint idM = vmapM[id];
		    iint idP = vmapP[id];

		   if(idP<0) idP = idM;
		  
	  // load negative and positive trace node values of q
	     dfloat  uxm = U[idM + UXID*p_NtotalDofs];
	     dfloat  uxp = U[idP + UXID*p_NtotalDofs];
	     //
		   dfloat  uym = U[idM + UYID*p_NtotalDofs];
		   dfloat  uyp = U[idP + UYID*p_NtotalDofs];
		   
		    // apply boundary condition
		    iint bc = EToB[face+p_Nfaces*e];
		    if(bc>0)
		      boundaryConditionsRhs2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym,&uxp, &uyp);

		    // !!!!!!!!!!! Use just Central Flux, may change !!!!!!!!!!!
        s_fluxU[es][n] = 0.5f*sJ*(nx*(uxp-uxm) + ny*(uyp-uym)); // Multiplied with mass matrix no invJ
       	 }
    		}
			}
		}
    
   
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
			for(iint n=0;n<p_maxNodes;++n;inner0){
				iint e = eo + es;
					if(e<Nelements){
						if(n<p_Np){
							iint id = e*p_Np + n;

							dfloat rhspr = rhsPr[id];
							// Lift
							occaUnroll(p_NfacesNfp)
							for(int m=0;m<p_Nfaces*p_Nfp;++m){
								dfloat FM = FMMT[n+m*p_Np];
								//
								rhspr += FM*s_fluxU[es][m];
					}
          //  rhsu = -grad(p) 
					rhsPr[id] = g0*rhspr/dt; // Hold inverse dt later !!!!!
				  }
				}
      }
    }
  }


}


// Actually solves for Pr increamnet not presssure
kernel void insPoissonRhsIpdgBC2D(  const iint Nelements,
				                            const dfloat * restrict sgeo,
				                            const dfloat * restrict vgeo,
																    const dfloat * restrict DrT,
																    const dfloat * restrict DsT,
																    const dfloat * restrict FMMT,
				                            const iint   * restrict vmapM,
				                            const iint   * restrict vmapP,
				                            const iint   * restrict EToB,
				                            const dfloat time,
				                            const dfloat dt, 
				                            const dfloat tau,
				     										    const dfloat * restrict x,
				    									      const dfloat * restrict y,
				     										    const dfloat * restrict Pr,
				                                  dfloat * restrict rhsPr
				                                  ){
for(int e=0;e<Nelements;++e;outer0){
	// shared storage for flux terms
	  shared  dfloat s_prB[p_Nfp*p_Nfaces];
	  shared  dfloat s_prnB[p_Nfp*p_Nfaces];
    shared  dfloat s_nxprB[p_Nfp*p_Nfaces];
    shared  dfloat s_nyprB[p_Nfp*p_Nfaces];
    //
    shared  dfloat s_Lpr[p_Np];
	  shared  dfloat s_Lprn[p_Np];
	  shared  dfloat s_Lnxpr[p_Np];
	  shared  dfloat s_Lnypr[p_Np];
	 
	  exclusive dfloat tau_n;
	 
   for(iint n=0;n<p_maxNodes;++n;inner0){
	      if(n<p_Nfp*p_Nfaces){
	      	// Find face index and bc type
					 iint face     = n/p_Nfp;
					 iint bc       = EToB[face+p_Nfaces*e];
					  //
					  s_prB[n]      = 0.f;
						s_prnB[n]     = 0.f;
						s_nxprB[n]    = 0.f;
						s_nyprB[n]    = 0.f;
					  //
	        if(bc){ 
						//
						const iint id  = n + e*p_Nfaces*p_Nfp;
						const iint idM = vmapM[id];					
						const iint idP = vmapP[id];					
            // load surface geofactors for this face
						iint sid    = p_Nsgeo*(e*p_Nfaces+face);
						dfloat nx          = sgeo[sid+p_NXID];
						dfloat ny          = sgeo[sid+p_NYID];
						dfloat sJ          = sgeo[sid+p_SJID];
						//invJ        = sgeo[sid+p_IJID];
						dfloat hinv  = sgeo[sid+p_IHID];

						tau_n = hinv* tau; // Scale stabilization parameter
						//					            
            // Initialize external dirichlet for ux and uy
            dfloat  prp = 0.f,  prpo = 0.f; 
            // Initialize external Neumann for ux and uy
            dfloat  prnp = 0.f, prnpo = 0.f;
           // Pressure BC at t^(n+1)
           boundaryConditionsIpdg2D(bc, time, x[idM], y[idM], nx, ny, 
            	                       &prp, &prnp);
           // Pressure BC at t^n
           dfloat timeo = time-dt; 
           boundaryConditionsIpdg2D(bc,timeo, x[idM], y[idM], nx, ny, 
            	                      &prpo, &prnpo);

            prp  -= prpo; // increment in pressure bc
            prnp -= prnpo;         
					 // Hold RHS information and multiply with sJ
						s_prB[n]      = sJ*prp;
						s_prnB[n]     = sJ*prnp;
						s_nxprB[n]    = sJ*nx*prp;
						s_nyprB[n]    = sJ*ny*prp;
    		}
  		}
		}

		barrier(localMemFence);

   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
	      dfloat prb = 0.f,  prnb =0.f;
	      dfloat nxpr = 0.f, nypr =0.f;  
		    // lift remaining surface terms
		    occaUnroll(p_NfacesNfp)
		    for(int i=0;i<p_NfacesNfp;++i){
		    	 const dfloat L = FMMT[n+i*p_Np];
		       prb   += L*s_prB[i];
		       prnb  += L*s_prnB[i];
           nxpr  += L*s_nxprB[i];
		       nypr  += L*s_nyprB[i];
		     }	

				s_Lpr[n]      = prb;
				s_Lprn[n]     = prnb;
				s_Lnxpr[n]    = nxpr;
		    s_Lnypr[n]    = nypr;
	      }
	    } 

	     barrier(localMemFence);
   

   // n . grad P
   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
				const int gid = e*p_Nvgeo;
				const dfloat drdx = vgeo[gid + p_RXID];
				const dfloat drdy = vgeo[gid + p_RYID];
				const dfloat dsdx = vgeo[gid + p_SXID];
				const dfloat dsdy = vgeo[gid + p_SYID];
				//
        dfloat drnxpr= 0.f, drnypr= 0.f;
        dfloat dsnxpr= 0.f, dsnypr= 0.f;
		    // lift remaining surface terms
		    occaUnroll(p_Np)
		    for(int i=0;i<p_Np;++i){
		    	const dfloat Drni = DrT[i+n*p_Np]; // Take transpose was DrT[n+i*p_Np]
					const dfloat Dsni = DsT[i+n*p_Np]; // Take transpose was DsT[i+n*p_Np]

					drnxpr += Drni*s_Lnxpr[n];
					dsnxpr += Dsni*s_Lnxpr[n];
					//
					drnypr += Drni*s_Lnypr[n];
					dsnypr += Dsni*s_Lnypr[n];
				}

        dfloat dndpr = (drdx*drnxpr + dsdx*dsnxpr + drdy*drnypr + dsdy*dsnypr);
        const iint id = e*p_Np+n;
				rhsPr[id] += tau_n*s_Lpr[n] - s_Lprn[n]  -   dndpr;

			}

   }

  }
}







			




