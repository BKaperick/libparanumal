
// Compute bcs for P increment
void boundaryConditions2D(const iint bc,
			      const dfloat  t, const dfloat dt, const dfloat  x, const dfloat  y,
			      const dfloat  nx,   const dfloat  ny,
			      dfloat * restrict pB, 
			      dfloat * restrict pxB, 
			      dfloat * restrict pyB){
  dfloat nu   = 1.0f/40.0f;
  dfloat lambda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

  if((bc==1)||(bc==4)){ // Wall/Slip 
    *pB = 0.f; 
   
    *pxB = 0.f; 
    *pyB = 0.f; 
  }
  if(bc==2){ // Inflow 
    *pB  = 0.f; 

    *pxB = 0.f; 
    *pyB = 0.f; 
    //Definition of Neuman data for Pressure
    // *pxB =-lambda*occaExp(2.0f*lambda*x); 
    // *pyB = 0.f; 
  }
  if(bc==3){ // Outflow 
    // do nothing 
    //*pB = 0.5f*(1.0f - occaExp(2.0f*lambda*x)); 
    *pB = 0.f;
    
    *pxB = 0.f;
    *pyB = 0.f;   
  }
}

// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcing2D(const iint Nelements,
				   const dfloat * restrict vgeo,
				   const dfloat * restrict MM,
				   const dfloat dt,
				   const dfloat g0,
				   dfloat * restrict rhs){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_rhs[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){ 
      	  const iint id = e*p_Np+n;
      	  s_rhs[es][n] = rhs[id]; 
      	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){	
      	  const dfloat J = vgeo[e*p_Nvgeo + p_JID];  
      	  dfloat rhs = 0.f; 
      	  
          occaUnroll(p_Np)
    	    for(iint i=0;i<p_Np;++i){
    	      const dfloat M = MM[n+i*p_Np];
    	      rhs += M*s_rhs[es][i];	
    	    }
      	  
          const iint id = e*p_Np+n;
      	  rhs[id] = -J*g0*rhs/dt; 
      	}
      }
    }
  }
}

// Actually solves for Pr increamnet not presssure
kernel void insPoissonRhsIpdgBC2D(  const iint Nelements,
				                            const dfloat * restrict sgeo,
				                            const dfloat * restrict vgeo,
																    const dfloat * restrict DrT,
																    const dfloat * restrict DsT,
																    const dfloat * restrict LIFTT,
																    const dfloat * restrict MM, 
				                            const iint   * restrict vmapM,
				                            const iint   * restrict vmapP,
				                            const iint   * restrict EToB,
				                            const dfloat time,
				                            const dfloat dt, 
				                            const dfloat tau,
				     										    const dfloat * restrict x,
				    									      const dfloat * restrict y,
				                                  dfloat * restrict rhsP){
for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dpdx[p_Np];
    shared  dfloat s_dpdy[p_Np];
    shared  dfloat s_lapp[p_Np];
    shared  dfloat s_nxdp[p_NfacesNfp];
    shared  dfloat s_nydp[p_NfacesNfp];
    shared  dfloat s_lappflux[p_NfacesNfp];
    shared  dfloat s_Lnxdp[p_Np];
    shared  dfloat s_Lnydp[p_Np];

    exclusive iint idM;
    exclusive dfloat nx, ny, sJ, invJ, hinv;
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
      	const iint id  = n + e*p_Nfaces*p_Nfp;
      	idM = vmapM[id];					
     
      	const iint face = n/p_Nfp;

      	dfloat4 gradpP;
      	gradpP.x = 0.f; gradpP.y = 0.f; gradpP.w = 0.f;
      	
      	// load surface geofactors for this face
      	iint sid = p_Nsgeo*(e*p_Nfaces+face);
      	nx   = sgeo[sid+p_NXID];
      	ny   = sgeo[sid+p_NYID];
      	sJ   = sgeo[sid+p_SJID];
      	invJ = sgeo[sid+p_IJID];
      	hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*e];
        if(bc>0)
        	boundaryConditions2D(bc, time,dt, x[idM], y[idM], nx, ny, 
					                             &gradpP.w, &gradpP.x, &gradpP.y);

      	const dfloat dp = gradpP.w;
      	s_nxdp[n] = sJ*invJ*nx*dp;
      	s_nydp[n] = sJ*invJ*ny*dp;

      	s_lappflux[n] = sJ*invJ*(-nx*(gradpP.x)-ny*(gradpP.y)
				                          -tau*hinv*dp);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
      	const int gid = e*p_Nvgeo;
      	const dfloat drdx = vgeo[gid + p_RXID];
      	const dfloat drdy = vgeo[gid + p_RYID];
      	const dfloat dsdx = vgeo[gid + p_SXID];
      	const dfloat dsdy = vgeo[gid + p_SYID];
      	int r_bcsum = 0;

      	dfloat Lnxdp = 0;
      	dfloat Lnydp = 0;
      	
      	occaUnroll(p_NfacesNfp)
    	  for(iint i=0;i<p_NfacesNfp;++i){
    	    Lnxdp += LIFTT[n+i*p_Np]*s_nxdp[i];
    	    Lnydp += LIFTT[n+i*p_Np]*s_nydp[i];
    	  }
      	
      	dfloat dpdx = Lnxdp;
      	dfloat dpdy = Lnydp;
      	s_dpdx[n] = drdx*dpdx + drdy*dpdy; // abuse of notation
      	s_dpdy[n] = dsdx*dpdx + dsdy*dpdy;

      	s_Lnxdp[n] = Lnxdp;
      	s_Lnydp[n] = Lnydp;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
				iint id = idM%p_Np;
				s_lappflux[n] += sJ*invJ*(nx*s_Lnxdp[id]+ny*s_Lnydp[id]);
      }

      if(n<p_Np){
      	dfloat lapr = 0, laps = 0;
      	
      	occaUnroll(p_Np)
	      for(int i=0;i<p_Np;++i){
  	      lapr += DrT[n+i*p_Np]*s_dpdx[i];
  	      laps += DsT[n+i*p_Np]*s_dpdy[i];
	      }

			  s_lapp[n] = -(lapr+laps);
      }
    }
    
    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
      	dfloat lap = 0;
      					
      	// lift remaining surface terms
      	occaUnroll(p_NfacesNfp)
    	  for(int i=0;i<p_NfacesNfp;++i){
    	    lap += LIFTT[n+i*p_Np]*s_lappflux[i];
    	  }			

    		s_lapp[n] += lap;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      
      if(n<p_Np){
      	const dfloat J = vgeo[e*p_Nvgeo + p_JID];
      				
      	dfloat Mlapp = 0;
      	
      	// multiply by mass matrix
      	occaUnroll(p_Np)
    	  for(int i=0;i<p_Np;++i){
    	    Mlapp += MM[n+i*p_Np]*s_lapp[i];
    	  }
    			
      	const iint id = e*p_Np+n;
      	rhsP[id] -=  J*Mlapp;
      }
    }
  }
}
