
kernel void ellipticCombinedUpdate(const iint Ntotal,
				   const iint degreeWeighted,
				   const dfloat * restrict invDegree,
				   const dfloat alpha,
				   const dfloat beta,
				   const dfloat * restrict Aw,
				   dfloat * restrict p,
				   dfloat * restrict r,
				   dfloat * restrict s,
				   dfloat * restrict w,
				   dfloat * restrict x,
				   dfloat * restrict z,
				   dfloat * restrict results){
   
  for(iint b=0;b<(Ntotal+p_blockSize-1)/p_blockSize;++b;outer0){

    volatile shared dfloat s_rdotr[p_blockSize];
    volatile shared dfloat s_rdotw[p_blockSize];
    
    for(iint n=0;n<p_blockSize;++n;inner0){
      const iint id = n + b*p_blockSize;
      
      s_rdotr[n] = 0;
      s_rdotw[n] = 0;
      
      if(id<Ntotal){
	dfloat Awn = Aw[id];
	dfloat zn = z[id];
	dfloat sn = s[id];
	dfloat pn = p[id];
	dfloat xn = x[id];
	dfloat rn = r[id];
	dfloat wn = w[id];

	const dfloat weight = (degreeWeighted)?invDegree[id]:1.f;
	
	// z <= A*w + beta*z
	zn = beta*zn + Awn;

	// s <= w + beta*s
	sn = beta*sn + wn;

	// p <= r + beta*p
	pn = beta*pn + rn;
	
	// x <= x + alpha*p
	xn += alpha*pn;
	
	// r <= r - alpha*s
	rn -= alpha*sn;
	
	// w <= w - alpha*z
	wn -= alpha*zn;

	// copy into shared
	s_rdotr[n] = rn*rn*weight;
	s_rdotw[n] = rn*wn*weight;

	// copy to global
	z[id] = zn;
	s[id] = sn;
	p[id] = pn;
	x[id] = xn;
	r[id] = rn;
	w[id] = wn;

      }
    }

    barrier(localMemFence);
    
#if p_blockSize>512
    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<512) { s_rdotr[n] += s_rdotr[n+512]; s_rdotw[n] += s_rdotw[n+512]; }
    barrier(localMemFence);
#endif
#if p_blockSize>256
    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<256) { s_rdotr[n] += s_rdotr[n+256]; s_rdotw[n] += s_rdotw[n+256]; }
    barrier(localMemFence);
#endif

    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<128) { s_rdotr[n] += s_rdotr[n+128]; s_rdotw[n] += s_rdotw[n+128]; }
    barrier(localMemFence);
    
    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n< 64) { s_rdotr[n] += s_rdotr[n+64]; s_rdotw[n] += s_rdotw[n+64]; }
    barrier(localMemFence);

    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n< 32) { s_rdotr[n] += s_rdotr[n+32]; s_rdotw[n] += s_rdotw[n+32]; }
    
    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n< 16) { s_rdotr[n] += s_rdotr[n+16]; s_rdotw[n] += s_rdotw[n+16]; }
 
    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<  8) { s_rdotr[n] += s_rdotr[n+ 8]; s_rdotw[n] += s_rdotw[n+ 8]; }

    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<  4) { s_rdotr[n] += s_rdotr[n+ 4]; s_rdotw[n] += s_rdotw[n+ 4]; }

    for(iint n=0;n<p_blockSize;++n;inner0)
      if(n<  2) { s_rdotr[n] += s_rdotr[n+ 2]; s_rdotw[n] += s_rdotw[n+ 2]; }

    for(iint n=0;n<p_blockSize;++n;inner0){
      if(n==0){ // nasty
	const dfloat rdotr = s_rdotr[0]+s_rdotr[1];
	const dfloat rdotw = s_rdotw[0]+s_rdotw[1];
	atomicAdd(results,   rdotr);
	atomicAdd(results+1, rdotw);
      }
    }
  }
}

