// increments gradients of pressure with pseudo-gradients at faces and 
// increments rhs with pseudo-gradient/penalty terms at faces (need to double check scaling with tau)

// sgeo stores dfloat4s with nx,ny,nz,(sJ/J)*(w1*w2*w3/(ws1*ws2))

// nx,ny,nz,sJ,invJ - need WsJ

#define surfaceTerms(sk,i, j)						\
  {									\
  const iint  idM = vmapM[sk];						\
  const iint  idP = vmapP[sk];						\
									\
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];				\
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];				\
  const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];				\
  const dfloat h   = 2.f*sgeo[sk*p_Nsgeo+p_SJID];			\
  									\
  const dfloat4 gradqM = gradq[idM];					\
  const dfloat4 gradqP = gradq[idP];					\
  									\
  const dfloat sc = (idP==idM) ? -1.f:1.f;				\
									\
  dfloat dq = gradqP.w - gradqM.w;					\
  									\
  s_dqdx[j][i] += 0.5f*WsJ*nx*dq;					\
  s_dqdy[j][i] += 0.5f*WsJ*ny*dq;					\
  									\
  s_rhsq[j][i] -= 0.5f*WsJ*(nx*(sc*gradqP.x+gradqM.x) +			\
			    ny*(sc*gradqP.y+gradqM.y) +			\
			    tau*dq/h);					\
  }

kernel void ellipticAxIpdgQuad2D(const int Nelements,
				 const iint * restrict vmapM,
				 const iint * restrict vmapP,
				 const dfloat lambda,
				 const dfloat tau,
				 const dfloat * restrict vgeo,
				 const dfloat * restrict sgeo,
				 const dfloat * restrict D,
				 const dfloat4 * restrict gradq,
				 dfloat  * restrict Aq){
  
#if 0
  // assume the following are precomputed:
  // p, px, py at SEM nodes
  // +/- traces of p, px, py at SEM surface nodes

  0<=i,j,k,m<=N AND 0<=e<Nelements

    (phix, px)_e
    + (phiy, py)_e 
    + (phix, nx*(p+ - p-)/2)_de
    + (phiy, ny*(p+ - p-)/2)_de
    - (phi-, nx*(px+ + px-)/2)_de
    - (phi-, ny*(py+ + py-)/2)_de
    - (phi-, tau*(p+ - p-)/2)_de
    
    // here w is one component of the product TP quadrature weights
    (phir, rx*(px + Fsc*nx*dp) + ry*(py + Fsc*ny*dp) + rz*(pz + Fsc*nz*dp)) )_e
+   (phir, sx*(px + Fsc*nx*dp) + sy*(py + Fsc*ny*dp) + sz*(pz + Fsc*nz*dp)) )_e
+   (phir, tx*(px + Fsc*nx*dp) + ty*(py + Fsc*ny*dp) + tz*(pz + Fsc*nz*dp)) )_e
    (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

    px => px + Fsc*nx*dp (i.e. add pseudo-gradient at end points 
    py => py + Fsc*ny*dp
    pz => pz + Fsc*nz*dp
    Fsc = delta*(Js/J)*(1/w)
    dp = (p+ - p-)/2;

    // simplify
    (phir, rx*px+ ry*py + rz*pz) )_e
+   (phir, sx*px+ sy*py + sz*pz) )_e
+   (phir, tx*px+ ty*py + tz*pz) )_e
+   (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

#endif

  for(int e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_dqdx[p_Nq][p_Nq];
    shared dfloat s_dqdy[p_Nq][p_Nq];
    shared dfloat s_rhsq[p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    // loop over slabs
    for(int j=0;j<p_Nq;++j){
      for(int i=0;i<p_Nq;++i;inner0){

	// assume that this stores (p, px, py, pz) as dfloat4
	const dfloat4 gradqn = gradq[e*p_Np+j*p_Nq+i];
	
	const int gid = i + j*p_Nq + e*p_Np*p_Nvgeo;
	dfloat JW = vgeo[gid + p_JWID*p_Np];
	
	s_dqdx[j][i] = JW*gradqn.x;
	s_dqdy[j][i] = JW*gradqn.y;
	s_rhsq[j][i] = JW*lambda*gradqn.w;
	
	s_D[j][i] = D[j*p_Nq+i];
      }
    }

    barrier(localMemFence);
	  
    // loop over faces to add pseudo-gradient

    // face 0 & 2
    for(iint i=0;i<p_Nq;++i;inner0){
      iint sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i ;
      iint sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + i ;	
      
      surfaceTerms(sk0,i,0);
      surfaceTerms(sk2,i,p_Nq-1);
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int j=0;j<p_Nq;++j;inner0){
      iint sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + j;
      iint sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + j;

      surfaceTerms(sk1,p_Nq-1,j);
      surfaceTerms(sk3,0,j); 
    }

    barrier(localMemFence);

    // prescale by geofacs
    for(int j=0;j<p_Nq;++j){
      for(int i=0;i<p_Nq;++i;inner0){
	// does need the nasty geofacs
	const int gid = i + j*p_Nq + e*p_Np*p_Nvgeo;
	
	const dfloat drdx = vgeo[gid + p_RXID*p_Np];
	const dfloat drdy = vgeo[gid + p_RYID*p_Np];
	
	const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
	const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

	const dfloat JW = vgeo[gid + p_JWID*p_Np];
	
	// chain rule (need to scale by wei
	const dfloat dqdx = s_dqdx[j][i];
	const dfloat dqdy = s_dqdy[j][i];
	
	s_dqdx[j][i] = (drdx*dqdx + drdy*dqdy);
	s_dqdy[j][i] = (dsdx*dqdx + dsdy*dqdy);
      }
    }
    
    barrier(localMemFence);

    // loop over slabs
    for(int j=0;j<p_Nq;++j){
      for(int i=0;i<p_Nq;++i;inner0){
	dfloat dr = 0, ds = 0;

	for(int n=0;n<p_Nq;++n){
	  dr += s_D[n][i]*s_dqdx[j][n];
	  ds += s_D[n][j]*s_dqdy[n][i];
	}

	iint id = e*p_Np + j*p_Nq + i;
	Aq[id] = s_rhsq[j][i]  + dr + ds;
      }
    }
  }
}
