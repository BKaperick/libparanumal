// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcing3D(const iint Nelements,
				   const dfloat * restrict vgeo,
				   const dfloat * restrict MM,
				   const dfloat dt,
				   const dfloat g0,
				   dfloat * restrict rhs){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
    shared dfloat s_rhs[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){
      	  const iint id = e*p_Np+n;
      	  s_rhs[es][n] = rhs[id];
      	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    // Multiply with Mass Matrix
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){
      	  const dfloat J = vgeo[e*p_Nvgeo + p_JID];
      	  dfloat rhsn = 0.f;

          occaUnroll(p_Np)
    	    for(iint i=0;i<p_Np;++i){
    	      const dfloat M = MM[n+i*p_Np];
    	      rhsn += M*s_rhs[es][i];
    	    }

          const iint id = e*p_Np+n;
      	  rhs[id] = -J*g0*rhsn/dt;
      	}
      }
    }
  }
}

// Actually solves for Pr increamnet not presssure
kernel void insPoissonRhsIpdgBC3D(const int Nelements,
            const iint * restrict vmapM,
            const iint * restrict vmapP,
            const dfloat tau,
            const dfloat time,
            const dfloat dt,
            const dfloat * restrict x,
            const dfloat * restrict y,
            const dfloat * restrict z,
            const dfloat * restrict vgeo,
            const dfloat * restrict sgeo,
            const iint   * restrict EToB,
            const dfloat * restrict DrT,
            const dfloat * restrict DsT,
            const dfloat * restrict DtT,
            const dfloat * restrict LIFTT,
            const dfloat * restrict MM,
            dfloat * restrict rhsP){
  for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dpdx[p_Np];
    shared  dfloat s_dpdy[p_Np];
    shared  dfloat s_dpdz[p_Np];
    shared  dfloat s_lapp[p_Np];

    shared  dfloat s_nxdp[p_NfacesNfp];
    shared  dfloat s_nydp[p_NfacesNfp];
    shared  dfloat s_nzdp[p_NfacesNfp];

    shared  dfloat s_lappflux[p_NfacesNfp];
    shared  dfloat s_Lnxdp[p_Np];
    shared  dfloat s_Lnydp[p_Np];
    shared  dfloat s_Lnzdp[p_Np];

    exclusive iint idM, bcsum;
    exclusive dfloat nx, ny,nz, sJ, invJ, hinv;
    
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id];          
     
        const iint face = n/p_Nfp;
        dfloat dpdxP=0.f, dpdyP=0.f, dpdzP=0.f, pP=0;        
        // load surface geofactors for this face
        iint sid = p_Nsgeo*(e*p_Nfaces+face);
        nx = sgeo[sid+p_NXID];
        ny = sgeo[sid+p_NYID];
        nz = sgeo[sid+p_NZID];
        sJ = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        int bc = EToB[face+p_Nfaces*e];
        if(bc>0) {
          dfloat pPm1=0.f, dpdxPm1=0.f, dpdyPm1=0.f, dpdzPm1=0.f;
          insPoissonBoundaryConditions3D(bc,time,dt, x[idM],y[idM],z[idM], nx,ny,nz, &pP,&dpdxP,&dpdyP,&dpdzP);
          insPoissonBoundaryConditions3D(bc,time-dt, dt, x[idM],y[idM],z[idM], nx,ny,nz, &pPm1, &dpdxPm1, &dpdyPm1,&dpdzPm1);
          
          pP = pP - pPm1;
          dpdxP = dpdxP - dpdxPm1;
          dpdyP = dpdyP - dpdyPm1;
          dpdzP = dpdzP - dpdzPm1;
        }
        const dfloat dp = pP;
        const dfloat hlf = 1.0f;

        s_nxdp[n] = hlf*sJ*invJ*nx*dp;
        s_nydp[n] = hlf*sJ*invJ*ny*dp;
        s_nzdp[n] = hlf*sJ*invJ*nz*dp;

        s_lappflux[n] = hlf*sJ*invJ*(-nx*(dpdxP)-ny*(dpdyP)-nz*(dpdzP)-tau*hinv*dp);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        const iint gid = e*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat drdz = vgeo[gid + p_RZID];

        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];
        const dfloat dsdz = vgeo[gid + p_SZID];

        const dfloat dtdx = vgeo[gid + p_TXID];
        const dfloat dtdy = vgeo[gid + p_TYID];
        const dfloat dtdz = vgeo[gid + p_TZID];

        dfloat Lnxdp = 0.f;
        dfloat Lnydp = 0.f;
        dfloat Lnzdp = 0.f;

        occaUnroll(p_NfacesNfp)
          for(iint i=0;i<p_NfacesNfp;++i){
            Lnxdp += LIFTT[n+i*p_Np]*s_nxdp[i];
            Lnydp += LIFTT[n+i*p_Np]*s_nydp[i];
            Lnzdp += LIFTT[n+i*p_Np]*s_nzdp[i];
          }

        dfloat dpdx = Lnxdp;
        dfloat dpdy = Lnydp;
        dfloat dpdz = Lnzdp;

        s_dpdx[n] = drdx*dpdx + drdy*dpdy + drdz*dpdz; // abuse of notation
        s_dpdy[n] = dsdx*dpdx + dsdy*dpdy + dsdz*dpdz;
        s_dpdz[n] = dtdx*dpdx + dtdy*dpdy + dtdz*dpdz;

        s_Lnxdp[n] = Lnxdp;
        s_Lnydp[n] = Lnydp;
        s_Lnzdp[n] = Lnzdp;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        iint id = idM%p_Np;
        s_lappflux[n] += sJ*invJ*(nx*s_Lnxdp[id]+ny*s_Lnydp[id]+nz*s_Lnzdp[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0.f, laps = 0.f, lapt = 0.f;
        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i) {
          lapr += DrT[n+i*p_Np]*s_dpdx[i];
          laps += DsT[n+i*p_Np]*s_dpdy[i];
          lapt += DtT[n+i*p_Np]*s_dpdz[i];
        }

        s_lapp[n] = -(lapr+laps+lapt);
      }

    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        dfloat lap = 0.f;
        // lift remaining surface terms
        occaUnroll(p_NfacesNfp)
        for(int i=0;i<p_NfacesNfp;++i){
          lap += LIFTT[n+i*p_Np]*s_lappflux[i];
        }
        s_lapp[n] += lap;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        const dfloat J = vgeo[e*p_Nvgeo + p_JID];
        dfloat Mlapp = 0;
        // multiply by mass matrix
        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i){
          Mlapp += MM[n+i*p_Np]*s_lapp[i];
        }

        const iint id = e*p_Np+n;
        rhsP[id] -=  J*Mlapp;
      }
    }
  }
}

//RHS contributions for continuous solver
kernel void insPoissonRhsBC3D(const int Nelements,
                              const iint pressure_solve,
                              const dfloat * restrict ggeo,
                              const dfloat * restrict sgeo,
                              const dfloat * restrict SrrT,
                              const dfloat * restrict SrsT,
                              const dfloat * restrict SrtT,
                              const dfloat * restrict SsrT,
                              const dfloat * restrict SssT,
                              const dfloat * restrict SstT,
                              const dfloat * restrict StrT,
                              const dfloat * restrict StsT,
                              const dfloat * restrict SttT,
                              const dfloat * restrict MM,
                              const iint   * restrict vmapM,
                              const dfloat * restrict sMT,
                              const dfloat time,
                              const dfloat dt,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const dfloat * restrict z,
                              const int    * restrict mapB,
                              dfloat  * restrict rhsP){
  
  for(iint e=0;e<Nelements;e++;outer0){
    shared dfloat s_q[p_Np];
    shared dfloat s_ndq[p_Nfp*p_Nfaces];

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
        s_q[n] = 0.;
      }
      if(n<p_NfacesNfp){
        s_ndq[n] = 0.;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        const iint idM = vmapM[id];          
        const iint nid = idM%p_Np; 

        const iint face = n/p_Nfp;

        dfloat dpdxP=0, dpdyP=0, dpdzP=0, pP=0;
        
        // load surface geofactors for this face
        const iint sid = p_Nsgeo*(e*p_Nfaces+face);
        const dfloat nx = sgeo[sid+p_NXID];
        const dfloat ny = sgeo[sid+p_NYID];
        const dfloat nz = sgeo[sid+p_NZID];
        const dfloat sJ = sgeo[sid+p_SJID];

        const int bc = mapB[idM];
        if(bc>0) {
          insPoissonBoundaryConditions3D(bc,time, dt, x[idM], y[idM], z[idM], nx,ny,nz, &pP,&dpdxP,&dpdyP,&dpdzP);
          if(pressure_solve==0){ // if the pressure increment is in use
            dfloat pPm1, dpdxPm1, dpdyPm1, dpdzPm1;
            insPoissonBoundaryConditions3D(bc,time-dt, dt, x[idM], y[idM], z[idM], nx,ny,nz, &pPm1, &dpdxPm1, &dpdyPm1, &dpdzPm1);
            pP = pP - pPm1;
            dpdxP = dpdxP - dpdxPm1;
            dpdyP = dpdyP - dpdyPm1;
            dpdzP = dpdzP - dpdzPm1;
          }
        } 

        s_q[nid] = pP;
        s_ndq[n] = sJ*(nx*dpdxP + ny*dpdyP + nz*dpdzP);
      }
    }

    barrier(localMemFence);
    
    for(int n=0;n<p_maxNodes;++n;inner0){ 
      if(n<p_Np){
        //volume Dirichlet data
        const iint id = n + e*p_Np;
        const iint gid = e*p_Nggeo;
        const dfloat Grr = ggeo[gid + p_G00ID];
        const dfloat Grs = ggeo[gid + p_G01ID];
        const dfloat Grt = ggeo[gid + p_G02ID];
        const dfloat Gss = ggeo[gid + p_G11ID];
        const dfloat Gst = ggeo[gid + p_G12ID];
        const dfloat Gtt = ggeo[gid + p_G22ID];
        const dfloat J   = ggeo[gid + p_GWJID];

        dfloat qrr = 0.;
        dfloat qrs = 0.;
        dfloat qrt = 0.;
        dfloat qsr = 0.;
        dfloat qss = 0.;
        dfloat qst = 0.;
        dfloat qtr = 0.;
        dfloat qts = 0.;
        dfloat qtt = 0.;

        occaUnroll(p_Np)
          for (int k=0;k<p_Np;k++) {
            qrr += SrrT[n+k*p_Np]*s_q[k];
            qrs += SrsT[n+k*p_Np]*s_q[k];
            qrt += SrtT[n+k*p_Np]*s_q[k];
            qsr += SsrT[n+k*p_Np]*s_q[k];
            qss += SssT[n+k*p_Np]*s_q[k];
            qst += SstT[n+k*p_Np]*s_q[k];
            qtr += StrT[n+k*p_Np]*s_q[k];
            qts += StsT[n+k*p_Np]*s_q[k];
            qtt += SttT[n+k*p_Np]*s_q[k];
          }

        dfloat Lndq = 0;            
        // surface mass * surface terms
        occaUnroll(p_NfacesNfp)
          for(int i=0;i<p_NfacesNfp;++i){
            Lndq += sMT[n+i*p_Np]*s_ndq[i];
          }

        rhsP[id] -= Grr*qrr+Grs*qrs+Grt*qrt
                   +Grs*qsr+Gss*qss+Gst*qst 
                   +Grt*qtr+Gst*qts+Gtt*qtt  - Lndq;
      }
    }
  }
}

kernel void insPoissonAddBCKernel(const iint Nelements,
                              const int pressure_solve,
                              const dfloat time,
                              const dfloat dt,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const dfloat * restrict z,
                              const iint   * restrict vmapM,
                              const int    * restrict mapB,
                              dfloat  * restrict p){
  
  for(iint e=0;e<Nelements;e++;outer0){
    for(int n=0;n<p_Nfp*p_Nfaces;++n;inner0){
      const iint idM = vmapM[e*p_Nfp*p_Nfaces + n];
      const int bc = mapB[idM];

      dfloat dpdxP=0, dpdyP=0, dpdzP=0, pP=0;

      if(bc>0) {
        insPoissonBoundaryConditions3D(bc,time, dt, x[idM], y[idM], z[idM], nx,ny,nz, &pP,&dpdxP,&dpdyP,&dpdzP);
        if(pressure_solve==0){ // if the pressure increment is in use
          dfloat pPm1, dpdxPm1, dpdyPm1, dpdzPm1;
          insPoissonBoundaryConditions3D(bc,time-dt, dt, x[idM], y[idM], z[idM], nx,ny,nz, &pPm1, &dpdxPm1, &dpdyPm1, &dpdzPm1);
          pP = pP - pPm1;
          dpdxP = dpdxP - dpdxPm1;
          dpdyP = dpdyP - dpdyPm1;
          dpdzP = dpdzP - dpdzPm1;
        }
        p[idM] += pP;
      }    
    }
  }
}