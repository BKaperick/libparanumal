#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))

// experimental overlapping patch solver 
kernel void ellipticPatchSolver2D(const int Nelements,
                                  const dfloat * restrict invAP,
                                  const iint   * restrict EToE,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){  

  
  // assume one patch per outer iteration (tune later)
  for(iint e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_q[p_patchNp];

    // loop over elements in sub-patch e and load q
    for(iint es=0;es<p_patchNelements;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first
        const iint id = n + es*p_Np;    

        s_q[id] = 0.f;
        if(eP>=0){
          s_q[id] = q[eP*p_Np+n];
        }
      }
    }
  
    // barrier to make sure patch q has loaded
    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(iint es=0;es<p_patchNelements;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        const iint id = n + es*p_Np; // node offset in patch
        const iint offset = e*p_patchNp*p_patchNp; // patch matrices offset

        dfloat invAPqn = 0.f;

        occaUnroll(p_patchNp)
          for(iint m=0;m<p_patchNp;++m){
            invAPqn += invAP[offset + m*p_patchNp + id]*s_q[id];
          }
        
        const iint eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first
        
        // gambles on rare collisions and FP64 atomics (must zero Pq first)
        // also need to do halo exchanges and further accumulate ?
        if (eP >-1)
          occaAtomicAdd((invAPq+eP*p_Np+n), invAPqn); 
      }
    }
  }
}
