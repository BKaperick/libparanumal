#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))


#if 0
// experimental overlapping patch solver
kernel void ellipticApproxPatchSolver2D(const int Nelements,
                                  const dfloat * restrict invAP,
                                  const int   * restrict EToE,
                                  const int   * restrict EToF,
                                  const int   * restrict rmapP,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_q[p_Np];
    exclusive  dfloat invAPqn;

    for(int n=0;n<p_Np;++n;inner0){
      invAPqn = 0.f;
    }

    // loop over elements in sub-patch e and load q
    for(int es=0;es<p_patchNelements;++es){

      barrier(localMemFence);

      for(int n=0;n<p_Np;++n;inner0){
        const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first
        const int fP = (es==0) ? 0: EToF[e*p_Nfaces+es-1];

        s_q[n] = 0.f;
        if(eP>=0){
          const int id = rmapP[fP*p_Np + n]; //rotate node ordering based on face number
          s_q[n] = q[eP*p_Np+id];
        }
      }

      barrier(localMemFence);

      // loop over elements/nodes in patch and do local smooth
      for(int n=0;n<p_Np;++n;inner0){
        const int offset = es*p_Np*p_patchNp; // patch matrices offset
        dfloat res = 0.f;
        occaUnroll(p_Np)
          for(int m=0;m<p_Np;++m){
            res += invAP[offset + m*p_patchNp + n]*s_q[m];
          }
        invAPqn += res;
      }
    }

    for(int n=0;n<p_Np;++n;inner0){
      // const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

      // gambles on rare collisions and FP64 atomics (must zero Pq first)
      // also need to do halo exchanges and further accumulate ?

      invAPqn *= 0.15f;

      invAPq[n+e*p_Np] = invAPqn;
    }
  }
}


// experimental overlapping patch solver
kernel void ellipticPatchSolver2D(const int Nelements,
                                  const dfloat * restrict invAP,
                                  const int   * restrict EToE,
                                  const int   * restrict EToF,
                                  const int   * restrict rmapP,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    shared dfloat s_q[p_NblockP][p_patchNp];

    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          s_q[e-eo][es*p_Np+n] = 0.f;
        }
      }
    }

    barrier(localMemFence);

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first
            int fP = (es==0) ? 0: EToF[e*p_Nfaces+es-1];

            // cycle faces
            fP = (es>0 && fP!=0) ? p_Nfaces-fP:fP;

            if(eP>=0){
              const int id = (fP==0) ? n: rmapP[fP*p_Np+n];
              s_q[e-eo][es*p_Np+id] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int offset = es*p_Np + n; // patch matrices offset
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f;

            //      occaUnroll(p_patchNp)
            occaUnroll(p_Np)
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp]*s_q[e-eo][m];
                res2 += invAP[offset + (m+  p_Np)*p_patchNp]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp]*s_q[e-eo][m+3*p_Np];
              }

            const dfloat invDeg = invDegree[e];
            //const dfloat sc = 2.0/(3.*p_N+4.);
            const dfloat sc = 1.0;

            invAPq[p_patchNp*e+es*p_Np+n] = sc*invDeg*(res1+res2+res3+res4);
          }
        }
      }
    }
  }
}
#endif

// experimental overlapping patch solver
kernel void ellipticExactPatchSolver2D(const int Nelements,
                                  const dfloat * restrict invAP,
                                  const int   * restrict EToE,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    shared dfloat s_q[p_NblockP][p_patchNp];

    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          s_q[e-eo][es*p_Np+n] = 0.f;
        }
      }
    }

    barrier(localMemFence);

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int offset = e*p_patchNp*p_patchNp + es*p_Np + n; // patch matrices offset
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f;

            //      occaUnroll(p_patchNp)
            occaUnroll(p_Np)
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp]*s_q[e-eo][m];
                res2 += invAP[offset + (m+  p_Np)*p_patchNp]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp]*s_q[e-eo][m+3*p_Np];
              }

            const dfloat invDeg = invDegree[e];
            //const dfloat sc = 2.0/(3.*p_N+4.);
            const dfloat sc = 1.0;

            invAPq[p_patchNp*e+es*p_Np+n] = sc*invDeg*(res1+res2+res3+res4);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxPatchSolver2D(const int Nelements,
                                  const int   * restrict patchesIndex,
                                  const dfloat * restrict invAP,
                                  const int   * restrict EToE,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    shared dfloat s_q[p_NblockP][p_patchNp];

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            s_q[e-eo][es*p_Np+n] = 0.f;
            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const dfloat invDeg = invDegree[e];

            // patch matrices offset
            const int offset = patchesIndex[e]*p_patchNp*p_patchNp + es*p_Np + n;
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f;
            occaUnroll(p_Np)
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp ]*s_q[e-eo][m];
                res2 += invAP[offset + (m  +p_Np)*p_patchNp ]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp ]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp ]*s_q[e-eo][m+3*p_Np];
              }

            invAPq[p_patchNp*e+es*p_Np+n] = invDeg*(res1+res2+res3+res4);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticExactFacePatchSolver2D(const int NfacePairs,
                                  const dfloat * restrict invAP,
                                  const int   * restrict FPairsToE,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;outer0){

    shared dfloat s_q[2*p_Np];

    // loop over elements in sub-patch e and load q
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int e = FPairsToE[2*f+es];

          s_q[es*p_Np+n] = 0.f;
          if(e>=0){
            s_q[es*p_Np+n] = q[e*p_Np+n];
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int offset = f*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset
          dfloat res1 = 0.f, res2 = 0.f;

          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
              res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
            }

          const int e = FPairsToE[2*f+es];
          dfloat invDeg;
          if(e>=0) {
            invDeg = invDegree[e];
          } else {
            invDeg = 0.f;
          }

          invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxFacePatchSolver2D(const int NfacePairs,
                                  const int   * restrict patchesIndex,
                                  const dfloat * restrict invAP,
                                  const int   * restrict FPairsToE,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;outer0){

    shared dfloat s_q[2*p_Np];

    // loop over elements in sub-patch f and load q
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int e = FPairsToE[2*f+es];

          s_q[es*p_Np+n] = 0.f;
          if(e>=0){
            s_q[es*p_Np+n] = q[e*p_Np+n];
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int offset = patchesIndex[f]*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset
          dfloat res1 = 0.f, res2 = 0.f;

          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
              res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
            }

          const int e = FPairsToE[2*f+es];

          dfloat invDeg;
          if(e>=0) {
            invDeg = invDegree[e];
          } else {
            invDeg = 0.f;
          }
          invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
        }
      }
    }
  }
}


// experimental overlapping patch solver
kernel void ellipticExactBlockJacobiSolver2D(const int Nelements,
                                  const dfloat * restrict invAP,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];
          const int offset = e*p_Np*p_Np + n; // patch matrices offset
          dfloat res = 0.f;

          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxBlockJacobiSolver2D(const int Nelements,
                                  const int   * restrict patchesIndex,
                                  const dfloat * restrict invAP,
                                  const dfloat * restrict invDegree,
                                  const dfloat * restrict q,
                                  dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];

          // patch matrices offset
          const int offset = patchesIndex[e]*p_Np*p_Np + n;
          dfloat res = 0.f;
          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np ]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}


#if 0
// experimental overlapping patch solver
kernel void ellipticPatchSolver2D(const int Nelements,
                                  const dfloat * restrict A,
                                  const int   * restrict EToE,
                                  const dfloat * restrict b,
                                  dfloat * restrict x){


  // assume one patch per outer iteration (tune later)
  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_x[p_patchNp];
    shared dfloat s_r[p_patchNp];
    shared dfloat s_z[p_patchNp];
    shared dfloat s_p[p_patchNp];

    exclusive dfloat bn, oldrz;

    // loop over elements in sub-patch e and load q
    for(int es=0;es<p_patchNelements;++es;inner1){
      for(int n=0;n<p_patchNp;++n;inner0){

        int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

        const int id = n + es*p_Np;

        s_x[id] = 0.f;
        bn = 0.f;
        if(eP>=0){
          s_x[id] = x[eP*p_Np+n];
          bn = b[eP*p_Np+n];
        }
      }
    }

    // barrier to make sure patch q has loaded
    barrier(localMemFence);

    // r = b - A*x
    for(int es=0;es<p_patchNelements;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        const int offset = e*p_patchNp*p_patchNp; // patch matrices offset
        const int id = n + es*p_Np;
        dfloat rn = bn;
        for(int m=0;m<p_patchNp;++m){
          rn -= A[offset + m*p_patchNp + id]*s_x[m];
        }
        s_r[id] = rn;
        s_z[id] = rn; // bypass precon
        s_p[id] = rn;
      }
    }

    dotProduct(p_patchNp, s_r,  s_z, s_rz);

    barrier(localMemFence);

    for(int it=0;it<p_maxNits;++it){

      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){

          const int id = n + es*p_Np;

          dfloat Ap = 0.f;
          for(int m=0;m<p_patchNp;++m)
            Ap += A[offset + m*p_patchNp + id]*s_p[m];
          s_Ap[n] = Ap;

        }
      }

      dotProduct(p_patchNp, s_p, s_Ap, s_pAp);

      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          const int id = n + es*p_Np;

          const dfloat alpha = s_rz[0]/s_pAp[0];

          s_x[id] += alpha*s_p[id];
          s_r[id] -= alpha*s_Ap[id];
          s_z[id]  = s_r[id];

          oldrz = s_rz[0];
        }
      }

      dotProduct(p_patchNp, s_r, s_r, s_rz);

      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          const int id = n + es*p_Np;

          const dfloat beta = s_rz[0]/oldrz;
          s_p[id] = s_z[id] + beta*s_p[id];
        }
      }
    }
  }
}
#endif
