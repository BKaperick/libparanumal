@kernel void testHYBmatvec_v0(int N,
                             double * values,
                             int * indices,
                             double * vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			if (r <N){
				for (int k = 0; k< p_rowSize; k++){
					int colindex = indices[r*p_rowSize+k];
					if (colindex !=0)
					{
						rowsum += values[k+r*p_rowSize]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

@kernel void testHYBmatvec_v1(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			if (r <N){
				for (int k = 0; k< p_rowSize; k++){
					int colindex = indices[r*p_rowSize+k];
					if (colindex !=0)
					{
						rowsum += values[k+r*p_rowSize]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

@kernel void testHYBmatvec_v2(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			if (r <N){
				#pragma unroll p_rowSize
				for (int k = 0; k< p_rowSize; k++){
					int colindex = indices[r*p_rowSize+k];
					if (colindex !=0)
					{
						rowsum += values[k+r*p_rowSize]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

@kernel void testHYBmatvec_v3(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		@shared double s_val[p_blockSize*p_rowSize];
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			
			for (int p = 0; p<p_rowSize; ++p)
			{
				if (r <N){
					s_val[m*p_rowSize+p] = values[p+r*p_rowSize];
				}
			}
			//fetch values to @shared memory
			@barrier("local");
			
			if (r <N){
				#pragma unroll p_rowSize
				for (int k = 0; k< p_rowSize; k++){
					int colindex = indices[r*p_rowSize+k];
					if (colindex !=0)
					{
						rowsum += s_val[k+m*p_rowSize]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}


@kernel void testHYBmatvec_v4(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		@shared double s_val[p_blockSize*p_rowSize];
		@shared int s_ind[p_blockSize*p_rowSize];
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			
			for (int p = 0; p<p_rowSize; ++p)
			{
				if (r <N){
					s_val[m*p_rowSize+p] = values[p+r*p_rowSize];
					s_ind[m*p_rowSize+p] = indices[p+r*p_rowSize];
				}
			}
			//fetch values to @shared memory
			@barrier("local");
			
			if (r <N){
				#pragma unroll p_rowSize
				for (int k = 0; k< p_rowSize; k++){
					int colindex = s_ind[m*p_rowSize+k];
					if (colindex !=0)
					{
						rowsum += s_val[k+m*p_rowSize]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

//registers!
@kernel void testHYBmatvec_v5(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		//	@shared double s_val[p_blockSize*p_rowSize];
		//@shared int s_ind[p_blockSize*p_rowSize];
		@exclusive double r_val[p_rowSize];
		@exclusive int r_ind[p_rowSize];
		@exclusive int colindex;
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			int r = p_blockSize*b+m;
			#pragma unroll p_rowSize
			for (int p = 0; p<p_rowSize; ++p)
			{
				if (r <N){
					r_val[p] = values[p+r*p_rowSize];
					r_ind[p] = indices[p+r*p_rowSize];
				}
			}
			//fetch values to @shared memory
			//		@barrier("local");
			
			if (r <N){
				#pragma unroll p_rowSize
				for (int k = 0; k< p_rowSize; k++){
					colindex = r_ind[k];
					if (colindex !=0)
					{
						rowsum += r_val[k]*vector[colindex-1];
						
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

@kernel void testHYBmatvec_v6(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		@shared double s_val[p_blockSize*p_rowSize];
		@shared int s_ind[p_blockSize*p_rowSize];
		@shared double s_vec[p_blockSize];
		//		@shared double s_vec[]
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			const int r = p_blockSize*b+m;
			#pragma unroll p_rowSize
			for (int p = 0; p<p_rowSize; ++p)
			{
				if (r <N){
					s_val[m*p_rowSize+p] = values[p+r*p_rowSize];
					s_ind[m*p_rowSize+p] = indices[p+r*p_rowSize];
				}
			}
			//fetch values to @shared memory
			@barrier("local");
			//	if (r<N){
			//	if (b ==p_Nblocks-1){
			//	printf("loading value %d to @shared at position %d\n", r, m);
			//	}
			s_vec[m] = vector[r];
			//		}
			@barrier("local");
			
			if (r <N){
				#pragma unroll p_rowSize
				//	for (int k = 0; k< p_rowSize; k++){
				int k = 0;
				int colindex = s_ind[m*p_rowSize+k];
				while (colindex!=0){
					//if (b == p_blockSize-1){
					
					//		}
					rowsum += s_val[k+m*p_rowSize]*s_vec[colindex-b*p_blockSize-1];
					
					k++;
					if (k<p_rowSize){
						colindex = s_ind[m*p_rowSize+k];
						
						
					}
					else{
						colindex=0;
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

@kernel void testHYBmatvec_v7(const int N,
                             @restrict const double *  values,
                             @restrict const  int *  indices,
                             @restrict const double *  vector,
                             double * result){
                             
	for(int b=0;b<p_Nblocks;++b;@outer(0)){
	
		@shared double s_val[p_blockSize*p_rowSize];
		@shared int s_ind[p_blockSize*p_rowSize];
		@shared double s_vec[p_blockSize];
		//		@shared double s_vec[]
		for (int m=0; m<p_blockSize; m++; @inner(0)){
			double rowsum = 0.0f;
			const int r = p_blockSize*b+m;
			#pragma unroll p_rowSize
			for (int p = 0; p<p_rowSize; ++p)
			{
				if (r <N){
					s_val[m*p_rowSize+p] = values[p+r*p_rowSize];
					s_ind[m*p_rowSize+p] = indices[p+r*p_rowSize];
				}
			}
			//fetch values to @shared memory
			@barrier("local");
			//	if (r<N){
			//	if (b ==p_Nblocks-1){
			//	printf("loading value %d to @shared at position %d\n", r, m);
			//	}
			s_vec[m] = vector[r];
			//		}
			@barrier("local");
			
			if (r <N){
				#pragma unroll p_rowSize
				//	for (int k = 0; k< p_rowSize; k++){
				int k = 0;
				int colindex = s_ind[m*p_rowSize+k];
				while (colindex!=0){
					//if (b == p_blockSize-1){
					
					//		}
					rowsum += s_val[k+m*p_rowSize]*s_vec[colindex-b*p_blockSize-1];
					
					k++;
					if (k<p_rowSize){
						colindex = s_ind[m*p_rowSize+k];
						
						
					}
					else{
						colindex=0;
					}
				}
			}
			result[r] = rowsum;
		}//m
	}
}

