
void upwind1D(const dfloat nx, const dfloat ny,
              const dfloat RM, const dfloat UM, const dfloat VM,
	      const dfloat RP, const dfloat UP, const dfloat VP,
              dfloat * restrict RS, dfloat * restrict US, dfloat * restrict VS){


  const dfloat RA = 0.5f*(RM+RP);
  const dfloat UA = 0.5f*(UM+UP);
  const dfloat VA = 0.5f*(VM+VP);

  const dfloat udotn = (UA*nx+VA*ny)/RA;
  const dfloat udott = (UA*ny-VA*nx)/RA;
  
  const dfloat W1 = udotn + p_sqrtRT;
  const dfloat W2 = udotn - p_sqrtRT;
  const dfloat W3 = udotn;
  
  // characteristic variables for wave speeds W1, W2, W3 on negative trace
  dfloat C1M = (0.5f*p_isqrtRT)*(-(udotn-p_sqrtRT)*RM+(+nx)*UM+(+ny)*VM);
  dfloat C2M = (0.5f*p_isqrtRT)*(+(udotn+p_sqrtRT)*RM+(-nx)*UM+(-ny)*VM);
  dfloat C3M = (udott)*RM+(-ny)*UM+(+nx)*VM;

  // characteristic variables for wave speeds W1, W2, W3 on positive trace
  dfloat C1P = (0.5f*p_isqrtRT)*(-(udotn-p_sqrtRT)*RP+(+nx)*UP+(+ny)*VP);
  dfloat C2P = (0.5f*p_isqrtRT)*(+(udotn+p_sqrtRT)*RP+(-nx)*UP+(-ny)*VP);
  dfloat C3P = (udott)*RP+(-ny)*UP+(+nx)*VP;

  // choose characteristics based on wave speed (may need to reverse)
  const dfloat C1U = (W1>0) ? C1M:C1P;
  const dfloat C2U = (W2>0) ? C2M:C2P;
  const dfloat C3U = (W3>0) ? C3M:C3P;
  
  *RS =                     C1U +                    C2U + (0.f)*C3U;
  *US = (UA/RA+p_sqrtRT*nx)*C1U +(UA/RA-p_sqrtRT*nx)*C2U + (-ny)*C3U;
  *VS = (VA/RA+p_sqrtRT*ny)*C1U +(VA/RA-p_sqrtRT*ny)*C2U + (+nx)*C3U;

}


void boundaryConditions2D(const iint bc,
			  const dfloat t, 
			  const dfloat x,  const dfloat y, 
			  const dfloat nx, const dfloat ny,
			  const dfloat RM,  const dfloat UM, const dfloat VM,
			  dfloat * restrict RB, dfloat * restrict UB, dfloat * restrict VB){

  *RB = RM;
  *UB = -UM;
  *VB = -VM;

#if 0
  if(bc==1){
    *RB = RM;
    *UB = -UM;
    *VB = -VM;
  }
  if(bc>1){ // wall for non-mean flow
    *RB = 2.f*p_Rbar - RM;
    *UB = 2.f*p_Ubar - UM;
    *VB = 2.f*p_Vbar - VM; 
  }
#endif
}




// batch process elements
// assume that the derivatives are on the test function
kernel void eulerSurface2D(const iint Nelements,
			   const dfloat * restrict sgeo,
			   const dfloat * restrict intInterpT, // interpolate to integration nodes
			   const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
			   const iint   * restrict vmapM,
			   const iint   * restrict vmapP,
			   const iint   * restrict EToB,
			   const dfloat time,
			   const dfloat * restrict intx, // integration nodes
			   const dfloat * restrict inty,
			   const dfloat4 * restrict q,
			   dfloat4 * restrict rhsq){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_RM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_RP[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];
    shared dfloat s_iRflux[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iUflux[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iVflux[p_NblockS][p_intNfpNfaces];

    
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const iint id  = e*p_Nfp*p_Nfaces + n;

	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM;
    
	    // load negative and positive trace node values of q
	    const dfloat4 qM = q[idM];
	    const dfloat4 qP = q[idP];
	    
	    dfloat RM = qM.x, UM = qM.y, VM = qM.z;
	    dfloat RP = qP.x, UP = qP.y, VP = qP.z;

	    s_RM[es][n] = RM;
	    s_UM[es][n] = UM;
	    s_VM[es][n] = VM;
	    
	    s_RP[es][n] = RP;
	    s_UP[es][n] = UP;
	    s_VP[es][n] = VP;
	  }
	}
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){ 
	iint e = eo + es;
	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const iint face = n/p_intNfp; // find face that owns this integration node
	  
	    // load surface geofactors for this face
	    const iint sid = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    dfloat iRM = 0.f, iUM = 0.f, iVM = 0.f;
	    dfloat iRP = 0.f, iUP = 0.f, iVP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    // [ exact to here ]
	    for(iint m=0;m<p_Nfp;++m){
	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
	      const iint fm = face*p_Nfp+m;
	      iRM += iInm*s_RM[es][fm];
	      iUM += iInm*s_UM[es][fm];
	      iVM += iInm*s_VM[es][fm];

	      iRP += iInm*s_RP[es][fm];
	      iUP += iInm*s_UP[es][fm];
	      iVP += iInm*s_VP[es][fm];
	    }


	    // apply boundary condition
	    // [ exact to here ]
	    iint bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      boundaryConditions2D(bc, time, 
				   intx[n+e*p_Nfaces*p_intNfp], 
				   inty[n+e*p_Nfaces*p_intNfp], 
				   nx, ny,
				   iRM, iUM, iVM,
				   &iRP, &iUP, &iVP);
	    }
	    
	    // compute (q^*)
	    dfloat iRS, iUS, iVS;
	    upwind1D(nx, ny,
		     iRM, iUM, iVM, 
		     iRP, iUP, iVP, 
		     &iRS, &iUS, &iVS);

	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^*) at integration nodes
	    const dfloat sc = invJ*sJ;
	    
	    s_iRflux[es][n] = -sc*(nx*iUS+ny*iVS);
	    s_iUflux[es][n] = -sc*(nx*(iUS*iUS/iRS + iRS*p_RT)+ny*(iUS*iVS/iRS));
	    s_iVflux[es][n] = -sc*(nx*(iUS*iVS/iRS)+ny*(iVS*iVS/iRS + iRS*p_RT));

	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){
	const iint e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    // prefetch volume rhs
	    dfloat4 rhsqn = rhsq[n+p_Np*e];
	    
	    dfloat rhsR = 0.f, rhsU = 0.f, rhsV = 0.f;
	    for(int m=0;m<p_intNfpNfaces;++m){
	      // RefMassMatrix^{-1}*cInterp^t*cWeight
#if 1
	      const dfloat L = intLIFTT[n+m*p_Np];
#else
	      const dfloat L = intLIFTT[n*p_Nfaces*p_intNfp+m];
#endif
	      double foo = s_iUflux[es][m];
	      
	      rhsR += L*s_iRflux[es][m];
	      rhsU += L*s_iUflux[es][m];
	      rhsV += L*s_iVflux[es][m];	      
	    }
	    
	    // increment volume RHS
	    rhsqn.x += rhsR;
	    rhsqn.y += rhsU;
	    rhsqn.z += rhsV;

	    rhsq[n+p_Np*e] = rhsqn;

	  }
	}
      }
    }

    
    
    
  }
}

