#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

kernel void boltzmannVolume2D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    const dfloat * restrict vgeo,
				    const dfloat * restrict DrT,
				    const dfloat * restrict DsT,
				    const dfloat4 * restrict q,
				          dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];

	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;

	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq4 -= p_tauInv*(s_q[es][3][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq5 -= p_tauInv*(s_q[es][4][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  rhsq6 -= p_tauInv*(s_q[es][5][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

	  // add mean flow forcing
	  rhsq2 += drampdt*p_q2bar;
	  rhsq3 += drampdt*p_q3bar;
	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

	  const int id = element*p_Np+n;	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*id] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*id+1] = tmp;
	}
      }
    }
  }
}



kernel void boltzmannVolumeCub2D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    const dfloat * restrict vgeo,
				    const dfloat * restrict DrT,
				    const dfloat * restrict DsT,
				    const dfloat4 * restrict q,
				          dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];

	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;

	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // add mean flow forcing
	  rhsq2 += drampdt*p_q2bar;
	  rhsq3 += drampdt*p_q3bar;
	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

	  const int id = element*p_Np+n;	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*id] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*id+1] = tmp;
	}
      }
    }
  }
}





kernel void boltzmannSplitPmlVolume2D(const iint Nelements,
				      const iint * restrict elementIds,
				      const dfloat * restrict vgeo,
				      const dfloat * restrict sigmax,
				      const dfloat * restrict sigmay,
				      const dfloat * restrict DrT,
				      const dfloat * restrict DsT,
				      const dfloat4 * restrict q,
				      const dfloat * restrict pmlqx,
				      const dfloat * restrict pmlqy,
				            dfloat * restrict rhspmlqx,
				            dfloat * restrict rhspmlqy
				      ){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];

	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

	  iint base = element*p_Np*p_Nfields+n;
	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
	  // transport operator
	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhspmlqx6 = 0;

	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
	  dfloat rhspmlqy5 = 0;
	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // BGK relaxation approximation to the Boltzmann collision operator
	  dfloat N4 = -p_tauInv*(s_q[es][3][n]-(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat N5 = -p_tauInv*(s_q[es][4][n]-(p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  dfloat N6 = -p_tauInv*(s_q[es][5][n]-(p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

	  //
	  dfloat alpha = 0.5f;
	  dfloat beta  = 0.5f; 

	  rhspmlqx4 += alpha*N4; // split
	  rhspmlqx5 += alpha*N5;
	  rhspmlqx6 += alpha*N6;

	  rhspmlqy4 += beta*N4; // split
	  rhspmlqy5 += beta*N5;
	  rhspmlqy6 += beta*N6;

	  // pml relaxation back to mean flow
	  rhspmlqx1 += -msigmaxe*(pmlqx1);
	  rhspmlqx2 += -msigmaxe*(pmlqx2);
	  rhspmlqx3 += -msigmaxe*(pmlqx3);
	  rhspmlqx4 += -msigmaxe*(pmlqx4);
	  rhspmlqx5 += -msigmaxe*(pmlqx5);
	  rhspmlqx6 += -msigmaxe*(pmlqx6);

	  rhspmlqy1 += -msigmaye*(pmlqy1);
	  rhspmlqy2 += -msigmaye*(pmlqy2);
	  rhspmlqy3 += -msigmaye*(pmlqy3);
	  rhspmlqy4 += -msigmaye*(pmlqy4);
	  rhspmlqy5 += -msigmaye*(pmlqy5);
	  rhspmlqy6 += -msigmaye*(pmlqy6);
	  
	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
	  rhspmlqy[base+5*p_Np] = rhspmlqy6;

	}
      }
    }
  


  }
}



kernel void boltzmannSplitPmlVolumeCub2D(const iint Nelements,
				      const iint * restrict elementIds,
				      const dfloat * restrict vgeo,
				      const dfloat * restrict sigmax,
				      const dfloat * restrict sigmay,
				      const dfloat * restrict DrT,
				      const dfloat * restrict DsT,
				      const dfloat4 * restrict q,
				      const dfloat * restrict pmlqx,
				      const dfloat * restrict pmlqy,
				            dfloat * restrict rhspmlqx,
				            dfloat * restrict rhspmlqy){
  
   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];

	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

	  iint base = element*p_Np*p_Nfields+n;
	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

  
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
	  // transport operator
	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhspmlqx6 = 0;

	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
	  dfloat rhspmlqy5 = 0;
	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // pml relaxation back to mean flow
	  rhspmlqx1 += -msigmaxe*(pmlqx1);
	  rhspmlqx2 += -msigmaxe*(pmlqx2);
	  rhspmlqx3 += -msigmaxe*(pmlqx3);
	  rhspmlqx4 += -msigmaxe*(pmlqx4);
	  rhspmlqx5 += -msigmaxe*(pmlqx5);
	  rhspmlqx6 += -msigmaxe*(pmlqx6);

	  rhspmlqy1 += -msigmaye*(pmlqy1);
	  rhspmlqy2 += -msigmaye*(pmlqy2);
	  rhspmlqy3 += -msigmaye*(pmlqy3);
	  rhspmlqy4 += -msigmaye*(pmlqy4);
	  rhspmlqy5 += -msigmaye*(pmlqy5);
	  rhspmlqy6 += -msigmaye*(pmlqy6);
	  
	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
	  rhspmlqy[base+5*p_Np] = rhspmlqy6;

	}
      }
    }
  }
}











kernel void boltzmannSAVolume2D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    const dfloat * restrict vgeo,
				    const dfloat * restrict DrT,
				    const dfloat * restrict DsT,
				    const dfloat4 * restrict q,
				          dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];

	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;

	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq4 += p_tauInv* (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]);
	  rhsq5 += p_tauInv* p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]);
	  rhsq6 += p_tauInv* p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]);

	  // add mean flow forcing
	  rhsq2 += drampdt*p_q2bar;
	  rhsq3 += drampdt*p_q3bar;
	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

	  const int id = element*p_Np+n;	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*id] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*id+1] = tmp;
	}
      }
    }
  }
}


kernel void boltzmannSASplitPmlVolume2D(const iint Nelements,
				      const iint * restrict elementIds,
				      const dfloat ramp,
				      const dfloat * restrict vgeo,
				      const dfloat * restrict sigmax,
				      const dfloat * restrict sigmay,
				      const dfloat * restrict DrT,
				      const dfloat * restrict DsT,
				      const dfloat4 * restrict q,
				      const dfloat * restrict pmlqx,
				      const dfloat * restrict pmlqy,
				            dfloat * restrict rhspmlqx,
				            dfloat * restrict rhspmlqy
				      ){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];

	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

	  iint base = element*p_Np*p_Nfields+n;
	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
	  dfloat pmlqy6 = pmlqy[base+5*p_Np];
	  
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
	  // transport operator
	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhspmlqx6 = 0;

	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
	  dfloat rhspmlqy5 = 0;
	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   
      

       dfloat nq4 = (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]) ;
       dfloat nq5 = (p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]);
       dfloat nq6 = (p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]);


	  // BGK relaxation approximation to the Boltzmann collision operator
	  dfloat N4 = -p_tauInv*(s_q[es][3][n]-nq4);
	  dfloat N5 = -p_tauInv*(s_q[es][4][n]-nq5);
	  dfloat N6 = -p_tauInv*(s_q[es][5][n]-nq6);
	  //
	  // BGK relaxation approximation to the Boltzmann collision operator
	  dfloat NX4 = -p_tauInv*(ramp*ramp*p_q4bar + pmlqy4-nq4);
	  dfloat NX5 = -p_tauInv*(ramp*ramp*p_q5bar + pmlqy5-nq5);
	  dfloat NX6 = -p_tauInv*(ramp*ramp*p_q6bar + pmlqy6-nq6);
	  //
	  // BGK relaxation approximation to the Boltzmann collision operator
	  dfloat NY4 = -p_tauInv*(ramp*ramp*p_q4bar+ pmlqx4-nq4);
	  dfloat NY5 = -p_tauInv*(ramp*ramp*p_q5bar+ pmlqx5-nq5);
	  dfloat NY6 = -p_tauInv*(ramp*ramp*p_q6bar+ pmlqx6-nq6);
	  //
	  dfloat alpha = 0.5f; 
	  dfloat beta  = 0.5f; 

	  rhspmlqx4 += alpha*NX4; // split
	  rhspmlqx5 += alpha*NX5;
	  rhspmlqx6 += alpha*NX6;

	  rhspmlqy4 += beta*NY4; // split
	  rhspmlqy5 += beta*NY5;
	  rhspmlqy6 += beta*NY6;

	  // pml relaxation back to mean flow
	  rhspmlqx1 += -msigmaxe*(pmlqx1);
	  rhspmlqx2 += -msigmaxe*(pmlqx2);
	  rhspmlqx3 += -msigmaxe*(pmlqx3);
	  rhspmlqx4 += -msigmaxe*(pmlqx4);
	  rhspmlqx5 += -msigmaxe*(pmlqx5);
	  rhspmlqx6 += -msigmaxe*(pmlqx6);

	  rhspmlqy1 += -msigmaye*(pmlqy1);
	  rhspmlqy2 += -msigmaye*(pmlqy2);
	  rhspmlqy3 += -msigmaye*(pmlqy3);
	  rhspmlqy4 += -msigmaye*(pmlqy4);
	  rhspmlqy5 += -msigmaye*(pmlqy5);
	  rhspmlqy6 += -msigmaye*(pmlqy6);
	  
	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
	  rhspmlqy[base+5*p_Np] = rhspmlqy6;
	}
      }
    }
  }
}



kernel void boltzmannSASplitPmlVolumeCub2D(const iint Nelements,
				      const iint * restrict elementIds,
				      dfloat ramp,
				      const dfloat * restrict vgeo,
				      const dfloat * restrict sigmax,
				      const dfloat * restrict sigmay,
				      const dfloat * restrict DrT,
				      const dfloat * restrict DsT,
				      const dfloat4 * restrict q,
				      const dfloat * restrict pmlqx,
				      const dfloat * restrict pmlqy,
				            dfloat * restrict rhspmlqx,
				            dfloat * restrict rhspmlqy){
  
   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  
	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];

	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

	  iint base = element*p_Np*p_Nfields+n;
	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
	  dfloat pmlqy6 = pmlqy[base+5*p_Np];
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
	  // transport operator
	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhspmlqx6 = 0;

	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
	  dfloat rhspmlqy5 = 0;
	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

	  // pml relaxation back to mean flow
	  rhspmlqx1 += -msigmaxe*(pmlqx1);
	  rhspmlqx2 += -msigmaxe*(pmlqx2);
	  rhspmlqx3 += -msigmaxe*(pmlqx3);
	  rhspmlqx4 += -msigmaxe*(pmlqx4);
	  rhspmlqx5 += -msigmaxe*(pmlqx5);
	  rhspmlqx6 += -msigmaxe*(pmlqx6);

	  rhspmlqy1 += -msigmaye*(pmlqy1);
	  rhspmlqy2 += -msigmaye*(pmlqy2);
	  rhspmlqy3 += -msigmaye*(pmlqy3);
	  rhspmlqy4 += -msigmaye*(pmlqy4);
	  rhspmlqy5 += -msigmaye*(pmlqy5);
	  rhspmlqy6 += -msigmaye*(pmlqy6);
	  
	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
	  rhspmlqy[base+5*p_Np] = rhspmlqy6;
	}
      }
    }
  }
}








kernel void boltzmannVolume2Dbbdg(const iint Nelements,
					const iint * restrict elementIds,
					const dfloat ramp,
					const dfloat drampdt,
					const dfloat * restrict vgeo,
					const iint * restrict D1ids,
					const iint * restrict D2ids,
					const iint * restrict D3ids,
					const dfloat * restrict Dvals,		
					const dfloat4 * restrict q,
					dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][6][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];

	  s_q[es][0][n] = qan.x;
	  s_q[es][1][n] = qan.y;
	  s_q[es][2][n] = qan.z;
	  s_q[es][3][n] = qan.w;

	  s_q[es][4][n] = qbn.x;
	  s_q[es][5][n] = qbn.y;

	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  //dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  //dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  const iint D1i1 = D1ids[n];
	  const iint D2i1 = D2ids[n];
	  const iint D3i1 = D3ids[n];
	  const dfloat Dval1 = Dvals[n];
	  
	  const iint D1i2 = D1ids[n + p_Np];
	  const iint D2i2 = D2ids[n + p_Np];
	  const iint D3i2 = D3ids[n + p_Np];
	  const dfloat Dval2 = Dvals[n + p_Np];

	  const iint D1i3 = D1ids[n + 2*p_Np];
	  const iint D2i3 = D2ids[n + 2*p_Np];
	  const iint D3i3 = D3ids[n + 2*p_Np];	  
	  const dfloat Dval3 = Dvals[n + 2*p_Np];

#if 1
	  const dfloat dq1dr = .5f*(Dval1*(s_q[es][0][D2i1] - s_q[es][0][D1i1]) +
				    Dval2*(s_q[es][0][D2i2] - s_q[es][0][D1i2]) +
				    Dval3*(s_q[es][0][D2i3] - s_q[es][0][D1i3]));
	  const dfloat dq1ds = .5f*(Dval1*(s_q[es][0][D3i1] - s_q[es][0][D1i1]) +
				    Dval2*(s_q[es][0][D3i2] - s_q[es][0][D1i2]) +
				    Dval3*(s_q[es][0][D3i3] - s_q[es][0][D1i3]));
	  
	  const dfloat dq2dr = .5f*(Dval1*(s_q[es][1][D2i1] - s_q[es][1][D1i1]) +
				    Dval2*(s_q[es][1][D2i2] - s_q[es][1][D1i2]) +
				    Dval3*(s_q[es][1][D2i3] - s_q[es][1][D1i3]));
	  const dfloat dq2ds = .5f*(Dval1*(s_q[es][1][D3i1] - s_q[es][1][D1i1]) +
				    Dval2*(s_q[es][1][D3i2] - s_q[es][1][D1i2]) +
				    Dval3*(s_q[es][1][D3i3] - s_q[es][1][D1i3]));
	  
	  const dfloat dq3dr = .5f*(Dval1*(s_q[es][2][D2i1] - s_q[es][2][D1i1]) +
				    Dval2*(s_q[es][2][D2i2] - s_q[es][2][D1i2]) +
				    Dval3*(s_q[es][2][D2i3] - s_q[es][2][D1i3]));
	  const dfloat dq3ds = .5f*(Dval1*(s_q[es][2][D3i1] - s_q[es][2][D1i1]) +
				    Dval2*(s_q[es][2][D3i2] - s_q[es][2][D1i2]) +
				    Dval3*(s_q[es][2][D3i3] - s_q[es][2][D1i3]));
	  
	  const dfloat dq4dr = .5f*(Dval1*(s_q[es][3][D2i1] - s_q[es][3][D1i1]) +
				    Dval2*(s_q[es][3][D2i2] - s_q[es][3][D1i2]) +
				    Dval3*(s_q[es][3][D2i3] - s_q[es][3][D1i3]));
	  const dfloat dq4ds = .5f*(Dval1*(s_q[es][3][D3i1] - s_q[es][3][D1i1]) +
				    Dval2*(s_q[es][3][D3i2] - s_q[es][3][D1i2]) +
				    Dval3*(s_q[es][3][D3i3] - s_q[es][3][D1i3]));
	  
	  const dfloat dq5dr = .5f*(Dval1*(s_q[es][4][D2i1] - s_q[es][4][D1i1]) +
				    Dval2*(s_q[es][4][D2i2] - s_q[es][4][D1i2]) +
				    Dval3*(s_q[es][4][D2i3] - s_q[es][4][D1i3]));
	  const dfloat dq5ds = .5f*(Dval1*(s_q[es][4][D3i1] - s_q[es][4][D1i1]) +
				    Dval2*(s_q[es][4][D3i2] - s_q[es][4][D1i2]) +
				    Dval3*(s_q[es][4][D3i3] - s_q[es][4][D1i3])); 

	  const dfloat dq6dr = .5f*(Dval1*(s_q[es][5][D2i1] - s_q[es][5][D1i1]) +
				    Dval2*(s_q[es][5][D2i2] - s_q[es][5][D1i2]) +
				    Dval3*(s_q[es][5][D2i3] - s_q[es][5][D1i3]));
	  const dfloat dq6ds = .5f*(Dval1*(s_q[es][5][D3i1] - s_q[es][5][D1i1]) +
				    Dval2*(s_q[es][5][D3i2] - s_q[es][5][D1i2]) +
				    Dval3*(s_q[es][5][D3i3] - s_q[es][5][D1i3])); 
	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   
#endif
	  
#if 0
	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq4 -= p_tauInv*(s_q[es][3][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq5 -= p_tauInv*(s_q[es][4][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  rhsq6 -= p_tauInv*(s_q[es][5][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
#endif

#if 1
	  // add mean flow forcing
	  rhsq2 += drampdt*p_q2bar;
	  rhsq3 += drampdt*p_q3bar;
	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

	  const int id = element*p_Np+n;	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*id] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*id+1] = tmp;
#endif
	}
      }
    }
  }
}




// kernel void boltzmannSASplitPmlVolumeCub2D(const iint Nelements,
// 				      const iint * restrict elementIds,
// 				      dfloat ramp,
// 				      const dfloat * restrict vgeo,
// 				      const dfloat * restrict sigmax,
// 				      const dfloat * restrict sigmay,
// 				      const dfloat * restrict DrT,
// 				      const dfloat * restrict DsT,
// 				      const dfloat4 * restrict q,
// 				      const dfloat * restrict pmlqx,
// 				      const dfloat * restrict pmlqy,
// 				            dfloat * restrict rhspmlqx,
// 				            dfloat * restrict rhspmlqy){
  
//    for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     shared dfloat s_q[p_NblockV][6][p_Np];
//     exclusive iint element;

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const iint id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;
// 	}
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  const dfloat sigmaxe = sigmax[element*p_Np+n];
// 	  const dfloat sigmaye = sigmay[element*p_Np+n];

// 	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
// 	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

// 	  iint base = element*p_Np*p_Nfields+n;
// 	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
// 	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
// 	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
// 	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
// 	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
// 	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

// 	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
// 	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
// 	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
// 	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
// 	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
// 	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

// 	  dfloat pmlNT4 = pmlNT[base+3*p_Np];
// 	  dfloat pmlNT5 = pmlNT[base+4*p_Np];
// 	  dfloat pmlNT6 = pmlNT[base+5*p_Np];
	  
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  occaUnroll(p_Np)
// 	  for(iint i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
// 	  // transport operator
// 	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
// 	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
// 	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
// 	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
// 	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhspmlqx6 = 0;

// 	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
// 	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
// 	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
// 	  dfloat rhspmlqy5 = 0;
// 	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // pml relaxation back to mean flow
// 	  rhspmlqx1 += -msigmaxe*(pmlqx1);
// 	  rhspmlqx2 += -msigmaxe*(pmlqx2);
// 	  rhspmlqx3 += -msigmaxe*(pmlqx3);
// 	  rhspmlqx4 += -msigmaxe*(pmlqx4) + 0.5f*msigmaxe*pmlNT4;
// 	  rhspmlqx5 += -msigmaxe*(pmlqx5) + 0.5f*msigmaxe*pmlNT5;
// 	  rhspmlqx6 += -msigmaxe*(pmlqx6) + 0.5f*msigmaxe*pmlNT6;

// 	  rhspmlqy1 += -msigmaye*(pmlqy1);
// 	  rhspmlqy2 += -msigmaye*(pmlqy2);
// 	  rhspmlqy3 += -msigmaye*(pmlqy3);
// 	  rhspmlqy4 += -msigmaye*(pmlqy4) + 0.5f*msigmaye*pmlNT4;
// 	  rhspmlqy5 += -msigmaye*(pmlqy5) + 0.5f*msigmaye*pmlNT5;
// 	  rhspmlqy6 += -msigmaye*(pmlqy6) + 0.5f*msigmaye*pmlNT6;
	  
// 	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
// 	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
// 	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
// 	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
// 	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
// 	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
// 	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
// 	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
// 	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
// 	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
// 	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
// 	  rhspmlqy[base+5*p_Np] = rhspmlqy6;
// 	}
//       }
//     }
//   }
// }










// kernel void boltzmannSASplitPmlVolume2D(const iint Nelements,
// 				      const iint * restrict elementIds,
// 				      const dfloat ramp,
// 				      const dfloat * restrict vgeo,
// 				      const dfloat * restrict sigmax,
// 				      const dfloat * restrict sigmay,
// 				      const dfloat * restrict DrT,
// 				      const dfloat * restrict DsT,
// 				      const dfloat4 * restrict q,
// 				      const dfloat * restrict pmlqx,
// 				      const dfloat * restrict pmlqy,
// 				      const dfloat * restrict pmlNT,
// 				            dfloat * restrict rhspmlqx,
// 				            dfloat * restrict rhspmlqy,
// 				            dfloat * restrict rhspmlNT
// 				      ){
  
//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     shared dfloat s_q[p_NblockV][6][p_Np];
//     exclusive iint element;

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const iint id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;
// 	}
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  const dfloat sigmaxe = sigmax[element*p_Np+n];
// 	  const dfloat sigmaye = sigmay[element*p_Np+n];

// 	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
// 	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

// 	  iint base = element*p_Np*p_Nfields+n;
// 	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
// 	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
// 	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
// 	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
// 	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
// 	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

// 	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
// 	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
// 	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
// 	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
// 	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
// 	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

// 	  dfloat pmlNT4 = pmlNT[base+3*p_Np];
// 	  dfloat pmlNT5 = pmlNT[base+4*p_Np];
// 	  dfloat pmlNT6 = pmlNT[base+5*p_Np];
	  
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  occaUnroll(p_Np)
// 	  for(iint i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
// 	  // transport operator
// 	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
// 	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
// 	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
// 	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
// 	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhspmlqx6 = 0;

// 	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
// 	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
// 	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
// 	  dfloat rhspmlqy5 = 0;
// 	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   
      

//        dfloat nq4 = (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]) ;
//        dfloat nq5 = (p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]);
//        dfloat nq6 = (p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]);


// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  dfloat N4 = -p_tauInv*(s_q[es][3][n]-nq4);
// 	  dfloat N5 = -p_tauInv*(s_q[es][4][n]-nq5);
// 	  dfloat N6 = -p_tauInv*(s_q[es][5][n]-nq6);
// 	  //
// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  dfloat NX4 = -p_tauInv*(ramp*ramp*p_q4bar + pmlqy4-nq4);
// 	  dfloat NX5 = -p_tauInv*(ramp*ramp*p_q5bar + pmlqy5-nq5);
// 	  dfloat NX6 = -p_tauInv*(ramp*ramp*p_q6bar + pmlqy6-nq6);
// 	  //
// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  dfloat NY4 = -p_tauInv*(ramp*ramp*p_q4bar+ pmlqx4-nq4);
// 	  dfloat NY5 = -p_tauInv*(ramp*ramp*p_q5bar+ pmlqx5-nq5);
// 	  dfloat NY6 = -p_tauInv*(ramp*ramp*p_q6bar+ pmlqx6-nq6);

// 	  rhspmlqx4 += 0.5f*NX4; // split
// 	  rhspmlqx5 += 0.5f*NX5;
// 	  rhspmlqx6 += 0.5f*NX6;

// 	  rhspmlqy4 += 0.5f*NY4; // split
// 	  rhspmlqy5 += 0.5f*NY5;
// 	  rhspmlqy6 += 0.5f*NY6;

// 	  // pml relaxation back to mean flow
// 	  rhspmlqx1 += -msigmaxe*(pmlqx1);
// 	  rhspmlqx2 += -msigmaxe*(pmlqx2);
// 	  rhspmlqx3 += -msigmaxe*(pmlqx3);
// 	  rhspmlqx4 += -msigmaxe*(pmlqx4) + 0.5f*msigmaxe*pmlNT4;
// 	  rhspmlqx5 += -msigmaxe*(pmlqx5) + 0.5f*msigmaxe*pmlNT5;
// 	  rhspmlqx6 += -msigmaxe*(pmlqx6) + 0.5f*msigmaxe*pmlNT6;

// 	  rhspmlqy1 += -msigmaye*(pmlqy1);
// 	  rhspmlqy2 += -msigmaye*(pmlqy2);
// 	  rhspmlqy3 += -msigmaye*(pmlqy3);
// 	  rhspmlqy4 += -msigmaye*(pmlqy4) + 0.5f*msigmaye*pmlNT4;
// 	  rhspmlqy5 += -msigmaye*(pmlqy5) + 0.5f*msigmaye*pmlNT5;
// 	  rhspmlqy6 += -msigmaye*(pmlqy6) + 0.5f*msigmaye*pmlNT6;
	  
// 	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
// 	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
// 	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
// 	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
// 	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
// 	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
// 	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
// 	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
// 	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
// 	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
// 	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
// 	  rhspmlqy[base+5*p_Np] = rhspmlqy6;

// 	  rhspmlNT[base+3*p_Np] = N4;
// 	  rhspmlNT[base+4*p_Np] = N5;
// 	  rhspmlNT[base+5*p_Np] = N6;  
// 	}
//       }
//     }
//   }
// }






// kernel void boltzmannSplitPmlVolumeCub2D(const iint Nelements,
// 				      const iint * restrict elementIds,
// 				      const dfloat * restrict vgeo,
// 				      const dfloat * restrict sigmax,
// 				      const dfloat * restrict sigmay,
// 				      const dfloat * restrict DrT,
// 				      const dfloat * restrict DsT,
// 				      const dfloat4 * restrict q,
// 				      const dfloat * restrict pmlqx,
// 				      const dfloat * restrict pmlqy,
// 				      const dfloat * restrict pmlNT,
// 				            dfloat * restrict rhspmlqx,
// 				            dfloat * restrict rhspmlqy,
// 				      const dfloat * restrict rhspmlNT
// 				      ){
  
//    for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     shared dfloat s_q[p_NblockV][6][p_Np];
//     exclusive iint element;

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const iint id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;
// 	}
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  const dfloat sigmaxe = sigmax[element*p_Np+n];
// 	  const dfloat sigmaye = sigmay[element*p_Np+n];

// 	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
// 	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

// 	  iint base = element*p_Np*p_Nfields+n;
// 	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
// 	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
// 	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
// 	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
// 	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
// 	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

// 	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
// 	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
// 	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
// 	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
// 	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
// 	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

// 	  dfloat pmlNT4 = pmlNT[base+3*p_Np];
// 	  dfloat pmlNT5 = pmlNT[base+4*p_Np];
// 	  dfloat pmlNT6 = pmlNT[base+5*p_Np];
	  
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  occaUnroll(p_Np)
// 	  for(iint i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
// 	  // transport operator
// 	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
// 	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
// 	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
// 	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
// 	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhspmlqx6 = 0;

// 	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
// 	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
// 	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
// 	  dfloat rhspmlqy5 = 0;
// 	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // pml relaxation back to mean flow
// 	  rhspmlqx1 += -msigmaxe*(pmlqx1);
// 	  rhspmlqx2 += -msigmaxe*(pmlqx2);
// 	  rhspmlqx3 += -msigmaxe*(pmlqx3);
// 	  rhspmlqx4 += -msigmaxe*(pmlqx4) + 0.5f*msigmaxe*pmlNT4;
// 	  rhspmlqx5 += -msigmaxe*(pmlqx5) + 0.5f*msigmaxe*pmlNT5;
// 	  rhspmlqx6 += -msigmaxe*(pmlqx6) + 0.5f*msigmaxe*pmlNT6;

// 	  rhspmlqy1 += -msigmaye*(pmlqy1);
// 	  rhspmlqy2 += -msigmaye*(pmlqy2);
// 	  rhspmlqy3 += -msigmaye*(pmlqy3);
// 	  rhspmlqy4 += -msigmaye*(pmlqy4) + 0.5f*msigmaye*pmlNT4;
// 	  rhspmlqy5 += -msigmaye*(pmlqy5) + 0.5f*msigmaye*pmlNT5;
// 	  rhspmlqy6 += -msigmaye*(pmlqy6) + 0.5f*msigmaye*pmlNT6;
	  
// 	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
// 	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
// 	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
// 	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
// 	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
// 	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
// 	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
// 	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
// 	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
// 	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
// 	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
// 	  rhspmlqy[base+5*p_Np] = rhspmlqy6;

// 	}
//       }
//     }
//   }
// }




// kernel void boltzmannSplitPmlVolume2D(const iint Nelements,
// 				      const iint * restrict elementIds,
// 				      const dfloat * restrict vgeo,
// 				      const dfloat * restrict sigmax,
// 				      const dfloat * restrict sigmay,
// 				      const dfloat * restrict DrT,
// 				      const dfloat * restrict DsT,
// 				      const dfloat4 * restrict q,
// 				      const dfloat * restrict pmlqx,
// 				      const dfloat * restrict pmlqy,
// 				      const dfloat * restrict pmlNT,
// 				            dfloat * restrict rhspmlqx,
// 				            dfloat * restrict rhspmlqy,
// 				            dfloat * restrict rhspmlNT
// 				      ){
  
//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     shared dfloat s_q[p_NblockV][6][p_Np];
//     exclusive iint element;

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const iint id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];
	  
// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;
// 	}
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  const dfloat sigmaxe = sigmax[element*p_Np+n];
// 	  const dfloat sigmaye = sigmay[element*p_Np+n];

// 	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha;
// 	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha;

// 	  iint base = element*p_Np*p_Nfields+n;
// 	  dfloat pmlqx1 = pmlqx[base+0*p_Np];
// 	  dfloat pmlqx2 = pmlqx[base+1*p_Np];
// 	  dfloat pmlqx3 = pmlqx[base+2*p_Np];
// 	  dfloat pmlqx4 = pmlqx[base+3*p_Np];
// 	  dfloat pmlqx5 = pmlqx[base+4*p_Np];
// 	  dfloat pmlqx6 = pmlqx[base+5*p_Np];

// 	  dfloat pmlqy1 = pmlqy[base+0*p_Np];
// 	  dfloat pmlqy2 = pmlqy[base+1*p_Np];
// 	  dfloat pmlqy3 = pmlqy[base+2*p_Np];
// 	  dfloat pmlqy4 = pmlqy[base+3*p_Np];
// 	  dfloat pmlqy5 = pmlqy[base+4*p_Np];
// 	  dfloat pmlqy6 = pmlqy[base+5*p_Np];

// 	  dfloat pmlNT4 = pmlNT[base+3*p_Np];
// 	  dfloat pmlNT5 = pmlNT[base+4*p_Np];
// 	  dfloat pmlNT6 = pmlNT[base+5*p_Np];
	  
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  occaUnroll(p_Np)
// 	  for(iint i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  	 	  
// 	  // transport operator
// 	  dfloat rhspmlqx1 = -p_sqrtRT*(dq2dx);
// 	  dfloat rhspmlqx2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx);	
// 	  dfloat rhspmlqx3 = -p_sqrtRT*(dq4dx);
// 	  dfloat rhspmlqx4 = -p_sqrtRT*(dq3dx);
// 	  dfloat rhspmlqx5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhspmlqx6 = 0;

// 	  dfloat rhspmlqy1 = -p_sqrtRT*(dq3dy);
// 	  dfloat rhspmlqy2 = -p_sqrtRT*(dq4dy);	
// 	  dfloat rhspmlqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhspmlqy4 = -p_sqrtRT*(dq2dy);		
// 	  dfloat rhspmlqy5 = 0;
// 	  dfloat rhspmlqy6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  dfloat N4 = -p_tauInv*(s_q[es][3][n]-(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
// 	  dfloat N5 = -p_tauInv*(s_q[es][4][n]-(p_invsqrt2*s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
// 	  dfloat N6 = -p_tauInv*(s_q[es][5][n]-(p_invsqrt2*s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

// 	  rhspmlqx4 += 0.5f*N4; // split
// 	  rhspmlqx5 += 0.5f*N5;
// 	  rhspmlqx6 += 0.5f*N6;

// 	  rhspmlqy4 += 0.5f*N4; // split
// 	  rhspmlqy5 += 0.5f*N5;
// 	  rhspmlqy6 += 0.5f*N6;

// 	  // pml relaxation back to mean flow
// 	  rhspmlqx1 += -msigmaxe*(pmlqx1);
// 	  rhspmlqx2 += -msigmaxe*(pmlqx2);
// 	  rhspmlqx3 += -msigmaxe*(pmlqx3);
// 	  rhspmlqx4 += -msigmaxe*(pmlqx4) + 0.5f*msigmaxe*pmlNT4;
// 	  rhspmlqx5 += -msigmaxe*(pmlqx5) + 0.5f*msigmaxe*pmlNT5;
// 	  rhspmlqx6 += -msigmaxe*(pmlqx6) + 0.5f*msigmaxe*pmlNT6;

// 	  rhspmlqy1 += -msigmaye*(pmlqy1);
// 	  rhspmlqy2 += -msigmaye*(pmlqy2);
// 	  rhspmlqy3 += -msigmaye*(pmlqy3);
// 	  rhspmlqy4 += -msigmaye*(pmlqy4) + 0.5f*msigmaye*pmlNT4;
// 	  rhspmlqy5 += -msigmaye*(pmlqy5) + 0.5f*msigmaye*pmlNT5;
// 	  rhspmlqy6 += -msigmaye*(pmlqy6) + 0.5f*msigmaye*pmlNT6;
	  
// 	  rhspmlqx[base+0*p_Np] = rhspmlqx1;
// 	  rhspmlqx[base+1*p_Np] = rhspmlqx2;
// 	  rhspmlqx[base+2*p_Np] = rhspmlqx3;
// 	  rhspmlqx[base+3*p_Np] = rhspmlqx4;
// 	  rhspmlqx[base+4*p_Np] = rhspmlqx5;
// 	  rhspmlqx[base+5*p_Np] = rhspmlqx6;
	  
// 	  rhspmlqy[base+0*p_Np] = rhspmlqy1;
// 	  rhspmlqy[base+1*p_Np] = rhspmlqy2;
// 	  rhspmlqy[base+2*p_Np] = rhspmlqy3;
// 	  rhspmlqy[base+3*p_Np] = rhspmlqy4;
// 	  rhspmlqy[base+4*p_Np] = rhspmlqy5;
// 	  rhspmlqy[base+5*p_Np] = rhspmlqy6;

// 	  rhspmlNT[base+3*p_Np] = N4;
// 	  rhspmlNT[base+4*p_Np] = N5;
// 	  rhspmlNT[base+5*p_Np] = N6;  
// 	}
//       }
//     }
//   }
// }
