
// compute div(NU)  = div(uxu) in collocation way
kernel void insAdvectionVolumeQuad2D(const dlong Nelements,
         const dfloat * restrict vgeo,
         const dfloat * restrict D,
         const dlong offset,
         const dfloat * restrict U,
         const dfloat * restrict V,
         dfloat * restrict NU,
         dfloat * restrict NV){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F12[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F22[p_NblockV][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            const dfloat Un = U[id];
            const dfloat Vn = V[id];

            s_F11[es][j][i] = Un*Un;
            s_F12[es][j][i] = Vn*Un;
            s_F22[es][j][i] = Vn*Vn;

            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

            // compute 'r' and 's' derivatives of (q_m) at node n
            dfloat df11dr = 0.f, df11ds = 0.f;
            dfloat df12dr = 0.f, df12ds = 0.f;
            dfloat df22dr = 0.f, df22ds = 0.f;

            occaUnroll(p_Nq)
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[i][n];
                const dfloat Ds = s_D[j][n];

                df11dr += Dr*s_F11[es][j][n];
                df11ds += Ds*s_F11[es][n][i];
                
                df12dr += Dr*s_F12[es][j][n];
                df12ds += Ds*s_F12[es][n][i];
                
                df22dr += Dr*s_F22[es][j][n];
                df22ds += Ds*s_F22[es][n][i];
              }

            const dfloat df11dx = drdx*df11dr + dsdx*df11ds;
            const dfloat df12dx = drdx*df12dr + dsdx*df12ds;
            const dfloat df12dy = drdy*df12dr + dsdy*df12ds;
            const dfloat df22dy = drdy*df22dr + dsdy*df22ds;

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            NU[id] = df11dx + df12dy;
            NV[id] = df12dx + df22dy;
          }
        }
      }
    }
  }  
}


/*
// compute div(NU)  = div(uxu) in collocation way (weak form)
kernel void insAdvectionVolumeQuad2D(const dlong Nelements,
         const dfloat * restrict vgeo,
         const dfloat * restrict D,
         const dlong offset,
         const dfloat * restrict U,
         const dfloat * restrict V,
         dfloat * restrict NU,
         dfloat * restrict NV){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F12[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F21[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F22[p_NblockV][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
            const dfloat JW = vgeo[gid + p_JWID*p_Np];

            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            const dfloat Un = U[id];
            const dfloat Vn = V[id];

            const dfloat cUn = JW*(drdx*Un+drdy*Vn);
            const dfloat cVn = JW*(dsdx*Un+dsdy*Vn);

            s_F11[es][j][i] = cUn*Un;
            s_F12[es][j][i] = cVn*Un;
            s_F21[es][j][i] = cUn*Vn;
            s_F22[es][j][i] = cVn*Vn;

            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat JW = vgeo[gid + p_JWID*p_Np];
            dfloat nu = 0.f, nv = 0.f;
            
            occaUnroll(p_Nq)
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[n][i];
                const dfloat Ds = s_D[n][j];

                nu += Dr*s_F11[es][j][n]
                     +Ds*s_F12[es][n][i];

                nv += Dr*s_F21[es][j][n]
                     +Ds*s_F22[es][n][i];
              }

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            NU[id] = -nu/JW;
            NV[id] = -nv/JW;
          }
        }
      }
    }
  }  
}
*/

#define surfaceTerms(sk,face,i, j)                                      \
  {                                                                     \
  const dlong  idM = vmapM[sk]+offset*p_Np;                             \
  const dlong  idP = vmapP[sk]+offset*p_Np;                             \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat  uM = U[idM], vM = V[idM];                               \
         dfloat uP = U[idP], vP = V[idP];                               \
                                                                        \
  int bc = EToB[face+p_Nfaces*e];                                       \
  if(bc>0) {                                                            \
    const dlong idm = vmapM[sk];                                                    \
    insAdvectionBoundaryConditions2D(bc, time, x[idm], y[idm], nx, ny, uM, vM, &uP, &vP); \
  }                                                                     \
                                                                        \
  dfloat unM   = occaFabs(nx*uM + ny*vM);                               \
  dfloat unP   = occaFabs(nx*uP + ny*vP);                               \
  dfloat unMax = (unM > unP) ? unM : unP;                               \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[es][j][i] += sc*(.5f*(nx*(uP*uP - uM*uM)                     \
                               + ny*(uP*vP - uM*vM)  + unMax*(uM-uP) ));\
  s_fluxNV[es][j][i] += sc*(.5f*(nx*(vP*uP - vM*uM)                     \
                               + ny*(vP*vP - vM*vM)  + unMax*(vM-vP) ));\
  }

kernel void insAdvectionSurfaceQuad2D(const dlong Nelements,
                                      const dfloat * restrict sgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int   * restrict EToB,
                                      const dfloat time,
                                      const dfloat * restrict x,
                                      const dfloat * restrict y,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNU[p_NblockS][p_Nq][p_Nq];
    shared dfloat s_fluxNV[p_NblockS][p_Nq][p_Nq];

    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          s_fluxNU[es][j][i] = 0.;
          s_fluxNV[es][j][i] = 0.;
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 2
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i;
          const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + i;

          surfaceTerms(sk0,0,i,0     );
          surfaceTerms(sk2,2,i,p_Nq-1);
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + j;
          const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + j;

          surfaceTerms(sk1,1,p_Nq-1,j);
          surfaceTerms(sk3,3,0     ,j);
        }
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong id = (e+offset)*p_Np + j*p_Nq + i;

            NU[id] += s_fluxNU[es][j][i];
            NV[id] += s_fluxNV[es][j][i];
          }
        }
      }
    }
  }
}

