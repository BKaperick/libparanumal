
// compute div(NU)  = div(uxu) in collocation way
kernel void insAdvectionVolumeQuad2D(const iint Nelements,
         const dfloat * restrict vgeo,
         const dfloat * restrict D,
         const iint offset,
         const dfloat * restrict U,
         const dfloat * restrict V,
         dfloat * restrict NU,
         dfloat * restrict NV){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_dF1dr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_dF1ds[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_dF2dr[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_dF2ds[p_NblockV][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(iint j=0;j<p_Nq;++j){ // 
      for(iint es=0;es<p_NblockV;++es;inner1){   
        for(iint i=0;i<p_Nq;++i;inner0){    
          iint e = eo+es; // element in block
          if(e<Nelements){ 
            const iint id = (e+offset)*p_Np + j*p_Nq+i;
            const dfloat u = U[id];
            const dfloat v = V[id];

            const int gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;

            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

            s_dF1dr[es][j][i] = drdx*(u*u) + drdy*(u*v);
            s_dF1ds[es][j][i] = dsdx*(u*u) + dsdy*(u*v);

            s_dF2dr[es][j][i] = drdx*(v*u) + drdy*(v*v);
            s_dF2ds[es][j][i] = dsdx*(v*u) + dsdy*(v*v);

            s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

  for(iint j=0;j<p_Nq;++j){ 
    for(iint es=0;es<p_NblockV;++es;inner1){ 
      for(iint i=0;i<p_Nq;++i;inner0){  
        iint e = eo+es; 
        if(e<Nelements){ 
        // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat f11 = 0.f, f12 = 0.f; 
          dfloat f21 = 0.f, f12 = 0.f; 
          //
          for(int n=0;n<p_Nq;++n){
            dfloat dr = s_D[n][i];
            dfloat ds = s_D[n][j];

            f11 += dr*s_dF1dr[es][j][n];
            f12 += ds*s_dF1ds[es][n][i]; 

            f21 += dr*s_dF2dr[es][j][n];
            f22 += ds*s_dF2ds[es][n][i]; 
          }

          iint id = (e+offset)*p_Np + j*p_Nq + i;
          NU[id] = f11 + f12;
          NV[id] = f21 + f22;
        }
      }
    }
  }

}  
}



kernel void insAdvectionSurfaceQuad2D(const iint Nelements,
          const dfloat * restrict sgeo,
          const dfloat * restrict LIFTT,
          const iint   * restrict vmapM,
          const iint   * restrict vmapP,
          const iint   * restrict EToB,
          const dfloat time,
          const dfloat * restrict x,
          const dfloat * restrict y,
          const iint offset,
          const dfloat * restrict U,
          const dfloat * restrict V,
          dfloat * restrict NU,
          dfloat * restrict NV){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxNy[p_NblockS][p_Nfp*p_Nfaces];
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            iint face = n/p_Nfp;
            // load surface geofactors for this face
            iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx   = sgeo[sid+p_NXID];
            dfloat ny   = sgeo[sid+p_NYID];
            dfloat sJ   = sgeo[sid+p_SJID];
            dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            iint id  = e*p_Nfp*p_Nfaces + n;
            iint idM = vmapM[id]+offset*p_Np;
            iint idP = vmapP[id]+offset*p_Np;

            if(idP<0) idP = idM; // 
            // load negative and positive trace node values of U, V, Pr
            dfloat  uM = U[idM], uP = U[idP];
            dfloat  vM = V[idM], vP = V[idP];

            // apply boundary condition
            iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              idM = vmapM[id];
              insAdvectionBoundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, uM, vM, &uP, &vP);
            }

            // Find max normal velocity on the face
            dfloat unM   = occaFabs(nx*uM + ny*vM);
            dfloat unP   = occaFabs(nx*uP + ny*vP);    
            dfloat unMax = (unM > unP) ? unM : unP;
             // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ; 
            s_fluxNx[es][n] = sc*(.5f*( nx*(uP*uP - uM*uM) 
                + ny*(uP*vP - uM*vM)  + unMax*(uM-uP) ));
            s_fluxNy[es][n] = sc*(.5f*( nx*(vP*uP - vM*uM) 
                + ny*(vP*vP - vM*vM)  + unMax*(vM-vP) ));
          }
        }
      }
    }


    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            iint id = (e+offset)*p_Np + n;

            dfloat rhsnu = NU[id];
            dfloat rhsnv = NV[id];
            // Lift
            occaUnroll(p_NfacesNfp)
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];

                rhsnu  += L*s_fluxNx[es][m];
                rhsnv  += L*s_fluxNy[es][m];
              }

            NU[id] = rhsnu;
            NV[id] = rhsnv;
          }
        }
      }
    }
  }
}







// // compute div(NU)  = div(uxu) in collocation way
// kernel void insAdvectionVolumeQuad2D(const iint Nelements,
//          const dfloat * restrict vgeo,
//          const dfloat * restrict D,
//          const iint offset,
//          const dfloat * restrict U,
//          const dfloat * restrict V,
//          dfloat * restrict NU,
//          dfloat * restrict NV){

//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_F11[p_NblockV][p_Nq][p_Nq];
//     shared dfloat s_F12[p_NblockV][p_Nq][p_Nq];
//     shared dfloat s_F22[p_NblockV][p_Nq][p_Nq];

//     shared dfloat s_D[p_Nq][p_Nq];

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint j=0; j<p_Nq;++j){
//         for(iint i=0;i<p_Nq;++i;inner0){     // for all nodes in this element
//           iint e = eo+es; // element in block
//           if(e<Nelements){ 
//             const iint id = (e+offset)*p_Np + j*p_Nq + i;
//             const dfloat u = U[id];
//             const dfloat v = V[id];

//             s_F11[es][j][i] = u*u;
//             s_F12[es][j][i] = u*v;
//             s_F22[es][j][i] = v*v;

//             s_D[j][i] = D[j*p_Nq+i];
//           }
//         }
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){
//       for(iint j=0; j<p_Nq;++j){
//         for(iint i=0;i<p_Nq;++i;inner0){    
//         iint e = eo+es; 
//         if(e<Nelements){    
//           const iint gid = i + j*p_Nq + e*p_Np*p_Nvgeo;
//           const dfloat drdx = vgeo[gid + p_RXID*p_Np];
//           const dfloat drdy = vgeo[gid + p_RYID*p_Np];
//           const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
//           const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
//           const dfloat JW   = vgeo[gid + p_JWID*p_Np];
//           // compute 'r' and 's' derivatives of (q_m) at node n
//           dfloat df11dr = 0.f, df11ds = 0.f; 
//           dfloat df12dr = 0.f, df12ds = 0.f; 
//           dfloat df22dr = 0.f, df22ds = 0.f; 

//           occaUnroll(p_Nq)
//           for(int n=0;n<p_Nq;++n){
//             const dfloat drn = s_D[n][i];
//             const dfloat dsn = s_D[n][j];

//             df11dr += drn*s_F11[es][j][n];
//             df11ds += dsn*s_F11[es][n][i];

//             df12dr += drn*s_F12[es][j][n];
//             df12ds += dsn*s_F12[es][n][i];

//             df22dr += drn*s_F22[es][j][n];
//             df22ds += dsn*s_F22[es][n][i];
//           }
//           // NU = del(u1xu1)/ dx + del(u1xu2)/dy
//           dfloat nu = drdx*df11dr + dsdx*df11ds 
//                      + drdy*df12dr + dsdy*df12ds;
//           // NV = del(u2xu1)/ dx + del(u2xu2)/dy
//           dfloat nv = drdx*df12dr + dsdx*df12ds 
//                     + drdy*df22dr + dsdy*df22ds;

//           // Update
//           const iint id = (e+offset)*p_Np + j*p_Nq + i;
//           NU[id] = nu;
//           NV[id] = nv;     
//         }
//       }
//     }
//   }

// }
// }















// // compute div(NU)  = div(uxu) in collocation way
// kernel void insAdvectionCubatureVolume2D(const iint Nelements,
// 					 const dfloat * restrict vgeo,
// 					 const dfloat * restrict cubDrWT,
// 					 const dfloat * restrict cubDsWT,
// 					 const dfloat * restrict cubInterpT,
// 					 const iint offset,
// 					 const dfloat * restrict U,
// 					 const dfloat * restrict V,
// 					 dfloat * restrict NU,
// 					 dfloat * restrict NV){

//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_NblockV][p_Np];
//     shared dfloat s_V[p_NblockV][p_Np];
//     shared dfloat s_cF11[p_NblockV][p_cubNp];
//     shared dfloat s_cF12[p_NblockV][p_cubNp];
//     shared dfloat s_cF22[p_NblockV][p_cubNp];

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){      // for all nodes in this element
//       	iint e = eo+es; // element in block
//       	if(e<Nelements){
//           if(n<p_Np){ 
//         	  const iint id = (e+offset)*p_Np+n;
//         	  s_U[es][n] = U[id];
//         	  s_V[es][n] = V[id];
//       	 }
//         } 
//       }
//     }

//     barrier(localMemFence);


//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){     // for all nodes in this element
//       	iint e = eo+es; // element in block
//       	if(e<Nelements && n<p_cubNp){
//         	  dfloat cU = 0, cV = 0;
//             occaUnroll(p_Np)
//         	  for(iint i=0;i<p_Np;++i){
//         	    dfloat cIni = cubInterpT[n+i*p_cubNp];
//         	    cU += cIni*s_U[es][i];
//         	    cV += cIni*s_V[es][i];
//         	  }

//       	  s_cF11[es][n] = cU*cU;
//       	  s_cF12[es][n] = cU*cV;
//       	  s_cF22[es][n] = cV*cV;
//       	 }
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){     // for all nodes in this element
//       	iint e = eo+es; 
//       	if(e<Nelements && n<p_Np){	  
//       	  // prefetch geometric factors (constant on triangle)
//       	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//       	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//       	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//       	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
//       	  // compute 'r' and 's' derivatives of (q_m) at node n
//       	  dfloat df11dr = 0.f, df11ds = 0.f; 
//       	  dfloat df12dr = 0.f, df12ds = 0.f; 
//       	  dfloat df22dr = 0.f, df22ds = 0.f; 

//       	  occaUnroll(p_cubNp)
//       	    for(iint i=0;i<p_cubNp;++i){
//       	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
//       	      const dfloat cDsWni = cubDsWT[n+i*p_Np];

//       	      df11dr += cDrWni*s_cF11[es][i];
//       	      df11ds += cDsWni*s_cF11[es][i];

//       	      df12dr += cDrWni*s_cF12[es][i];
//       	      df12ds += cDsWni*s_cF12[es][i];

//       	      df22dr += cDrWni*s_cF22[es][i];
//       	      df22ds += cDsWni*s_cF22[es][i];
//       	    }

//       	  dfloat nu   = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
//       	  dfloat nv   = drdx*df12dr + dsdx*df12ds + drdy*df22dr + dsdy*df22ds;

//       	  // Update
//       	  const iint id = (e+offset)*p_Np+n;
//       	  NU[id] = -nu; // note  change in sign
//       	  NV[id] = -nv;		  
//       	}
//       }
//     }
//   }
// }


// kernel void insAdvectionCubatureSurface2D(const iint Nelements,
// 					  const dfloat * restrict sgeo,
// 					  const dfloat * restrict intInterpT, // interpolate to integration nodes
// 					  const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
// 					  const iint   * restrict vmapM,
// 					  const iint   * restrict vmapP,
// 					  const iint   * restrict EToB,
// 					  const dfloat time,
// 					  const dfloat * restrict intx, // integration nodes
// 					  const dfloat * restrict inty,
// 					  const iint offset,
// 					  const dfloat * restrict U,
// 					  const dfloat * restrict V,
// 					  dfloat * restrict NU,
// 					  dfloat * restrict NV){

//   // for all elements
//   for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_NblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_NblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_NblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_NblockS][p_NfacesNfp];
//     shared dfloat s_iFluxNx[p_NblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxNy[p_NblockS][p_intNfpNfaces];

//     // for all face nodes of all elements
//     for(iint es=0;es<p_NblockS;++es;inner1){
//       for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){
//       	iint e = eo + es;
//       	if(e<Nelements && n<(p_Nfaces*p_Nfp)){
//     	    const iint id  = e*p_Nfp*p_Nfaces + n;
//           iint idM = vmapM[id]+offset*p_Np;
//           iint idP = vmapP[id]+offset*p_Np;

//     	    if(idP<0) idP = idM;

//     	    // load negative and positive trace node values of velocity
//     	    s_UM[es][n] = U[idM];
//     	    s_VM[es][n] = V[idM];
//     	    s_UP[es][n] = U[idP];
//     	    s_VP[es][n] = V[idP];
//   	  }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(iint es=0;es<p_NblockS;++es;inner1){
//       for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){ 
//       	iint e = eo + es;
//       	if(e<Nelements && n<(p_Nfaces*p_intNfp)){
//       	    const iint face = n/p_intNfp; // find face that owns this integration node

//       	    // load surface geofactors for this face
//       	    const iint sid = p_Nsgeo*(e*p_Nfaces+face);
//       	    const dfloat nx   = sgeo[sid+p_NXID];
//       	    const dfloat ny   = sgeo[sid+p_NYID];
//       	    const dfloat sJ   = sgeo[sid+p_SJID];
//       	    const dfloat invJ = sgeo[sid+p_IJID];

//       	    dfloat iUM = 0.f, iVM = 0.f;
//       	    dfloat iUP = 0.f, iVP = 0.f;

//       	    // local block interpolation (face nodes to integration nodes)
//             occaUnroll(p_Nfp)
//       	    for(iint m=0;m<p_Nfp;++m){
//       	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//       	      const iint fm = face*p_Nfp+m;
//       	      iUM += iInm*s_UM[es][fm];
//       	      iVM += iInm*s_VM[es][fm];

//       	      iUP += iInm*s_UP[es][fm];
//       	      iVP += iInm*s_VP[es][fm];
//       	    }

//       	    // apply boundary condition
//       	    iint bc = EToB[face+p_Nfaces*e];


//       	    if(bc>0){
//               dfloat xb = -0.5f;
//               dfloat yb = 0.0f; 
//       	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp],inty[n+e*p_Nfaces*p_intNfp] , nx, ny, iUM,iVM, &iUP, &iVP);
//       	    }

//       	    // Find max normal velocity on the face
//       	    dfloat unM   = occaFabs(nx*iUM + ny*iVM);
//       	    dfloat unP   = occaFabs(nx*iUP + ny*iVP);    
//       	    dfloat unMax = (unM > unP) ? unM : unP;

//       	    // evaluate "flux" terms: LLF
//       	    const dfloat sc = invJ * sJ ;  // notice sign changes in flux because of weak form
//       	    s_iFluxNx[es][n] = sc*(.5f*(   nx*(iUP*iUP + iUM*iUM) 
//       					   + ny*(iUP*iVP + iUM*iVM) 
//       					   + unMax*(iUM-iUP) ));
//       	    s_iFluxNy[es][n] = sc*(.5f*(   nx*(iVP*iUP + iVM*iUM) 
//       					   + ny*(iVP*iVP + iVM*iVM) 
//       					   + unMax*(iVM-iVP) ));
//       	  }
//       }
//     }

//     // wait for all shared memory writes of the previous inner loop to complete
//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(iint es=0;es<p_NblockS;++es;inner1){
//       for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){
//       	const iint e = eo + es;
//       	if(e<Nelements && n<p_Np ){
//       	    iint id = n + p_Np*(e+offset);
//       	    // prefetch volume rhs
//       	    dfloat NUn = NU[id];
//       	    dfloat NVn = NV[id];
//             occaUnroll(p_intNfp*p_Nfaces)
//       	    for(int m=0;m<(p_intNfp*p_Nfaces);++m){
//       	      // RefMassMatrix^{-1}*cInterp^t*cWeight
//       	      const dfloat L = intLIFTT[n+m*p_Np];

//       	      NUn += L*s_iFluxNx[es][m];
//       	      NVn += L*s_iFluxNy[es][m];
//       	    }

//       	    NU[id] = NUn;
//       	    NV[id] = NVn;
//       	  }
//       }
//     }
//   }
// }

