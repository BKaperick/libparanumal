/*
// compute div(NU)  = div(uxu) in collocation way
kernel void insAdvectionVolumeQuad2D(const dlong Nelements,
         const dfloat * restrict vgeo,
         const dfloat * restrict D,
         const dlong offset,
         const dfloat * restrict U,
         const dfloat * restrict V,
         dfloat * restrict NU,
         dfloat * restrict NV){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F12[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F22[p_NblockV][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            const dfloat Un = U[id];
            const dfloat Vn = V[id];

            s_F11[es][j][i] = Un*Un;
            s_F12[es][j][i] = Vn*Un;
            s_F22[es][j][i] = Vn*Vn;

            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];

            // compute 'r' and 's' derivatives of (q_m) at node n
            dfloat df11dr = 0.f, df11ds = 0.f;
            dfloat df12dr = 0.f, df12ds = 0.f;
            dfloat df22dr = 0.f, df22ds = 0.f;

            occaUnroll(p_Nq)
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[i][n];
                const dfloat Ds = s_D[j][n];

                df11dr += Dr*s_F11[es][j][n];
                df11ds += Ds*s_F11[es][n][i];
                
                df12dr += Dr*s_F12[es][j][n];
                df12ds += Ds*s_F12[es][n][i];
                
                df22dr += Dr*s_F22[es][j][n];
                df22ds += Ds*s_F22[es][n][i];
              }

            const dfloat df11dx = drdx*df11dr + dsdx*df11ds;
            const dfloat df12dx = drdx*df12dr + dsdx*df12ds;
            const dfloat df12dy = drdy*df12dr + dsdy*df12ds;
            const dfloat df22dy = drdy*df22dr + dsdy*df22ds;

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            NU[id] = df11dx + df12dy;
            NV[id] = df12dx + df22dy;
          }
        }
      }
    }
  }  
}
*/


// compute div(NU)  = div(uxu) in collocation way (weak form)
kernel void insAdvectionVolumeQuad2D(const dlong Nelements,
         const dfloat * restrict vgeo,
         const dfloat * restrict D,
         const dlong offset,
         const dfloat * restrict U,
         const dfloat * restrict V,
         dfloat * restrict NU,
         dfloat * restrict NV){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F12[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F21[p_NblockV][p_Nq][p_Nq];
    shared dfloat s_F22[p_NblockV][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat drdx = vgeo[gid + p_RXID*p_Np];
            const dfloat drdy = vgeo[gid + p_RYID*p_Np];
            const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
            const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
            const dfloat JW = vgeo[gid + p_JWID*p_Np];

            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            const dfloat Un = U[id];
            const dfloat Vn = V[id];

            const dfloat cUn = JW*(drdx*Un+drdy*Vn);
            const dfloat cVn = JW*(dsdx*Un+dsdy*Vn);

            s_F11[es][j][i] = cUn*Un;
            s_F12[es][j][i] = cVn*Un;
            s_F21[es][j][i] = cUn*Vn;
            s_F22[es][j][i] = cVn*Vn;

            if (es==0)
              s_D[j][i] = D[j*p_Nq+i];
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){  
          const dlong e = eo+es; 
          if(e<Nelements){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
            dfloat nu = 0.f, nv = 0.f;
            
            occaUnroll(p_Nq)
              for(int n=0;n<p_Nq;++n){
                const dfloat Dr = s_D[n][i];
                const dfloat Ds = s_D[n][j];

                nu += Dr*s_F11[es][j][n]
                     +Ds*s_F12[es][n][i];

                nv += Dr*s_F21[es][j][n]
                     +Ds*s_F22[es][n][i];
              }

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            NU[id] = -invJW*nu;
            NV[id] = -invJW*nv;
          }
        }
      }
    }
  }  
}


#define surfaceTerms(sk,face,i, j)                                      \
  {                                                                     \
  const dlong  idM = vmapM[sk]+offset*p_Np;                             \
  const dlong  idP = vmapP[sk]+offset*p_Np;                             \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat  uM = U[idM], vM = V[idM];                               \
         dfloat uP = U[idP], vP = V[idP];                               \
                                                                        \
  int bc = EToB[face+p_Nfaces*e];                                       \
  if(bc>0) {                                                            \
    const dlong idm = vmapM[sk];                                                    \
    insAdvectionBoundaryConditions2D(bc, time, x[idm], y[idm], nx, ny, uM, vM, &uP, &vP); \
  }                                                                     \
                                                                        \
  dfloat unM   = occaFabs(nx*uM + ny*vM);                               \
  dfloat unP   = occaFabs(nx*uP + ny*vP);                               \
  dfloat unMax = (unM > unP) ? unM : unP;                               \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[es][j][i] += sc*(.5f*(nx*(uP*uP + uM*uM)                     \
                               + ny*(uP*vP + uM*vM)  + unMax*(uM-uP) ));\
  s_fluxNV[es][j][i] += sc*(.5f*(nx*(vP*uP + vM*uM)                     \
                               + ny*(vP*vP + vM*vM)  + unMax*(vM-vP) ));\
  }

kernel void insAdvectionSurfaceQuad2D(const dlong Nelements,
                                      const dfloat * restrict sgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int   * restrict EToB,
                                      const dfloat time,
                                      const dfloat * restrict x,
                                      const dfloat * restrict y,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNU[p_NblockS][p_Nq][p_Nq];
    shared dfloat s_fluxNV[p_NblockS][p_Nq][p_Nq];

    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          s_fluxNU[es][j][i] = 0.;
          s_fluxNV[es][j][i] = 0.;
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 2
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i;
          const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + i;

          surfaceTerms(sk0,0,i,0     );
          surfaceTerms(sk2,2,i,p_Nq-1);
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong e = eo + es;
        if(e<Nelements){
          const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + j;
          const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + j;

          surfaceTerms(sk1,1,p_Nq-1,j);
          surfaceTerms(sk3,3,0     ,j);
        }
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong id = (e+offset)*p_Np + j*p_Nq + i;

            NU[id] += s_fluxNU[es][j][i];
            NV[id] += s_fluxNV[es][j][i];
          }
        }
      }
    }
  }
}
#undef surfaceTerms


/* ------------------Quadrature kernels ----------------------------------*/


// compute div(NU)  = div(uxu) using quadrature (weak form)
kernel void insAdvectionCubatureVolumeQuad2D(const dlong Nelements,
                                             const dfloat * restrict vgeo,
                                             const dfloat * restrict cubvgeo,
                                             const dfloat * restrict cubDWT,
                                             const dfloat * restrict cubInterpT,
                                             const dfloat * restrict cubProjectT,
                                             const dlong offset,
                                             const dfloat * restrict U,
                                             const dfloat * restrict V,
                                             dfloat * restrict NU,
                                             dfloat * restrict NV){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_cubNq][p_cubNq];
    shared dfloat s_F12[p_NblockV][p_cubNq][p_cubNq];
    shared dfloat s_F21[p_NblockV][p_cubNq][p_cubNq];
    shared dfloat s_F22[p_NblockV][p_cubNq][p_cubNq];

    shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];
    shared dfloat s_cubDWT[p_cubNq][p_Nq];

    exclusive dfloat r_Un, r_Vn;
    exclusive dfloat r_F11, r_F12, r_F21, r_F22;

    //fetch the U and V values and store in flux arrays in shared
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){    
          const dlong e = eo+es; // element in block
          if(e<Nelements && i<p_Nq && j<p_Nq){ 
            const dlong id = (e+offset)*p_Np + j*p_Nq+i;

            const dfloat Un = U[id];
            const dfloat Vn = V[id];

            s_F11[es][j][i] = Un;
            s_F12[es][j][i] = Vn;
          }

          const int id = i+j*p_cubNq;
          if (es==0 && id<p_Nq*p_cubNq) {
            s_cubDWT[0][id] = cubDWT[id];
            s_cubInterpT[0][id] = cubInterpT[id];
            s_cubProjectT[0][id] = cubProjectT[id];
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate in i, store in register
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            r_Un  = 0.; r_Vn  = 0.;

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ini = s_cubInterpT[n][i];
              r_Un  += Ini*s_F11[es][j][n];
              r_Vn  += Ini*s_F12[es][j][n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            s_F11[es][j][i] = r_Un;
            s_F12[es][j][i] = r_Vn;
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate in j and store flux in register
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo+es; // element in block
          if(e<Nelements){ 
            r_Un  = 0.; r_Vn  = 0.;

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Inj = s_cubInterpT[n][j];
              r_Un  += Inj*s_F11[es][n][i];
              r_Vn  += Inj*s_F12[es][n][i];
            }
        
            const dlong gid = e*p_cubNp*p_Nvgeo+ j*p_cubNq +i;
            const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
            const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
            const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
            const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
            const dfloat JW = cubvgeo[gid + p_JWID*p_cubNp];

            const dfloat cUn = JW*(drdx*r_Un+drdy*r_Vn);
            const dfloat cVn = JW*(dsdx*r_Un+dsdy*r_Vn);

            s_F11[es][j][i] = cUn*r_Un;
            s_F12[es][j][i] = cVn*r_Un;
            s_F21[es][j][i] = cUn*r_Vn;
            s_F22[es][j][i] = cVn*r_Vn;
          }
        }
      }
    }

    barrier(localMemFence);

    //project/differentiate in j
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          r_F11  = 0.; r_F12  = 0.;
          r_F21  = 0.; r_F22  = 0.;

          if (j<p_Nq) {
            occaUnroll(p_cubNq)
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pnj = s_cubProjectT[n][j];
              const dfloat Dnj = s_cubDWT[n][j];
              r_F11  += Pnj*s_F11[es][n][i];
              r_F21  += Pnj*s_F21[es][n][i];
              r_F12  += Dnj*s_F12[es][n][i];
              r_F22  += Dnj*s_F22[es][n][i];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            s_F11[es][j][i] = r_F11;
            s_F12[es][j][i] = r_F12;
            s_F21[es][j][i] = r_F21;
            s_F22[es][j][i] = r_F22;
          }
        }
      }
    }

    barrier(localMemFence);    

    //project/differentiate in i and write back 
    for(int es=0;es<p_NblockV;++es;inner2){ 
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){  
          const dlong e = eo+es; // element in block
          if(e<Nelements && i<p_Nq && j<p_Nq){ 
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
            
            dfloat nu = 0.f, nv = 0.f;
            
            occaUnroll(p_cubNq)
              for(int n=0;n<p_cubNq;++n){
                const dfloat Pni = s_cubProjectT[n][i];
                const dfloat Dni = s_cubDWT[n][i];

                nu += Dni*s_F11[es][j][n]
                     +Pni*s_F12[es][j][n];

                nv += Dni*s_F21[es][j][n]
                     +Pni*s_F22[es][j][n];
              }

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;
            NU[id] = -invJW*nu;
            NV[id] = -invJW*nv;
          }
        }
      }
    }
    
  }  
} 



#define quadSurfaceTerms(face,i, j)                                     \
{                                                                       \
  dfloat nu = 0.f, nv = 0.f;                                            \
                                                                        \
  occaUnroll(p_cubNq)                                                   \
    for(int n=0;n<p_cubNq;++n){                                         \
      const dfloat Pni = s_cubProjectT[n][i];                           \
      nu  += Pni*s_fluxNU[es][face][n];                                 \
      nv  += Pni*s_fluxNV[es][face][n];                                 \
    }                                                                   \
                                                                        \
  s_NU[es][j][i] += nu;                                                 \
  s_NV[es][j][i] += nv;                                                 \
}


kernel void insAdvectionCubatureSurfaceQuad2D(const dlong Nelements,
                                      const dfloat * restrict vgeo,
                                      const dfloat * restrict cubsgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int    * restrict EToB,
                                      const dfloat * restrict cubInterpT,
                                      const dfloat * restrict cubProjectT,
                                      const dfloat time,
                                      const dfloat * restrict intx,
                                      const dfloat * restrict inty,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_NU[p_NblockS][p_Nq][p_Nq];
    shared dfloat s_NV[p_NblockS][p_Nq][p_Nq];

    shared dfloat s_UM[p_NblockS][p_Nfaces][p_cubNq];
    shared dfloat s_VM[p_NblockS][p_Nfaces][p_cubNq];
    shared dfloat s_UP[p_NblockS][p_Nfaces][p_cubNq];
    shared dfloat s_VP[p_NblockS][p_Nfaces][p_cubNq];

    //reuse shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM

    exclusive dfloat r_UMn[p_Nfaces], r_VMn[p_Nfaces];
    exclusive dfloat r_UPn[p_Nfaces], r_VPn[p_Nfaces];

    shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for (int face=0;face<p_Nfaces;face++) {
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements && i<p_Nq){
            const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nq + i;
            const dlong idM = vmapM[id]+offset*p_Np;
            const dlong idP = vmapP[id]+offset*p_Np;

            // load negative and positive trace node values of velocity
            s_UM[es][face][i] = U[idM];
            s_VM[es][face][i] = V[idM];
            s_UP[es][face][i] = U[idP];
            s_VP[es][face][i] = V[idP];
          }
        }
      }
    }

    //zero out resulting surface contributions
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if (i<p_cubNq) {
            s_NU[es][j][i] = 0.;
            s_NV[es][j][i] = 0.;
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate traces, store flux in register
    for (int face=0;face<p_Nfaces;face++) {
      for(int es=0;es<p_NblockV;++es;inner2){   
        for(int i=0;i<p_cubNq;++i;inner0){
          r_UMn[face] = 0., r_VMn[face] = 0.;
          r_UPn[face] = 0., r_VPn[face] = 0.;

          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ini = s_cubInterpT[n][i];
            r_UMn[face]  += Ini*s_UM[es][face][n];
            r_VMn[face]  += Ini*s_VM[es][face][n];
            r_UPn[face]  += Ini*s_UP[es][face][n];
            r_VPn[face]  += Ini*s_VP[es][face][n];
          }
        }
      }
    }

    barrier(localMemFence); //need a barrier since s_fluxNU and s_fluxNV are aliased

    //write fluxes to shared
    for (int face=0;face<p_Nfaces;face++) {
      for(int es=0;es<p_NblockV;++es;inner2){   
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk = e*p_cubNq*p_Nfaces + face*p_cubNq + i;
            const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];
            const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];
            const dfloat sJ = cubsgeo[sk*p_Nsgeo+p_SJID];

            const dfloat uM = r_UMn[face], vM = r_VMn[es];
                  dfloat uP = r_UPn[face], vP = r_VPn[es];

            int bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const dlong idm = e*p_Nfaces*p_cubNq + face*p_cubNq + i;
              insAdvectionBoundaryConditions2D(bc, time, intx[idm], inty[idm], nx, ny, uM, vM, &uP, &vP);
            }

            dfloat unM   = occaFabs(nx*uM + ny*vM);
            dfloat unP   = occaFabs(nx*uP + ny*vP);
            dfloat unMax = (unM > unP) ? unM : unP;

            s_fluxNU[es][face][i] = sJ*(.5f*(nx*(uP*uP + uM*uM)
                                           + ny*(uP*vP + uM*vM)  + unMax*(uM-uP) ));
            s_fluxNV[es][face][i] = sJ*(.5f*(nx*(vP*uP + vM*uM)
                                           + ny*(vP*vP + vM*vM)  + unMax*(vM-vP) ));
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 2
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        const dlong e = eo + es;
        if(e<Nelements && i<p_Nq){
          quadSurfaceTerms(0,i,0     );
          quadSurfaceTerms(2,i,p_Nq-1);
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int j=0;j<p_cubNq;++j;inner0){
        const dlong e = eo + es;
        if(e<Nelements && j<p_Nq){
          quadSurfaceTerms(1,p_Nq-1,j);
          quadSurfaceTerms(3,0     ,j);
        }
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int j=0;j<p_Nq;++j){
      for(int es=0;es<p_NblockS;++es;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements && i<p_Nq){
            const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
            const dfloat JW = vgeo[gid + p_JWID*p_Np];

            const dlong id = (e+offset)*p_Np + j*p_Nq + i;

            NU[id] += s_fluxNU[es][j][i]/JW;
            NV[id] += s_fluxNV[es][j][i]/JW;
          }
        }
      }
    }
  }
}
#undef quadSurfaceTerms
