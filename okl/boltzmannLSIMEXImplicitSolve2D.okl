
kernel void boltzmannLSIMEXImplicitSolve2D(const iint Nelements,
					       const iint * restrict elementIds,
					       const dfloat dt,	
					       const dfloat akk,
					       const dfloat  * restrict cubInterpT,
					       const dfloat  * restrict cubProjectT,
					       const dfloat4 * restrict qex,
					             dfloat4 * restrict qim){

for(iint e=0;e<Nelements;++e;outer0){
	for(iint n=0;n<p_Np;++n;inner0){

      const iint element = elementIds[e];
      const iint id0     = 2*(element*p_Np + n);
      const iint id1     = id0 + 1;
            
      dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

      // Read explicit part 
      dfloat4 qexa = qex[id0];
      dfloat4 qexb = qex[id1];
      
      // Read implicit part
      dfloat4 qima = qim[id0];
      dfloat4 qimb = qim[id1];      
      
      //
      dfloat qex1 = qexa.x;
      dfloat qex2 = qexa.y;
      dfloat qex3 = qexa.z;
      dfloat qex4 = qexa.w;
      dfloat qex5 = qexb.x;
      dfloat qex6 = qexb.y;       
      
      // First iteration, Qim = Qex ; 
      dfloat qim1 = qex1;
      dfloat qim2 = qex2;
      dfloat qim3 = qex3;
      dfloat qim4 = qex4;
      dfloat qim5 = qex5;
      dfloat qim6 = qex6; 
      //         
      if(akk>0){ // No need to solve, just update

		dfloat cc  = akk * dt * p_tauInv;
		dfloat icc    = 1.0f/cc; 

		//
		N4 = -cc*( qim4 -            ( qim2*qim3/qim1 ) );
		N5 = -cc*( qim5 - p_invsqrt2*( qim2*qim2/qim1 ) );
		N6 = -cc*( qim6 - p_invsqrt2*( qim3*qim3/qim1 ) );

		//
		dfloat z1 =  qex1 - qim1 ;
		dfloat z2 =  qex2 - qim2 ;
		dfloat z3 =  qex3 - qim3 ;
		dfloat z4 =  qex4 - qim4 +  N4 ;
		dfloat z5 =  qex5 - qim5 +  N5 ;
		dfloat z6 =  qex6 - qim6 +  N6 ;

		//hold old values
		dfloat qim4o = qim4;
		dfloat qim5o = qim5;
		dfloat qim6o = qim6;

		//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
		qim4 = qim4o  + z4/(cc+1.0f)  
		+ z2*qim3/(qim1*(1.0f+icc)) 
		+ z3*qim2/(qim1*(1.0f+icc))
		- z1*qim2*qim3/(qim1*qim1*(1.0f+icc)); 

		qim5 = qim5o  +  z5/(cc+1)
		+  p_sqrt2 * ( z2*qim2/(qim1*(1.0f + icc)))
		-  p_sqrt2 * ( z1*(qim2*qim2)/(2.0f *(qim1*qim1)*(1.0f+icc)));

		qim6 = qim6o +  z6/(cc+1.0f)
		+  p_sqrt2* ( z3*qim3/(qim1*(1.0f+icc)))
		-  p_sqrt2* ( z1*(qim3*qim3)/(2.0f*(qim1*qim1)*(1.0f+icc)));
	}

	N4 = -p_tauInv*( qim4 -            ( qim2*qim3/qim1 ) );
	N5 = -p_tauInv*( qim5 - p_invsqrt2*( qim2*qim2/qim1 ) );
	N6 = -p_tauInv*( qim6 - p_invsqrt2*( qim3*qim3/qim1 ) );
	
	// do not update q1 ,q2 ,q3 
	qim[id0].x =  0. ;
	qim[id0].y =  0. ;
	qim[id0].z =  0. ;  
	qim[id0].w =  N4 ;
	//
	qim[id1].x =  N5 ;
	qim[id1].y =  N6 ;  
	
	}
}
  

}







kernel void boltzmannLSIMEXSplitPmlImplicitSolve2D(const iint Nelements,
						       const iint * restrict elementIds,
						       const dfloat dt,  
						       const dfloat ramp,
						       const dfloat akk,
						       const dfloat * restrict cubInterpT,
						       const dfloat * restrict cubProjectT,
						       const dfloat * restrict qYx,
						       const dfloat * restrict qYy,
						       dfloat * restrict qZx,
						       dfloat * restrict qZy,
						       dfloat4 *restrict qZ ){

for(iint e=0;e<Nelements;++e;outer0){
	for(iint n=0;n<p_Np;++n;inner0){
      
		const iint element = elementIds[e];
		//
		const iint base = n + element*p_Nfields*p_Np;
		const iint id1 = base + 0*p_Np;
		const iint id2 = base + 1*p_Np;
		const iint id3 = base + 2*p_Np;
		const iint id4 = base + 3*p_Np;
		const iint id5 = base + 4*p_Np;
		const iint id6 = base + 5*p_Np;

		// PML UPDATES
		dfloat qxe1 = qYx[id1];
		dfloat qxe2 = qYx[id2];
		dfloat qxe3 = qYx[id3];
		dfloat qxe4 = qYx[id4];
		dfloat qxe5 = qYx[id5];
		dfloat qxe6 = qYx[id6]; 
		//
		dfloat qye1 = qYy[id1];
		dfloat qye2 = qYy[id2];
		dfloat qye3 = qYy[id3];
		dfloat qye4 = qYy[id4];
		dfloat qye5 = qYy[id5];
		dfloat qye6 = qYy[id6]; 
		// Initialize
		dfloat qxi1 = qxe1;
		dfloat qxi2 = qxe2;
		dfloat qxi3 = qxe3;
		dfloat qxi4 = qxe4;
		dfloat qxi5 = qxe5;
		dfloat qxi6 = qxe6; 
		//
		dfloat qyi1 = qye1;
		dfloat qyi2 = qye2;
		dfloat qyi3 = qye3;
		dfloat qyi4 = qye4;
		dfloat qyi5 = qye5;
		dfloat qyi6 = qye6; 
		//
		dfloat q1 =  p_q1bar                 + qxi1 + qyi1;
		dfloat q2 =  ramp*p_q2bar            + qxi2 + qyi2;
		dfloat q3 =  ramp*p_q3bar            + qxi3 + qyi3;
		dfloat q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
		dfloat q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
		dfloat q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;
		//	
	    dfloat N4=0.,N5=0.,N6=0.;  

		//
		if(akk>0) { 
			dfloat err = 0.0;  
			dfloat coeff  = akk * dt * p_tauInv;
			dfloat icc    = 1.0f/coeff; 
			    
			dfloat cch    = 0.5f*coeff; 
			dfloat icch   = 1.0f/cch; 
			
			
			//
			N4 = -coeff*( q4 -            ( q2*q3/q1 ) );
			N5 = -coeff*( q5 - p_invsqrt2*( q2*q2/q1 ) );
			N6 = -coeff*( q6 - p_invsqrt2*( q3*q3/q1 ) );
			    
			//
			dfloat zx1 =  qxe1 - qxi1 ;
			dfloat zx2 =  qxe2 - qxi2 ;
			dfloat zx3 =  qxe3 - qxi3 ;
			dfloat zx4 =  qxe4 - qxi4 +  0.5f*N4 ;
			dfloat zx5 =  qxe5 - qxi5 +  0.5f*N5 ;
			dfloat zx6 =  qxe6 - qxi6 +  0.5f*N6 ;
			//
			dfloat zy1 =  qye1 - qyi1 ;
			dfloat zy2 =  qye2 - qyi2 ;
			dfloat zy3 =  qye3 - qyi3 ;
			dfloat zy4 =  qye4 - qyi4 +  0.5f*N4 ;
			dfloat zy5 =  qye5 - qyi5 +  0.5f*N5 ;
			dfloat zy6 =  qye6 - qyi6 +  0.5f*N6 ;
			    
			//
			dfloat qxi4o = qxi4;
			dfloat qxi5o = qxi5;
			dfloat qxi6o = qxi6;
			//
			dfloat qyi4o = qyi4;
			dfloat qyi5o = qyi5;
			dfloat qyi6o = qyi6;
			    
			//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
			    
			qxi4  +=
			  zx4/(cch+1.0f)  
			  + zx2*q3/(q1*(1.0f+icch)) 
			  + zx3*q2/(q1*(1.0f+icch))
			  - zx1*q2*q3/(q1*q1*(1.0f+icch)); 
			    
			qxi5  +=
			  zx5/(cch+1.)
			  +  p_sqrt2 * ( zx2*q2/(q1*(1.0f + icch)))
			  -  p_sqrt2 * ( zx1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icch)));
			    
			qxi6 +=
			  zx6/(cch+1.0f)
			  +  p_sqrt2* ( zx3*q3/(q1*(1.0f+icch)))
			  -  p_sqrt2* ( zx1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icch)));
			    
			//  
			qyi4  +=
			  zy4/(cch+1.0f)  
			  + zy2*q3/(q1*(1.0f+icch)) 
			  + zy3*q2/(q1*(1.0f+icch))
			  - zy1*q2*q3/(q1*q1*(1.0f+icch)); 
			    
			qyi5  +=
			  zy5/(cch+1.)
			  +  p_sqrt2 * ( zy2*q2/(q1*(1.0f + icch)))
			  -  p_sqrt2 * ( zy1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icch)));
			    
			qyi6 +=
			  zy6/(cch+1.0f)
			  +  p_sqrt2* ( zy3*q3/(q1*(1.0f+icch)))
			  -  p_sqrt2* ( zy1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icch)));   
			    
			    
			q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
			q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
			q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;                                     
	    
		}  

        //
	   N4 = -p_tauInv*( q4 -            ( q2*q3/q1 ) );
	   N5 = -p_tauInv*( q5 - p_invsqrt2*( q2*q2/q1 ) );
	   N6 = -p_tauInv*( q6 - p_invsqrt2*( q3*q3/q1 ) );

// PML UPDATES
      qZx[id1]  = 0.; // Required because of low storage
      qZx[id2]  = 0.;
      qZx[id3]  = 0.;
      qZx[id4]  = 0.5f*N4;
      qZx[id5]  = 0.5f*N5;
      qZx[id6]  = 0.5f*N6; 
       
   // PML UPDATES
      qZy[id1]  = 0.;
      qZy[id2]  = 0.;
      qZy[id3]  = 0.;
      qZy[id4]  = 0.5f*N4;
      qZy[id5]  = 0.5f*N5;
      qZy[id6]  = 0.5f*N6; 
       
      // 
      dfloat4 temp;
      temp.x =  0.;
      temp.y =  0.;
      temp.z =  0.;
      temp.w =  N4;

      qZ[2*(n + element*p_Np)] = temp;

      temp.x =  N5;
      temp.y =  N6;
      temp.z =  0.0;
      temp.w =  0.0;

      qZ[2*(n + element*p_Np) +1] = temp;
      
    }
  }
}


kernel void boltzmannLSIMEXImplicitSolveCub2D(const iint Nelements,
						  const iint * restrict elementIds,
						  const dfloat dt, 
						  const dfloat akk,
						  const dfloat * restrict cubInterpT,
						  const dfloat * restrict cubProjectT,
						  const dfloat4 * restrict qe,
						  dfloat4 * restrict q){ 

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][6][p_Np];
    shared dfloat s_qE[p_NblockV][6][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];
    
   
    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qe1 =0.0, qe2 = 0.0, qe3=0.0 ;
    exclusive dfloat qe4 =0.0, qe5 = 0.0, qe6=0.0 ;  
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;  

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
        iint e = eo+es; // element in block
        if(e<Nelements){
	  
	  element = elementIds[e];
	  if(n<p_Np){
	    
	    const iint id = element*p_Np+n;
	    dfloat4 qea  = qe[2*id];
	    dfloat4 qeb  = qe[2*id+1];
	    //load 
	    if(akk>0){
	    s_qE[es][0][n] = qea.x;
	    s_qE[es][1][n] = qea.y;
	    s_qE[es][2][n] = qea.z;
	    s_qE[es][3][n] = qea.w;   
	    s_qE[es][4][n] = qeb.x;
	    s_qE[es][5][n] = qeb.y;
	    }
	    //
	    s_q[es][0][n] = qea.x;
	    s_q[es][1][n] = qea.y;
	    s_q[es][2][n] = qea.z;
	    s_q[es][3][n] = qea.w;   
	    s_q[es][4][n] = qeb.x;
	    s_q[es][5][n] = qeb.y;  
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){

		iint e = eo+es; // element in block
		if(e<Nelements){

			if(n<p_cubNp){

				occaUnroll(p_Np)
				for(iint m=0;m<p_Np;++m){

				const dfloat Icn  = cubInterpT[m*p_cubNp+n];
				q1 += Icn*s_q[es][0][m];
				q2 += Icn*s_q[es][1][m];
				q3 += Icn*s_q[es][2][m];
				q4 += Icn*s_q[es][3][m];
				q5 += Icn*s_q[es][4][m];
				q6 += Icn*s_q[es][5][m];

				if(akk>0){
				//
				qe1 += Icn*s_qE[es][0][m];
				qe2 += Icn*s_qE[es][1][m];
				qe3 += Icn*s_qE[es][2][m];
				qe4 += Icn*s_qE[es][3][m];
				qe5 += Icn*s_qE[es][4][m];
				qe6 += Icn*s_qE[es][5][m];
			   }
	      }
	  }
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_cubNp){
	      if(akk>0){ 	
	      dfloat cc  = akk * dt * p_tauInv;
	      dfloat icc    = 1.0f/cc; 
	      dfloat iq1    = 1.0f/ q1;
	      // BGK relaxation approximation to the Boltzmann collision operator
	      dfloat N4 = -cc * (q4-(           q2*q3*iq1));
	      dfloat N5 = -cc * (q5-(p_invsqrt2*q2*q2*iq1));
	      dfloat N6 = -cc * (q6-(p_invsqrt2*q3*q3*iq1));
	      
	      //
	      dfloat z1 =  qe1 - q1 ;
	      dfloat z2 =  qe2 - q2 ;
	      dfloat z3 =  qe3 - q3 ;
	      dfloat z4 =  qe4 - q4 +  N4 ;
	      dfloat z5 =  qe5 - q5 +  N5 ;
	      dfloat z6 =  qe6 - q6 +  N6 ;

	      // Store solution for error check
	      dfloat q4o = q4;
	      dfloat q5o = q5;
	      dfloat q6o = q6;
	      //
	      //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
	      q4 +=
		z4/(cc+1.0f)  
		+ z2*q3/(q1*(1.0f+icc)) 
		+ z3*q2/(q1*(1.0f+icc))
		- z1*q2*q3/(q1*q1*(1.0f+icc)); 

	      q5 +=
		z5/(cc+1)
		+  p_sqrt2 * ( z2*q2/(q1*(1.0f + icc)))
		-  p_sqrt2 * ( z1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icc)));

	      q6 +=
		z6/(cc+1.0f)
		+  p_sqrt2* ( z3*q3/(q1*(1.0f+icc)))
		-  p_sqrt2* ( z1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icc)));
			}

            // BGK relaxation approximation to the Boltzmann collision operator
      	    s_cubN4[es][n] = -p_tauInv*(q4-(           q2*q3/q1));
      	    s_cubN5[es][n] = -p_tauInv*(q5-(p_invsqrt2*q2*q2/q1));
      	    s_cubN6[es][n] = -p_tauInv*(q6-(p_invsqrt2*q3*q3/q1));
	    }
	  }
	}
      }
      
      // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
      
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_Np){

	      // use temporaries for part sums for N4,N5,N6 because of exclusives
	  	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
	  	    for(iint i=0;i<p_cubNp;++i){
	  	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	  	      N4 += Pnc*s_cubN4[es][i];
	  	      N5 += Pnc*s_cubN5[es][i];
	  	      N6 += Pnc*s_cubN6[es][i];
	  	    }

	    const iint id = element*p_Np+n;
	      	      
	      //  
       dfloat4 temp; 
       temp.x = 0.; 
       temp.y = 0.;
       temp.z = 0.; 
       temp.w = N4; 

       q[2*id] = temp; 

       temp.x = N5;
       temp.y = N6;
       temp.z = 0.; 
       temp.w = 0.; 

       q[2*id +1] = temp; 
	      
	    }
	  }
	}
      }
    //}
  }
}

kernel void boltzmannLSIMEXSplitPmlImplicitSolveCub2D(const iint Nelements,
							  const iint * restrict elementIds,
							  const dfloat dt,  
							  const dfloat ramp,
							  const dfloat akk,
							  const dfloat * restrict cubInterpT,
							  const dfloat * restrict cubProjectT,
							  const dfloat * restrict qYx,
							  const dfloat * restrict qYy,
							  dfloat * restrict qZx,
							  dfloat * restrict qZy,
							  dfloat4 *restrict qZ ){
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_qxE[p_NblockV][6][p_Np];            
    shared dfloat s_qyE[p_NblockV][6][p_Np];
      
    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];
    
    
    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qxe1 =0.0, qxe2 = 0.0, qxe3=0.0 ;
    exclusive dfloat qxe4 =0.0, qxe5 = 0.0, qxe6=0.0 ; 
    //
    exclusive dfloat qye1 =0.0, qye2 = 0.0, qye3=0.0 ;
    exclusive dfloat qye4 =0.0, qye5 = 0.0, qye6=0.0 ;  
    // //
    exclusive dfloat qx1 =0.0, qx2 = 0.0, qx3=0.0 ;
    exclusive dfloat qx4 =0.0, qx5 = 0.0, qx6=0.0 ;  
    
    exclusive dfloat qy1 =0.0, qy2 = 0.0, qy3=0.0 ;
    exclusive dfloat qy4 =0.0, qy5 = 0.0, qy6=0.0 ;  
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;   
    
    
    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];
	  if(n<p_Np){
	    //
	    const iint base = n + element*p_Nfields*p_Np;
	    const iint id1 = base + 0*p_Np;
	    const iint id2 = base + 1*p_Np;
	    const iint id3 = base + 2*p_Np;
	    const iint id4 = base + 3*p_Np;
	    const iint id5 = base + 4*p_Np;
	    const iint id6 = base + 5*p_Np;
	    
	    // PML UPDATES
	    s_qxE[es][0][n] = qYx[id1];
	    s_qxE[es][1][n] = qYx[id2];
	    s_qxE[es][2][n] = qYx[id3];
	    s_qxE[es][3][n] = qYx[id4];
	    s_qxE[es][4][n] = qYx[id5];
	    s_qxE[es][5][n] = qYx[id6]; 
	    //
	    s_qyE[es][0][n] = qYy[id1];
	    s_qyE[es][1][n] = qYy[id2];
	    s_qyE[es][2][n] = qYy[id3];
	    s_qyE[es][3][n] = qYy[id4];
	    s_qyE[es][4][n] = qYy[id5];
	    s_qyE[es][5][n] = qYy[id6]; 
	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);
    

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){

	    occaUnroll(p_Np)
	      for(iint m=0;m<p_Np;++m){
		const dfloat Icn  = cubInterpT[m*p_cubNp+n];
		qxe1 += Icn*s_qxE[es][0][m];
		qxe2 += Icn*s_qxE[es][1][m];
		qxe3 += Icn*s_qxE[es][2][m];
		qxe4 += Icn*s_qxE[es][3][m];
		qxe5 += Icn*s_qxE[es][4][m];
		qxe6 += Icn*s_qxE[es][5][m];
		//
		qye1 += Icn*s_qyE[es][0][m];
		qye2 += Icn*s_qyE[es][1][m];
		qye3 += Icn*s_qyE[es][2][m];
		qye4 += Icn*s_qyE[es][3][m];
		qye5 += Icn*s_qyE[es][4][m];
		qye6 += Icn*s_qyE[es][5][m];
	      }
	    
	    qx1 = qxe1;
	    qx2 = qxe2;
	    qx3 = qxe3;
	    qx4 = qxe4;
	    qx5 = qxe5;
	    qx6 = qxe6;
	    //
	    qy1 = qye1;
	    qy2 = qye2;
	    qy3 = qye3;
	    qy4 = qye4;
	    qy5 = qye5;
	    qy6 = qye6;
	    //
        q1=  p_q1bar            + qx1 + qy1;
	    q2=  ramp*p_q2bar       + qx2 + qy2;
	    q3=  ramp*p_q3bar       + qx3 + qy3;
	    q4=  ramp*ramp*p_q4bar  + qx4 + qy4;
	    q5=  ramp*ramp*p_q5bar  + qx5 + qy5;
	    q6=  ramp*ramp*p_q6bar  + qx6 + qy6;
     
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_cubNp){
	    	if(akk>0){
	      
	      dfloat cc     = akk * dt * p_tauInv;
	      dfloat icc    = 1.0f/cc; 
	      dfloat cch    = 0.5f*cc; 
	      dfloat icch   = 1.0f/cch;  
	      dfloat iq1    = 1.0f / q1;
              
	      // BGK relaxation approximation to the Boltzmann collision operator
	      dfloat N4 = -cc*(q4-(           q2*q3*iq1));
	      dfloat N5 = -cc*(q5-(p_invsqrt2*q2*q2*iq1));
	      dfloat N6 = -cc*(q6-(p_invsqrt2*q3*q3*iq1));
	      //
	      dfloat alpha = 0.5f;
	      dfloat beta  = 0.5f;
	      //
	      dfloat zx1 =  qxe1 - qx1 ;
	      dfloat zx2 =  qxe2 - qx2 ;
	      dfloat zx3 =  qxe3 - qx3 ;
	      dfloat zx4 =  qxe4 - qx4 +  alpha*N4 ;
	      dfloat zx5 =  qxe5 - qx5 +  alpha*N5 ;
	      dfloat zx6 =  qxe6 - qx6 +  alpha*N6 ;
	      //
	      dfloat zy1 =  qye1 - qy1 ;
	      dfloat zy2 =  qye2 - qy2 ;
	      dfloat zy3 =  qye3 - qy3 ;
	      dfloat zy4 =  qye4 - qy4 +  beta*N4 ;
	      dfloat zy5 =  qye5 - qy5 +  beta*N5 ;
	      dfloat zy6 =  qye6 - qy6 +  beta*N6 ;
	      //
	      dfloat qx4o = qx4;
	      dfloat qx5o = qx5;
	      dfloat qx6o = qx6;
	      //
	      dfloat qy4o = qy4;
	      dfloat qy5o = qy5;
	      dfloat qy6o = qy6;
	      //
	      
	      //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
	      qx4  +=        zx4/(cch+1.0f)  
		+ zx2*q3/(q1*(1.0f+icch)) 
		+ zx3*q2/(q1*(1.0f+icch))
		- zx1*q2*q3/(q1*q1*(1.0f+icch)); 
	      
	      qx5  +=         zx5/(cch+1.)
		+  p_sqrt2 * ( zx2*q2/(q1*(1.0f + icch)))
		-  p_sqrt2 * ( zx1*(q2*q2)/(2.0 *(q1*q1)*(1.0f+icch)));
	      
	      qx6 +=         zx6/(cch+1.0f)
		+  p_sqrt2* ( zx3*q3/(q1*(1.0f+icch)))
		-  p_sqrt2* ( zx1*(q3*q3)/(2.0*(q1*q1)*(1.0f+icch)));
	      
	      //  
	      qy4  +=        zy4/(cch+1.0f)  
		+ zy2*q3/(q1*(1.0f+icch)) 
		+ zy3*q2/(q1*(1.0f+icch))
		- zy1*q2*q3/(q1*q1*(1.0f+icch)); 
	      
	      qy5  +=         zy5/(cch+1.)
		+  p_sqrt2 * ( zy2*q2/(q1*(1.0f + icch)))
		-  p_sqrt2 * ( zy1*(q2*q2)/(2.0 *(q1*q1)*(1.0f+icch)));
	      
	      qy6 +=         zy6/(cch+1.0f)
		+  p_sqrt2* ( zy3*q3/(q1*(1.0f+icch)))
		-  p_sqrt2* ( zy1*(q3*q3)/(2.0*(q1*q1)*(1.0f+icch)));   
	      
	      
	      q4 =  ramp*ramp*p_q4bar       + qx4 + qy4;
	      q5 =  ramp*ramp*p_q5bar       + qx5 + qy5;
	      q6 =  ramp*ramp*p_q6bar       + qx6 + qy6;  
	      } 


        // BGK relaxation approximation to the Boltzmann collision operator
  	    s_cubN4[es][n] = -p_tauInv*(q4-(           q2*q3/q1));
  	    s_cubN5[es][n] = -p_tauInv*(q5-(p_invsqrt2*q2*q2/q1));
  	    s_cubN6[es][n] = -p_tauInv*(q6-(p_invsqrt2*q3*q3/q1));                                  
	    
	    }
	  }
	}
      }
      
      // make sure all cubature node data is loaded into shared
      barrier(localMemFence);
      
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_Np){     	    
      	    // use temporaries for part sums for N4,N5,N6 because of exclusives
      	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;
      	    for(iint i=0;i<p_cubNp;++i){
      	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
      	      N4 += Pnc*s_cubN4[es][i];
      	      N5 += Pnc*s_cubN5[es][i];
      	      N6 += Pnc*s_cubN6[es][i];
      	    }

	      //
	      const iint base = n + element*p_Nfields*p_Np;
	      const iint id1 = base + 0*p_Np;
	      const iint id2 = base + 1*p_Np;
	      const iint id3 = base + 2*p_Np;
	      const iint id4 = base + 3*p_Np;
	      const iint id5 = base + 4*p_Np;
	      const iint id6 = base + 5*p_Np;
	      
		dfloat alpha = 0.5f; 
		dfloat beta  = 0.5f;       

		// split relaxation
		qZx[base+0*p_Np]  = 0.;
		qZx[base+1*p_Np]  = 0.;
		qZx[base+2*p_Np]  = 0.;
		qZx[base+3*p_Np]  = alpha*N4;
		qZx[base+4*p_Np]  = alpha*N5;
		qZx[base+5*p_Np]  = alpha*N6;


		qZy[base+0*p_Np]  = 0.;
		qZy[base+1*p_Np]  = 0.;
		qZy[base+2*p_Np]  = 0.;
		qZy[base+3*p_Np]  = beta*N4;
		qZy[base+4*p_Np]  = beta*N5;
		qZy[base+5*p_Np]  = beta*N6;
	    
	     //
	      dfloat4 temp;
	      
	      temp.x =  0.;
	      temp.y =  0.;
	      temp.z =  0.;
	      temp.w =  N4;
	      
	      qZ[2*(n + element*p_Np)] = temp;
	      
	      temp.x =  N5;
	      temp.y =  N6;
	      temp.z =  0.0;
	      temp.w =  0.0;
	      
	      qZ[2*(n + element*p_Np) +1] = temp; 
	      
	    }
	  }
	}
      }
  //  }
  }
}

