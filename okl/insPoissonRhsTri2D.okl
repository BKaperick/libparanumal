
// Computes volume contribution of div(UI)
@kernel void insPoissonRhsForcingTri2D(const dlong Nelements,
                                      @restrict const  dfloat *  vgeo,
                                      @restrict const  dfloat *  MM,
                                      const dfloat dt,
                                      const dfloat g0,
                                            @restrict dfloat *  rhs){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_rhs[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dlong id = e*p_Np+n;
          s_rhs[es][n] = rhs[id];
        }
      }
    }

    // Make sure all node data is loaded into @shared
    @barrier("local");

    // Multiply with Mass Matrix
    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dfloat J = vgeo[e*p_Nvgeo + p_JID];
          dfloat rhsn = 0.f;

          #pragma unroll p_Np
            for(int i=0;i<p_Np;++i){
              const dfloat M = MM[n+i*p_Np];
              rhsn += M*s_rhs[es][i];
            }

          const dlong id = e*p_Np+n;
          rhs[id] = -J*g0*rhsn/dt;
        }
      }
    }
  }
}


@kernel void insPoissonUpdateTri2D(const dlong Nelements,
                                  const dfloat dt,
                                  const dfloat g0,
                                  @restrict const  dfloat *  Px,
                                  @restrict const  dfloat *  Py,
                                        @restrict dfloat *  Ut,
                                        @restrict dfloat *  Vt){

  for(dlong e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const dlong id  = n + e*p_Np;
      // // Update Velocity u = u - dt/g0 * grad(Pr)
      Ut[id] -= dt*Px[id]/g0;
      Vt[id] -= dt*Py[id]/g0;
    }
  }
}


// Actually solves for Pr increamnet not presssure
@kernel void insPoissonRhsIpdgBCTri2D(const dlong Nelements,
                                     const int pressure_solve,
                                     @restrict const  dlong  *  vmapM,
                                     const dfloat tau,
                                     const dfloat time,
                                     const dfloat dt,
                                     @restrict const  dfloat *  x,
                                     @restrict const  dfloat *  y,
                                     @restrict const  dfloat *  vgeo,
                                     @restrict const  dfloat *  sgeo,
                                     @restrict const  int    *  EToB,
                                     @restrict const  dfloat *  DrT,
                                     @restrict const  dfloat *  DsT,
                                     @restrict const  dfloat *  LIFTT,
                                     @restrict const  dfloat *  MM,
                                           @restrict dfloat *  rhsP){
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    @shared  dfloat s_dpdx[p_Np];
    @shared  dfloat s_dpdy[p_Np];
    @shared  dfloat s_lapp[p_Np];

    @shared  dfloat s_nxdp[p_NfacesNfp];
    @shared  dfloat s_nydp[p_NfacesNfp];

    @shared  dfloat s_lappflux[p_NfacesNfp];
    @shared  dfloat s_Lnxdp[p_Np];
    @shared  dfloat s_Lnydp[p_Np];

    @exclusive dlong idM;
    @exclusive dfloat nx, ny, sJ, invJ, hinv;
    
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        const dlong id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id];          
     
        const int face = n/p_Nfp;
        // load surface geofactors for this face
        const dlong sid = p_Nsgeo*(e*p_Nfaces+face);
        nx = sgeo[sid+p_NXID];
        ny = sgeo[sid+p_NYID];
        sJ = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];
        
        dfloat dpdxP=0, dpdyP=0, pP=0;        

        const int bc = EToB[face+p_Nfaces*e];
        if(bc>0) {
          insPressureDirichletConditions2D(bc,time, x[idM], y[idM], nx, ny, 0.f, &pP);
          insPressureNeumannConditions2D(bc,time, x[idM], y[idM], nx, ny, 0.f, 0.f, &dpdxP, &dpdyP);
          if(pressure_solve==0){
            dfloat pPm1, dpdxPm1, dpdyPm1;
            insPressureDirichletConditions2D(bc,time-dt, x[idM], y[idM], nx, ny, 0.f, &pPm1);
            insPressureNeumannConditions2D(bc,time-dt, x[idM], y[idM], nx, ny, 0.f, 0.f, &dpdxPm1, &dpdyPm1);
            pP = pP - pPm1;
            dpdxP = dpdxP - dpdxPm1;
            dpdyP = dpdyP - dpdyPm1;
          }                             
        }
        const dfloat dp = pP;

        s_nxdp[n] = sJ*invJ*nx*dp;
        s_nydp[n] = sJ*invJ*ny*dp;
        s_lappflux[n] = sJ*invJ*(-nx*(dpdxP)-ny*(dpdyP) -tau*hinv*dp);
      }
    }

    @barrier("local");

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        const dlong gid = e*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdp = 0;
        dfloat Lnydp = 0;

        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lnxdp += LIFTT[n+i*p_Np]*s_nxdp[i];
            Lnydp += LIFTT[n+i*p_Np]*s_nydp[i];
          }

        const dfloat dpdx = Lnxdp;
        const dfloat dpdy = Lnydp;

        s_dpdx[n] = drdx*dpdx + drdy*dpdy; // abuse of notation
        s_dpdy[n] = dsdx*dpdx + dsdy*dpdy;

        s_Lnxdp[n] = Lnxdp;
        s_Lnydp[n] = Lnydp;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        const int id = idM%p_Np;
        s_lappflux[n] += sJ*invJ*(nx*s_Lnxdp[id]+ny*s_Lnydp[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0;

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i) {
          lapr += DrT[n+i*p_Np]*s_dpdx[i];
          laps += DsT[n+i*p_Np]*s_dpdy[i];
        }

        s_lapp[n] = -(lapr+laps);
      }

    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        dfloat lap = 0;
        // lift remaining surface terms
        #pragma unroll p_NfacesNfp
        for(int i=0;i<p_NfacesNfp;++i){
          lap += LIFTT[n+i*p_Np]*s_lappflux[i];
        }
        s_lapp[n] += lap;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        const dfloat J = vgeo[e*p_Nvgeo + p_JID];

        dfloat Mlapp = 0;

        // multiply by mass matrix
        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          Mlapp += MM[n+i*p_Np]*s_lapp[i];
        }

        const dlong id = e*p_Np+n;
        rhsP[id] -=  J*Mlapp;
      }
    }
  }
}

//RHS contributions for continuous solver
@kernel void insPoissonRhsBCTri2D(const dlong Nelements,
                                 const int pressure_solve,
                                 @restrict const  dfloat *  ggeo,
                                 @restrict const  dfloat *  sgeo,
                                 @restrict const  dfloat *  SrrT,
                                 @restrict const  dfloat *  SrsT,
                                 @restrict const  dfloat *  SsrT,
                                 @restrict const  dfloat *  SssT,
                                 @restrict const  dfloat *  MM,
                                 @restrict const  dlong  *  vmapM,
                                 @restrict const  dfloat *  sMT,
                                 const dfloat time,
                                 const dfloat dt,
                                 @restrict const  dfloat *  x,
                                 @restrict const  dfloat *  y,
                                 @restrict const  int    *  mapB,
                                       @restrict dfloat *  rhsP){
  
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    @shared dfloat s_q[p_Np];
    @shared dfloat s_ndq[p_Nfp*p_Nfaces];

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_Np){
        s_q[n] = 0.;
      }
      if(n<p_NfacesNfp){
        s_ndq[n] = 0.;
      }
    }

    @barrier("local");

    for(int n=0;n<p_maxNodes;++n;@inner(0)){
      if(n<p_NfacesNfp){
        const dlong id  = n + e*p_Nfaces*p_Nfp;
        const dlong idM = vmapM[id];          
        const int nid = idM%p_Np; 

        const int face = n/p_Nfp;

        // load surface geofactors for this face
        const dlong sid = p_Nsgeo*(e*p_Nfaces+face);
        const dfloat nx = sgeo[sid+p_NXID];
        const dfloat ny = sgeo[sid+p_NYID];
        const dfloat sJ = sgeo[sid+p_SJID];
        
        dfloat dpdxP=0, dpdyP=0, pP=0;

        const int bc = mapB[idM];
        if(bc>0) {
          insPressureDirichletConditions2D(bc,time, x[idM], y[idM], nx, ny, 0.f, &pP);
          insPressureNeumannConditions2D(bc,time, x[idM], y[idM], nx, ny, 0.f, 0.f, &dpdxP, &dpdyP);
          if(pressure_solve==0){
            dfloat pPm1, dpdxPm1, dpdyPm1;
            insPressureDirichletConditions2D(bc,time-dt, x[idM], y[idM], nx, ny, 0.f, &pPm1);
            insPressureNeumannConditions2D(bc,time-dt, x[idM], y[idM], nx, ny, 0.f, 0.f, &dpdxPm1, &dpdyPm1);
            pP = pP - pPm1;
            dpdxP = dpdxP - dpdxPm1;
            dpdyP = dpdyP - dpdyPm1;
          }                  
        } 

        s_q[nid] = pP;
        s_ndq[n] = sJ*(nx*dpdxP + ny*dpdyP);
      }
    }

    @barrier("local");
    
    for(int n=0;n<p_maxNodes;++n;@inner(0)){ 
      if(n<p_Np){
        //volume Dirichlet data
        const dlong id = n + e*p_Np;
        const dlong gid = e*p_Nggeo;
        const dfloat Grr = ggeo[gid + p_G00ID];
        const dfloat Grs = ggeo[gid + p_G01ID];
        const dfloat Gss = ggeo[gid + p_G11ID];
        const dfloat J   = ggeo[gid + p_GWJID];

        dfloat qrr = 0.;
        dfloat qrs = 0.;
        dfloat qsr = 0.;
        dfloat qss = 0.;
        dfloat qM = 0.;

        #pragma unroll p_Np
          for (int k=0;k<p_Np;k++) {
            qrr += SrrT[n+k*p_Np]*s_q[k];
            qrs += SrsT[n+k*p_Np]*s_q[k];
            qsr += SsrT[n+k*p_Np]*s_q[k];
            qss += SssT[n+k*p_Np]*s_q[k];
            qM  += MM[n+k*p_Np]*s_q[k];
          }

        dfloat Lndq = 0;            
        // surface mass * surface terms
        #pragma unroll p_NfacesNfp
          for(int i=0;i<p_NfacesNfp;++i){
            Lndq += sMT[n+i*p_Np]*s_ndq[i];
          }

        rhsP[id] -= Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss - Lndq;
      }
    }
  }
}

@kernel void insPoissonAddBCTri2D(const dlong Nelements,
                                 const int pressure_solve,
                                 const dfloat time,
                                 const dfloat dt,
                                 @restrict const  dfloat *  x,
                                 @restrict const  dfloat *  y,
                                 @restrict const  dlong  *  vmapM,
                                 @restrict const  int    *  mapB,
                                       @restrict dfloat *  P){
  
  for(dlong e=0;e<Nelements;e++;@outer(0)){
    for(int n=0;n<p_Nfp*p_Nfaces;++n;@inner(0)){
      const dlong idM = vmapM[e*p_Nfp*p_Nfaces + n];
      const int bc = mapB[idM];

      if(bc>0) {
        const dfloat pM = P[idM];
        dfloat pP = 0.f;
        insPressureDirichletConditions2D(bc,time, x[idM], y[idM], nx, ny, pM, &pP);
        if(pressure_solve==0 && bc==3){ // if on an outflow BC and the pressure increment is in use
          dfloat pPm1 = 0.f;
          insPressureDirichletConditions2D(bc,time-dt, x[idM], y[idM], nx, ny, pM, &pPm1);
          pP = pP - pPm1;
        }
        P[idM] = pP;
      }    
    }
  }
}

