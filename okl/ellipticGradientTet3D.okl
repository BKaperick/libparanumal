
kernel void ellipticGradientTet3D(const int Nelements,
          const dfloat * restrict vgeo,
          const dfloat * restrict const DrT,
          const dfloat * restrict const DsT,
          const dfloat * restrict const DtT,
          const dfloat * restrict q,
          dfloat4 * restrict gradq){  
  
  // block partition of elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          // prefetch q
          const iint id = e*p_Np+n;
          s_q[e-eo][n] = q[id];
        }
      }
    }
          
    barrier(localMemFence);

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const iint es = e-eo;
          const int gid = e*p_Nvgeo;

          const dfloat drdx = vgeo[e*Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*Nvgeo + p_RYID];
          const dfloat drdz = vgeo[e*Nvgeo + p_RZID];
          const dfloat dsdx = vgeo[e*Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*Nvgeo + p_SYID];
          const dfloat dsdz = vgeo[e*Nvgeo + p_SZID];
          const dfloat dtdx = vgeo[e*Nvgeo + p_TXID];
          const dfloat dtdy = vgeo[e*Nvgeo + p_TYID];
          const dfloat dtdz = vgeo[e*Nvgeo + p_TZID];    

          // compute 1D derivatives
          dfloat qr = 0, qs = 0, qt =0;

          occaUnroll(p_Np)
            for(iint i=0;i<p_Np;++i) {
              qr += DrT[n + i*p_Np]*s_q[es][i];
              qs += DsT[n + i*p_Np]*s_q[es][i];
              qt += DtT[n + i*p_Np]*s_q[es][i];
            }

          dfloat4 gradqn;
          gradqn.x = drdx*qr + dsdx*qs + dtdx*qt;
          gradqn.y = drdy*qr + dsdy*qs + dtdy*qt;
          gradqn.z = drdz*qr + dsdz*qs + dtdz*qt;
          gradqn.w = s_q[es][n];
          
          const iint id = e*p_Np+n; 
          gradq[id] = gradqn;
        }
      }
    }
  }
}
