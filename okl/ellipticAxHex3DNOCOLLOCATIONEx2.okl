//this is a sequwnce of optimizations applied to a full Ax AKA BP3 (benchmark problem 3)
// put together by Kasia for paper
// ONLY 2D versions in this file

#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)

//Ref 0, no optimizations and 3 kernel version

kernel void ellipticAxHex3D_Ref3D0( iint Nelements,
                                    iint *  elementList,
                                    dfloat *gjGeo,
                                    dfloat *  gllD,
                                    dfloat *  gjI,
                                    dfloat lambda,
                                    dfloat * q,
                                    dfloat * Ixq,
                                    dfloat *  Aq
                                  ){
                                  
                                  
	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive iint emap;
		exclusive dfloat r_res;
		//	shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					
				}//for a
			}// for b
		}//for c
		
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							iint emap = elementList[e];
							iint t = n + b*p_gjNq + c*p_gjNq2;
							
							Iq += s_gsI[i][n]*q[t+emap*p_Np];
						}
					}
					//		r_res = Iq;
					iint emap = elementList[e];
					iint t = i + b*p_gjNq + c*p_gjNq2;
					Ixq[t+emap*p_Np] = Iq;
				}
			}
		}
		
		
		//	barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							iint emap = elementList[e];
							iint t = i + n*p_gjNq + c*p_gjNq2;
							Iq += s_gsI[j][n]*Aq[emap*p_Np];
						}
					}
					iint emap = elementList[e];
					iint t = i + j*p_gjNq + c*p_gjNq2;
					Aq[t+emap*p_gjNp] = Iq;
					//		r_res = Iq;
				}
			}
		}
		barrier(localMemFence);
		
		
		//		barrier(localMemFence);
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						iint emap = elementList[e];
						iint t = i + j*p_gjNq + n*p_gjNq2;
						Iq += s_gsI[k][n]*Aq[n+emap*p_gjNp];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const iint id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
		
	}// for e
	
	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->
	
	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		//	shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		exclusive dfloat r_dr, r_ds, r_dt, r_tmp;
		//	exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive iint emap;
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					//	s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		barrier(localMemFence);
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					dfloat		GwJ = gjGeo[base+p_GWJID*p_gjNp];
					
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n]*Ixq[n + j*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						ds += s_gjD[j][n]*Ixq[i + n*p_gjNq + k*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
						dt += s_gjD[k][n]*Ixq[i + j*p_gjNq + n*p_gjNq*p_gjNq + elementList[e]*p_gjNp];
					}
					r_dr = dr;
					r_ds = ds;
					r_dt = dt;
					
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					
					Aq[t+emap*p_gjNp] = GwJ*Ixq[t+emap*p_gjNp]*lambda;
				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat		G00 = gjGeo[base+p_G00ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					//	s_q[k][j][i] = r_qr;
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] = G00*r_dr + G01*r_ds + G02*r_dt;;
					
				}
			}
		}
		barrier(localMemFence);
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						//k j m
						emap = elementList[e];
						iint t = m + j*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][i]*Ixq[t+p_gjNp*emap];
					}
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		barrier(localMemFence);
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					dfloat			G11 = gjGeo[base+p_G11ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G01 = gjGeo[base+p_G01ID*p_gjNp];
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] =G01*r_dr + G11*r_ds + G12*r_dt;
					//s_q[k][j][i] = r_qs;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						//k m i
						emap = elementList[e];
						iint t = i + m*p_gjNq + k*p_gjNq2;
						tmp += s_gjD[m][j]*Ixq[t+emap*p_gjNp];
					}
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					Aq[t+emap*p_gjNp] +=tmp;
				}
			}
		}
		barrier(localMemFence);
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
			
				for(int i=0; i<p_gjNq; ++i; inner0) {
					iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					
					dfloat		G02 = gjGeo[base+p_G02ID*p_gjNp];
					dfloat G12 = gjGeo[base+p_G12ID*p_gjNp];
					dfloat		G22 = gjGeo[base+p_G22ID*p_gjNp];
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					Ixq[t+emap*p_gjNp] =G02*r_dr + G12*r_ds + G22*r_dt;
					//		s_q[k][j][i] = r_qt;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						// m j i
						emap = elementList[e];
						iint t = i + j*p_gjNq + m*p_gjNq2;
						tmp += s_gjD[m][k]*Ixq[t+emap*p_gjNp];
					}
					r_tmp +=tmp;
					
					iint base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Aq[base] = r_tmp;
				}
			}
		}
	}//for e
}
/*
//-------------------- kernel 3 interpolate back to gll hex ------------------->

for(int e=0; e<Nelements; ++e; outer0) {
// read q

shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
shared dfloat s_I[p_gjNq][p_Nq];
exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
iint emap;
for(int k=0; k<p_gjNq; ++k; inner2) {
for(int j=0; j<p_gjNq; ++j; inner1) {
for(int i=0; i<p_gjNq; ++i; inner0) {

iint base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
emap =elementList[e];
s_q[k][j][i] = Ixq[emap*p_gjNp+base];
if(i<p_Nq &&  k == 0 && j<p_gjNq) {
s_I[j][i] = gjI[j*p_Nq+i];
}
}
}
}
barrier(localMemFence);


// t first
for(int c=0; c<p_gjNq; ++c; inner2) {
for(int j=0; j<p_gjNq; ++j; inner1) {
for(int i=0; i<p_gjNq; ++i; inner0) {
dfloat Iq = 0.0f;
if(c<p_Nq){
occaUnroll(p_gjNq)
for(int m=0; m<p_gjNq; ++m) {
// k--> c
Iq += s_I[m][c]*s_q[m][j][i];
}
}
r_res = Iq;
}
}
}

barrier(localMemFence);

for(int c=0; c<p_gjNq; ++c; inner2) {
for(int j=0; j<p_gjNq; ++j; inner1) {
for(int i=0; i<p_gjNq; ++i; inner0) {
s_q[c][j][i] = r_res;
}
}
}




// r direction
barrier(localMemFence);

for(int c=0; c<p_gjNq; ++c; inner2) {
for(int b=0; b<p_gjNq; ++b; inner1) {
for(int i=0; i<p_gjNq; ++i; inner0) {
if(c<p_Nq && b<p_Nq){
dfloat Iq = 0.0f;
occaUnroll(p_gjNq)
for(int m=0; m<p_gjNq; ++m) {
Iq += s_I[m][b]*s_q[c][m][i];
}
r_res = Iq;
}
}
}
}
barrier(localMemFence);

for(int c=0; c<p_gjNq; ++c; inner2) {
for(int b=0; b<p_gjNq; ++b; inner1) {
for(int i=0; i<p_gjNq; ++i; inner0) {
s_q[c][b][i]= r_res;
}
}
}
barrier(localMemFence);

for(int c=0; c<p_gjNq; ++c; inner2) {
for(int b=0; b<p_gjNq; ++b; inner1) {
for(int a=0; a<p_gjNq; ++a; inner0) {
if (c<p_Nq && b<p_Nq && a< p_Nq){
dfloat Iq = 0.0f;
occaUnroll(p_gjNq)
for(int m=0; m<p_gjNq; ++m) {
Iq += s_I[m][a]*s_q[c][b][m];
}
emap = elementList[e];
iint base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
Aq[base] = Iq;
}
}
}
}
}//e
} //kernel e9






// for refeence and testing

kernel void ellipticAxHex3D_e9(const iint Nelements,
                               const iint * restrict elementList,
                               const dfloat * restrict gjGeo,
                               const dfloat * restrict gllD,
                               const dfloat * restrict gjI,
                               const dfloat lambda,
                               dfloat * restrict q,
                               dfloat * restrict Ixq,
                               dfloat * restrict Aq
                              ){
                              
                              
	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive iint emap;
		exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					iint t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						iint ta = t%p_Nq;
						iint tb = (t/p_Nq)%p_Nq;
						iint tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}
		
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		barrier(localMemFence);
		
		
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		barrier(localMemFence);
		
		// t direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const iint id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e
	
	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->
	
	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		//	exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive iint emap;
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		barrier(localMemFence);
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					
					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI
					
					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;
					
					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq
		
		// r direction
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		barrier(localMemFence);
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);
		
		//s direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);
		//t direction
		
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					iint base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
				}
			}
		}
	}//for e
	
	//-------------------- kernel 3 interpolate back to gll hex ------------------->
	
	for(int e=0; e<Nelements; ++e; outer0) {
		// read q
		
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		iint emap;
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
				
					iint base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		barrier(localMemFence);
		
		
		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		
		
		
		
		// r direction
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		barrier(localMemFence);
		
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						iint base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e9
*/


