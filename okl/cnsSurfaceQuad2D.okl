
void boundaryConditions2D(const int bc,
			  const dfloat  t, const dfloat  x, const dfloat  y, const dfloat  nx, const dfloat  ny,
			  const dfloat ramp,
			  const dflot rM, const dfloat  uM, const dfloat  vM, 
			  dfloat * restrict rB, dfloat * restrict uB, dfloat * restrict vB){

  // check these
  if(bc==1){ // wall 
    *rB = rM; 
    *uB = -uM;
    *vB = -vM;
  }
  if(bc>1){ // inflow
    *rB = p_two*p_rbar - rM; 
    *uB = p_two*ramp*p_ubar - uM; 
    *vB = p_two*ramp*p_vbar - vM; 
  }
  if(bc==2){ // slip
    // specify reversed normal velocity (no-penetration/slip boundary)
    *rB = rM;
    *uB = uM - p_two*(nx*uM+ny*vM)*nx;
    *vB = vM - p_two*(nx*uM+ny*vM)*ny;
  }
  if(bc==4){ // outflow
    // only specify density (specifies pressure since p = rho*RT)
    *rB = p_rbar;
    *uB = uM;
    *vB = vM;
  }
}


// batch process elements
kernel void cnsSurfaceQuad2D(const int Nelements,
			     const dfloat * restrict sgeo,
			     const dfloat * restrict LIFTT,
			     const int   * restrict vmapM,
			     const int   * restrict vmapP,
			     const int   * restrict EToB,
			     const dfloat time,
			     const dfloat * restrict x,
			     const dfloat * restrict y,
			     const dfloat ramp,
			     const dfloat * restrict q,
			     const dfloat * restrict viscousStresses,
			     dfloat       * restrict rhsq){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // shared storage for flux terms
    shared dfloat s_Lrflux[p_NblockS][p_maxNodes];
    shared dfloat s_Lruflux[p_NblockS][p_maxNodes];
    shared dfloat s_Lrvflux[p_NblockS][p_maxNodes];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_NfacesNfp){
	    // find face that owns this node
	    const int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    const int sid = p_Nsgeo*(p_Nfp*p_Nfaces*e+n); // fix later for TP
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;

	    // load traces
	    const dlong eM = e;
	    const dlong eP = idP/p_Np;
	    const int vidM = idM%p_Np;
	    const int vidP = idP%p_Np;

	    const dlong baseM = eM*p_Np*p_Nfields + vidM;
	    const dlong baseP = eP*p_Np*p_Nfields + vidP;

	    const dlong sbaseM = eM*p_Np*p_Nstresses + vidM;
	    const dlong sbaseP = eP*p_Np*p_Nstresses + vidP;
	    
	    const dfloat rM  = q[baseM + 0*p_Np];
	    const dfloat ruM = q[baseM + 1*p_Np];
	    const dfloat rvM = q[baseM + 2*p_Np];

	    const dfloat T11M = viscousStresses[sbaseM+0*p_Np];
	    const dfloat T12M = viscousStresses[sbaseM+1*p_Np];
	    const dfloat T22M = viscousStresses[sbaseM+2*p_Np];
	    
	    const dfloat rP  = q[baseP + 0*p_Np];
	    const dfloat ruP = q[baseP + 1*p_Np];
	    const dfloat rvP = q[baseP + 2*p_Np];

	    const dfloat T11P = viscousStresses[sbaseP+0*p_Np];
	    const dfloat T12P = viscousStresses[sbaseP+1*p_Np];
	    const dfloat T22P = viscousStresses[sbaseP+2*p_Np];

	    const dfloat uM = ruM/rM;
	    const dfloat vM = rvM/rM;
	    const dfloat pM = p_RT*rM;

	    const dfloat uP = ruP/rP;
	    const dfloat vP = rvP/rP;
	    const dfloat pP = p_RT*rP;
	    
	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, ramp,
				   rM, uM, vM, &rP, &uP, &vP);

	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    const dfloat sc = invJ*sJ;
	    
	    // simple Lax Friedrichs flux to get started (change later)
	    {
	      const dfloat fM = ruM, gM = rvM;
	      const dfloat fP = ruP, gP = rvP;
	      const dfloat rflux = -nx*(fP-fM) -ny*(gP-gM) - lambda*(rP-rM);

	      s_rflux[es][n] = p_half*sc*(rflux);
	    }

	    {
	      const dfloat fM = T11M - ruM*uM - pM, gM = T12M - ruM*vM;
	      const dfloat fP = T11P - ruP*uP - pP, gP = T12P - ruP*vP;

	      const dfloat ruflux = nx*(fP-fM) + ny*(gP-gM) + lambda*(ruP-ruM); // should add viscous penalty
	      s_ruflux[es][n] = p_half*sc*(ruflux);
	    }

	    {
	      const dfloat fM = T12M - rvM*uM, gM = T22M - rvM*vM - pM;
	      const dfloat fP = T12P - rvP*uP, gP = T22P - rvP*vP - pP;

	      const dfloat rvflux = nx*(fP-fM) + ny*(gP-gM) + lambda*(rvP-rvM); // should add viscous penalty
	      s_rvflux[es][n] = p_half*sc*(rvflux);
	    }
	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	const int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat Lrflux = 0.f, Lruflux = 0.f, Lrvflux = 0.f;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_Nfaces)
	      for(int m=0;m<p_NfacesNfp;++m){
		const dfloat L = LIFTT[n+m*p_Np];
		Lrflux  += L*s_rflux[es][m];
		Lruflux += L*s_ruflux[es][m];
		Lrvflux += L*s_rvflux[es][m];
	      }
	    
	    const int base = e*p_Np*p_Nfields+n;
	    rhsq[base+0*p_Np] += Lrflux;
	    rhsq[base+1*p_Np] += Lruflux;
	    rhsq[base+2*p_Np] += Lrvflux;
	  }
	}
      }
    }
  }
}

kernel void cnsStressesSurfaceQuad2D(const int Nelements,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const int   * restrict vmapM,
				     const int   * restrict vmapP,
				     const int   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat ramp,
				     const dfloat * restrict q,
				     dfloat * restrict viscousStresses){
  
  
}
