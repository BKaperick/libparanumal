
#if 1
void boundaryConditions2D(const int bc,
			  const dfloat  t, const dfloat  x, const dfloat  y, const dfloat  nx, const dfloat  ny,
			  const dfloat ramp,
			  const dfloat rM, const dfloat  uM, const dfloat  vM, 
			  dfloat * restrict rB, dfloat * restrict uB, dfloat * restrict vB){

  // check these
  if(bc==1){ // wall 
    *rB = rM; 
    *uB = -uM;
    *vB = -vM;
  }
  if(bc==2){ // inflow
    *rB = p_rbar;
//    *uB = ramp*p_ubar*y*(6-y)/9.;
    const dfloat alpha = 20;
    *uB = p_ubar*occaTanh(alpha*y)*occaTanh(alpha*(6-y));
    *vB = ramp*p_vbar;
  }
  if(bc==4){ // slip
    // specify reversed normal velocity (no-penetration/slip boundary)
    *rB = rM;
    *uB = uM - (nx*uM+ny*vM)*nx;
    *vB = vM - (nx*uM+ny*vM)*ny;
  }
  if(bc==3){ // outflow
    // only specify density (specifies pressure since p = rho*RT)
    *rB = p_rbar;
    *uB = uM;
    *vB = vM;
  }
}
#else
void boundaryConditions2D(const int bc,
			  const dfloat  t, const dfloat  x, const dfloat  y, const dfloat  nx, const dfloat  ny,
			  const dfloat ramp,
			  const dfloat rM, const dfloat  uM, const dfloat  vM, 
			  dfloat * restrict rB, dfloat * restrict uB, dfloat * restrict vB){

  // check these
  if(bc==1){ // wall 
    *rB = rM; 
    *uB = 0;
    *vB = 0;
  }
  if(bc==2){ // inflow
    *rB = p_rbar;
    *uB = ramp*p_ubar;
    *vB = ramp*p_vbar;
  }
  if(bc==5){ // slip
    // specify reversed normal velocity (no-penetration/slip boundary)
    *rB = rM;
    *uB = uM - (nx*uM+ny*vM)*nx;
    *vB = vM - (nx*uM+ny*vM)*ny;
  }
  if(bc==3){ // outflow
    // only specify density (specifies pressure since p = rho*RT)
    *rB = p_rbar;
    *uB = uM;
    *vB = vM;
  }
}
#endif

// Roe averaged Riemann solver

void upwindRoeAveraged(const dfloat nx,
		       const dfloat ny,
		       const dfloat rM,
		       const dfloat ruM,
		       const dfloat rvM,
		       const dfloat rP,
		       const dfloat ruP,
		       const dfloat rvP,
		       dfloat *rflux,
		       dfloat *ruflux,
		       dfloat *rvflux
		       ){

  // Rotate "-" trace momentum to face normal-tangent coordinates

  dfloat rMrot = rM;
  dfloat rProt = rP;
  
  dfloat ruMrot = nx*ruM + ny*rvM;
  dfloat rvMrot =-ny*ruM + nx*rvM;

  dfloat ruProt = nx*ruP + ny*rvP;
  dfloat rvProt =-ny*ruP + nx*rvP;
  
  dfloat uMrot = ruMrot/rM;
  dfloat vMrot = rvMrot/rM;

  dfloat uProt = ruProt/rP;
  dfloat vProt = rvProt/rP;

  dfloat pM = p_RT*rM;
  dfloat pP = p_RT*rP;
  
  // Compute fluxes and primitive variables in rotated coordinates
  dfloat frMrot = ruMrot;
  dfloat grMrot = rvMrot;

  dfloat fruMrot = uMrot*ruMrot + pM;
  dfloat gruMrot = uMrot*rvMrot;

  dfloat frvMrot = vMrot*ruMrot;
  dfloat grvMrot = vMrot*rvMrot + pM;


  dfloat frProt = ruProt;
  dfloat grProt = rvProt;

  dfloat fruProt = uProt*ruProt + pP;
  dfloat gruProt = uProt*rvProt;

  dfloat frvProt = vProt*ruProt;
  dfloat grvProt = vProt*rvProt + pP;

  // Compute Roe average variables
  dfloat rMsqr = occaSqrt(rM);
  dfloat rPsqr = occaSqrt(rP); 

  dfloat r = rMsqr*rPsqr;
  dfloat urot = (rMsqr*uMrot + rPsqr*uProt)/(rMsqr + rPsqr);
  dfloat vrot = (rMsqr*vMrot + rPsqr*vProt)/(rMsqr + rPsqr);
  
  dfloat c2  = p_RT;
  dfloat c   = p_sqrtRT;

  // Riemann fluxes
  dfloat dW1 = -p_half*r*(uProt-uMrot)/c + p_half*(pP-pM)/c2;  
  dfloat dW2 = r*(vProt-vMrot);
  dfloat dW3 =  p_half*r*(uProt-uMrot)/c + p_half*(pP-pM)/c2;  


  dW1 *= occaFabs(urot-c);
  dW2 *= occaFabs(urot);
  dW3 *= occaFabs(urot+c); 

  // Form Roe fluxes
  *rflux = p_half*(frProt-frMrot);
  dfloat rufluxRot = p_half*(fruProt-fruMrot);
  dfloat rvfluxRot = p_half*(frvProt-frvMrot);

  
  *rflux    -= p_half*(dW1*p_one    + dW2*p_zero  + dW3*p_one);
  rufluxRot -= p_half*(dW1*(urot-c) + dW2*p_zero  + dW3*(urot+c));
  rvfluxRot -= p_half*(dW1*vrot     + dW2*p_one   + dW3*vrot);

  // rotate back to Cartesian
  *ruflux = nx*rufluxRot - ny*rvfluxRot;
  *rvflux = ny*rufluxRot + nx*rvfluxRot;

}


// batch process elements
kernel void cnsSurfaceQuad2D(const int Nelements,
			     const dfloat * restrict sgeo,
			     const dfloat * restrict LIFTT,
			     const int   * restrict vmapM,
			     const int   * restrict vmapP,
			     const int   * restrict EToB,
			     const dfloat time,
			     const dfloat * restrict x,
			     const dfloat * restrict y,
			     const dfloat ramp,
			     const dfloat mu,
			     const dfloat * restrict q,
			     const dfloat * restrict viscousStresses,
			     dfloat       * restrict rhsq){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // shared storage for flux terms
    shared dfloat s_rflux[p_NblockS][p_maxNodes];
    shared dfloat s_ruflux[p_NblockS][p_maxNodes];
    shared dfloat s_rvflux[p_NblockS][p_maxNodes];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_NfacesNfp){
	    // find face that owns this node
	    const int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    const int sid = p_Nsgeo*(p_Nfp*p_Nfaces*e+n); // fix later for TP
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;

	    // load traces
	    const dlong eM = e;
	    const dlong eP = idP/p_Np;
	    const int vidM = idM%p_Np;
	    const int vidP = idP%p_Np;

	    const dlong qbaseM = eM*p_Np*p_Nfields + vidM;
	    const dlong qbaseP = eP*p_Np*p_Nfields + vidP;

	    const dlong sbaseM = eM*p_Np*p_Nstresses + vidM;
	    const dlong sbaseP = eP*p_Np*p_Nstresses + vidP;
	    
	    const dfloat rM  = q[qbaseM + 0*p_Np];
	    const dfloat ruM = q[qbaseM + 1*p_Np];
	    const dfloat rvM = q[qbaseM + 2*p_Np];

	    const dfloat T11M = viscousStresses[sbaseM+0*p_Np];
	    const dfloat T12M = viscousStresses[sbaseM+1*p_Np];
	    const dfloat T22M = viscousStresses[sbaseM+2*p_Np];
	    
	    dfloat rP  = q[qbaseP + 0*p_Np];
	    dfloat ruP = q[qbaseP + 1*p_Np];
	    dfloat rvP = q[qbaseP + 2*p_Np];

	    const dfloat T11P = viscousStresses[sbaseP+0*p_Np];
	    const dfloat T12P = viscousStresses[sbaseP+1*p_Np];
	    const dfloat T22P = viscousStresses[sbaseP+2*p_Np];

	    const dfloat uM = ruM/rM;
	    const dfloat vM = rvM/rM;
	    const dfloat pM = p_RT*rM;

	    dfloat uP = ruP/rP;
	    dfloat vP = rvP/rP;
	    dfloat pP = p_RT*rP;
	    
	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0){
	      boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, ramp,
				   rM, uM, vM, &rP, &uP, &vP);

	      ruP = rP*uP;
	      rvP = rP*vP;
	      pP = p_RT*rP;
	    }
	    
	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    const dfloat sc = invJ*sJ;

#if 0
	    dfloat rflux, ruflux, rvflux;
	    
	    upwindRoeAveraged(nx, ny, rM, ruM, rvM, rP, ruP, rvP, &rflux, &ruflux, &rvflux);
	    
	    // simple Lax Friedrichs flux to get started (change later)
	    {
	      s_rflux[es][n] = sc*(-rflux);
	    }

	    const dfloat hinv = sgeo[sid + p_IHID];
	    dfloat penalty = p_Nq*p_Nq*hinv*mu;	      

	    {
	      ruflux -= p_half*(nx*(T11P-T11M) + ny*(T12P-T12M) + penalty*(uP-uM)); // should add viscous penalty
	      s_ruflux[es][n] = sc*(-ruflux);
	    }

	    {
	      rvflux -= p_half*(nx*(T12P-T12M) + ny*(T22P-T22M) + penalty*(vP-vM)); // should add viscous penalty
	      s_rvflux[es][n] = sc*(-rvflux);
	    }
	    
#else
	    const dfloat lambdaM = occaSqrt(uM*uM+vM*vM) + p_sqrtRT;
	    const dfloat lambdaP = occaSqrt(uP*uP+vP*vP) + p_sqrtRT;

	    dfloat lambda = (lambdaM>lambdaP) ? lambdaM:lambdaP;
	    
	    // simple Lax Friedrichs flux to get started (change later)
	    {
	      const dfloat fM = -ruM, gM = -rvM;
	      const dfloat fP = -ruP, gP = -rvP;
	      const dfloat rflux = nx*(fP-fM) + ny*(gP-gM) + lambda*(rP-rM);

	      s_rflux[es][n] = p_half*sc*(rflux);
	    }

	    const dfloat hinv = sgeo[sid + p_IHID];
	    dfloat penalty = p_Nq*p_Nq*hinv*mu;	      

	    {
	      
	      const dfloat fM = T11M - ruM*uM - pM, gM = T12M - ruM*vM;
	      const dfloat fP = T11P - ruP*uP - pP, gP = T12P - ruP*vP;

	      const dfloat ruflux = nx*(fP-fM) + ny*(gP-gM) + lambda*(ruP-ruM) + penalty*(uP-uM); // should add viscous penalty
	      s_ruflux[es][n] = p_half*sc*(ruflux);
	    }

	    {
	      const dfloat fM = T12M - rvM*uM, gM = T22M - rvM*vM - pM;
	      const dfloat fP = T12P - rvP*uP, gP = T22P - rvP*vP - pP;

	      const dfloat rvflux = nx*(fP-fM) + ny*(gP-gM) + lambda*(rvP-rvM) + penalty*(vP-vM); // should add viscous penalty
	      s_rvflux[es][n] = p_half*sc*(rvflux);
	    }
#endif
	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	const int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat Lrflux = 0.f, Lruflux = 0.f, Lrvflux = 0.f;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_Nfaces)
	      for(int m=0;m<p_NfacesNfp;++m){
		const dfloat L = LIFTT[n+m*p_Np];
		Lrflux  += L*s_rflux[es][m];
		Lruflux += L*s_ruflux[es][m];
		Lrvflux += L*s_rvflux[es][m];
	      }
	    
	    const int base = e*p_Np*p_Nfields+n;
	    rhsq[base+0*p_Np] += Lrflux;
	    rhsq[base+1*p_Np] += Lruflux;
	    rhsq[base+2*p_Np] += Lrvflux;
	  }
	}
      }
    }
  }
}

kernel void cnsStressesSurfaceQuad2D(const int Nelements,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const int   * restrict vmapM,
				     const int   * restrict vmapP,
				     const int   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat ramp,
				     const dfloat mu,
				     const dfloat * restrict q,
				     dfloat * restrict viscousStresses){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // shared storage for flux terms
    shared dfloat s_T11flux[p_NblockS][p_maxNodes];
    shared dfloat s_T12flux[p_NblockS][p_maxNodes];
    shared dfloat s_T22flux[p_NblockS][p_maxNodes];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_NfacesNfp){
	    // find face that owns this node
	    const int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    const int sid = p_Nsgeo*(p_Nfp*p_Nfaces*e+n); // fix later for TP
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;

	    // load traces
	    const dlong eM = e;
	    const dlong eP = idP/p_Np;
	    const int vidM = idM%p_Np;
	    const int vidP = idP%p_Np;

	    const dlong baseM = eM*p_Np*p_Nfields + vidM;
	    const dlong baseP = eP*p_Np*p_Nfields + vidP;

	    const dfloat rM  = q[baseM + 0*p_Np];
	    const dfloat ruM = q[baseM + 1*p_Np];
	    const dfloat rvM = q[baseM + 2*p_Np];

	    dfloat uM = ruM/rM;
	    dfloat vM = rvM/rM;
	    
	    dfloat rP  = q[baseP + 0*p_Np];
	    dfloat ruP = q[baseP + 1*p_Np];
	    dfloat rvP = q[baseP + 2*p_Np];
	    
	    dfloat uP = ruP/rP;
	    dfloat vP = rvP/rP;

	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, ramp,
				   rM, uM, vM, &rP, &uP, &vP);
	    
	    const dfloat dS11 = p_half*(nx*(p_two*(uP-uM))) - p_third*(nx*(uP-uM)+ny*(vP-vM));
	    const dfloat dS12 = p_half*(ny*(uP-uM) + nx*(vP-vM));
	    const dfloat dS22 = p_half*(ny*(p_two*(vP-vM))) - p_third*(nx*(uP-uM)+ny*(vP-vM));
	    
	    s_T11flux[es][n] = p_two*mu*dS11;
	    s_T12flux[es][n] = p_two*mu*dS12;
	    s_T22flux[es][n] = p_two*mu*dS22;
	  }
	}
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	const int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat LT11flux = 0.f, LT12flux = 0.f, LT22flux = 0.f;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_Nfaces)
	      for(int m=0;m<p_NfacesNfp;++m){
		const dfloat L = LIFTT[n+m*p_Np];
		LT11flux += L*s_T11flux[es][m];
		LT12flux += L*s_T12flux[es][m];
		LT22flux += L*s_T22flux[es][m];
	      }
	    
	    const int base = e*p_Np*p_Nstresses+n;
	    viscousStresses[base+0*p_Np] += LT11flux;
	    viscousStresses[base+1*p_Np] += LT12flux;
	    viscousStresses[base+2*p_Np] += LT22flux;
	  }
	}
      }
    }
  }
}

  
