// compute local gradients

kernel void ellipticGradientHex3D(const int Nelements,
				  const dfloat4 * restrict vgeo,
				  const dfloat  * restrict const D,
				  const dfloat * restrict q,
				  dfloat4 * restrict gradq){  

  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_Nq][p_Nq];
    shared dfloat s_q[p_Nq][p_Nq][p_Nq];
    
    // prefetch D
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
	s_D[j][i] = D[i + p_Nq*j];
      }
    }

    // loop over slabs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	// prefetch q
	for(int i=0;i<p_Nq;++i;inner0){
	  s_q[k][j][i] = q[e*p_Np+k*p_Nq*p_Nq+j*p_Nq+i];
	}
      }
    }
    
    barrier(localMemFence);
    
    // loop over slabs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	
	  const int gid = i + j*p_Nq + k*p_Nfp + e*p_Np*p_Nvgeo;

	  const dfloat drdx = vgeo[gid + RXID*p_Np];
	  const dfloat drdy = vgeo[gid + RYID*p_Np];
	  const dfloat drdz = vgeo[gid + RZID*p_Np];
	  
	  const dfloat dsdx = vgeo[gid + SXID*p_Np];
	  const dfloat dsdy = vgeo[gid + SYID*p_Np];
	  const dfloat dsdz = vgeo[gid + SZID*p_Np];
	  
	  const dfloat dtdx = vgeo[gid + TXID*p_Np];
	  const dfloat dtdy = vgeo[gid + TYID*p_Np];
	  const dfloat dtdz = vgeo[gid + TZID*p_Np];
	  
	  // compute 1D derivatives
	  dfloat qr = 0, qs = 0, qt = 0;
	  for(int n=0;n<p_Nq;++n){
	    qr += s_D[i][n]*s_q[k][j][n];
	    qs += s_D[j][n]*s_q[k][n][i];
	    qt += s_D[k][n]*s_q[n][j][i];
	  }
	  
	  dfloat4 gradqn;
	  gradqn.x = drdx*pr + dsdx*ps + dtdx*pt;
	  gradqn.y = drdy*pr + dsdy*ps + dtdy*pt;
	  gradqn.z = drdz*pr + dsdz*ps + dtdz*pt;
	  gradqn.w = s_q[k][j][i];
	  
	  q[gid] = gradqn;
	}
      }
    }
  }
}
