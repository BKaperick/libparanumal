

// compute div(NU)  = div(uxu) in collocation way
kernel void insSubCycleVolumeTri2D(const dlong Nelements,
                                const dfloat * restrict vgeo,
                                const dfloat * restrict DrT,
                                const dfloat * restrict DsT,
                                const dfloat * restrict Ux,
                                const dfloat * restrict Uy,
                                const dfloat * restrict Px,
                                const dfloat * restrict Py,
                                      dfloat * restrict rhsUx,
                                      dfloat * restrict rhsUy){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_F11[p_NblockV][p_Np];
    shared dfloat s_F12[p_NblockV][p_Np];
    shared dfloat s_F21[p_NblockV][p_Np];
    shared dfloat s_F22[p_NblockV][p_Np];
    //
    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        dlong e = eo+es; // element in block
        if(e<Nelements){ 
          const dlong id = e*p_Np+n;
          const dfloat ux = Ux[id];
          const dfloat uy = Uy[id];
          const dfloat px = Px[id];
          const dfloat py = Py[id];

          s_F11[es][n] = ux*px;
          s_F12[es][n] = uy*px;
          s_F21[es][n] = ux*py;
          s_F22[es][n] = uy*py;
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){      
        const dlong e = eo+es; 
        if(e<Nelements){    
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
          // compute 'r' and 's' derivatives of (q_m) at node n
          dfloat df11dr = 0.f, df11ds = 0.f; 
          dfloat df12dr = 0.f, df12ds = 0.f; 
          dfloat df21dr = 0.f, df21ds = 0.f; 
          dfloat df22dr = 0.f, df22ds = 0.f; 

          occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            const dfloat Drni = DrT[n+i*p_Np];
            const dfloat Dsni = DsT[n+i*p_Np];

            df11dr += Drni*s_F11[es][i];
            df11ds += Dsni*s_F11[es][i];

            df12dr += Drni*s_F12[es][i];
            df12ds += Dsni*s_F12[es][i];

            df21dr += Drni*s_F21[es][i];
            df21ds += Dsni*s_F21[es][i];

            df22dr += Drni*s_F22[es][i];
            df22ds += Dsni*s_F22[es][i];
          }

          const dfloat rhsux   = drdx*df11dr + dsdx*df11ds 
                               + drdy*df12dr + dsdy*df12ds;

          const dfloat rhsuy   = drdx*df21dr + dsdx*df21ds 
                               + drdy*df22dr + dsdy*df22ds;

          const dlong id = e*p_Np+n;
          // Compute div(uxu)
          rhsUx[id]   = rhsux;
          rhsUy[id]   = rhsuy;     
        }
      }
    }
  }
}


kernel void insSubCycleSurfaceTri2D(const dlong Nelements,
                                    const dfloat * restrict sgeo,
                                    const dfloat * restrict LIFTT,
                                    const dlong  * restrict vmapM,
                                    const dlong  * restrict vmapP,
                                    const int    * restrict EToB,
                                    const dfloat bScale,
                                    const dfloat time,
                                    const dfloat * restrict x,
                                    const dfloat * restrict y,
                                    const dfloat * restrict Ux,
                                    const dfloat * restrict Uy,
                                    const dfloat * restrict Px,
                                    const dfloat * restrict Py,
                                          dfloat * restrict rhsUx,
                                          dfloat * restrict rhsUy){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        const dlong e = eo + es;
        if(e<Nelements && n<p_Nfp*p_Nfaces){
          // find face that owns this node
          const int face = n/p_Nfp;
          // load surface geofactors for this face
          const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
          const dfloat nx   = sgeo[sid+p_NXID];
          const dfloat ny   = sgeo[sid+p_NYID];
          const dfloat sJ   = sgeo[sid+p_SJID];
          const dfloat invJ = sgeo[sid+p_IJID];

          // indices of negative and positive traces of face node
          const dlong id  = e*p_Nfp*p_Nfaces + n;
          const dlong idM = vmapM[id];
          const dlong idP = vmapP[id];

          // load negative and positive trace node values of Ux, Uy, Pr
          const dfloat  uxM = Ux[idM], uxP = Ux[idP];
          const dfloat  uyM = Uy[idM], uyP = Uy[idP];

          const dfloat  pxM = Px[idM], pyM = Py[idM];
                dfloat  pxP = Px[idP], pyP = Py[idP];

          // apply boundary condition
          const int bc = EToB[face+p_Nfaces*e];
          if(bc>0) {
            insVelocityDirichletConditions2D(bc, time, x[idM], y[idM], nx, ny, pxM, pyM, &pxP, &pyP);
            pxP *= bScale; 
            pyP *= bScale; 
          }

          // Find max normal velocity on the face
          dfloat unM   = occaFabs(nx*uxM + ny*uyM);
          dfloat unP   = occaFabs(nx*uxP + ny*uyP);    
          dfloat unMax = (unM > unP) ? unM : unP;

          // evaluate "flux" terms: LLF
          const dfloat sc = invJ * sJ ; 
          s_fluxUx[es][n] = sc*(.5f*( nx*(uxP*pxP - uxM*pxM) 
                                    + ny*(uyP*pxP - uyM*pxM) + unMax*(pxM-pxP) ));
          s_fluxUy[es][n] = sc*(.5f*( nx*(uxP*pyP - uxM*pyP) 
                                    + ny*(uyP*pyP - uyM*pyM) + unMax*(pyM-pyP) ));
        }
      }
    }

    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        const dlong e = eo + es;
        if(e<Nelements && n<p_Np){
          const dlong id = e*p_Np + n;
          dfloat rhsux = rhsUx[id];
          dfloat rhsuy = rhsUy[id];
          // Lift
          occaUnroll(p_NfacesNfp)
            for(int m=0;m<p_Nfaces*p_Nfp;++m){
              const dfloat L = LIFTT[n+m*p_Np];
              rhsux  += L*s_fluxUx[es][m];
              rhsuy  += L*s_fluxUy[es][m];
            }

          // M^-1* (div(u*u)) + Lift*(F*-F))
          rhsUx[id] = -rhsux;
          rhsUy[id] = -rhsuy;
        }
      }
    }
  }
}


// // Optimized sizes for kernel 6, currently best one !!!!
#if p_N==1
#define p_NbV 20
#define p_Nmt 1
#endif

#if p_N==2
#define p_NbV 5
#define p_Nmt 2
#endif

#if p_N==3
#define p_NbV 6
#define p_Nmt 2
#endif

#if p_N==4
#define p_NbV 2
#define p_Nmt 2
#endif

#if p_N==5
#define p_NbV 3
#define p_Nmt 2
#endif

#if p_N==6
#define p_NbV 6
#define p_Nmt 3
#endif

#if p_N==7
#define p_NbV 3
#define p_Nmt 3
#endif

#if p_N==8
#define p_NbV 5
#define p_Nmt 2
#endif

#if p_N==9
#define p_NbV 3
#define p_Nmt 2
#endif

#if p_N==10
#define p_NbV 3
#define p_Nmt 2
#endif



kernel void insSubCycleCubatureVolumeTri2D(const dlong Nelements,
                                           const dfloat * restrict vgeo,
                                           const dfloat * restrict cubDrWT,
                                           const dfloat * restrict cubDsWT,
                                           const dfloat * restrict cubInterpT,
                                           const dfloat * restrict U,
                                           const dfloat * restrict V,
                                           const dfloat * restrict Ud,
                                           const dfloat * restrict Vd,
                                                 dfloat * restrict rhsU,
                                                 dfloat * restrict rhsV){

  for(dlong eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_Nmt][p_NbV][p_Np];
    shared dfloat  s_V[p_Nmt][p_NbV][p_Np];
    shared dfloat s_Ud[p_Nmt][p_NbV][p_Np];
    shared dfloat s_Vd[p_Nmt][p_NbV][p_Np];
    
    shared dfloat s_cF11[p_Nmt][p_NbV][p_Np];
    shared dfloat s_cF12[p_Nmt][p_NbV][p_Np];
    shared dfloat s_cF21[p_Nmt][p_NbV][p_Np];
    shared dfloat s_cF22[p_Nmt][p_NbV][p_Np];
    
    exclusive dfloat fluxU[p_Nmt], fluxV[p_Nmt];
    
    for(int es=0;es<p_NbV;++es;inner1){// for all elements in block      
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        occaUnroll(p_Nmt)
          for(int em=0;em<p_Nmt;++em){
            const dlong e = eo + es*p_Nmt + em;
            const dlong id = e*p_Np + n;
            
            if(e<Nelements){
              // prefetch geometric factors (constant on triangle)
              const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
              const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
              const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
              const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
              
              const dfloat Un = U[id];
              const dfloat Vn = V[id];
              
              s_Ud[em][es][n] = Ud[id];
              s_Vd[em][es][n] = Vd[id];
              
              s_U[em][es][n] = drdx*Un + drdy*Vn; // rotate velocity 
              s_V[em][es][n] = dsdx*Un + dsdy*Vn; // 
            } else {
              s_Ud[em][es][n] = 0.;
              s_Vd[em][es][n] = 0.;
              
              s_U[em][es][n] = 0.;
              s_V[em][es][n] = 0.;
            }
          } 
      }
    }

    barrier(localMemFence);
      
    for(int es=0;es<p_NbV;++es;inner1){// for all elements in block
      for(int ns=0;ns<p_Np;++ns;inner0){     // for all nodes in this element
        occaUnroll(p_Nmt)
          for(int em=0;em<p_Nmt;++em){
            fluxU[em] = 0;
            fluxV[em] = 0;
          }
      }
    }

    //occaUnroll()
    for(int io=0;io<p_cubNp;io+=p_Np){ // block the cubature nodes

      barrier(localMemFence);

      for(int es=0;es<p_NbV;++es;inner1){// for all elements in block
        for(int ns=0;ns<p_Np;++ns;inner0){     // for all nodes in this element
          const int n = ns+io; // choose cubature node to interpolate to
          if(n<p_cubNp){
            // compute Np of the cubNp cubature values
            dfloat cU[p_Nmt], cV[p_Nmt], cUd[p_Nmt], cVd[p_Nmt];
            
            occaUnroll(p_Nmt)
              for(int em=0;em<p_Nmt;++em){
                cU[em] = 0.f;
                cV[em] = 0.f;
                cUd[em] = 0.f; 
                cVd[em] = 0.f;
              }
            
            occaUnroll(p_Np)
              for(int i=0;i<p_Np;++i){
                const dfloat cIni = cubInterpT[n+i*p_cubNp];
                occaUnroll(p_Nmt)
                  for(int em=0;em<p_Nmt;++em){
                    cU[em]  += cIni*s_U[em][es][i];
                    cV[em]  += cIni*s_V[em][es][i];
                    cUd[em] += cIni*s_Ud[em][es][i];
                    cVd[em] += cIni*s_Vd[em][es][i];        
                  }
              }
            
            // share up to the Np cubature vals computed in this block
            occaUnroll(p_Nmt)
              for(int em=0;em<p_Nmt;++em){
                s_cF11[em][es][ns] = cU[em]*cUd[em];
                s_cF12[em][es][ns] = cV[em]*cUd[em];
                s_cF21[em][es][ns] = cU[em]*cVd[em];
                s_cF22[em][es][ns] = cV[em]*cVd[em];
              }
          }
        }
      }
        
      // Make sure all node data is loaded into shared
      barrier(localMemFence);
      
      for(int es=0;es<p_NbV;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){      
          
          occaUnroll(p_Np)
            for(int i=0;i<p_Np;++i){
              if(i+io<p_cubNp){ // differentiate this sub block
                const dfloat cDrWni = cubDrWT[n+(i+io)*p_Np];
                const dfloat cDsWni = cubDsWT[n+(i+io)*p_Np];
                
                occaUnroll(p_Nmt)
                  for(int em=0;em<p_Nmt;++em){  
                    const dfloat cF11 = s_cF11[em][es][i];
                    const dfloat cF12 = s_cF12[em][es][i];
                    const dfloat cF21 = s_cF21[em][es][i];
                    const dfloat cF22 = s_cF22[em][es][i];
                    
                    fluxU[em] += cDrWni*cF11;
                    fluxU[em] += cDsWni*cF12;
                    fluxV[em] += cDrWni*cF21;
                    fluxV[em] += cDsWni*cF22;
                  }
              }
            }
        }
      }
    }
    
    for(int es=0;es<p_NbV;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){          
        occaUnroll(p_Nmt)
          for(int em=0;em<p_Nmt;++em){
            const dlong e = eo+es*p_Nmt+em;
            if(e<Nelements){
              const dlong id = e*p_Np+n;
              rhsU[id]   = -fluxU[em]; // note  change in sign
              rhsV[id]   = -fluxV[em];      
            }
          }
      }
    }
  }
}

// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS4 8
#define p_NnodesS4 4
#endif

#if p_N==2
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 2
#define p_NnodesS4 3
#endif

#if p_N==5
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 4
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 5
#define p_NnodesS4 2
#endif

#if p_N==8
#define p_NblockS4 1
#define p_NnodesS4 4
#endif

#if p_N==9
#define p_NblockS4 3
#define p_NnodesS4 2
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 3
#endif



// Multiple nodes per thread// use less shared memory by factor 4 
kernel void insSubCycleCubatureSurfaceTri2D(const dlong Nelements,
                                            const dfloat * restrict sgeo,
                                            const dfloat * restrict intInterpT, // interpolate to integration nodes
                                            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
                                            const dlong  * restrict vmapM,
                                            const dlong  * restrict vmapP,
                                            const int    * restrict EToB,
                                            const dfloat bScale,
                                            const dfloat time,
                                            const dfloat * restrict intx, // integration nodes
                                            const dfloat * restrict inty,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict Ud,
                                            const dfloat * restrict Vd,
                                                  dfloat * restrict rhsU,
                                                  dfloat * restrict rhsV){
  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);outer0){

    // shared storage 
    shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse shared memory arrays
    #define s_iFluxV s_V

    exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

    exclusive dlong idM[p_NnodesS4], idP[p_NnodesS4];
    exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const dlong id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em]];
              s_V[em][es][n] = U[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iUP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em]];
              s_V[em][es][n] = Ud[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iUdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = V[idM[em]];
              s_V[em][es][n] = V[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iVM[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<(p_Nfaces*p_Nfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Vd[idM[em]];
              s_V[em][es][n] = Vd[idP[em]];              
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        if(n<(p_Nfaces*p_intNfp)){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          occaUnroll(p_Nfp)
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iVdM[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    barrier(localMemFence);

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
        occaUnroll(p_NnodesS4)
        for (int em=0;em<p_NnodesS4;++em){
          const dlong e = em*p_NblockS4 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // apply boundary conditions
            const int bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              insVelocityDirichletConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
              r_iUdP[em] *= bScale;
              r_iVdP[em] *= bScale;
            }

            // Find max normal velocity on the face
            const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                     +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                                    + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) +unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS4;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
        if(n<p_Np){
          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              r_iUM[em] = rhsU[id];
              r_iVM[em] = rhsV[id];
            }
          }

          occaUnroll(p_intNfpNfaces)
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            occaUnroll(p_NnodesS4)
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          occaUnroll(p_NnodesS4)
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id] = r_iUM[em];
              rhsV[id] = r_iVM[em];
            }
          }
        }
      }
    }
  }
}
#undef s_iFluxU
#undef s_iFluxV  






//reference versions
#if 0
// compute div(NU)  = div(uxu) in collocation way
kernel void insSubCycleCubatureVolume2D_v0(const int Nelements,
          const dfloat * restrict vgeo,
          const dfloat * restrict cubDrWT,
          const dfloat * restrict cubDsWT,
          const dfloat * restrict cubInterpT,
          const dfloat * restrict U,
          const dfloat * restrict V,
          const dfloat * restrict Ud,
          const dfloat * restrict Vd,
          dfloat * restrict rhsU,
          dfloat * restrict rhsV){

  for(int eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_cubNblockV][p_Np];
    shared dfloat s_V[p_cubNblockV][p_Np];
    shared dfloat s_Ud[p_cubNblockV][p_Np];
    shared dfloat s_Vd[p_cubNblockV][p_Np];

    shared dfloat s_cF11[p_cubNblockV][p_cubNp];
    shared dfloat s_cF12[p_cubNblockV][p_cubNp];
    shared dfloat s_cF21[p_cubNblockV][p_cubNp];
    shared dfloat s_cF22[p_cubNblockV][p_cubNp];
    //
    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
        int e = eo+es; // element in block
        if(e<Nelements && n<p_Np){ 
          const int id = e*p_Np+n;
          s_U[es][n]  = U[id];
          s_V[es][n]  = V[id];
          s_Ud[es][n] = Ud[id];
          s_Vd[es][n] = Vd[id];

  }   
      }
    }

    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
  int e = eo+es; // element in block
  if(e<Nelements && n<p_cubNp){

    dfloat cU = 0.f,  cV = 0.f;
    dfloat cUd = 0.f, cVd = 0.f;

    occaUnroll(p_Np)
      for(int i=0;i<p_Np;++i){
        dfloat cIni = cubInterpT[n+i*p_cubNp];
        cU  += cIni*s_U[es][i];
        cV  += cIni*s_V[es][i];
        cUd += cIni*s_Ud[es][i];
        cVd += cIni*s_Vd[es][i];        
      }
    //
    s_cF11[es][n] = cU*cUd;
    s_cF12[es][n] = cV*cUd;
    s_cF21[es][n] = cU*cVd;
    s_cF22[es][n] = cV*cVd;
  }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_cubNblockV;++es;inner1){
      for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     
  int e = eo+es;

  if(e<Nelements && n<p_Np){    
    // prefetch geometric factors (constant on triangle)
    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
    // compute 'r' and 's' derivatives of (q_m) at node n
    dfloat df11dr = 0.f, df11ds = 0.f; 
    dfloat df12dr = 0.f, df12ds = 0.f; 
    dfloat df21dr = 0.f, df21ds = 0.f; 
    dfloat df22dr = 0.f, df22ds = 0.f; 

    occaUnroll(p_cubNp)
      for(int i=0;i<p_cubNp;++i){
        const dfloat cDrWni = cubDrWT[n+i*p_Np];
        const dfloat cDsWni = cubDsWT[n+i*p_Np];
        // Fetch to shared, used twice
        const dfloat cF11 = s_cF11[es][i];
        const dfloat cF12 = s_cF12[es][i];
        const dfloat cF21 = s_cF21[es][i];
        const dfloat cF22 = s_cF22[es][i];

        df11dr += cDrWni*cF11;
        df11ds += cDsWni*cF11;

        df12dr += cDrWni*cF12;
        df12ds += cDsWni*cF12;

        df21dr += cDrWni*cF21;
        df21ds += cDsWni*cF21;

        df22dr += cDrWni*cF22;
        df22ds += cDsWni*cF22;
      }

    const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
    const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

    const int id = e*p_Np+n;

    rhsU[id]   = -rhsu; // note  change in sign
    rhsV[id]   = -rhsv;     
  }
      }
    }

  }

}


kernel void insSubCycleCubatureSurface2D_v0(const int Nelements,
           const dfloat * restrict sgeo,
           const dfloat * restrict intInterpT, // interpolate to integration nodes
           const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
           const int   * restrict vmapM,
           const int   * restrict vmapP,
           const int   * restrict EToB,
           const dfloat time,
           const dfloat * restrict intx, // integration nodes
           const dfloat * restrict inty,
           const dfloat * restrict U,
           const dfloat * restrict V,
           const dfloat * restrict Ud,
           const dfloat * restrict Vd,
           dfloat * restrict rhsU,
           dfloat * restrict rhsV){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

  int e = eo + es;

  if(e<Nelements){
    if(n<(p_Nfaces*p_Nfp)){
      // indices of negative and positive traces of face node
      const int id  = e*p_Nfp*p_Nfaces + n;

      int idM = vmapM[id];
      int idP = vmapP[id];

      if(idP<0) idP = idM;
      // load negative and positive trace node values of velocity
      s_UM[es][n] = U[idM];
      s_VM[es][n] = V[idM];
      s_UP[es][n] = U[idP];
      s_VP[es][n] = V[idP];

      s_UdM[es][n] = Ud[idM];
      s_VdM[es][n] = Vd[idM];
      s_UdP[es][n] = Ud[idP];
      s_VdP[es][n] = Vd[idP];

    }
  }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

  int e = eo + es;

  if(e<Nelements){
    if(n<(p_Nfaces*p_intNfp)){

      const int face = n/p_intNfp; // find face that owns this integration node

      // load surface geofactors for this face
      const int sid    = p_Nsgeo*(e*p_Nfaces+face);
      const dfloat nx   = sgeo[sid+p_NXID];
      const dfloat ny   = sgeo[sid+p_NYID];
      const dfloat sJ   = sgeo[sid+p_SJID];
      const dfloat invJ = sgeo[sid+p_IJID];

      dfloat iUM  = 0.f, iVM  = 0.f;
      dfloat iUP  = 0.f, iVP  = 0.f;
      dfloat iUdM = 0.f, iVdM = 0.f;
      dfloat iUdP = 0.f, iVdP = 0.f;

      // local block interpolation (face nodes to integration nodes)
      occaUnroll(p_Nfp)
        for(int m=0;m<p_Nfp;++m){
    const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
    const int fm = face*p_Nfp+m;

    iUM  += iInm*s_UM[es][fm];
    iVM  += iInm*s_VM[es][fm];
    iUdM += iInm*s_UdM[es][fm];
    iVdM += iInm*s_VdM[es][fm];

    iUP  += iInm*s_UP[es][fm];
    iVP  += iInm*s_VP[es][fm];
    iUdP += iInm*s_UdP[es][fm];
    iVdP += iInm*s_VdP[es][fm];
        }

      // apply boundary conditions
      int bc = EToB[face+p_Nfaces*e];

      if(bc>0){
        insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
      }


      // Find max normal velocity on the face
      dfloat unm   = occaFabs(nx*iUM + ny*iVM);
      dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
      dfloat unmax = (unm > unp) ? unm : unp;

      // evaluate "flux" terms: LLF
      const dfloat sc = invJ * sJ ;

      s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
               +ny*(iVP*iUdP + iVM*iUdM) 
               +unmax*(iUdM-iUdP) ));

      s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
               + ny*(iVP*iVdP + iVM*iVdM) 
               + unmax*(iVdM-iVdP) ));
    }
  }
      }
    }

    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;inner1){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

        const int e = eo + es;

        if(e<Nelements){
          if(n<p_Np){
            int id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = rhsU[id];
            dfloat rhsv = rhsV[id];

            occaUnroll(p_intNfpNfaces)
        for(int m=0;m<p_intNfpNfaces;++m){
    // RefMassMatrix^{-1}*cInterp^t*cWeight
    const dfloat L = intLIFTT[n+m*p_Np];

    rhsu += L*s_iFluxU[es][m];
    rhsv += L*s_iFluxV[es][m];
        }

            rhsU[id] = rhsu;  // 
            rhsV[id] = rhsv;  //  
          }
        }
      }
    }
  }

}
#endif


// #define p_NblockS5 5
// #define p_NnodesS5 3

// // Based on 4; Add multiple nodes // use all shared memory

// kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat2 * restrict UM,
//               const dfloat2 * restrict UP,
//               const dfloat2 * restrict UdM,
//               const dfloat2 * restrict UdP,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_NblockS5*p_NnodesS5);outer0){

//     // shared storage 
//     shared dfloat s_U[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
//     shared dfloat s_V[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    
//     shared dfloat s_Ud[p_NnodesS5][p_NblockS5][p_NfacesNfp];
//     shared dfloat s_Vd[p_NnodesS5][p_NblockS5][p_NfacesNfp];

//     #define s_iFluxU s_U // Reuse shared memory arrays
//     #define s_iFluxV s_V

//     exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
//     exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
//     exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
//     exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];
    
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS5;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_NnodesS5)
//      for(int em=0;em<p_NnodesS5;++em){ 
                
//       const int e   = eo + es*p_NnodesS5 + em; 
//       const int id  = e*p_NfacesNfp + n;

//       if(e<Nelements && n<p_NfacesNfp ){
//         //int idM = vmapM[id];
//         // //load negative and positive trace node values of velocity
//         // s_U[em][es][n]  = U[idM];
//         // s_V[em][es][n]  = V[idM];
//         // s_Ud[em][es][n] = Ud[idM];
//         // s_Vd[em][es][n] = Vd[idM];
//         dfloat2 um  = UM[id];
//         dfloat2 udm = UdM[id];

//         s_U[em][es][n]  = um.x;
//         s_V[em][es][n]  = um.y;
//         s_Ud[em][es][n] = udm.x;
//         s_Vd[em][es][n] = udm.y;


//         }        
//      }
//     }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS5;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//            const int face = n/p_intNfp;       
//             occaUnroll(p_NnodesS5)
//             for(int em=0;em<p_NnodesS5;++em){
//               r_iUM [em] = 0.f;  
//               r_iVM [em] = 0.f;  
//               r_iUdM[em] = 0.f; 
//               r_iVdM[em] = 0.f;                 
//             }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//           for(int m=0;m<p_Nfp;++m){
//             const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//             //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//             const int fm = face*p_Nfp + m;
//             occaUnroll(p_NnodesS5)
//               for(int em=0;em<p_NnodesS5;++em){
//               r_iUM [em] += iInm*s_U[em][es][fm];
//               r_iVM [em] += iInm*s_V[em][es][fm];
//               r_iUdM[em] += iInm*s_Ud[em][es][fm];
//               r_iVdM[em] += iInm*s_Vd[em][es][fm];
//             }
//           }
//         }
//       }
//     }
    
       
//     barrier(localMemFence);

//      // for all face nodes of all elements
//     for(int es=0;es<p_NblockS4;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//       occaUnroll(p_NnodesS4)
//       for(int em=0;em<p_NnodesS4;++em){           
//        const int e   = eo + es*p_NnodesS4 + em; 
//        const int id  = e*p_NfacesNfp + n;
//       if(e<Nelements && n<p_NfacesNfp ){       
//         s_U[em][es][n]  = 0.f;
//         s_V[em][es][n]  = 0.f;
//         s_Ud[em][es][n] = 0.f;
//         s_Vd[em][es][n] = 0.f;
//         }        
//      }
//     }
//     }

//     barrier(localMemFence);


//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//            const int face = n/p_intNfp;       
//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               r_iUP [em] = 0.f;  
//               r_iVP [em] = 0.f;  
//               r_iUdP[em] = 0.f; 
//               r_iVdP[em] = 0.f;              
//             }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//           for(int m=0;m<p_Nfp;++m){
//             const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//             //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//             const int fm = face*p_Nfp + m;
//             occaUnroll(p_NnodesS3)
//               for(int em=0;em<p_NnodesS3;++em){
//               r_iUP [em] += iInm*s_U[em][es][fm];
//               r_iVP [em] += iInm*s_V[em][es][fm];
//               r_iUdP[em] += iInm*s_Ud[em][es][fm];
//               r_iVdP[em] += iInm*s_Vd[em][es][fm];
//             }
//           }
//         }
//       }
//     }
    
//      barrier(localMemFence);


//      // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS5;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//           const int face = n/p_intNfp;       
//           occaUnroll(p_NnodesS5)
//           for(int em=0;em<p_NnodesS5;++em){
//             const int e   = eo + es*p_NnodesS5 + em; 

//             // load surface geofactors for this face
//             const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//             const dfloat nx   = sgeo[sid+p_NXID];
//             const dfloat ny   = sgeo[sid+p_NYID];
//             const dfloat sJ   = sgeo[sid+p_SJID];
//             const dfloat invJ = sgeo[sid+p_IJID];
       
//             const int bc = EToB[face+p_Nfaces*e];
//             // if(bc>0){
//             //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
//             // }

//             const dfloat sc = sJ*invJ; 
//             //Find max normal velocity on the face
//             const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
//             const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
//                    +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
//                    +unmax*(r_iUdM[em]- r_iUdP[em]) ));

//             s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
//                    +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
//                    +unmax*(r_iVdM[em]-r_iVdP[em]) ));
//            }
//         }
//       }
//     }

//     barrier(localMemeFence);
//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS5;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         dfloat rhsu[p_NnodesS5], rhsv[p_NnodesS5];

//         if(n<p_Np){
//           occaUnroll(p_NnodesS5)
//          for(int em=0;em<p_NnodesS5;++em){
//           rhsu[em] = 0.f;
//           rhsv[em] = 0.f;
//           }
//         //
//           occaUnroll(p_intNfpNfaces)
//           for(int m=0;m<p_intNfpNfaces;++m){
//             const dfloat L = intLIFTT[n+m*p_Np];
//             occaUnroll(p_NnodesS5)
//             for(int em=0;em<p_NnodesS5;++em){
//               rhsu[em] += L*s_iFluxU[em][es][m];
//               rhsv[em] += L*s_iFluxV[em][es][m];
//            }
//          }

//         occaUnroll(p_NnodesS5)
//        for(int em=0;em<p_NnodesS5;++em){
//         int e = eo+es*p_NnodesS5+em;
//           if(e<Nelements){
//             const int id = e*p_Np+n;
//             rhsU[id]   += rhsu[em]; // note  change in sign
//             rhsV[id]   += rhsv[em];    

//            }
//         }
//         }
//       }
//     }
//   #undef s_iFluxU
//   #undef s_iFluxV   

//   }

// }






// // Add multiple nodes; shared memory for interpolation matrix

// kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat * restrict U,
//               const dfloat * restrict V,
//               const dfloat * restrict Ud,
//               const dfloat * restrict Vd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_NblockS3*p_NnodesS3);outer0){

//     // shared storage 
//     shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
//     shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    
//     shared dfloat s_Ud[p_NnodesS3][p_NblockS3][p_NfacesNfp];
//     shared dfloat s_Vd[p_NnodesS3][p_NblockS3][p_NfacesNfp];

//     #define s_iFluxU s_U // Reuse shared memory arrays
//     #define s_iFluxV s_V

//     exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
//     exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
//     exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
//     exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];


//     shared dfloat s_sgeo[p_NnodesS3][p_NblockS3][p_Nfaces][p_Nsgeo];
//     shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_NnodesS3)
//      for(int em=0;em<p_NnodesS3;++em){ 
                
//       const int e   = eo + es*p_NnodesS3 + em; 
//       const int id  = e*p_NfacesNfp + n;

//        if(e<Nelements && n<p_Np ){
//           int m = n + p_Np*es;
//           // oad surface geofacs for all faces of all elements in block(s)
//           while(m<p_NblockS3*p_Nfaces*p_Nsgeo*p_NnodesS3){
//             const int id = eo*p_Nfaces*p_Nsgeo+ m;
//              s_sgeo[0][0][0][m] = sgeo[id];
//              m+=p_Np*p_NblockS3;
//          }
     
//           if (es==0 && em==0) {
//             for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
//             s_intInterpT[m] = intInterpT[m];
//             }
//           }



//         }

//       if(e<Nelements && n<p_NfacesNfp ){
//         int idM = vmapM[id];
//         // //load negative and positive trace node values of velocity
//         s_U[em][es][n]  = U[idM];
//         s_V[em][es][n]  = V[idM];
//         s_Ud[em][es][n] = Ud[idM];
//         s_Vd[em][es][n] = Vd[idM];
//         }        
//      }
//     }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//            const int face = n/p_intNfp;       
//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               r_iUM [em] = 0.f;  
//               r_iVM [em] = 0.f;  
//               r_iUdM[em] = 0.f; 
//               r_iVdM[em] = 0.f;              
//             }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//           for(int m=0;m<p_Nfp;++m){
//             const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//             const int fm = face*p_Nfp + m;
//             occaUnroll(p_NnodesS3)
//               for(int em=0;em<p_NnodesS3;++em){
//               r_iUM [em] += iInm*s_U[em][es][fm];
//               r_iVM [em] += iInm*s_V[em][es][fm];
//               r_iUdM[em] += iInm*s_Ud[em][es][fm];
//               r_iVdM[em] += iInm*s_Vd[em][es][fm];
//             }
//           }
//         }
//       }
//     }
    
//     barrier(localMemFence);



//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//       occaUnroll(p_NnodesS3)
//       for(int em=0;em<p_NnodesS3;++em){           
//        const int e   = eo + es*p_NnodesS3 + em; 
//        const int id  = e*p_NfacesNfp + n;
//       if(e<Nelements && n<p_NfacesNfp ){
//         int idP = vmapP[id];
//         // //load negative and positive trace node values of velocity
//         s_U[em][es][n]  = U[idP];
//         s_V[em][es][n]  = V[idP];
//         s_Ud[em][es][n] = Ud[idP];
//         s_Vd[em][es][n] = Vd[idP];
//         }        
//      }
//     }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//            const int face = n/p_intNfp;       
//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               r_iUP [em] = 0.f;  
//               r_iVP [em] = 0.f;  
//               r_iUdP[em] = 0.f; 
//               r_iVdP[em] = 0.f;              
//             }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//           for(int m=0;m<p_Nfp;++m){
//             const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//             const int fm = face*p_Nfp + m;
//             occaUnroll(p_NnodesS3)
//               for(int em=0;em<p_NnodesS3;++em){
//               r_iUP [em] += iInm*s_U[em][es][fm];
//               r_iVP [em] += iInm*s_V[em][es][fm];
//               r_iUdP[em] += iInm*s_Ud[em][es][fm];
//               r_iVdP[em] += iInm*s_Vd[em][es][fm];
//             }
//           }
//         }
//       }
//     }
    
//     barrier(localMemFence);


//      // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){
//           const int face = n/p_intNfp;       
//           occaUnroll(p_NnodesS3)
//           for(int em=0;em<p_NnodesS3;++em){
//             const int e   = eo + es*p_NnodesS3 + em; 
//             const dfloat nx   = s_sgeo[em][es][face][p_NXID];
//             const dfloat ny   = s_sgeo[em][es][face][p_NYID];
//             const dfloat sj   = s_sgeo[em][es][face][p_SJID];
//             const dfloat ij   = s_sgeo[em][es][face][p_IJID];
        
//             const int bc = EToB[face+p_Nfaces*e];
//             // if(bc>0){
//             //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
//             // }

//             const dfloat sc = sj*ij; 
//             //Find max normal velocity on the face
//             const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
//             const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             s_iFluxU[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
//                    +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
//                    +unmax*(r_iUdM[em]- r_iUdP[em]) ));

//             s_iFluxV[em][es][n] = sc*(.5f*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
//                    +ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
//                    +unmax*(r_iVdM[em]-r_iVdP[em]) ));
//            }
//         }
//       }
//     }

//     barrier(localMemeFence);
//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         dfloat rhsu[p_NnodesS3], rhsv[p_NnodesS3];

//         if(n<p_Np){
//           occaUnroll(p_NnodesS3)
//          for(int em=0;em<p_NnodesS3;++em){
//           rhsu[em] = 0.f;
//           rhsv[em] = 0.f;
//           }
//         //
//           occaUnroll(p_intNfpNfaces)
//           for(int m=0;m<p_intNfpNfaces;++m){
//             const dfloat L = intLIFTT[n+m*p_Np];
//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               rhsu[em] += L*s_iFluxU[em][es][m];
//               rhsv[em] += L*s_iFluxV[em][es][m];
//            }
//          }

//         occaUnroll(p_NnodesS3)
//        for(int em=0;em<p_NnodesS3;++em){
//         int e = eo+es*p_NnodesS3+em;
//           if(e<Nelements){
//             const int id = e*p_Np+n;
//             rhsU[id]   += rhsu[em]; // note  change in sign
//             rhsV[id]   += rhsv[em];    

//            }
//         }
//         }
//       }
//     }
//   #undef s_iFluxU
//   #undef s_iFluxV   

//   }

// }











// // add multiple nodes per thread
// kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
//                                             const dfloat * restrict sgeo,
//                                             const dfloat * restrict intInterpT, // interpolate to integration nodes
//                                             const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//                                             const int   * restrict vmapM,
//                                             const int   * restrict vmapP,
//                                             const int   * restrict EToB,
//                                             const dfloat time,
//                                             const dfloat * restrict intx, // integration nodes
//                                             const dfloat * restrict inty,
//                                             const dfloat * restrict U,
//                                             const dfloat * restrict V,
//                                             const dfloat * restrict Ud,
//                                             const dfloat * restrict Vd,
//                                             dfloat * restrict rhsU,
//                                             dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_NblockS3;outer0){

//     // shared storage for flux terms
//     shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
//     shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
//     shared dfloat s_Ud[p_NnodesS3][p_NblockS3][p_NfacesNfp];
//     shared dfloat s_Vd[p_NnodesS3][p_NblockS3][p_NfacesNfp];

//     shared dfloat s_sgeo[p_NnodesS3][p_NblockS3][p_Nfaces][p_Nsgeo];
//     //shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];

//    #define s_iFluxU s_U // Reuse shemem array
//    #define s_iFluxV s_V
  
//     exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
//     exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
//     exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
//     exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];

//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         occaUnroll(p_NnodesS3)
//         for(int em=0;em<p_NnodesS3;++em){ 
//             const int e   = eo + es*p_NnodesS3 + em;        
//             if(e<Nelements){

//               if(n<p_Np ){
//                 int m = n + p_Np*es;
//               // oad surface geofacs for all faces of all elements in block(s)
//                 while(m<p_NblockS3*p_Nfaces*p_Nsgeo*p_NnodesS3){
//                   const int id = eo*p_Nfaces*p_Nsgeo+ m;
//                   s_sgeo[0][0][0][m] = sgeo[id];
//                   m+=p_Np*p_NblockS3;
//                }
//                //  if (es==0 && em==0) {
//                //    for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
//                //      s_intInterpT[m] = intInterpT[m];
//                //    }
//                // }
//               }

      
//             if(n<(p_Nfaces*p_Nfp)){
//               // indices of negative and positive traces of face node
//               const int id  = e*p_Nfp*p_Nfaces + n;
//               const int idM = vmapM[id];

//               // load negative and positive trace node values of velocity
//               s_U[em][es][n] = U[idM];
//               s_V[em][es][n] = V[idM];
//               s_Ud[em][es][n] = Ud[idM];
//               s_Vd[em][es][n] = Vd[idM];
//             }
//             else{
//                // load negative and positive trace node values of velocity
//               s_U[em][es][n]  = 0.f;
//               s_V[em][es][n]  = 0.f;
//               s_Ud[em][es][n] = 0.f;
//               s_Vd[em][es][n] = 0.f;
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//           if(n<(p_Nfaces*p_intNfp)){
//             const int face = n/p_intNfp; // find face that owns this integration node
            
//             occaUnroll(p_NblockS3)
//               for(int em=0;em<p_NnodesS3;++em){
//                 r_iUM [em] = 0.f;
//                 r_iVM [em] = 0.f;
//                 r_iUdM[em] = 0.f; 
//                 r_iVdM[em] = 0.f;       
//               }
//             // local block interpolation (face nodes to integration nodes)
//             occaUnroll(p_Nfp)
//               for(int m=0;m<p_Nfp;++m){
//                 //const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+m;
//                  for(int em=0; em<p_NnodesS3; ++em){
//                   r_iUM[em]  += iInm*s_U[em][es][fm];
//                   r_iVM[em]  += iInm*s_V[em][es][fm];
//                   r_iUdM[em] += iInm*s_Ud[em][es][fm];
//                   r_iVdM[em] += iInm*s_Vd[em][es][fm];
//                  }
//               }
//           }
//       }
//     }


//     barrier(localMemFence);

//     Loop for positive traces 
//     // for all face nodes of all elements
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         for(int em=0;em<p_NnodesS3;++em){ 
//           const int e   = eo + es*p_NnodesS3 + em; 
//            if(e<Nelements){
//             if(n<(p_Nfaces*p_Nfp)){
//               // indices of negative and positive traces of face node
//               const int id  = e*p_Nfp*p_Nfaces + n;
//               const int idP = vmapP[id];
//               // load negative and positive trace node values of velocity
//               s_U[em][es][n] = U[idP];
//               s_V[em][es][n] = V[idP];
//               s_Ud[em][es][n] = Ud[idP];
//               s_Vd[em][es][n] = Vd[idP];
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

   
//     // interpolate to surface integration nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//           if(n<(p_Nfaces*p_intNfp)){
//           const int face = n/p_intNfp; // find face that owns this integration node
//           occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               r_iUP [em] = 0.f;
//               r_iVP [em] = 0.f;
//               r_iUdP[em] = 0.f; 
//               r_iVdP[em] = 0.f;
             
//             }
//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//             for(int m=0;m<p_Nfp;++m){
//               // const dfloat iInm = s_intInterpT[n+m*p_Nfaces*p_intNfp];
//               const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//               const int fm = face*p_Nfp+m;
//                for(int em=0; em<p_NnodesS3; ++em){
//                 r_iUP[em]  += iInm*s_U[em][es][fm];
//                 r_iVP[em]  += iInm*s_V[em][es][fm];
//                 r_iUdP[em] += iInm*s_Ud[em][es][fm];
//                 r_iVdP[em] += iInm*s_Vd[em][es][fm];
//                }
//             }
//         }
//       }
//     }
//     barrier(localMemFence);

//     // Use traces to compuite and store flux 
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//          occaUnroll(p_NnodesS3)
//           for(int em=0;em<p_NnodesS3;++em){
//              const int e   = eo + es*p_NnodesS3 + em; 
//              if(n<(p_Nfaces*p_intNfp)){

//               const int face = n/p_intNfp; // find face that owns this integration node
//               // load surface geofactors for this face
//               const dfloat nx   = s_sgeo[em][es][face][p_NXID];
//               const dfloat ny   = s_sgeo[em][es][face][p_NYID];
//               const dfloat sJ   = s_sgeo[em][es][face][p_SJID];
//               const dfloat invJ = s_sgeo[em][es][face][p_IJID];
            
//             // apply boundary conditions
//             const int bc = EToB[face+p_Nfaces*e];
//             // if(bc>0){
//             //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM,r_iVdM, &r_iUdP[em], &r_iVdP[em]);
//             // }

//             // Find max normal velocity on the face
//             const dfloat unm   = occaFabs(nx*r_iUM[em] + ny*r_iVM[em]);
//             const dfloat unp   = occaFabs(nx*r_iUP[em] + ny*r_iVP[em]);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = 0.5f*invJ*sJ ;

//             // bad notation here //
//             s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
//                                      +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
//                                     +unmax*(r_iUdM[em]-r_iUdP[em]));

//             s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
//                             + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
//                             + unmax*(r_iVdM[em]-r_iVdP[em]));
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS3;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         dfloat rhsu[p_NnodesS3], rhsv[p_NnodesS3];
//           if(n<p_Np){
//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               const int e   = eo + es*p_NnodesS3 + em; 
//               const int id = e*p_Np+n;
//               rhsu[em] = rhsU[id];
//               rhsv[em] = rhsV[id];
//               // rhsu[em] = 0.f;
//               // rhsv[em] = 0.f;
//             }

//             occaUnroll(p_intNfpNfaces)
//             for(int m=0;m<p_intNfpNfaces;++m){
//               const dfloat L = intLIFTT[n+m*p_Np];
//               occaUnroll(p_NnodesS3)
//               for(int em=0;em<p_NnodesS3;++em){
//                 rhsu[em] += L*s_iFluxU[em][es][m];
//                 rhsv[em] += L*s_iFluxV[em][es][m];
//               }
//             }

//             occaUnroll(p_NnodesS3)
//             for(int em=0;em<p_NnodesS3;++em){
//               const int e = eo+es*p_NnodesS3 +em;
//               if(e<Nelements){
//                 int id = e*p_Np+n;
//                 rhsU[id]   = rhsu[em]; // note  change in sign
//                 rhsV[id]   = rhsv[em];
//                 // rhsU[id]   += rhsu[em]; // note  change in sign
//                 // rhsV[id]   += rhsv[em];
//                } 
//              } 
//            }
           
//          }
//        }  
//   #undef s_iFluxU
//   #undef s_iFluxV   
//   }
// }























// // same with Kernel 3 with shared memory for Geo
// kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat * restrict U,
//               const dfloat * restrict V,
//               const dfloat * restrict Ud,
//               const dfloat * restrict Vd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

//     shared dfloat s_sgeo[p_cubNblockS][p_Nfaces][p_Nsgeo];
//     //shared dfloat s_bc[p_cubNblockS][p_Nfaces];

//     // for all face nodes of all elements
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//   int e = eo + es;

//   if(e<Nelements){

//       if(n<p_Np ){
//           int m = n + p_Np*es;
//           // oad surface geofacs for all faces of all elements in block(s)
//           while(m<p_cubNblockS*p_Nfaces*p_Nsgeo){
//             const int id = eo*p_Nfaces*p_Nsgeo+ m;
//             s_sgeo[0][0][m] = sgeo[id];
//             m+=p_Np*p_cubNblockS;
//          }
//         }

//     if(n<(p_Nfaces*p_Nfp)){
//       // indices of negative and positive traces of face node
//       const int id  = e*p_Nfp*p_Nfaces + n;

//       int idM = vmapM[id];
//       int idP = vmapP[id];

//       if(idP<0) idP = idM;
//       // load negative and positive trace node values of velocity
//       s_UM[es][n] = U[idM];
//       s_VM[es][n] = V[idM];
//       s_UP[es][n] = U[idP];
//       s_VP[es][n] = V[idP];

//       s_UdM[es][n] = Ud[idM];
//       s_VdM[es][n] = Vd[idM];
//       s_UdP[es][n] = Ud[idP];
//       s_VdP[es][n] = Vd[idP];

//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

//   int e = eo + es;

//   if(e<Nelements){
//     if(n<(p_Nfaces*p_intNfp)){

//       const int face = n/p_intNfp; // find face that owns this integration node

//       // load surface geofactors for this face
//       //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//        const dfloat nx   = s_sgeo[es][face][p_NXID];
//        const dfloat ny   = s_sgeo[es][face][p_NYID];
//        const dfloat sJ   = s_sgeo[es][face][p_SJID];
//        const dfloat invJ = s_sgeo[es][face][p_IJID];
      
//       dfloat iUM  = 0.f, iVM  = 0.f;
//       dfloat iUP  = 0.f, iVP  = 0.f;
//       dfloat iUdM = 0.f, iVdM = 0.f;
//       dfloat iUdP = 0.f, iVdP = 0.f;

//       // local block interpolation (face nodes to integration nodes)
//       occaUnroll(p_Nfp)
//         for(int m=0;m<p_Nfp;++m){
//     const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//     const int fm = face*p_Nfp+m;

//     iUM  += iInm*s_UM[es][fm];
//     iVM  += iInm*s_VM[es][fm];
//     iUdM += iInm*s_UdM[es][fm];
//     iVdM += iInm*s_VdM[es][fm];

//     iUP  += iInm*s_UP[es][fm];
//     iVP  += iInm*s_VP[es][fm];
//     iUdP += iInm*s_UdP[es][fm];
//     iVdP += iInm*s_VdP[es][fm];
//         }

//       // apply boundary conditions
//       int bc = EToB[face+p_Nfaces*e];

//       if(bc>0){
//         insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//       }


//       // Find max normal velocity on the face
//       dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//       dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//       dfloat unmax = (unm > unp) ? unm : unp;

//       // evaluate "flux" terms: LLF
//       const dfloat sc = invJ * sJ ;

//       s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
//                +ny*(iVP*iUdP + iVM*iUdM) 
//                +unmax*(iUdM-iUdP) ));

//       s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
//                + ny*(iVP*iVdP + iVM*iVdM) 
//                + unmax*(iVdM-iVdP) ));
//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         const int e = eo + es;

//         if(e<Nelements){
//           if(n<p_Np){
//             int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             occaUnroll(p_intNfpNfaces)
//         for(int m=0;m<p_intNfpNfaces;++m){
//     // RefMassMatrix^{-1}*cInterp^t*cWeight
//     const dfloat L = intLIFTT[n+m*p_Np];

//     rhsu += L*s_iFluxU[es][m];
//     rhsv += L*s_iFluxV[es][m];
//         }

//             rhsU[id] = rhsu;  // 
//             rhsV[id] = rhsv;  //  
//           }
//         }
//       }
//     }
//   }

// }



//  // // Optimized sizes for kernel 4-5
// #if p_N==1
//  #define p_cNbS 10
//  #define p_cNmtS 2
//  #endif

// #if p_N==2
// #define p_cNbS 8
// #define p_cNmtS 1
// #endif

// #if p_N==3
// #define p_cNbS 2
// #define p_cNmtS 2
// #endif

// #if p_N==4
// #define p_cNbS 3
// #define p_cNmtS 2
// #endif

// #if p_N==5
// #define p_cNbS 2
// #define p_cNmtS 2
// #endif

// #if p_N==6
// #define p_cNbS 2
// #define p_cNmtS 2
// #endif

// #if p_N==7
// #define p_cNbS 3
// #define p_cNmtS 2
// #endif

// #if p_N==8
// #define p_cNbS 4
// #define p_cNmtS 2
// #endif

// #if p_N==9
// #define p_cNbS 1
// #define p_cNmtS 3
// #endif

// #if p_N==10
// #define p_cNbS 2
// #define p_cNmtS 2
// #endif


// // Add multiple nodes to kernel 4

// kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat * restrict U,
//               const dfloat * restrict V,
//               const dfloat * restrict Ud,
//               const dfloat * restrict Vd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_cNbS*p_cNmtS);outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS][p_cNbS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS][p_cNbS][p_intNfpNfaces];


//     shared dfloat s_sgeo[p_cNmtS][p_cNbS][p_Nfaces][p_Nsgeo];
//     shared dfloat s_bc[p_cNmtS][p_cNbS][p_Nfaces];
       
//     // for all face nodes of all elements
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_cNmtS)
//      for(int em=0;em<p_cNmtS;++em){ 
                
//       const int e   = eo + es*p_cNmtS + em; 
//       const int id  = e*p_NfacesNfp + n;

//        if(e<Nelements && n<p_Np ){
//           int m = n + p_Np*es;
//           // oad surface geofacs for all faces of all elements in block(s)
//           while(m<p_cNbS*p_Nfaces*p_Nsgeo*p_cNmtS){
//             const int id = eo*p_Nfaces*p_Nsgeo+ m;
//              s_sgeo[0][0][0][m] = sgeo[id];
//              m+=p_Np*p_cNbS;
//          }
//         }

//       if(e<Nelements && n<p_NfacesNfp ){
//         int idM = vmapM[id];
//         int idP = vmapP[id];

//         if(idP<0) idP = idM;

//         // //load negative and positive trace node values of velocity
//         s_UM[em][es][n] = U[idM];
//         s_VM[em][es][n] = V[idM];
//         s_UP[em][es][n] = U[idP];
//         s_VP[em][es][n] = V[idP];
       
//         s_UdM[em][es][n] = Ud[idM];
//         s_VdM[em][es][n] = Vd[idM];
//         s_UdP[em][es][n] = Ud[idP];
//         s_VdP[em][es][n] = Vd[idP];
//          }

        
//      }
//     }
//     }


//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){

//     dfloat cUM[p_cNmtS], cVM[p_cNmtS], cUdM[p_cNmtS], cVdM[p_cNmtS];
//     dfloat cUP[p_cNmtS], cVP[p_cNmtS], cUdP[p_cNmtS], cVdP[p_cNmtS];
//     const int face = n/p_intNfp;       
         
//           occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         cUM [em] = 0.f;
//         cVM [em] = 0.f;
//         cUdM[em] = 0.f; 
//         cVdM[em] = 0.f;
//         //
//         cUP [em] = 0.f;
//         cVP [em] = 0.f;
//         cUdP[em] = 0.f; 
//         cVdP[em] = 0.f;
//       }

//           // local block interpolation (face nodes to integration nodes)
//       occaUnroll(p_Nfp)
//       for(int m=0;m<p_Nfp;++m){
//         const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//         const int fm = face*p_Nfp + m;
//         occaUnroll(p_cNmtS)
//     for(int em=0;em<p_cNmtS;++em){

//       cUM [em] += iInm*s_UM[em][es][fm];
//       cVM [em] += iInm*s_VM[em][es][fm];
//       cUdM[em] += iInm*s_UdM[em][es][fm];
//       cVdM[em] += iInm*s_VdM[em][es][fm];

//       cUP[em]  += iInm*s_UP[em][es][fm];
//       cVP[em]  += iInm*s_VP[em][es][fm];
//       cUdP[em] += iInm*s_UdP[em][es][fm];
//       cVdP[em] += iInm*s_VdP[em][es][fm];
//     }
//       }

//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         //const int e = eo + es*p_cNmtS + em;
//         //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//         const dfloat nx   = s_sgeo[em][es][face][p_NXID];
//         const dfloat ny   = s_sgeo[em][es][face][p_NYID];
//         const dfloat sj   = s_sgeo[em][es][face][p_SJID];
//         const dfloat ij   = s_sgeo[em][es][face][p_IJID];
        
//         //const int   bc   = EToB[face+p_Nfaces*e];
        
        
//         const dfloat sc = sj*ij; 
//         //Find max normal velocity on the face
//         const dfloat unm   = occaFabs(nx*cUM[em] + ny*cVM[em]);
//         const dfloat unp   = occaFabs(nx*cUP[em] + ny*cVP[em]);    
//         const dfloat unmax = (unm > unp) ? unm : unp;

//         s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
//                +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
//                +unmax*(cUdM[em]- cUdP[em]) ));

//         s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
//                +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
//                +unmax*(cVdM[em]-cVdP[em]) ));



//       }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//   dfloat rhsu[p_cNmtS], rhsv[p_cNmtS];

//         if(n<p_Np){
//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         rhsu[em] = 0.f;
//         rhsv[em] = 0.f;
//       }
//     //
//     occaUnroll(p_intNfpNfaces)
//       for(int m=0;m<p_intNfpNfaces;++m){
//         const dfloat L = intLIFTT[n+m*p_Np];
//         occaUnroll(p_cNmtS)
//     for(int em=0;em<p_cNmtS;++em){
//       rhsu[em] += L*s_iFluxU[em][es][m];
//       rhsv[em] += L*s_iFluxV[em][es][m];
//     }
//       }

//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         int e = eo+es*p_cNmtS+em;
//         if(e<Nelements){
//     const int id = e*p_Np+n;
//     rhsU[id]   += rhsu[em]; // note  change in sign
//     rhsV[id]   += rhsv[em];    

//         }
//       }
//   }
//       }
//     }
      

//   }

// }



//  // // Optimized sizes for kernel 4-5
// #if p_N==1
//  #define p_cNbS1 10
//  #define p_cNmtS1 2
//  #endif

// #if p_N==2
// #define p_cNbS1 8
// #define p_cNmtS1 1
// #endif

// #if p_N==3
// #define p_cNbS1 2
// #define p_cNmtS1 2
// #endif

// #if p_N==4
// #define p_cNbS1 3
// #define p_cNmtS1 2
// #endif

// #if p_N==5
// #define p_cNbS1 2
// #define p_cNmtS1 2
// #endif

// #if p_N==6
// #define p_cNbS1 2
// #define p_cNmtS1 2
// #endif

// #if p_N==7
// #define p_cNbS1 3
// #define p_cNmtS1 2
// #endif

// #if p_N==8
// #define p_cNbS1 4
// #define p_cNmtS1 2
// #endif

// #if p_N==9
// #define p_cNbS1 1
// #define p_cNmtS1 3
// #endif

// #if p_N==10
// #define p_cNbS1 2
// #define p_cNmtS1 2
// #endif




// // add "restrict to p_Np thread"  to kernel 5
// kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
//                                             const dfloat * restrict sgeo,
//                                             const dfloat * restrict intInterpT, // interpolate to integration nodes
//                                             const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//                                             const int   * restrict vmapM,
//                                             const int   * restrict vmapP,
//                                             const int   * restrict EToB,
//                                             const dfloat time,
//                                             const dfloat * restrict intx, // integration nodes
//                                             const dfloat * restrict inty,
//                                             const dfloat * restrict U,
//                                             const dfloat * restrict V,
//                                             const dfloat * restrict Ud,
//                                             const dfloat * restrict Vd,
//                                             dfloat * restrict rhsU,
//                                             dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cNbS1*p_cNmtS1;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS1][p_cNbS1][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS1][p_cNbS1][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS1][p_cNbS1][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS1][p_cNbS1][p_intNfpNfaces];

//     shared dfloat s_sgeo[p_cNmtS1][p_cNbS1][p_Nfaces][p_Nsgeo];
    
//     for (int es=0;es<p_cNbS1;++es;inner1){
//       for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
//         int m = n + p_Np*es;
//         while(m<p_cNmtS1*p_cNbS1*p_Nfaces*p_Nsgeo){
//           const int id = eo*p_Nfaces*p_Nsgeo + m;
//           s_sgeo[0][0][0][m] = sgeo[id];
//           m+=p_Np*p_cNbS1;
//         }
        
//         occaUnroll(p_cNmtS1)
//         for (int et=0;et<p_cNmtS1;++et){
//           const int e = et*p_cNbS1 + es + eo;
//           if(e<Nelements){
//             for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
//               // indices of negative and positive traces of face node
//               const int id  = e*p_Nfp*p_Nfaces + m;

//               const int idM = vmapM[id];
//               const int idP = vmapP[id];

//               // load negative and positive trace node values of velocity
//               s_UM[et][es][m] = U[idM];
//               s_VM[et][es][m] = V[idM];
//               s_UP[et][es][m] = U[idP];
//               s_VP[et][es][m] = V[idP];

//               s_UdM[et][es][m] = Ud[idM];
//               s_VdM[et][es][m] = Vd[idM];
//               s_UdP[et][es][m] = Ud[idP];
//               s_VdP[et][es][m] = Vd[idP];
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS1;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){ 
        
//         dfloat iUM [p_cNmtS1], iVM [p_cNmtS1];
//         dfloat iUP [p_cNmtS1], iVP [p_cNmtS1];
//         dfloat iUdM[p_cNmtS1], iVdM[p_cNmtS1];
//         dfloat iUdP[p_cNmtS1], iVdP[p_cNmtS1];

//         for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

//           occaUnroll(p_cNmtS1)
//           for (int et=0;et<p_cNmtS1;++et){
//             iUM [et] = 0.f, iVM [et] = 0.f;
//             iUP [et] = 0.f, iVP [et] = 0.f;
//             iUdM[et] = 0.f, iVdM[et] = 0.f;
//             iUdP[et] = 0.f, iVdP[et] = 0.f;
//           }
      
//           const int face = m/p_intNfp; // find face that owns this integration node
//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//             for(int k=0;k<p_Nfp;++k){
//               const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
//               const int fm = face*p_Nfp+k;

//               occaUnroll(p_cNmtS1)
//               for (int et=0;et<p_cNmtS1;++et){

//                 iUM [et] += iInm* s_UM[et][es][fm];
//                 iVM [et] += iInm* s_VM[et][es][fm];
//                 iUdM[et] += iInm*s_UdM[et][es][fm];
//                 iVdM[et] += iInm*s_VdM[et][es][fm];

//                 iUP [et] += iInm* s_UP[et][es][fm];
//                 iVP [et] += iInm* s_VP[et][es][fm];
//                 iUdP[et] += iInm*s_UdP[et][es][fm];
//                 iVdP[et] += iInm*s_VdP[et][es][fm];
//               }
//             }

//           occaUnroll(p_cNmtS1)
//           for (int et=0;et<p_cNmtS1;++et){
//             const int e = et*p_cNbS1 + es + eo;
//             if (e<Nelements) {
//               // load surface geofactors for this face
//               const dfloat nx   = s_sgeo[et][es][face][p_NXID];
//               const dfloat ny   = s_sgeo[et][es][face][p_NYID];
//               const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
//               const dfloat invJ = s_sgeo[et][es][face][p_IJID];

//               // apply boundary conditions
//               const int bc = EToB[face+p_Nfaces*e];
//               if(bc>0){
//                 insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
//               }

//               // Find max normal velocity on the face
//               const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
//               const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);    
//               const dfloat unmax = (unm > unp) ? unm : unp;

//               // evaluate "flux" terms: LLF
//               const dfloat sc = 0.5f*invJ*sJ ;

//               s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et]) 
//                                    +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et]) 
//                                    +unmax*(iUdM[et]-iUdP[et]));

//               s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et]) 
//                                   + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et]) 
//                                   + unmax*(iVdM[et]-iVdP[et]));
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS1;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){
        
//         dfloat rhsu[p_cNmtS1];
//         dfloat rhsv[p_cNmtS1];
        
//         occaUnroll(p_cNmtS1)
//         for (int et=0;et<p_cNmtS1;++et){
//           rhsu[et] = 0;
//           rhsv[et] = 0;
//         }
        
//         occaUnroll(p_intNfpNfaces)
//           for(int m=0;m<p_intNfpNfaces;++m){
//             const dfloat L = intLIFTT[n+m*p_Np];
//             occaUnroll(p_cNmtS1)
//             for (int et=0;et<p_cNmtS1;++et){
//               rhsu[et] += L*s_iFluxU[et][es][m];
//               rhsv[et] += L*s_iFluxV[et][es][m];
//             }
//           }
        
//         occaUnroll(p_cNmtS1)
//         for (int et=0;et<p_cNmtS1;++et){
//           const int e = et*p_cNbS1 + es + eo;
//           if(e<Nelements){
//             const int id = n + p_Np*e;
//             rhsU[id] += rhsu[et];
//             rhsV[id] += rhsv[et];
//           }
//         }
//       }
//     }
//   }
// }


//  // // Optimized sizes for kernel 4-5
// #if p_N==1
//  #define p_cNbS2 10
//  #define p_cNmtS2 2
//  #endif

// #if p_N==2
// #define p_cNbS2 8
// #define p_cNmtS2 1
// #endif

// #if p_N==3
// #define p_cNbS2 2
// #define p_cNmtS2 2
// #endif

// #if p_N==4
// #define p_cNbS2 3
// #define p_cNmtS2 2
// #endif

// #if p_N==5
// #define p_cNbS2 2
// #define p_cNmtS2 2
// #endif

// #if p_N==6
// #define p_cNbS2 2
// #define p_cNmtS2 2
// #endif

// #if p_N==7
// #define p_cNbS2 3
// #define p_cNmtS2 2
// #endif

// #if p_N==8
// #define p_cNbS2 4
// #define p_cNmtS2 2
// #endif

// #if p_N==9
// #define p_cNbS2 1
// #define p_cNmtS2 3
// #endif

// #if p_N==10
// #define p_cNbS2 2
// #define p_cNmtS2 2
// #endif

// // interp in shared
// kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
//                                             const dfloat * restrict sgeo,
//                                             const dfloat * restrict intInterpT, // interpolate to integration nodes
//                                             const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//                                             const int   * restrict vmapM,
//                                             const int   * restrict vmapP,
//                                             const int   * restrict EToB,
//                                             const dfloat time,
//                                             const dfloat * restrict intx, // integration nodes
//                                             const dfloat * restrict inty,
//                                             const dfloat * restrict U,
//                                             const dfloat * restrict V,
//                                             const dfloat * restrict Ud,
//                                             const dfloat * restrict Vd,
//                                             dfloat * restrict rhsU,
//                                             dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_cNbS2*p_cNmtS2);outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS2][p_cNbS2][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS2][p_cNbS2][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS2][p_cNbS2][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS2][p_cNbS2][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS2][p_cNbS2][p_intNfpNfaces];

//     shared dfloat s_sgeo[p_cNmtS2][p_cNbS2][p_Nfaces][p_Nsgeo];
//     shared dfloat s_intInterpT[p_Nfaces*p_intNfp*p_Nfp];
    
    
//     for (int es=0;es<p_cNbS2;++es;inner1){
//       for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element
//         int m = n + p_Np*es;
//         while(m<p_cNmtS2*p_cNbS2*p_Nfaces*p_Nsgeo){
//           const int id = eo*p_Nfaces*p_Nsgeo + m;
//           s_sgeo[0][0][0][m] = sgeo[id];
//           m+=p_Np*p_cNbS2;
//         }

//         if (es==0) {
//           for(int m=n;m<p_Nfaces*p_Nfp*p_Nfp;m+=p_Np){
//             s_intInterpT[m] = intInterpT[m];
//           }
//         }
        
//         occaUnroll(p_cNmtS2)
//         for (int et=0;et<p_cNmtS2;++et){
//           const int e = et*p_cNbS2 + es + eo;
//           if(e<Nelements){
//             for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
//               // indices of negative and positive traces of face node
//               const int id  = e*p_Nfp*p_Nfaces + m;

//               const int idM = vmapM[id];
//               const int idP = vmapP[id];

//               // load negative and positive trace node values of velocity
//               s_UM[et][es][m] = U[idM];
//               s_VM[et][es][m] = V[idM];
//               s_UP[et][es][m] = U[idP];
//               s_VP[et][es][m] = V[idP];

//               s_UdM[et][es][m] = Ud[idM];
//               s_VdM[et][es][m] = Vd[idM];
//               s_UdP[et][es][m] = Ud[idP];
//               s_VdP[et][es][m] = Vd[idP];
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS2;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){ 
        
//         dfloat iUM [p_cNmtS2], iVM [p_cNmtS2];
//         dfloat iUP [p_cNmtS2], iVP [p_cNmtS2];
//         dfloat iUdM[p_cNmtS2], iVdM[p_cNmtS2];
//         dfloat iUdP[p_cNmtS2], iVdP[p_cNmtS2];

//         for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

//           occaUnroll(p_cNmtS2)
//           for (int et=0;et<p_cNmtS2;++et){
//             iUM [et] = 0.f, iVM [et] = 0.f;
//             iUP [et] = 0.f, iVP [et] = 0.f;
//             iUdM[et] = 0.f, iVdM[et] = 0.f;
//             iUdP[et] = 0.f, iVdP[et] = 0.f;
//           }
      
//           const int face = m/p_intNfp; // find face that owns this integration node
//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//             for(int k=0;k<p_Nfp;++k){
//               const dfloat iInm = s_intInterpT[m+k*p_Nfaces*p_intNfp];
//               const int fm = face*p_Nfp+k;

//               occaUnroll(p_cNmtS2)
//               for (int et=0;et<p_cNmtS2;++et){

//                 iUM [et] += iInm* s_UM[et][es][fm];
//                 iVM [et] += iInm* s_VM[et][es][fm];
//                 iUdM[et] += iInm*s_UdM[et][es][fm];
//                 iVdM[et] += iInm*s_VdM[et][es][fm];

//                 iUP [et] += iInm* s_UP[et][es][fm];
//                 iVP [et] += iInm* s_VP[et][es][fm];
//                 iUdP[et] += iInm*s_UdP[et][es][fm];
//                 iVdP[et] += iInm*s_VdP[et][es][fm];
//               }
//             }

//           occaUnroll(p_cNmtS2)
//           for (int et=0;et<p_cNmtS2;++et){
//             const int e = et*p_cNbS2 + es + eo;
//             if (e<Nelements) {
//               // load surface geofactors for this face
//               const dfloat nx   = s_sgeo[et][es][face][p_NXID];
//               const dfloat ny   = s_sgeo[et][es][face][p_NYID];
//               const dfloat sJ   = s_sgeo[et][es][face][p_SJID];
//               const dfloat invJ = s_sgeo[et][es][face][p_IJID];

//               // apply boundary conditions
//               const int bc = EToB[face+p_Nfaces*e];
//               if(bc>0){
//                 insAdvectionBoundaryConditions2D(bc,time, intx[m+e*p_Nfaces*p_intNfp], inty[m+e*p_Nfaces*p_intNfp], nx, ny, iUdM[et],iVdM[et], &(iUdP[et]), &(iVdP[et]));
//               }

//               // Find max normal velocity on the face
//               const dfloat unm   = occaFabs(nx*iUM[et]+ ny*iVM[et]);
//               const dfloat unp   = occaFabs(nx*iUP[et]+ ny*iVP[et]);    
//               const dfloat unmax = (unm > unp) ? unm : unp;

//               // evaluate "flux" terms: LLF
//               const dfloat sc = 0.5f*invJ*sJ ;

//               s_iFluxU[et][es][m] = sc*(nx*(iUP[et]*iUdP[et] + iUM[et]*iUdM[et]) 
//                                    +ny*(iVP[et]*iUdP[et] + iVM[et]*iUdM[et]) 
//                                    +unmax*(iUdM[et]-iUdP[et]));

//               s_iFluxV[et][es][m] = sc*(nx*(iUP[et]*iVdP[et] + iUM[et]*iVdM[et]) 
//                                   + ny*(iVP[et]*iVdP[et] + iVM[et]*iVdM[et]) 
//                                   + unmax*(iVdM[et]-iVdP[et]));
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS2;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){
        
//         dfloat rhsu[p_cNmtS2];
//         dfloat rhsv[p_cNmtS2];
        
//         occaUnroll(p_cNmtS2)
//         for (int et=0;et<p_cNmtS2;++et){
//           rhsu[et] = 0;
//           rhsv[et] = 0;
//         }
        
//         occaUnroll(p_intNfpNfaces)
//           for(int m=0;m<p_intNfpNfaces;++m){
//             const dfloat L = intLIFTT[n+m*p_Np];
//             occaUnroll(p_cNmtS2)
//             for (int et=0;et<p_cNmtS2;++et){
//               rhsu[et] += L*s_iFluxU[et][es][m];
//               rhsv[et] += L*s_iFluxV[et][es][m];
//             }
//           }
        
//         occaUnroll(p_cNmtS2)
//         for (int et=0;et<p_cNmtS2;++et){
//           const int e = et*p_cNbS2 + es + eo;
//           if(e<Nelements){
//             const int id = n + p_Np*e;
//             rhsU[id] += rhsu[et];
//             rhsV[id] += rhsv[et];
//           }
//         }
//       }
//     }
//   }
// }







// // Copied from Noel "Based on v4. Assume trace buffers are pre-built"
// kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
//                                             const dfloat * restrict sgeo,
//                                             const dfloat * restrict intInterpT, // interpolate to integration nodes
//                                             const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//                                             const int   * restrict vmapM,
//                                             const int   * restrict vmapP,
//                                             const int   * restrict EToB,
//                                             const dfloat time,
//                                             const dfloat * restrict intx, // integration nodes
//                                             const dfloat * restrict inty,
//                                             const dfloat * restrict fU,
//                                             const dfloat * restrict fV,
//                                             const dfloat * restrict fUd,
//                                             const dfloat * restrict fVd,
//                                             dfloat * restrict rhsU,
//                                             dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

//     shared dfloat s_iFluxU[p_NblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_NblockS][p_intNfpNfaces];

//     // get surface integration nodes and compute flux
//     for(int es=0;es<p_NblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<(p_Nfaces*p_intNfp)){

//             const int face = n/p_intNfp; // find face that owns this integration node

//             // load surface geofactors for this face
//             const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//             const dfloat nx   = sgeo[sid+p_NXID];
//             const dfloat ny   = sgeo[sid+p_NYID];
//             const dfloat sJ   = sgeo[sid+p_SJID];
//             const dfloat invJ = sgeo[sid+p_IJID];

//             const int idM  = e*p_intNfp*p_Nfaces + n;
//             const int idP  = idM;

//             const dfloat iUM  = fU[idM];
//             const dfloat iUP  = fU[idP];
//             const dfloat iUdM = fUd[idM];
//             const dfloat iUdP = fUd[idP];

//             const dfloat iVM  = fV[idM];
//             const dfloat iVP  = fV[idP];
//             const dfloat iVdM = fVd[idM];
//             const dfloat iVdP = fVd[idP];

//             // apply boundary conditions
//             const int bc = EToB[face+p_Nfaces*e];
//             //if(bc>0){
//             //  insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//             //}

//             // Find max normal velocity on the face
//             const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//             const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = 0.5f*invJ*sJ ;

//             s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM) 
//                              +ny*(iVP*iUdP + iVM*iUdM) 
//                              +unmax*(iUdM-iUdP));

//             s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM) 
//                             + ny*(iVP*iVdP + iVM*iVdM) 
//                             + unmax*(iVdM-iVdP));
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<p_Np){
//             const int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             occaUnroll(p_intNfpNfaces)
//               for(int m=0;m<p_intNfpNfaces;++m){
//                 const dfloat L = intLIFTT[n+m*p_Np];
//                 rhsu += L*s_iFluxU[es][m];
//                 rhsv += L*s_iFluxV[es][m];
//               }

//             rhsU[id] = rhsu;
//             rhsV[id] = rhsv; 
//           }
//         }
//       }
//     }
//   }
// }







// // Kernel is split in two
// kernel void insSubCycleCubatureSurface2D_v9(const int Nelements,
//                                             const dfloat * restrict sgeo,
//                                             const dfloat * restrict intInterpT, // interpolate to integration nodes
//                                             const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//                                             const int   * restrict vmapM,
//                                             const int   * restrict vmapP,
//                                             const int   * restrict EToB,
//                                             const dfloat time,
//                                             const dfloat * restrict intx, // integration nodes
//                                             const dfloat * restrict inty,
//                                             const dfloat * restrict U,
//                                             const dfloat * restrict V,
//                                             const dfloat * restrict Ud,
//                                             const dfloat * restrict Vd,                                            
//                                                   dfloat2 * restrict fU,
//                                                   dfloat2 * restrict fUd,
//                                                   dfloat * restrict rhsU,
//                                                   dfloat * restrict rhsV){

//  // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cNbS1*p_cNmtS1;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_UdM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS1][p_cNbS1][p_NfacesNfp];
    
//     //shared dfloat s_sgeo[p_cNmtS1][p_cNbS1][p_Nfaces][p_Nsgeo];
    
//     for (int es=0;es<p_cNbS1;++es;inner1){
//       for (int n=0;n<p_Np;++n;inner0) { //all faces*facenodes on this element     
//         occaUnroll(p_cNmtS1)
//         for (int et=0;et<p_cNmtS1;++et){
//           const int e = et*p_cNbS1 + es + eo;
//           if(e<Nelements){
//             for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){
//               // indices of negative and positive traces of face node
//               const int id  = e*p_Nfp*p_Nfaces + m;
//               const int idM = vmapM[id]; 
//               // load negative and positive trace node values of velocity
//               s_UM[et][es][m] = U[idM];
//               s_VM[et][es][m] = V[idM];
//               s_UP[et][es][m] = U[idP];
//               s_VP[et][es][m] = V[idP];
//             }
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS1;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){ 
        
//         dfloat iUM [p_cNmtS1];
//         dfloat iVM [p_cNmtS1];
//         dfloat iUdM[p_cNmtS1];
//         dfloat iUdP[p_cNmtS1];

//         for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

//           occaUnroll(p_cNmtS1)
//           for (int et=0;et<p_cNmtS1;++et){
//             iUM [et] = 0.f ;
//             iVM [et] = 0.f ;
//             iUdM[et] = 0.f ;
//             iVdM[et] = 0.f ;
//           }
      
//           const int face = m/p_intNfp; // find face that owns this integration node
//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//             for(int k=0;k<p_Nfp;++k){
//               const dfloat iInm = intInterpT[m+k*p_Nfaces*p_intNfp];
//               const int fm = face*p_Nfp+k;
//               occaUnroll(p_cNmtS1)
//               for (int et=0;et<p_cNmtS1;++et){
//                 iUM [et] += iInm* s_UM[et][es][fm];
//                 iVM [et] += iInm* s_VM[et][es][fm];
//                 iUdM[et] += iInm*s_UdM[et][es][fm];
//                 iVdM[et] += iInm*s_VdM[et][es][fm];
//               }
//             }
//           }

//           occaUnroll(p_cNmt)
//             for(int em=0;em<p_cNmt;++em){
//               int e = eo+es*p_cNmt+em;
//                if(e<Nelements){
//                 for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){
//                     // indices of negative and positive traces of face node
//                     const int id  = e*p_Nfp*p_intNfaces + m;
//                     dfloat2 tmp;
//                     tmp.x = iUM[em];
//                     tmp.y = iVM[em];
//                     fU[id] = tmp; 
    
//                     tmp.x = iUdM[em];
//                     tmp.y = iVdM[em];
//                     //
//                     fUd[id] = tmp; // note  change in sign
//                 }
//               }
//            }

//          }
//        }
//      }




//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cNbS1*p_cNmtS1;outer0){

//     shared dfloat s_iFluxU[p_cNmtS1][p_cNbS1][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS1][p_cNbS1][p_intNfpNfaces];

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS1;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){ 
        
//         // dfloat iUM [p_cNmtS1], iVM [p_cNmtS1];
//         // dfloat iUP [p_cNmtS1], iVP [p_cNmtS1];
//         // dfloat iUdM[p_cNmtS1], iVdM[p_cNmtS1];
//         // dfloat iUdP[p_cNmtS1], iVdP[p_cNmtS1];

//         for(int m=n;m<p_Nfaces*p_intNfp;m+=p_Np){

//            const int face = m/p_intNfp; // find face that owns this integration node

//            for (int et=0;et<p_cNmtS1;++et){

//               const int e = et*p_cNbS1 + es + eo;
//               // load surface geofactors for this face
//               const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//               const dfloat nx   = sgeo[sid+p_NXID];
//               const dfloat ny   = sgeo[sid+p_NYID];
//               const dfloat sJ   = sgeo[sid+p_SJID];
//               const dfloat invJ = sgeo[sid+p_IJID];

//               const int idM  = e*p_intNfp*p_Nfaces + m;
//               const int idP  = idM;

//               const dfloat2 fum  = fU[idM];
//               const dfloat2 fup = fUd[idM];
//               const dfloat2 fud = fU[idM];
//               const dfloat2  = fUd[idM];


//             // apply boundary conditions
//             const int bc = EToB[face+p_Nfaces*e];
//             //if(bc>0){
//             //  insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//             //}

//             // Find max normal velocity on the face
//             const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//             const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//             const dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = 0.5f*invJ*sJ ;

//             s_iFluxU[es][n] = sc*(nx*(iUP*iUdP + iUM*iUdM) 
//                              +ny*(iVP*iUdP + iVM*iUdM) 
//                              +unmax*(iUdM-iUdP));

//             s_iFluxV[es][n] = sc*(nx*(iUP*iVdP + iUM*iVdM) 
//                             + ny*(iVP*iVdP + iVM*iVdM) 
//                             + unmax*(iVdM-iVdP));
//           }
//         }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_NblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//         const int e = eo + es;
//         if(e<Nelements){
//           if(n<p_Np){
//             const int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             occaUnroll(p_intNfpNfaces)
//               for(int m=0;m<p_intNfpNfaces;++m){
//                 const dfloat L = intLIFTT[n+m*p_Np];
//                 rhsu += L*s_iFluxU[es][m];
//                 rhsv += L*s_iFluxV[es][m];
//               }

//             rhsU[id] = rhsu;
//             rhsV[id] = rhsv; 
//           }
//         }
//       }
//     }
//   }
// }















// kernel void insSubCycleCubatureSurface2D_v4(const int Nelements,
// 					    const dfloat * restrict sgeo,
// 					    const dfloat * restrict intInterpT, // interpolate to integration nodes
// 					    const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
// 					    const int   * restrict vmapM,
// 					    const int   * restrict vmapP,
// 					    const int   * restrict EToB,
// 					    const dfloat time,
// 					    const dfloat * restrict intx, // integration nodes
// 					    const dfloat * restrict inty,
// 					    const dfloat * restrict U,
// 					    const dfloat * restrict V,
// 					    const dfloat * restrict Ud,
// 					    const dfloat * restrict Vd,
// 					    dfloat * restrict rhsU,
// 					    dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_cNbS*p_cNmtS);outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS][p_cNbS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS][p_cNbS][p_intNfpNfaces];
   
//     // for all face nodes of all elements
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_cNmtS)
// 	  for(int em=0;em<p_cNmtS;++em){ 
                
// 	    const int e   = eo + es*p_cNmtS + em; 
// 	    const int id  = e*p_NfacesNfp + n;

// 	    if(e<Nelements && n<p_NfacesNfp ){
// 	      int idM = vmapM[id];
// 	      int idP = vmapP[id];

// 	      if(idP<0) idP = idM;

// 	      // //load negative and positive trace node values of velocity
// 	      s_UM[em][es][n] = U[idM];
// 	      s_VM[em][es][n] = V[idM];
// 	      s_UP[em][es][n] = U[idP];
// 	      s_VP[em][es][n] = V[idP];
       
// 	      s_UdM[em][es][n] = Ud[idM];
// 	      s_VdM[em][es][n] = Vd[idM];
// 	      s_UdP[em][es][n] = Ud[idP];
// 	      s_VdP[em][es][n] = Vd[idP];
// 	    }
// 	  }
//       }
//     }
  
//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){

// 	  dfloat cUM[p_cNmtS], cVM[p_cNmtS], cUdM[p_cNmtS], cVdM[p_cNmtS];
// 	  dfloat cUP[p_cNmtS], cVP[p_cNmtS], cUdP[p_cNmtS], cVdP[p_cNmtS];
// 	  // dfloat nx[p_cNmtS], ny[p_cNmtS], sc[p_cNmtS], bc[p_cNmtS]; 

// 	  const int face = n/p_intNfp;       
         
//           occaUnroll(p_cNmtS)
// 	    for(int em=0;em<p_cNmtS;++em){
// 	      //
// 	      cUM [em] = 0.f;
// 	      cVM [em] = 0.f;
// 	      cUdM[em] = 0.f; 
// 	      cVdM[em] = 0.f;
// 	      //
// 	      cUP [em] = 0.f;
// 	      cVP [em] = 0.f;
// 	      cUdP[em] = 0.f; 
// 	      cVdP[em] = 0.f;
// 	    }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
// 	    for(int m=0;m<p_Nfp;++m){
// 	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
// 	      const int fm = face*p_intNfp + m;
// 	      occaUnroll(p_cNmtS)
// 		for(int em=0;em<p_cNmtS;++em){

// 		  cUM [em] += iInm*s_UM[em][es][fm];
// 		  cVM [em] += iInm*s_VM[em][es][fm];
// 		  cUdM[em] += iInm*s_UdM[em][es][fm];
// 		  cVdM[em] += iInm*s_VdM[em][es][fm];

// 		  cUP[em]  += iInm*s_UP[em][es][fm];
// 		  cVP[em]  += iInm*s_VP[em][es][fm];
// 		  cUdP[em] += iInm*s_UdP[em][es][fm];
// 		  cVdP[em] += iInm*s_VdP[em][es][fm];
// 		}
// 	    }

// 	  occaUnroll(p_cNmtS)
// 	    for(int em=0;em<p_cNmtS;++em){
// 	      const int e = eo + es*p_cNmtS + em;
// 	      const int sid    = p_Nsgeo*(e*p_Nfaces+face);
// 	      const dfloat nx   = sgeo[sid+p_NXID];
// 	      const dfloat ny   = sgeo[sid+p_NYID];
// 	      const dfloat sc   = sgeo[sid+p_SJID]*sgeo[sid+p_IJID]; // sJ*invJ
// 	      const int   bc   = EToB[face+p_Nfaces*e];
          
// 	      // if(bc>0){
// 	      //  insAdvectionBoundaryConditions2D(bc[em],time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx[em], ny[em], cUdM[em],cVdM[em], &cUdP[em], &cVdP[em]);
// 	      // }

// 	      //Find max normal velocity on the face
// 	      const dfloat unm   = occaFabs(nx*cUM[em] + ny*cVM[em]);
// 	      const dfloat unp   = occaFabs(nx*cUP[em] + ny*cVP[em]);    
// 	      const dfloat unmax = (unm > unp) ? unm : unp;

// 	      s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
// 					     +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
// 					     +unmax*(cUdM[em]- cUdP[em]) ));

// 	      s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
// 					     +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
// 					     +unmax*(cVdM[em]-cVdP[em]) ));



// 	    }
// 	}
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
// 	dfloat rhsu[p_cNmtS], rhsv[p_cNmtS];

//         if(n<p_Np){
// 	  occaUnroll(p_cNmtS)
// 	    for(int em=0;em<p_cNmtS;++em){
// 	      rhsu[em] = 0.f;
// 	      rhsv[em] = 0.f;
// 	    }
// 	  //
// 	  occaUnroll(p_intNfpNfaces)
// 	    for(int m=0;m<p_intNfpNfaces;++m){
// 	      const dfloat L = intLIFTT[n+m*p_Np];
// 	      occaUnroll(p_cNmtS)
// 		for(int em=0;em<p_cNmtS;++em){
// 		  rhsu[em] += L*s_iFluxU[em][es][m];
// 		  rhsv[em] += L*s_iFluxV[em][es][m];
// 		}
// 	    }

// 	  occaUnroll(p_cNmtS)
// 	    for(int em=0;em<p_cNmtS;++em){
// 	      int e = eo+es*p_cNmtS+em;
// 	      if(e<Nelements){
// 		const int id = e*p_Np+n;
// 		rhsU[id]   += rhsu[em]; // note  change in sign
// 		rhsV[id]   += rhsv[em];    

// 	      }
// 	    }
// 	}
//       }
//     }
      

//   }

// }




// // same with kernel 4, move geo to shared

// kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat * restrict U,
//               const dfloat * restrict V,
//               const dfloat * restrict Ud,
//               const dfloat * restrict Vd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_cNbS*p_cNmtS);outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS][p_cNbS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS][p_cNbS][p_intNfpNfaces];


//     shared dfloat s_sgeo[p_cNmtS][p_cNbS][p_Nfaces][p_Nsgeo];
//     shared dfloat s_bc[p_cNmtS][p_cNbS][p_Nfaces];
       
//     // for all face nodes of all elements
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_cNmtS)
//      for(int em=0;em<p_cNmtS;++em){ 
                
//       const int e   = eo + es*p_cNmtS + em; 
//       const int id  = e*p_NfacesNfp + n;

//        if(e<Nelements && n<p_Np ){
//           int m = n + p_Np*es;
//           // oad surface geofacs for all faces of all elements in block(s)
//           while(m<p_cNbS*p_Nfaces*p_Nsgeo*p_cNmtS){
//             const int id = eo*p_Nfaces*p_Nsgeo+ m;
//              s_sgeo[0][0][0][m] = sgeo[id];
//              m+=p_Np*p_cNbS;
//          }
//         }

//       if(e<Nelements && n<p_NfacesNfp ){
//         int idM = vmapM[id];
//         int idP = vmapP[id];

//         if(idP<0) idP = idM;

//         // //load negative and positive trace node values of velocity
//         s_UM[em][es][n] = U[idM];
//         s_VM[em][es][n] = V[idM];
//         s_UP[em][es][n] = U[idP];
//         s_VP[em][es][n] = V[idP];
       
//         s_UdM[em][es][n] = Ud[idM];
//         s_VdM[em][es][n] = Vd[idM];
//         s_UdP[em][es][n] = Ud[idP];
//         s_VdP[em][es][n] = Vd[idP];
//          }

        
//      }
//     }
//     }


//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){

//     dfloat cUM[p_cNmtS], cVM[p_cNmtS], cUdM[p_cNmtS], cVdM[p_cNmtS];
//     dfloat cUP[p_cNmtS], cVP[p_cNmtS], cUdP[p_cNmtS], cVdP[p_cNmtS];
//     const int face = n/p_intNfp;       
         
//           occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         cUM [em] = 0.f;
//         cVM [em] = 0.f;
//         cUdM[em] = 0.f; 
//         cVdM[em] = 0.f;
//         //
//         cUP [em] = 0.f;
//         cVP [em] = 0.f;
//         cUdP[em] = 0.f; 
//         cVdP[em] = 0.f;
//       }

//           // local block interpolation (face nodes to integration nodes)
//       occaUnroll(p_Nfp)
//       for(int m=0;m<p_Nfp;++m){
//         const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//         const int fm = face*p_Nfp + m;
//         occaUnroll(p_cNmtS)
//     for(int em=0;em<p_cNmtS;++em){

//       cUM [em] += iInm*s_UM[em][es][fm];
//       cVM [em] += iInm*s_VM[em][es][fm];
//       cUdM[em] += iInm*s_UdM[em][es][fm];
//       cVdM[em] += iInm*s_VdM[em][es][fm];

//       cUP[em]  += iInm*s_UP[em][es][fm];
//       cVP[em]  += iInm*s_VP[em][es][fm];
//       cUdP[em] += iInm*s_UdP[em][es][fm];
//       cVdP[em] += iInm*s_VdP[em][es][fm];
//     }
//       }

//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         //const int e = eo + es*p_cNmtS + em;
//         //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//         const dfloat nx   = s_sgeo[em][es][face][p_NXID];
//         const dfloat ny   = s_sgeo[em][es][face][p_NYID];
//         const dfloat sj   = s_sgeo[em][es][face][p_SJID];
//         const dfloat ij   = s_sgeo[em][es][face][p_IJID];
        
//         //const int   bc   = EToB[face+p_Nfaces*e];
        
        
//         const dfloat sc = sj*ij; 
//         //Find max normal velocity on the face
//         const dfloat unm   = occaFabs(nx*cUM[em] + ny*cVM[em]);
//         const dfloat unp   = occaFabs(nx*cUP[em] + ny*cVP[em]);    
//         const dfloat unmax = (unm > unp) ? unm : unp;

//         s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
//                +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
//                +unmax*(cUdM[em]- cUdP[em]) ));

//         s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
//                +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
//                +unmax*(cVdM[em]-cVdP[em]) ));



//       }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//   dfloat rhsu[p_cNmtS], rhsv[p_cNmtS];

//         if(n<p_Np){
//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         rhsu[em] = 0.f;
//         rhsv[em] = 0.f;
//       }
//     //
//     occaUnroll(p_intNfpNfaces)
//       for(int m=0;m<p_intNfpNfaces;++m){
//         const dfloat L = intLIFTT[n+m*p_Np];
//         occaUnroll(p_cNmtS)
//     for(int em=0;em<p_cNmtS;++em){
//       rhsu[em] += L*s_iFluxU[em][es][m];
//       rhsv[em] += L*s_iFluxV[em][es][m];
//     }
//       }

//     occaUnroll(p_cNmtS)
//       for(int em=0;em<p_cNmtS;++em){
//         int e = eo+es*p_cNmtS+em;
//         if(e<Nelements){
//     const int id = e*p_Np+n;
//     rhsU[id]   += rhsu[em]; // note  change in sign
//     rhsV[id]   += rhsv[em];    

//         }
//       }
//   }
//       }
//     }
      

//   }

// }










// // same with Kernel 3 with shared memory for Geo
// kernel void insSubCycleCubatureSurface2D_v6(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat * restrict U,
//               const dfloat * restrict V,
//               const dfloat * restrict Ud,
//               const dfloat * restrict Vd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

//     shared dfloat s_sgeo[p_cubNblockS][p_Nfaces][p_Nsgeo];
//     //shared dfloat s_bc[p_cubNblockS][p_Nfaces];

//     // for all face nodes of all elements
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//   int e = eo + es;

//   if(e<Nelements){

//       if(n<p_Np ){
//           int m = n + p_Np*es;
//           // oad surface geofacs for all faces of all elements in block(s)
//           while(m<p_cubNblockS*p_Nfaces*p_Nsgeo){
//             const int id = eo*p_Nfaces*p_Nsgeo+ m;
//             s_sgeo[0][0][m] = sgeo[id];
//             m+=p_Np*p_cubNblockS;
//          }
//         }

//     if(n<(p_Nfaces*p_Nfp)){
//       // indices of negative and positive traces of face node
//       const int id  = e*p_Nfp*p_Nfaces + n;

//       int idM = vmapM[id];
//       int idP = vmapP[id];

//       if(idP<0) idP = idM;
//       // load negative and positive trace node values of velocity
//       s_UM[es][n] = U[idM];
//       s_VM[es][n] = V[idM];
//       s_UP[es][n] = U[idP];
//       s_VP[es][n] = V[idP];

//       s_UdM[es][n] = Ud[idM];
//       s_VdM[es][n] = Vd[idM];
//       s_UdP[es][n] = Ud[idP];
//       s_VdP[es][n] = Vd[idP];

//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

//   int e = eo + es;

//   if(e<Nelements){
//     if(n<(p_Nfaces*p_intNfp)){

//       const int face = n/p_intNfp; // find face that owns this integration node

//       // load surface geofactors for this face
//       //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//        const dfloat nx   = s_sgeo[es][face][p_NXID];
//        const dfloat ny   = s_sgeo[es][face][p_NYID];
//        const dfloat sJ   = s_sgeo[es][face][p_SJID];
//        const dfloat invJ = s_sgeo[es][face][p_IJID];
      
//       dfloat iUM  = 0.f, iVM  = 0.f;
//       dfloat iUP  = 0.f, iVP  = 0.f;
//       dfloat iUdM = 0.f, iVdM = 0.f;
//       dfloat iUdP = 0.f, iVdP = 0.f;

//       // local block interpolation (face nodes to integration nodes)
//       occaUnroll(p_Nfp)
//         for(int m=0;m<p_Nfp;++m){
//     const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//     const int fm = face*p_Nfp+m;

//     iUM  += iInm*s_UM[es][fm];
//     iVM  += iInm*s_VM[es][fm];
//     iUdM += iInm*s_UdM[es][fm];
//     iVdM += iInm*s_VdM[es][fm];

//     iUP  += iInm*s_UP[es][fm];
//     iVP  += iInm*s_VP[es][fm];
//     iUdP += iInm*s_UdP[es][fm];
//     iVdP += iInm*s_VdP[es][fm];
//         }

//       // // apply boundary conditions
//       // int bc = EToB[face+p_Nfaces*e];

//       // if(bc>0){
//       //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//       // }


//       // Find max normal velocity on the face
//       dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//       dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//       dfloat unmax = (unm > unp) ? unm : unp;

//       // evaluate "flux" terms: LLF
//       const dfloat sc = invJ * sJ ;

//       s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
//                +ny*(iVP*iUdP + iVM*iUdM) 
//                +unmax*(iUdM-iUdP) ));

//       s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
//                + ny*(iVP*iVdP + iVM*iVdM) 
//                + unmax*(iVdM-iVdP) ));
//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         const int e = eo + es;

//         if(e<Nelements){
//           if(n<p_Np){
//             int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             occaUnroll(p_intNfpNfaces)
//         for(int m=0;m<p_intNfpNfaces;++m){
//     // RefMassMatrix^{-1}*cInterp^t*cWeight
//     const dfloat L = intLIFTT[n+m*p_Np];

//     rhsu += L*s_iFluxU[es][m];
//     rhsv += L*s_iFluxV[es][m];
//         }

//             rhsU[id] = rhsu;  // 
//             rhsV[id] = rhsv;  //  
//           }
//         }
//       }
//     }
//   }

// }


// // assume coalasced fetch for kernel 6
// kernel void insSubCycleCubatureSurface2D_v7(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat2 * restrict UM,
//               const dfloat2 * restrict UP,
//               const dfloat2 * restrict UMd,
//               const dfloat2 * restrict UPd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

//     shared dfloat s_sgeo[p_cubNblockS][p_Nfaces][p_Nsgeo];
//     //shared dfloat s_bc[p_cubNblockS][p_Nfaces];

//     // for all face nodes of all elements
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//       int e = eo + es;

//       if(e<Nelements){

//         if(n<p_Np ){
//             int m = n + p_Np*es;
//             // oad surface geofacs for all faces of all elements in block(s)
//             while(m<p_cubNblockS*p_Nfaces*p_Nsgeo){
//               const int id = eo*p_Nfaces*p_Nsgeo+ m;
//               s_sgeo[0][0][m] = sgeo[id];
//               m+=p_Np*p_cubNblockS;
//            }
//           }

//     if(n<(p_Nfaces*p_Nfp)){
//       // indices of negative and positive traces of face node
//       const int id  = e*p_Nfp*p_Nfaces + n;

//       dfloat2 um = UM[id];
//       dfloat2 up = UP[id];

//       dfloat2 udm = UMd[id];
//       dfloat2 udp = UPd[id];

    
//       // coalasced read
//       s_UM[es][n] = um.x;
//       s_VM[es][n] = um.y;
//       s_UP[es][n] = up.x;
//       s_VP[es][n] = up.y;

//       s_UdM[es][n] = udm.x;
//       s_VdM[es][n] = udm.y;
//       s_UdP[es][n] = udp.x;
//       s_VdP[es][n] = udp.y;

//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

//   int e = eo + es;

//   if(e<Nelements){
//     if(n<(p_Nfaces*p_intNfp)){

//       const int face = n/p_intNfp; // find face that owns this integration node

//       // load surface geofactors for this face
//       //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//        const dfloat nx   = s_sgeo[es][face][p_NXID];
//        const dfloat ny   = s_sgeo[es][face][p_NYID];
//        const dfloat sJ   = s_sgeo[es][face][p_SJID];
//        const dfloat invJ = s_sgeo[es][face][p_IJID];
      
//       dfloat iUM  = 0.f, iVM  = 0.f;
//       dfloat iUP  = 0.f, iVP  = 0.f;
//       dfloat iUdM = 0.f, iVdM = 0.f;
//       dfloat iUdP = 0.f, iVdP = 0.f;

//       // local block interpolation (face nodes to integration nodes)
//       occaUnroll(p_Nfp)
//         for(int m=0;m<p_Nfp;++m){
//     const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//     const int fm = face*p_Nfp+m;

//     iUM  += iInm*s_UM[es][fm];
//     iVM  += iInm*s_VM[es][fm];
//     iUdM += iInm*s_UdM[es][fm];
//     iVdM += iInm*s_VdM[es][fm];

//     iUP  += iInm*s_UP[es][fm];
//     iVP  += iInm*s_VP[es][fm];
//     iUdP += iInm*s_UdP[es][fm];
//     iVdP += iInm*s_VdP[es][fm];
//         }

//       // // apply boundary conditions
//       // int bc = EToB[face+p_Nfaces*e];

//       // if(bc>0){
//       //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//       // }


//       // Find max normal velocity on the face
//       dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//       dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//       dfloat unmax = (unm > unp) ? unm : unp;

//       // evaluate "flux" terms: LLF
//       const dfloat sc = invJ * sJ ;

//       s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
//                +ny*(iVP*iUdP + iVM*iUdM) 
//                +unmax*(iUdM-iUdP) ));

//       s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
//                + ny*(iVP*iVdP + iVM*iVdM) 
//                + unmax*(iVdM-iVdP) ));
//     }
//   }
//       }
//     }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         const int e = eo + es;

//         if(e<Nelements){
//           if(n<p_Np){
//             int id = n + p_Np*e;
//             // prefetch volume rhs
//             dfloat rhsu = rhsU[id];
//             dfloat rhsv = rhsV[id];

//             occaUnroll(p_intNfpNfaces)
//         for(int m=0;m<p_intNfpNfaces;++m){
//     // RefMassMatrix^{-1}*cInterp^t*cWeight
//     const dfloat L = intLIFTT[n+m*p_Np];

//     rhsu += L*s_iFluxU[es][m];
//     rhsv += L*s_iFluxV[es][m];
//         }

//             rhsU[id] = rhsu;  // 
//             rhsV[id] = rhsv;  //  
//           }
//         }
//       }
//     }
//   }

// }




// // employ Np threads to kernel 9
// kernel void insSubCycleCubatureSurface2D_v8(const int Nelements,
//               const dfloat * restrict sgeo,
//               const dfloat * restrict intInterpT, // interpolate to integration nodes
//               const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//               const int   * restrict vmapM,
//               const int   * restrict vmapP,
//               const int   * restrict EToB,
//               const dfloat time,
//               const dfloat * restrict intx, // integration nodes
//               const dfloat * restrict inty,
//               const dfloat2 * restrict UM,
//               const dfloat2 * restrict UP,
//               const dfloat2 * restrict UMd,
//               const dfloat2 * restrict UPd,
//               dfloat * restrict rhsU,
//               dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){
//     // Re-optimize number of elements per block
//     shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cubNblockS][p_Np];
//     shared dfloat s_iFluxV[p_cubNblockS][p_Np];

//     shared dfloat s_sgeo[p_cubNblockS][p_Nfaces][p_Nsgeo];

//     exclusive dfloat rhsu, rhsv; 

//     //shared dfloat s_bc[p_cubNblockS][p_Nfaces];

//     // for all face nodes of all elements
//     for(int es=0;es<p_cubNblockS;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){
//         int e = eo + es;
//         if(e<Nelements){
//           // Initialize register values;
//          int id = n + p_Np*e;  
//          rhsu = rhsU[id];
//          rhsv = rhsV[id]; 


//         // fetch geometric factors to register
//           int k = n + p_Np*es;
//           // load geometric factors to shared
//           while(k<p_cubNblockS*p_Nfaces*p_Nsgeo){
//             const int id = eo*p_Nfaces*p_Nsgeo+ k;
//             s_sgeo[0][0][k] = sgeo[id];
//             k+=p_Np*p_cubNblockS;
//           }


   
//           for(int m=n;m<p_Nfaces*p_Nfp;m+=p_Np){ // 
//              // indices of negative and positive traces of face node
//             const int id  = e*p_Nfp*p_Nfaces + n;

//             dfloat2 um = UM[id];
//             dfloat2 up = UP[id];

//             dfloat2 udm = UMd[id];
//             dfloat2 udp = UPd[id];

          
//             // coalasced read
//             s_UM[es][n] = um.x;
//             s_VM[es][n] = um.y;
//             s_UP[es][n] = up.x;
//             s_VP[es][n] = up.y;

//             s_UdM[es][n] = udm.x;
//             s_VdM[es][n] = udm.y;
//             s_UdP[es][n] = udp.x;
//             s_VdP[es][n] = udp.y;

//           }
//         }
//       }
//     }

//     barrier(localMemFence);



//     occaUnroll()
//     for(int io=0;io<p_Nfaces*p_intNfp;io+=p_Np){ // block the surface integration nodes
    
//     barrier(localMemFence); 
  
//       for(int es=0;es<p_cubNblockS;++es;inner1){
//         for(int ns=0;ns<p_Np;++ns;inner0){ 
//           int e = eo + es;
//           if(e<Nelements){

//             const int n = ns + io; 

//             if(n<(p_Nfaces*p_intNfp)){
//               const int face = n/p_intNfp; // find face that owns this integration node
//               //const int sid    = p_Nsgeo*(e*p_Nfaces+face);
//               const dfloat nx   = s_sgeo[es][face][p_NXID];
//               const dfloat ny   = s_sgeo[es][face][p_NYID];
//               const dfloat sJ   = s_sgeo[es][face][p_SJID];
//               const dfloat invJ = s_sgeo[es][face][p_IJID];
          
//               dfloat iUM  = 0.f, iVM  = 0.f;
//               dfloat iUP  = 0.f, iVP  = 0.f;
//               dfloat iUdM = 0.f, iVdM = 0.f;
//               dfloat iUdP = 0.f, iVdP = 0.f;

//           // local block interpolation (face nodes to integration nodes)
//               occaUnroll(p_Nfp)
//               for(int i=0;i<p_Nfp;++i){
//                 const dfloat iInm = intInterpT[n+i*p_Nfaces*p_intNfp];
//                 const int fm = face*p_Nfp+i;

//                 iUM  += iInm*s_UM[es][fm];
//                 iVM  += iInm*s_VM[es][fm];
//                 iUdM += iInm*s_UdM[es][fm];
//                 iVdM += iInm*s_VdM[es][fm];

//                 iUP  += iInm*s_UP[es][fm];
//                 iVP  += iInm*s_VP[es][fm];
//                 iUdP += iInm*s_UdP[es][fm];
//                 iVdP += iInm*s_VdP[es][fm];
//               }

//             // // apply boundary conditions
//             // int bc = EToB[face+p_Nfaces*e];

//             // if(bc>0){
//             //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
//             // }


//             // Find max normal velocity on the face
//             dfloat unm   = occaFabs(nx*iUM + ny*iVM);
//             dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
//             dfloat unmax = (unm > unp) ? unm : unp;

//             // evaluate "flux" terms: LLF
//             const dfloat sc = invJ * sJ ;

//             s_iFluxU[es][ns] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
//                      +ny*(iVP*iUdP + iVM*iUdM) 
//                      +unmax*(iUdM-iUdP) ));

//             s_iFluxV[es][ns] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
//                      + ny*(iVP*iVdP + iVM*iVdM) 
//                      + unmax*(iVdM-iVdP) ));
//           }
//        }
//       }
//      }

//       barrier(localMemFence);

//     // lift from surface integration to volume nodes
//       for(int es=0;es<p_cubNblockS;++es;inner1){
//         for(int n=0;n<p_Np;++n;inner0){
//           const int e = eo + es;
//           if(e<Nelements){    
//             occaUnroll(p_Np)
//             for(int i=0;i<p_Np;++i){
//               if(i+io < p_intNfpNfaces){
//             // RefMassMatrix^{-1}*cInterp^t*cWeight
//               const dfloat L = intLIFTT[n+(i+io)*p_Np];
//               rhsu += L*s_iFluxU[es][i];
//               rhsv += L*s_iFluxV[es][i];
//              }
//             }
//             }
//         }
//       }

//      }
  
//      // lift from surface integration to volume nodes
//       for(int es=0;es<p_cubNblockS;++es;inner1){
//         for(int n=0;n<p_Np;++n;inner0){
//           const int e = eo + es;
//           if(e<Nelements){
//            int id = n + p_Np*e;    
//             rhsU[id] = rhsu;  // 
//             rhsV[id] = rhsv;  //  
//             }
//         }
//       }




//   }

// }




// // Fetch geometric factors to shared
// kernel void insSubCycleCubatureSurface2D_v5(const int Nelements,
//            const dfloat * restrict sgeo,
//            const dfloat * restrict intInterpT, // interpolate to integration nodes
//            const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
//            const int   * restrict vmapM,
//            const int   * restrict vmapP,
//            const int   * restrict EToB,
//            const dfloat time,
//            const dfloat * restrict intx, // integration nodes
//            const dfloat * restrict inty,
//            const dfloat * restrict U,
//            const dfloat * restrict V,
//            const dfloat * restrict Ud,
//            const dfloat * restrict Vd,
//            dfloat * restrict rhsU,
//            dfloat * restrict rhsV){
//   // for all elements
//   for(int eo=0;eo<Nelements;eo+=(p_cNbS*p_cNmtS);outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cNmtS][p_cNbS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cNmtS][p_cNbS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cNmtS][p_cNbS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cNmtS][p_cNbS][p_intNfpNfaces];

//     shared dfloat s_Nx[p_cNmtS][p_cNbS][p_Nfaces];
//     shared dfloat s_Ny[p_cNmtS][p_cNbS][p_Nfaces];
//     shared dfloat s_Sc[p_cNmtS][p_cNbS][p_Nfaces];
//     shared int   s_Bc[p_cNmtS][p_cNbS][p_Nfaces];


//     // for all face nodes of all elements
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){

//         occaUnroll(p_cNmtS)
//         for(int em=0;em<p_cNmtS;++em){ 
                
//          const int e   = eo + es*p_cNmtS + em; 


//           if(e<Nelements && n<p_NfacesNfp ){
//              const int id  = e*p_NfacesNfp + n;
//             int idM = vmapM[id];
//             int idP = vmapP[id];

//             if(idP<0) idP = idM;

//             // //load negative and positive trace node values of velocity
//             s_UM[em][es][n] = U[idM];
//             s_VM[em][es][n] = V[idM];
//             s_UP[em][es][n] = U[idP];
//             s_VP[em][es][n] = V[idP];
       
//             s_UdM[em][es][n] = Ud[idM];
//             s_VdM[em][es][n] = Vd[idM];
//             s_UdP[em][es][n] = Ud[idP];
//             s_VdP[em][es][n] = Vd[idP];
//         }


//           if(e<Nelements && n<p_intNfpNfaces){
//             const int face      = n/p_intNfp;         
//             const int sid       = p_Nsgeo*(e*p_Nfaces+face);
//             s_Nx[em][es][face]   = sgeo[sid+p_NXID];
//             s_Ny[em][es][face]   = sgeo[sid+p_NYID];
//             s_Sc[em][es][face]   = sgeo[sid+p_SJID]*sgeo[sid+p_IJID]; // sJ*invJ
//             s_Sc[em][es][face]   = EToB[face+p_Nfaces*e];
//         }
//       }
//     }
//   }


//     barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 
//         if(n<(p_Nfaces*p_intNfp)){

//         dfloat cUM[p_cNmtS], cVM[p_cNmtS], cUdM[p_cNmtS], cVdM[p_cNmtS];
//         dfloat cUP[p_cNmtS], cVP[p_cNmtS], cUdP[p_cNmtS], cVdP[p_cNmtS];
       
//         const int face = n/p_intNfp;       
         
//           occaUnroll(p_cNmtS)
//           for(int em=0;em<p_cNmtS;++em){
           
//             cUM [em] = 0.f;
//             cVM [em] = 0.f;
//             cUdM[em] = 0.f; 
//             cVdM[em] = 0.f;
//             //
//             cUP [em] = 0.f;
//             cVP [em] = 0.f;
//             cUdP[em] = 0.f; 
//             cVdP[em] = 0.f;
//           }

//           // local block interpolation (face nodes to integration nodes)
//           occaUnroll(p_Nfp)
//           for(int m=0;m<p_Nfp;++m){
//             const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
//             const int fm = face*p_Nfp + m;
//             occaUnroll(p_cNmtS)
//               for(int em=0;em<p_cNmtS;++em){

//               cUM [em] += iInm*s_UM[em][es][fm];
//               cVM [em] += iInm*s_VM[em][es][fm];
//               cUdM[em] += iInm*s_UdM[em][es][fm];
//               cVdM[em] += iInm*s_VdM[em][es][fm];

//               cUP[em]  += iInm*s_UP[em][es][fm];
//               cVP[em]  += iInm*s_VP[em][es][fm];
//               cUdP[em] += iInm*s_UdP[em][es][fm];
//               cVdP[em] += iInm*s_VdP[em][es][fm];
//           }
//         }

//         occaUnroll(p_cNmtS)
//         for(int em=0;em<p_cNmtS;++em){
//            const int e = eo + es*p_cNmtS + em;
//             const dfloat nx   = s_Nx[em][es][face];
//             const dfloat ny   = s_Ny[em][es][face];
//             const dfloat sc   = s_Sc[em][es][face]; // sJ*invJ
//             const int   bc   = s_Bc[em][es][face];
          
//           if(bc>0){
//            insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx[em], ny[em], cUdM[em],cVdM[em], &cUdP[em], &cVdP[em]);
//           }

//           //Find max normal velocity on the face
//           const dfloat unm   = occaFabs(nx*cUM[em] + ny*cVM[em]);
//           const dfloat unp   = occaFabs(nx*cUP[em] + ny*cVP[em]);    
//           const dfloat unmax = (unm > unp) ? unm : unp;

//           s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
//                                             +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
//                                             +unmax*(cUdM[em]- cUdP[em]) ));

//           s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
//                                             +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
//                                             +unmax*(cVdM[em]-cVdP[em]) ));



//         }
//           }
//         }
//       }

//     barrier(localMemFence);

//     // lift from surface integration to volume nodes
//     for(int es=0;es<p_cNbS;++es;inner1){
//       for(int n=0;n<p_maxNodesSurfaceCub;++n;inner0){
//          dfloat rhsu[p_cNmtS], rhsv[p_cNmtS];

//         if(n<p_Np){
//         occaUnroll(p_cNmtS)
//         for(int em=0;em<p_cNmtS;++em){
//             rhsu[em] = 0.f;
//             rhsv[em] = 0.f;
//         }
//         //
//         occaUnroll(p_intNfpNfaces)
//         for(int m=0;m<p_intNfpNfaces;++m){
//             const dfloat L = intLIFTT[n+m*p_Np];
//             occaUnroll(p_cNmtS)
//             for(int em=0;em<p_cNmtS;++em){
//               rhsu[em] += L*s_iFluxU[em][es][m];
//               rhsv[em] += L*s_iFluxV[em][es][m];
//             }
//           }

//         occaUnroll(p_cNmtS)
//         for(int em=0;em<p_cNmtS;++em){
//           int e = eo+es*p_cNmtS+em;
//           if(e<Nelements){
//             const int id = e*p_Np+n;
//             rhsU[id]   += rhsu[em]; // note  change in sign
//             rhsV[id]   += rhsv[em];    

//             }
//           }
//           }
//         }
//       }
      

//   }

// }








// // ===========================================================================================================

// // compute div(NU)  = div(uxu) in collocation way
// kernel void insSubCycleVolume2D(const int Nelements,
// 				const dfloat * restrict vgeo,
// 				const dfloat * restrict DrT,
// 				const dfloat * restrict DsT,
// 				const dfloat * restrict Ux,
// 				const dfloat * restrict Uy,
// 				const dfloat * restrict Px,
// 				const dfloat * restrict Py,
// 				dfloat * restrict rhsUx,
// 				dfloat * restrict rhsUy){

//   for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_F11[p_NblockV][p_Np];
//     shared dfloat s_F12[p_NblockV][p_Np];
//     shared dfloat s_F21[p_NblockV][p_Np];
//     shared dfloat s_F22[p_NblockV][p_Np];
//     //
//     for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
// 	int e = eo+es; // element in block
// 	if(e<Nelements){ 
// 	  const int id = e*p_Np+n;

// 	  const dfloat ux = Ux[id];
// 	  const dfloat uy = Uy[id];
// 	  const dfloat px = Px[id];
// 	  const dfloat py = Py[id];
// 	  //
// 	  s_F11[es][n] = ux*px;
// 	  s_F12[es][n] = uy*px;

// 	  s_F21[es][n] = ux*py;
// 	  s_F22[es][n] = uy*py;
// 	}
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int es=0;es<p_NblockV;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){      
// 	int e = eo+es; 
// 	if(e<Nelements){    
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
// 	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
// 	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
// 	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat df11dr = 0.f, df11ds = 0.f; 
// 	  dfloat df12dr = 0.f, df12ds = 0.f; 
// 	  dfloat df21dr = 0.f, df21ds = 0.f; 
// 	  dfloat df22dr = 0.f, df22ds = 0.f; 
// 	  //
// 	  occaUnroll(p_Np)
// 	    for(int i=0;i<p_Np;++i){

// 	      const dfloat Drni = DrT[n+i*p_Np];
// 	      const dfloat Dsni = DsT[n+i*p_Np];

// 	      df11dr += Drni*s_F11[es][i];
// 	      df11ds += Dsni*s_F11[es][i];

// 	      df12dr += Drni*s_F12[es][i];
// 	      df12ds += Dsni*s_F12[es][i];

// 	      df21dr += Drni*s_F21[es][i];
// 	      df21ds += Dsni*s_F21[es][i];

// 	      df22dr += Drni*s_F22[es][i];
// 	      df22ds += Dsni*s_F22[es][i];

// 	    }

// 	  dfloat rhsux   = drdx*df11dr + dsdx*df11ds 
// 	    + drdy*df12dr + dsdy*df12ds;

// 	  dfloat rhsuy   = drdx*df21dr + dsdx*df21ds 
// 	    + drdy*df22dr + dsdy*df22ds;

// 	  const int id = e*p_Np+n;
// 	  // Compute div(uxu)
// 	  rhsUx[id]   = rhsux;
// 	  rhsUy[id]   = rhsuy;     
// 	}
//       }
//     }
//   }
// }















// Just play with numbers
// #if p_N==1
// #define p_Npad 29
// #define p_cubNpad 26
// #endif

// #if p_N==2
// #define p_Npad 26
// #define p_cubNpad 20
// #endif

// #if p_N==3
// #define p_Npad 22
// #define p_cubNpad 13
// #endif

// #if p_N==4
// #define p_Npad 17
// #define p_cubNpad 28
// #endif

// #if p_N==5
// #define p_Npad 11
// #define p_cubNpad 10
// #endif

// #if p_N==6
// #define p_Npad 4
// #define p_cubNpad 23
// #endif

// #if p_N==7
// #define p_Npad 28
// #define p_cubNpad 3
// #endif

// #if p_N==8
// #define p_Npad 19
// #define p_cubNpad 10
// #endif

// #if p_N==9
// #define p_Npad 9
// #define p_cubNpad 15
// #endif

// #if p_N==10
// #define p_Npad 30
// #define p_cubNpad 0
// #endif



// kernel void insSubCycleCubatureVolume2D_v5(const int Nelements,
//             const dfloat * restrict vgeo,
//             const dfloat * restrict cubDrWT,
//             const dfloat * restrict cubDsWT,
//             const dfloat * restrict cubInterpT,
//             const dfloat * restrict U,
//             const dfloat * restrict V,
//             const dfloat * restrict Ud,
//             const dfloat * restrict Vd,
//             dfloat * restrict rhsU,
//             dfloat * restrict rhsV){

//   for(int eo=0;eo<Nelements;eo+=(p_cNbV*p_Nmult);outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat  s_U[p_Nmult][p_cubNblockV][p_Np];
//     shared dfloat  s_V[p_Nmult][p_cubNblockV][p_Np];
//     shared dfloat s_Ud[p_Nmult][p_cubNblockV][p_Np];
//     shared dfloat s_Vd[p_Nmult][p_cubNblockV][p_Np];
    
//     shared dfloat s_cF11[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
//     shared dfloat s_cF12[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
//     shared dfloat s_cF21[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
//     shared dfloat s_cF22[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
    
//     //
//     for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block      
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
  
//  occaUnroll(p_Nmult)
//    for(int em=0;em<p_Nmult;++em){
//      const int e = eo + es*p_Nmult + em;
//      const int id = e*p_Np + n;
      
//      if(e<Nelements && n<p_Np){
        
//        // prefetch geometric factors (constant on triangle)
//        const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//        const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//        const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//        const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
        
//        const dfloat Un = U[id];
//        const dfloat Vn = V[id];
        
//        s_Ud[em][es][n] = Ud[id];
//        s_Vd[em][es][n] = Vd[id];
        
//        s_U[em][es][n] = drdx*Un + drdy*Vn; // rotate velocity 
//        s_V[em][es][n] = dsdx*Un + dsdy*Vn; // 
//      }
//      else{
//        s_U[em][es][n] = 0;
//        s_V[em][es][n] = 0;
//        s_Ud[em][es][n] = 0;
//        s_Vd[em][es][n] = 0;
//      }
//    }
//       }
//     }
    
//     barrier(localMemFence);
    
//     for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element

//  dfloat cU[p_Nmult], cV[p_Nmult], cUd[p_Nmult], cVd[p_Nmult];
  
//  occaUnroll(p_Nmult)
//    for(int em=0;em<p_Nmult;++em){
//      cU[em] = 0.f;
//      cV[em] = 0.f;
//      cUd[em] = 0.f; 
//      cVd[em] = 0.f;
//    }
  
//  occaUnroll(p_Np)
//    for(int i=0;i<p_Np;++i){
//      const dfloat cIni = cubInterpT[n+i*p_cubNp];
//      occaUnroll(p_Nmult)
//        for(int em=0;em<p_Nmult;++em){
//    cU[em]  += cIni*s_U[em][es][i];
//    cV[em]  += cIni*s_V[em][es][i];
//    cUd[em] += cIni*s_Ud[em][es][i];
//    cVd[em] += cIni*s_Vd[em][es][i];        
//        }
//    }
  
//  //
//  occaUnroll(p_Nmult)
//    for(int em=0;em<p_Nmult;++em){
//      s_cF11[em][es][n] = cU[em]*cUd[em];
//      s_cF12[em][es][n] = cV[em]*cUd[em];
//      s_cF21[em][es][n] = cU[em]*cVd[em];
//      s_cF22[em][es][n] = cV[em]*cVd[em];
//    }
//       }
//     }
    
//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);
    
//     for(int es=0;es<p_cubNblockV;++es;inner1){
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){      
  
//  if(n<p_Np){   
//    dfloat fluxU[p_Nmult], fluxV[p_Nmult];
    
//    occaUnroll(p_Nmult)
//      for(int em=0;em<p_Nmult;++em){
//        fluxU[em] = 0;
//        fluxV[em] = 0;
//      }
    
//    occaUnroll(p_cubNp)
//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
        
//        occaUnroll(p_Nmult)
//    for(int em=0;em<p_Nmult;++em){  
//      const dfloat cF11 = s_cF11[em][es][i];
//      const dfloat cF12 = s_cF12[em][es][i];
//      const dfloat cF21 = s_cF21[em][es][i];
//      const dfloat cF22 = s_cF22[em][es][i];
      
//      fluxU[em] += cDrWni*cF11;
//      fluxU[em] += cDsWni*cF12;
//      fluxV[em] += cDrWni*cF21;
//      fluxV[em] += cDsWni*cF22;
//    }
//      }

//    occaUnroll(p_Nmult)
//      for(int em=0;em<p_Nmult;++em){
//        int e = eo+es*p_Nmult+em;
//        if(e<Nelements){
//    const int id = e*p_Np+n;
    
//    rhsU[id]   = -fluxU[em]; // note  change in sign
//    rhsV[id]   = -fluxV[em];      
//        }
//      }
//  }
//       }
//     }
//   }
// }












// // Add unrolling
// kernel void insSubCycleCubatureVolume2D_v3(
//                const int Nelements,
//                const dfloat * restrict vgeo,
//                const dfloat * restrict cubDrWT,
//                const dfloat * restrict cubDsWT,
//                const dfloat * restrict cubInterpT,
//                const dfloat * restrict U,
//                const dfloat * restrict V,
//                const dfloat * restrict Ud,
//                const dfloat * restrict Vd,
//                      dfloat * restrict rhsU,
//                      dfloat * restrict rhsV){

//   for(int e=0;e<Nelements;++e;outer0){  // for all elements

//   // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_Np];
//     shared dfloat s_V[p_Np];
//     shared dfloat s_Ud[p_Np];
//     shared dfloat s_Vd[p_Np];

//     shared dfloat s_cF11[p_cubNp];
//     shared dfloat s_cF12[p_cubNp];
//     shared dfloat s_cF21[p_cubNp];
//     shared dfloat s_cF22[p_cubNp];


//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    if(e<Nelements && n<p_Np){ 
//      int id = e*p_Np+n;
      
//      // prefetch geometric factors (constant on triangle)
//      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      
//      const dfloat Un = U[id];
//      const dfloat Vn = V[id];
      
//      s_Ud[n] = Ud[id];
//      s_Vd[n] = Vd[id];
      
//      s_U[n] = drdx*Un + drdy*Vn; // rotate velocity 
//      s_V[n] = dsdx*Un + dsdy*Vn; // 

//    }
//  }

//    barrier(localMemFence);
  
//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    if(e<Nelements && n<p_cubNp){

//    dfloat cU = 0.f,  cV = 0.f;
//    dfloat cUd = 0.f, cVd = 0.f;
     
//       occaUnroll(p_Np)
//      for(int i=0;i<p_Np;++i){
//        dfloat cIni = cubInterpT[n+i*p_cubNp];
//        cU  += cIni*s_U[i];
//        cV  += cIni*s_V[i];
//        cUd += cIni*s_Ud[i];
//        cVd += cIni*s_Vd[i];        
//      }
//    //
//    s_cF11[n] = cU*cUd;
//    s_cF12[n] = cV*cUd;
//    s_cF21[n] = cU*cVd;
//    s_cF22[n] = cV*cVd;
//    }
//  }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);


//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     

//      if(e<Nelements && n<p_Np){    
       
//         dfloat fluxu = 0.f, fluxv = 0.f; 

//          occaUnroll(p_cubNp)
//            for(int i=0;i<p_cubNp;++i){
//              const dfloat cDrWni = cubDrWT[n+i*p_Np];
//              const dfloat cDsWni = cubDsWT[n+i*p_Np];
//              // Fetch to shared, used twice
//              const dfloat cF11 = s_cF11[es][i];
//              const dfloat cF12 = s_cF12[es][i];
//              const dfloat cF21 = s_cF21[es][i];
//              const dfloat cF22 = s_cF22[es][i];

//              fluxu += cDrWni*cF11 + cDsWni*cF12;
            
//              fluxv += cDrWni*cF21 + cDsWni*cF22;
//            }

//          const int id = e*p_Np+n;

//          rhsU[id]   = -fluxu; // note  change in sign
//          rhsV[id]   = -fluxv;      
//        }
//      }
//    }


// }
// }






// // Add shared memory for global read of U vectors
// kernel void insSubCycleCubatureVolume2D_v1(
//                int Nelements,
//                dfloat * vgeo,
//                dfloat * cubDrWT,
//                dfloat * cubDsWT,
//                dfloat * cubInterpT,
//                dfloat * U,
//                dfloat * V,
//                dfloat * Ud,
//                dfloat * Vd,
//                dfloat * rhsU,
//                dfloat * rhsV){

//   for(int e=0;e<Nelements;++e;outer0){  // for all elements

//   // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_Np];
//     shared dfloat s_V[p_Np];
//     shared dfloat s_Ud[p_Np];
//     shared dfloat s_Vd[p_Np];

//     shared dfloat s_cF11[p_cubNp];
//     shared dfloat s_cF12[p_cubNp];
//     shared dfloat s_cF21[p_cubNp];
//     shared dfloat s_cF22[p_cubNp];

//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//      if(e<Nelements && n<p_Np){ 
//        int id = e*p_Np+n;
//        s_U[n]  = U[id];
//        s_V[n]  = V[id];
//        s_Ud[n] = Ud[id];
//        s_Vd[n] = Vd[id]; 
//      }
//    }

//    barrier(localMemFence);
  
//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    if(e<Nelements && n<p_cubNp){

//    dfloat cU = 0.f,  cV = 0.f;
//    dfloat cUd = 0.f, cVd = 0.f;

//      for(int i=0;i<p_Np;++i){
//        dfloat cIni = cubInterpT[n+i*p_cubNp];
//        cU  += cIni*s_U[i];
//        cV  += cIni*s_V[i];
//        cUd += cIni*s_Ud[i];
//        cVd += cIni*s_Vd[i];        
//      }
//    //
//    s_cF11[n] = cU*cUd;
//    s_cF12[n] = cV*cUd;
//    s_cF21[n] = cU*cVd;
//    s_cF22[n] = cV*cVd;
//    }
//  }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     


//    if(e<Nelements && n<p_Np){    
//    // prefetch geometric factors (constant on triangle)
//    dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//    dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//    dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//    dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
//    // compute 'r' and 's' derivatives of (q_m) at node n
//    dfloat df11dr = 0.f, df11ds = 0.f; 
//    dfloat df12dr = 0.f, df12ds = 0.f; 
//    dfloat df21dr = 0.f, df21ds = 0.f; 
//    dfloat df22dr = 0.f, df22ds = 0.f; 


//      for(int i=0;i<p_cubNp;++i){
//        dfloat cDrWni = cubDrWT[n+i*p_Np];
//        dfloat cDsWni = cubDsWT[n+i*p_Np];
//        // Fetch to shared, used twice
//        dfloat cF11 = s_cF11[i];  // makew them global
//        dfloat cF12 = s_cF12[i];
//        dfloat cF21 = s_cF21[i];
//        dfloat cF22 = s_cF22[i];

//        df11dr += cDrWni*cF11;
//        df11ds += cDsWni*cF11;

//        df12dr += cDrWni*cF12;
//        df12ds += cDsWni*cF12;

//        df21dr += cDrWni*cF21;
//        df21ds += cDsWni*cF21;

//        df22dr += cDrWni*cF22;
//        df22ds += cDsWni*cF22;
//        }

//      dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
//      dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

//      int id = e*p_Np+n;

//      rhsU[id]   = -rhsu; // note  change in sign
//      rhsV[id]   = -rhsv;     
//    }
//  } 


// }
// }



// //Add constants 
// kernel void insSubCycleCubatureVolume2D_v2(
//                const int Nelements,
//                const dfloat * restrict vgeo,
//                const dfloat * restrict cubDrWT,
//                const dfloat * restrict cubDsWT,
//                const dfloat * restrict cubInterpT,
//                const dfloat * restrict U,
//                const dfloat * restrict V,
//                const dfloat * restrict Ud,
//                const dfloat * restrict Vd,
//                      dfloat * restrict rhsU,
//                      dfloat * restrict rhsV){

//   for(int e=0;e<Nelements;++e;outer0){  // for all elements

//   // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_Np];
//     shared dfloat s_V[p_Np];
//     shared dfloat s_Ud[p_Np];
//     shared dfloat s_Vd[p_Np];

//     shared dfloat s_cF11[p_cubNp];
//     shared dfloat s_cF12[p_cubNp];
//     shared dfloat s_cF21[p_cubNp];
//     shared dfloat s_cF22[p_cubNp];

//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//      if(e<Nelements && n<p_Np){ 
//        const int id = e*p_Np+n;
//        s_U[n]  = U[id];
//        s_V[n]  = V[id];
//        s_Ud[n] = Ud[id];
//        s_Vd[n] = Vd[id]; 
//      }
//    }

//    barrier(localMemFence);
  
//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    if(e<Nelements && n<p_cubNp){

//    dfloat cU = 0.f,  cV = 0.f;
//    dfloat cUd = 0.f, cVd = 0.f;

//      for(int i=0;i<p_Np;++i){
//        dfloat cIni = cubInterpT[n+i*p_cubNp];
//        cU  += cIni*s_U[i];
//        cV  += cIni*s_V[i];
//        cUd += cIni*s_Ud[i];
//        cVd += cIni*s_Vd[i];        
//      }
//    //
//    s_cF11[n] = cU*cUd;
//    s_cF12[n] = cV*cUd;
//    s_cF21[n] = cU*cVd;
//    s_cF22[n] = cV*cVd;
//    }
//  }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     


//    if(e<Nelements && n<p_Np){    
//    // prefetch geometric factors (constant on triangle)
//    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
//    // compute 'r' and 's' derivatives of (q_m) at node n
//    dfloat df11dr = 0.f, df11ds = 0.f; 
//    dfloat df12dr = 0.f, df12ds = 0.f; 
//    dfloat df21dr = 0.f, df21ds = 0.f; 
//    dfloat df22dr = 0.f, df22ds = 0.f; 


//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
//        // Fetch to shared, used twice
//        const dfloat cF11 = s_cF11[i];  // makew them global
//        const dfloat cF12 = s_cF12[i];
//        const dfloat cF21 = s_cF21[i];
//        const dfloat cF22 = s_cF22[i];

//        df11dr += cDrWni*cF11;
//        df11ds += cDsWni*cF11;

//        df12dr += cDrWni*cF12;
//        df12ds += cDsWni*cF12;

//        df21dr += cDrWni*cF21;
//        df21ds += cDsWni*cF21;

//        df22dr += cDrWni*cF22;
//        df22ds += cDsWni*cF22;
//        }

//      const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
      
//      const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

//      const int id = e*p_Np+n;

//      rhsU[id]   = -rhsu; // note  change in sign
//      rhsV[id]   = -rhsv;     
//    }
//  } 


// }
// }




// // Add unrolling
// kernel void insSubCycleCubatureVolume2D_v2(
//                const int Nelements,
//                const dfloat * restrict vgeo,
//                const dfloat * restrict cubDrWT,
//                const dfloat * restrict cubDsWT,
//                const dfloat * restrict cubInterpT,
//                const dfloat * restrict U,
//                const dfloat * restrict V,
//                const dfloat * restrict Ud,
//                const dfloat * restrict Vd,
//                      dfloat * restrict rhsU,
//                      dfloat * restrict rhsV){

//   for(int e=0;e<Nelements;++e;outer0){  // for all elements

//   // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_Np];
//     shared dfloat s_V[p_Np];
//     shared dfloat s_Ud[p_Np];
//     shared dfloat s_Vd[p_Np];

//     shared dfloat s_cF11[p_cubNp];
//     shared dfloat s_cF12[p_cubNp];
//     shared dfloat s_cF21[p_cubNp];
//     shared dfloat s_cF22[p_cubNp];

//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//      if(e<Nelements && n<p_Np){ 
//        const int id = e*p_Np+n;
//        s_U[n]  = U[id];
//        s_V[n]  = V[id];
//        s_Ud[n] = Ud[id];
//        s_Vd[n] = Vd[id]; 
//      }
//    }

//    barrier(localMemFence);
  
//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    if(e<Nelements && n<p_cubNp){

//    dfloat cU = 0.f,  cV = 0.f;
//    dfloat cUd = 0.f, cVd = 0.f;
     
//       occaUnroll(p_Np)
//      for(int i=0;i<p_Np;++i){
//        dfloat cIni = cubInterpT[n+i*p_cubNp];
//        cU  += cIni*s_U[i];
//        cV  += cIni*s_V[i];
//        cUd += cIni*s_Ud[i];
//        cVd += cIni*s_Vd[i];        
//      }
//    //
//    s_cF11[n] = cU*cUd;
//    s_cF12[n] = cV*cUd;
//    s_cF21[n] = cU*cVd;
//    s_cF22[n] = cV*cVd;
//    }
//  }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//  for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     


//    if(e<Nelements && n<p_Np){    
//    // prefetch geometric factors (constant on triangle)
//    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
//    // compute 'r' and 's' derivatives of (q_m) at node n
//    dfloat df11dr = 0.f, df11ds = 0.f; 
//    dfloat df12dr = 0.f, df12ds = 0.f; 
//    dfloat df21dr = 0.f, df21ds = 0.f; 
//    dfloat df22dr = 0.f, df22ds = 0.f; 

//       occaUnroll(p_cubNp)
//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
//        // Fetch to shared, used twice
//        const dfloat cF11 = s_cF11[i];  // makew them global
//        const dfloat cF12 = s_cF12[i];
//        const dfloat cF21 = s_cF21[i];
//        const dfloat cF22 = s_cF22[i];

//        df11dr += cDrWni*cF11;
//        df11ds += cDsWni*cF11;

//        df12dr += cDrWni*cF12;
//        df12ds += cDsWni*cF12;

//        df21dr += cDrWni*cF21;
//        df21ds += cDsWni*cF21;

//        df22dr += cDrWni*cF22;
//        df22ds += cDsWni*cF22;
//        }

//      const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
//      const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

//      const int id = e*p_Np+n;

//      rhsU[id]   = -rhsu; // note  change in sign
//      rhsV[id]   = -rhsv;     
//    }
//  } 


// }
// }



// // Add multiple elements per block
// kernel void insSubCycleCubatureVolume2D_v3(const int Nelements,
//          const dfloat * restrict vgeo,
//          const dfloat * restrict cubDrWT,
//          const dfloat * restrict cubDsWT,
//          const dfloat * restrict cubInterpT,
//          const dfloat * restrict U,
//          const dfloat * restrict V,
//          const dfloat * restrict Ud,
//          const dfloat * restrict Vd,
//              dfloat * restrict rhsU,
//              dfloat * restrict rhsV){

//   for(int eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_cubNblockV][p_Np];
//     shared dfloat s_V[p_cubNblockV][p_Np];
//     shared dfloat s_Ud[p_cubNblockV][p_Np];
//     shared dfloat s_Vd[p_cubNblockV][p_Np];

//     shared dfloat s_cF11[p_cubNblockV][p_cubNp];
//     shared dfloat s_cF12[p_cubNblockV][p_cubNp];
//     shared dfloat s_cF21[p_cubNblockV][p_cubNp];
//     shared dfloat s_cF22[p_cubNblockV][p_cubNp];
//     //
//     for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//        int e = eo+es; // element in block
//        if(e<Nelements && n<p_Np){ 
//          const int id = e*p_Np+n;
//          s_U[es][n]  = U[id];
//          s_V[es][n]  = V[id];
//          s_Ud[es][n] = Ud[id];
//          s_Vd[es][n] = Vd[id];

//  }   
//       }
//     }

//     barrier(localMemFence);

//     for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//  int e = eo+es; // element in block
//  if(e<Nelements && n<p_cubNp){

//    dfloat cU = 0.f,  cV = 0.f;
//    dfloat cUd = 0.f, cVd = 0.f;

//    occaUnroll(p_Np)
//      for(int i=0;i<p_Np;++i){
//        dfloat cIni = cubInterpT[n+i*p_cubNp];
//        cU  += cIni*s_U[es][i];
//        cV  += cIni*s_V[es][i];
//        cUd += cIni*s_Ud[es][i];
//        cVd += cIni*s_Vd[es][i];        
//      }
//    //
//    s_cF11[es][n] = cU*cUd;
//    s_cF12[es][n] = cV*cUd;
//    s_cF21[es][n] = cU*cVd;
//    s_cF22[es][n] = cV*cVd;
//  }
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(int es=0;es<p_cubNblockV;++es;inner1){
//       for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){      
//  int e = eo+es;

//  if(e<Nelements && n<p_Np){    
//    // prefetch geometric factors (constant on triangle)
//    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
//    // compute 'r' and 's' derivatives of (q_m) at node n
//    dfloat df11dr = 0.f, df11ds = 0.f; 
//    dfloat df12dr = 0.f, df12ds = 0.f; 
//    dfloat df21dr = 0.f, df21ds = 0.f; 
//    dfloat df22dr = 0.f, df22ds = 0.f; 

//    occaUnroll(p_cubNp)
//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
//        // Fetch to shared, used twice
//        const dfloat cF11 = s_cF11[es][i];
//        const dfloat cF12 = s_cF12[es][i];
//        const dfloat cF21 = s_cF21[es][i];
//        const dfloat cF22 = s_cF22[es][i];

//        df11dr += cDrWni*cF11;
//        df11ds += cDsWni*cF11;

//        df12dr += cDrWni*cF12;
//        df12ds += cDsWni*cF12;

//        df21dr += cDrWni*cF21;
//        df21ds += cDsWni*cF21;

//        df22dr += cDrWni*cF22;
//        df22ds += cDsWni*cF22;
//      }

//    const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
//    const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

//    const int id = e*p_Np+n;

//    rhsU[id]   = -rhsu; // note  change in sign
//    rhsV[id]   = -rhsv;     
//  }
//       }
//     }

//   }

// }




// // Use less shared memory, with one more memory fence
// kernel void insSubCycleCubatureVolume2D_v4(const int Nelements,
//          const dfloat * restrict vgeo,
//          const dfloat * restrict cubDrWT,
//          const dfloat * restrict cubDsWT,
//          const dfloat * restrict cubInterpT,
//          const dfloat * restrict U,
//          const dfloat * restrict V,
//          const dfloat * restrict Ud,
//          const dfloat * restrict Vd,
//          dfloat * restrict rhsU,
//          dfloat * restrict rhsV){
  
//   for(int eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat s_U[p_cubNblockV][p_cubNp];
//     shared dfloat s_V[p_cubNblockV][p_cubNp];
//     shared dfloat s_Ud[p_cubNblockV][p_cubNp];
//     shared dfloat s_Vd[p_cubNblockV][p_cubNp];

//    #define s_cF11 s_U
//    #define s_cF12 s_V
//    #define s_cF21 s_Ud
//    #define s_cF22 s_Vd

//     exclusive dfloat cU, cV, cUd, cVd;

//  //
//  for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//    int e = eo+es; // element in block
//      if(e<Nelements && n<p_Np){ 
//        const int id = e*p_Np+n;
//        s_U[es][n]  = U[id];
//        s_V[es][n]  = V[id];
//        s_Ud[es][n] = Ud[id];
//        s_Vd[es][n] = Vd[id];
//      }   
//    }
//  }
    
//     barrier(localMemFence);
    
//  for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//      int e = eo+es; // element in block
//      if(e<Nelements && n<p_cubNp){

//        cU = 0.f;  cV = 0.f;
//        cUd = 0.f; cVd = 0.f;

//        occaUnroll(p_Np)
//        for(int i=0;i<p_Np;++i){
//          dfloat cIni = cubInterpT[n+i*p_cubNp];
//          cU  += cIni*s_U[es][i];
//          cV  += cIni*s_V[es][i];
//          cUd += cIni*s_Ud[es][i];
//          cVd += cIni*s_Vd[es][i];        
//        }
//      }
//    }
//  }

//     barrier(localMemFence);

//  for(int es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
//      int e = eo+es; // element in block
//      if(e<Nelements && n<p_cubNp){
//        //
//        s_cF11[es][n] = cU*cUd;
//        s_cF12[es][n] = cV*cUd;
//        s_cF21[es][n] = cU*cVd;
//        s_cF22[es][n] = cV*cVd;
//      }
//    }
//  }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);

//  for(int es=0;es<p_cubNblockV;++es;inner1){
//    for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     
//    int e = eo+es;

//      if(e<Nelements && n<p_Np){    
//      // prefetch geometric factors (constant on triangle)
//      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

//      // compute 'r' and 's' derivatives of (q_m) at node n
//      dfloat df11dr = 0.f, df11ds = 0.f; 
//      dfloat df12dr = 0.f, df12ds = 0.f; 
//      dfloat df21dr = 0.f, df21ds = 0.f; 
//      dfloat df22dr = 0.f, df22ds = 0.f; 

//      occaUnroll(p_cubNp)
//        for(int i=0;i<p_cubNp;++i){
//          const dfloat cDrWni = cubDrWT[n+i*p_Np];
//          const dfloat cDsWni = cubDsWT[n+i*p_Np];

//          const dfloat cF11 = s_cF11[es][i];
//          const dfloat cF12 = s_cF12[es][i];
//          const dfloat cF21 = s_cF21[es][i];
//          const dfloat cF22 = s_cF22[es][i];

//          df11dr += cDrWni*cF11;
//          df11ds += cDsWni*cF11;

//          df12dr += cDrWni*cF12;
//          df12ds += cDsWni*cF12;

//          df21dr += cDrWni*cF21;
//          df21ds += cDsWni*cF21;

//          df22dr += cDrWni*cF22;
//          df22ds += cDsWni*cF22;
//        }

        
//        const int id = e*p_Np+n;

//        rhsU[id]   = -(drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds); // note  change in sign
//        rhsV[id]   = -(drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds);      
//        }
//      }
//    }
//  }

// #undef s_cF11
// #undef s_cF12
// #undef s_cF21
// #undef s_cF22
// }
















// #define p_NbV 4

// #define p_Nout 1

// #if ((p_Np)<(p_cubNp))
// #define p_Nout 2
// #endif
// #if ((p_Np*2)<(p_cubNp))
// #define p_Nout 3
// #endif
// #if ((p_Np*3)<(p_cubNp))
// #define p_Nout 4
// #endif

// kernel void insSubCycleCubatureVolume2D_v7(const int Nelements,
//             const dfloat * restrict vgeo,
//             const dfloat * restrict cubDrWT,
//             const dfloat * restrict cubDsWT,
//             const dfloat * restrict cubInterpT,
//             const dfloat * restrict U,
//             const dfloat * restrict V,
//             const dfloat * restrict Ud,
//             const dfloat * restrict Vd,
//             dfloat * restrict rhsU,
//             dfloat * restrict rhsV){
  
//   for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat  s_U[p_NblockV][p_Np];
//     shared dfloat  s_V[p_NblockV][p_Np];
//     shared dfloat s_Ud[p_NblockV][p_Np];
//     shared dfloat s_Vd[p_NblockV][p_Np];
    
//     shared dfloat s_cF11[p_NblockV][p_cubNp];
//     shared dfloat s_cF12[p_NblockV][p_cubNp];
//     shared dfloat s_cF21[p_NblockV][p_cubNp];
//     shared dfloat s_cF22[p_NblockV][p_cubNp];
    
//     //
//     for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block      
//       for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
  
//  const int e = eo + es;
//  const int id = e*p_Np + n;
  
//  if(e<Nelements){
    
//    // prefetch geometric factors (constant on triangle)
//    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
    
//    const dfloat Un = U[id];
//    const dfloat Vn = V[id];
    
//    s_Ud[es][n] = Ud[id];
//    s_Vd[es][n] = Vd[id];
    
//    s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
//    s_V[es][n] = dsdx*Un + dsdy*Vn; // 
//  }
//       }
//     }
    
//     barrier(localMemFence);

//     for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(int t=0;t<p_Np;++t;inner0){     // for all nodes in this element
//  dfloat cU[p_Nout], cV[p_Nout], cUd[p_Nout], cVd[p_Nout];

//  occaUnroll(p_Nout)
//    for(int nout=0;nout<p_Nout;++nout){
//      cU[nout] = 0.f;
//      cV[nout] = 0.f;
//      cUd[nout] = 0.f; 
//      cVd[nout] = 0.f;
//    }

//  occaUnroll(p_Np)
//    for(int i=0;i<p_Np;++i){
      
//      const dfloat Ui = s_U[es][i];
//      const dfloat Vi = s_V[es][i];
//      const dfloat Udi = s_Ud[es][i];
//      const dfloat Vdi = s_Vd[es][i];
      
//      occaUnroll(p_Nout)
//        for(int nout=0;nout<p_Nout;++nout){
//          const int n = p_Np*nout + t;
//          if(n<p_cubNp){
//           const dfloat cIni = cubInterpT[n+i*p_cubNp];
            
//            cU[nout]  += cIni*Ui;
//            cV[nout]  += cIni*Vi;
//            cUd[nout] += cIni*Udi;
//            cVd[nout] += cIni*Vdi;
//          }
//        }
//    }
  
//  occaUnroll(p_Nout)
//    for(int nout=0;nout<p_Nout;++nout){
//      const int n = p_Np*nout + t;
//      if(n<p_cubNp){
//        s_cF11[es][n] = cU[nout]*cUd[nout];
//        s_cF12[es][n] = cV[nout]*cUd[nout];
//        s_cF21[es][n] = cU[nout]*cVd[nout];
//        s_cF22[es][n] = cV[nout]*cVd[nout];
//      }
//    }
//       }
//     }

//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);
    
//     for(int es=0;es<p_NblockV;++es;inner1){
//       for(int n=0;n<p_Np;++n;inner0){     
//  int e = eo+es;
//  if(e<Nelements){
    
//    dfloat fluxU = 0, fluxV = 0;
    
//    occaUnroll(p_cubNp)
//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
        
//        const dfloat cF11 = s_cF11[es][i];
//        const dfloat cF12 = s_cF12[es][i];
//        const dfloat cF21 = s_cF21[es][i];
//        const dfloat cF22 = s_cF22[es][i];
        
//        fluxU += cDrWni*cF11;
//        fluxU += cDsWni*cF12;
//        fluxV += cDrWni*cF21;
//        fluxV += cDsWni*cF22;
//      }
    
//    const int id = e*p_Np+n;
    
//    rhsU[id]   = -fluxU; // note  change in sign
//    rhsV[id]   = -fluxV;      
//  }
//       }
//     }
//   }
// }


// // TW tweaks
// kernel void insSubCycleCubatureVolume2D_v8(const int Nelements,
//             const dfloat * restrict vgeo,
//             const dfloat * restrict cubDrWT,
//             const dfloat * restrict cubDsWT,
//             const dfloat * restrict cubInterpT,
//             const dfloat * restrict U,
//             const dfloat * restrict V,
//             const dfloat * restrict Ud,
//             const dfloat * restrict Vd,
//             dfloat * restrict rhsU,
//             dfloat * restrict rhsV){

// #define p_NblockE 1

//   for(int eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat  s_U[p_NblockE][p_Np];
//     shared dfloat  s_V[p_NblockE][p_Np];
//     shared dfloat s_Ud[p_NblockE][p_Np];
//     shared dfloat s_Vd[p_NblockE][p_Np];

//     shared dfloat s_cF11[p_NblockE][p_cubNp];
//     shared dfloat s_cF12[p_NblockE][p_cubNp];
//     shared dfloat s_cF21[p_NblockE][p_cubNp];
//     shared dfloat s_cF22[p_NblockE][p_cubNp];
    
//     //
//     for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element

//       occaUnroll(p_NblockE)
//  for(int es=0;es<p_NblockE;++es){
//    const int e = eo + es;
//    const int id = e*p_Np + n;
    
//    if(e<Nelements && n<p_Np){
      
//      // prefetch geometric factors (constant on triangle)
//      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      
//      const dfloat Un = U[id];
//      const dfloat Vn = V[id];
      
//      s_Ud[es][n] = Ud[id];
//      s_Vd[es][n] = Vd[id];
      
//      s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
//      s_V[es][n] = dsdx*Un + dsdy*Vn; // 
//    }
//    else{
//      s_U[es][n] = 0;
//      s_V[es][n] = 0;
//      s_Ud[es][n] = 0;
//      s_Vd[es][n] = 0;
//    }
//  }
//     }
    
//     barrier(localMemFence);

//     for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
      
//       dfloat cU[p_NblockE], cV[p_NblockE], cUd[p_NblockE], cVd[p_NblockE];

//       occaUnroll(p_NblockE)
//  for(int es=0;es<p_NblockE;++es){      
//    cU[es] = 0.f;
//    cV[es] = 0.f;
//    cUd[es] = 0.f; 
//    cVd[es] = 0.f;
//  }
      
//       occaUnroll(p_Np)
//  for(int i=0;i<p_Np;++i){
//    const dfloat cIni = cubInterpT[n+i*p_cubNp];
    
//    // block here to minimize fetches of cubInterpT
//    occaUnroll(p_NblockE)
//      for(int es=0;es<p_NblockE;++es){      
//        cU[es]  += cIni*s_U[es][i];
//        cV[es]  += cIni*s_V[es][i];
//        cUd[es] += cIni*s_Ud[es][i];
//        cVd[es] += cIni*s_Vd[es][i];        
//      }
//  }
      
//       //
//       occaUnroll(p_NblockE)
//  for(int es=0;es<p_NblockE;++es){      
//    s_cF11[es][n] = cU[es]*cUd[es];
//    s_cF12[es][n] = cV[es]*cUd[es];
//    s_cF21[es][n] = cU[es]*cVd[es];
//    s_cF22[es][n] = cV[es]*cVd[es];
//  }
//     }
    
//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);
    
//     for(int n=0;n<p_maxNodesVolumeCub;++n;inner0){      
      
//       if(n<p_Np){    
//  dfloat fluxU[p_NblockE], fluxV[p_NblockE];
  
//  occaUnroll(p_NblockE)
//    for(int es=0;es<p_NblockE;++es){      
//      fluxU[es] = 0;
//      fluxV[es] = 0;
//    }
  
//    occaUnroll(p_cubNp)
//      for(int i=0;i<p_cubNp;++i){
//        const dfloat cDrWni = cubDrWT[n+i*p_Np];
//        const dfloat cDsWni = cubDsWT[n+i*p_Np];
        
//        occaUnroll(p_NblockE)
//    for(int es=0;es<p_NblockE;++es){      
//      const dfloat cF11 = s_cF11[es][i];
//      const dfloat cF12 = s_cF12[es][i];
//      const dfloat cF21 = s_cF21[es][i];
//      const dfloat cF22 = s_cF22[es][i];
      
//      fluxU[es] += cDrWni*cF11;
//      fluxU[es] += cDsWni*cF12;
//      fluxV[es] += cDrWni*cF21;
//      fluxV[es] += cDsWni*cF22;
//    }
//      }
    
//    occaUnroll(p_NblockE)
//      for(int es=0;es<p_NblockE;++es){      
//        const int e = eo+es;
//        if(e<Nelements){
//    const int id = e*p_Np+n;
    
//    rhsU[id]   = -fluxU[es]; // note  change in sign
//    rhsV[id]   = -fluxV[es];      
//        }
//      }
//       }
//     }
//   }
// }


// // TW tweaks
// kernel void insSubCycleCubatureVolume2D_v9(const int Nelements,
//             const dfloat * restrict vgeo,
//             const dfloat * restrict cubDrWT,
//             const dfloat * restrict cubDsWT,
//             const dfloat * restrict cubInterpT,
//             const dfloat * restrict U,
//             const dfloat * restrict V,
//             const dfloat * restrict Ud,
//             const dfloat * restrict Vd,
//             dfloat * restrict rhsU,
//             dfloat * restrict rhsV){

// #define p_NblockE 2

//   for(int eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat  s_U[p_NblockE][p_Np];
//     shared dfloat  s_V[p_NblockE][p_Np];
//     shared dfloat s_Ud[p_NblockE][p_Np];
//     shared dfloat s_Vd[p_NblockE][p_Np];

//     shared dfloat s_cF11[p_NblockE][p_cubNp];
//     shared dfloat s_cF12[p_NblockE][p_cubNp];
//     shared dfloat s_cF21[p_NblockE][p_cubNp];
//     shared dfloat s_cF22[p_NblockE][p_cubNp];
    
//     //
//     for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

//       occaUnroll(p_NblockE)
//  for(int es=0;es<p_NblockE;++es){
//    const int e = eo + es;
//    const int id = e*p_Np + n;
    
//    if(e<Nelements){
      
//      // prefetch geometric factors (constant on triangle)
//      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      
//      const dfloat Un = U[id];
//      const dfloat Vn = V[id];
      
//      s_Ud[es][n] = Ud[id];
//      s_Vd[es][n] = Vd[id];
      
//      s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
//      s_V[es][n] = dsdx*Un + dsdy*Vn; // 
//    }
//    else{
//      s_U[es][n] = 0;
//      s_V[es][n] = 0;
//      s_Ud[es][n] = 0;
//      s_Vd[es][n] = 0;
//    }
//  }
//     }
    
//     barrier(localMemFence);

//     for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

//       for(int m=n;m<p_cubNp;m+=p_Np){
  
//  dfloat cU0 = 0.f, cV0 = 0.f, cUd0 = 0.f, cVd0 = 0.f;
//  dfloat cU1 = 0.f, cV1 = 0.f, cUd1 = 0.f, cVd1 = 0.f;
//  int es;

//  //  occaUnroll(p_Np)
//  for(int i=0;i<p_Np;++i){
//      const dfloat cIni = cubInterpT[m+i*p_cubNp];
      
//      // block here to minimize fetches of cubInterpT
//      es = 0;
//      cU0  += cIni*s_U[es][i];
//      cV0  += cIni*s_V[es][i];
//      cUd0 += cIni*s_Ud[es][i];
//      cVd0 += cIni*s_Vd[es][i];       
//      ++es;
//      cU1  += cIni*s_U[es][i];
//      cV1  += cIni*s_V[es][i];
//      cUd1 += cIni*s_Ud[es][i];
//      cVd1 += cIni*s_Vd[es][i];       
//    }
  
//  //
//  es = 0;
//  s_cF11[es][m] = cU0*cUd0;
//  s_cF12[es][m] = cV0*cUd0;
//  s_cF21[es][m] = cU0*cVd0;
//  s_cF22[es][m] = cV0*cVd0;
//  ++es;
//  s_cF11[es][m] = cU1*cUd1;
//  s_cF12[es][m] = cV1*cUd1;
//  s_cF21[es][m] = cU1*cVd1;
//  s_cF22[es][m] = cV1*cVd1;
//       }
//     }
    
//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);
    
//     for(int n=0;n<p_Np;++n;inner0){     
      
//       dfloat fluxU0 = 0, fluxV0 = 0;
//       dfloat fluxU1 = 0, fluxV1 = 0;
      
//       occaUnroll(p_cubNp)
//  for(int i=0;i<p_cubNp;++i){
//    const dfloat cDrWni = cubDrWT[n+i*p_Np];
//    const dfloat cDsWni = cubDsWT[n+i*p_Np];
    
//    {
//      int es = 0;
//      const dfloat cF11 = s_cF11[es][i];
//      const dfloat cF12 = s_cF12[es][i];
//      const dfloat cF21 = s_cF21[es][i];
//      const dfloat cF22 = s_cF22[es][i];
      
//      fluxU0 += cDrWni*cF11;
//      fluxU0 += cDsWni*cF12;
//      fluxV0 += cDrWni*cF21;
//      fluxV0 += cDsWni*cF22;
//    }

//    {
//      int es = 1;
//      const dfloat cF11 = s_cF11[es][i];
//      const dfloat cF12 = s_cF12[es][i];
//      const dfloat cF21 = s_cF21[es][i];
//      const dfloat cF22 = s_cF22[es][i];
      
//      fluxU1 += cDrWni*cF11;
//      fluxU1 += cDsWni*cF12;
//      fluxV1 += cDrWni*cF21;
//      fluxV1 += cDsWni*cF22;
//    }
//  }
      
//       int e = eo+0;
//       if(e<Nelements){
//  const int id = e*p_Np+n;
  
//  rhsU[id]   = -fluxU0; 
//  rhsV[id]   = -fluxV0;     
//       }
//       e = eo+1;
//       if(e<Nelements){
//  const int id = e*p_Np+n;
  
//  rhsU[id]   = -fluxU1; 
//  rhsV[id]   = -fluxV1;     
//       }
//     }
//   }
// }


// // TW tweaks
// kernel void insSubCycleCubatureVolume2D_v10(const int Nelements,
//             const dfloat * restrict vgeo,
//             const dfloat * restrict cubDrWT,
//             const dfloat * restrict cubDsWT,
//             const dfloat * restrict cubInterpT,
//             const dfloat * restrict U,
//             const dfloat * restrict V,
//             const dfloat * restrict Ud,
//             const dfloat * restrict Vd,
//             dfloat * restrict rhsU,
//             dfloat * restrict rhsV){

// #define p_NblockE 2

//   for(int eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
//     // Hold Flux Vector on Shared, use symmetry f21 = f12
//     shared dfloat  s_U[p_NblockE][p_Np];
//     shared dfloat  s_V[p_NblockE][p_Np];
//     shared dfloat s_Ud[p_NblockE][p_Np];
//     shared dfloat s_Vd[p_NblockE][p_Np];

//     shared dfloat s_cF11[p_NblockE][p_cubNp];
//     shared dfloat s_cF12[p_NblockE][p_cubNp];
//     shared dfloat s_cF21[p_NblockE][p_cubNp];
//     shared dfloat s_cF22[p_NblockE][p_cubNp];
    
//     //
//     for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

//       occaUnroll(p_NblockE)
//  for(int es=0;es<p_NblockE;++es){
//    const int e = eo + es;
//    const int id = e*p_Np + n;
    
//    if(e<Nelements){
      
//      // prefetch geometric factors (constant on triangle)
//      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
//      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
//      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
//      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      
//      const dfloat Un = U[id];
//      const dfloat Vn = V[id];
      
//      s_Ud[es][n] = Ud[id];
//      s_Vd[es][n] = Vd[id];
      
//      s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
//      s_V[es][n] = dsdx*Un + dsdy*Vn; // 
//    }
//    else{
//      s_U[es][n] = 0;
//      s_V[es][n] = 0;
//      s_Ud[es][n] = 0;
//      s_Vd[es][n] = 0;
//    }
//  }
//     }
    
//     barrier(localMemFence);

//     for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

//       dfloat cU[p_NblockE], cV[p_NblockE], cUd[p_NblockE], cVd[p_NblockE];
      
//       for(int m=n;m<p_cubNp;m+=p_Np){
  
//  occaUnroll(p_NblockE)
//    for(int es = 0; es<p_NblockE;++es){
//      cU[es] = 0;
//      cV[es] = 0;
//      cUd[es] = 0;
//      cVd[es] = 0;
//    }

//  for(int i=0;i<p_Np;++i){
//      const dfloat cIni = cubInterpT[m+i*p_cubNp];
      
//      // block here to minimize fetches of cubInterpT
//      int es = 0;
//      cU[es]  += cIni*s_U[es][i];
//      cV[es]  += cIni*s_V[es][i];
//      cUd[es] += cIni*s_Ud[es][i];
//      cVd[es] += cIni*s_Vd[es][i];        
//      ++es;
//      cU[es]  += cIni*s_U[es][i];
//      cV[es]  += cIni*s_V[es][i];
//      cUd[es] += cIni*s_Ud[es][i];
//      cVd[es] += cIni*s_Vd[es][i];        
//  }
  
//  occaUnroll(p_NblockE)
//    for(int es = 0; es<p_NblockE;++es){
//      s_cF11[es][m] = cU[es]*cUd[es];
//      s_cF12[es][m] = cV[es]*cUd[es];
//      s_cF21[es][m] = cU[es]*cVd[es];
//      s_cF22[es][m] = cV[es]*cVd[es];
//    }
//       }
//     }
    
//     // Make sure all node data is loaded into shared
//     barrier(localMemFence);
    
//     for(int n=0;n<p_Np;++n;inner0){     
      
//       dfloat fluxU[p_NblockE], fluxV[p_NblockE];
      
//       occaUnroll(p_NblockE)
//  for(int es = 0; es<p_NblockE;++es){   
//    fluxU[es] = 0;
//    fluxV[es] = 0;
//  }
      
//       occaUnroll(p_cubNp)
//  for(int i=0;i<p_cubNp;++i){
//    const dfloat cDrWni = cubDrWT[n+i*p_Np];
//    const dfloat cDsWni = cubDsWT[n+i*p_Np];

//    int es = 0;
//    {
//      const dfloat cF11 = s_cF11[es][i];
//      const dfloat cF12 = s_cF12[es][i];
//      const dfloat cF21 = s_cF21[es][i];
//      const dfloat cF22 = s_cF22[es][i];
      
//      fluxU[es] += cDrWni*cF11;
//      fluxU[es] += cDsWni*cF12;
//      fluxV[es] += cDrWni*cF21;
//      fluxV[es] += cDsWni*cF22;
//      ++es;
//    }
//    {
//      const dfloat cF11 = s_cF11[es][i];
//      const dfloat cF12 = s_cF12[es][i];
//      const dfloat cF21 = s_cF21[es][i];
//      const dfloat cF22 = s_cF22[es][i];
      
//      fluxU[es] += cDrWni*cF11;
//      fluxU[es] += cDsWni*cF12;
//      fluxV[es] += cDrWni*cF21;
//      fluxV[es] += cDsWni*cF22;
//      ++es;
//    }
//  }
      
//       occaUnroll(p_NblockE)
//  for(int es = 0; es<p_NblockE;++es){   
//    int e = eo+es;
//    if(e<Nelements){
//      const int id = e*p_Np+n;
      
//      rhsU[id]   = -fluxU[es]; 
//      rhsV[id]   = -fluxV[es];      
//    }
//  }
//     }
//   }
// }






