
@kernel void insTotalHaloExtract2D(const int Nelments,
                                  const int NhaloElements,
			                            @restrict const  int   *  haloElements,
                                  const int offset,
                                  @restrict const  dfloat *  U,
                                  @restrict const  dfloat *  V,
                                  @restrict const  dfloat *  P,
			                                  dfloat *haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      const int id   = haloElements[e] + offset;
      const int base = p_NTfields*p_Np*e;
      haloq[n + 0*p_Np + base] = U[n + p_Np*id];
      haloq[n + 1*p_Np + base] = V[n + p_Np*id];
      haloq[n + 2*p_Np + base] = P[n + p_Np*id];
    }
  }
}

@kernel void insTotalHaloExtract3D(const int Nelments,
                                  const int NhaloElements,
                                  @restrict const  int   *  haloElements,
                                  const int offset,
                                  @restrict const  dfloat *  U,
                                  @restrict const  dfloat *  V,
                                  @restrict const  dfloat *  W,
                                  @restrict const  dfloat *  P,
                                        dfloat *haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      const int id   = haloElements[e] + offset;
      const int base = p_NTfields*p_Np*e;
      haloq[n + 0*p_Np + base] = U[n + p_Np*id];
      haloq[n + 1*p_Np + base] = V[n + p_Np*id];
      haloq[n + 2*p_Np + base] = W[n + p_Np*id];
      haloq[n + 3*p_Np + base] = P[n + p_Np*id];
    }
  }
}



// @kernel void insSubStepTotalHaloExtract2D(const int Nelments,
//                                   const int NhaloElements,
//                                   @restrict const  int   *  haloElements,
//                                   const int offset0,
//                                   const int offset1,
//                                   const int offset2,
//                                   @restrict const  dfloat *  U,
//                                   @restrict const  dfloat *  V,
//                                   @restrict const  dfloat *  P,
//                                         dfloat *haloq){

//   for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
//     for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      
//       // const int offset0 = ((index+0)%3)*(Nelments + NhaloElements);
//       // const int offset1 = ((index+2)%3)*(Nelments + NhaloElements);
//       // const int offset2 = ((index+1)%3)*(Nelments + NhaloElements);

//       const int id0   = haloElements[e] + offset0;
//       const int id1   = haloElements[e] + offset1;
//       const int id2   = haloElements[e] + offset2;

//       const int base = (p_NTfields+4)*p_Np*e; // +2 for Un-1 and Un-2, hard coded
//       haloq[n + 0*p_Np + base] = U[n + p_Np*id0];
//       haloq[n + 1*p_Np + base] = V[n + p_Np*id0];
//       haloq[n + 2*p_Np + base] = P[n + p_Np*id0];
//       //
//       haloq[n + 3*p_Np + base] = U[n + p_Np*id1]; // Un-1
//       haloq[n + 4*p_Np + base] = V[n + p_Np*id1]; // Vn-1
//       haloq[n + 5*p_Np + base] = U[n + p_Np*id2]; // Un-2
//       haloq[n + 6*p_Np + base] = V[n + p_Np*id2]; // Un-2


//     }
//   }
// }


// @kernel void insSubStepTotalHaloScatter2D(const int Nelments,
//                                   const int NhaloElements,
//                                   @restrict const  int   *  haloElements,
//                                   const int offset0,
//                                   const int offset1,
//                                   const int offset2,
//                                         @restrict dfloat *  U,
//                                         @restrict dfloat *  V,
//                                         @restrict dfloat *  P,
//                                   @restrict const  dfloat *  haloq){

//   for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
//     for(int n=0;n<p_Np;++n;@inner(0)){ 
//       // const int offset0 = ((index+0)%3)*(Nelments + NhaloElements);
//       // const int offset1 = ((index+2)%3)*(Nelments + NhaloElements);
//       // const int offset2 = ((index+1)%3)*(Nelments + NhaloElements);

//       const int id0   = Nelments + offset0;
//       const int id1   = Nelments + offset1;
//       const int id2   = Nelments + offset2;
//       const int base = (p_NTfields+4)*p_Np*e;

//       U[n + p_Np*(e+id0)] = haloq[n + base + 0*p_Np];
//       V[n + p_Np*(e+id0)] = haloq[n + base + 1*p_Np];
//       P[n + p_Np*(e+id0)] = haloq[n + base + 2*p_Np];
//       //
//       U[n + p_Np*(e+id1)] = haloq[n + base + 3*p_Np];
//       V[n + p_Np*(e+id1)] = haloq[n + base + 4*p_Np];
//       U[n + p_Np*(e+id2)] = haloq[n + base + 5*p_Np];
//       V[n + p_Np*(e+id2)] = haloq[n + base + 6*p_Np];

//     }
//   }
// }






@kernel void insTotalHaloScatter2D(const int Nelments,
                                  const int NhaloElements,
                                  @restrict const  int   *  haloElements,
                                  const int offset,
                                        @restrict dfloat *  U,
                                        @restrict dfloat *  V,
                                        @restrict dfloat *  P,
                                  @restrict const  dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){ 
      const int id   = Nelments + offset;
      const int base = p_NTfields*p_Np*e;
      U[n + p_Np*(e+id)] = haloq[n + base + 0*p_Np];
      V[n + p_Np*(e+id)] = haloq[n + base + 1*p_Np];
      P[n + p_Np*(e+id)] = haloq[n + base + 2*p_Np];
    }
  }
}


@kernel void insTotalHaloScatter3D(const int Nelments,
                                  const int NhaloElements,
                                  @restrict const  int   *  haloElements,
                                  const int offset,
                                        @restrict dfloat *  U,
                                        @restrict dfloat *  V,
                                        @restrict dfloat *  W,
                                        @restrict dfloat *  P,
                                  @restrict const  dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){ 
      const int id   = Nelments + offset;
      const int base = p_NTfields*p_Np*e;
      U[n + p_Np*(e+id)] = haloq[n + base + 0*p_Np];
      V[n + p_Np*(e+id)] = haloq[n + base + 1*p_Np];
      W[n + p_Np*(e+id)] = haloq[n + base + 2*p_Np];
      P[n + p_Np*(e+id)] = haloq[n + base + 3*p_Np];
    }
  }
}



@kernel void insVelocityHaloExtract2D(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                             const int offset,
                             @restrict const  dfloat *  U,
                             @restrict const  dfloat *  V,
                                   @restrict dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      const int id   = haloElements[e] + offset;
      const int base = p_NVfields*p_Np*e;
      haloq[n + 0*p_Np + base] = U[n + p_Np*id];
      haloq[n + 1*p_Np + base] = V[n + p_Np*id];
    }
  }
}

@kernel void insVelocityHaloExtract3D(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                             const int offset,
                             @restrict const  dfloat *  U,
                             @restrict const  dfloat *  V,
                             @restrict const  dfloat *  W,
                                   @restrict dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      const int id   = haloElements[e] + offset;
      const int base = p_NVfields*p_Np*e;

      haloq[n + 0*p_Np + base] = U[n + p_Np*id];
      haloq[n + 1*p_Np + base] = V[n + p_Np*id];
      haloq[n + 2*p_Np + base] = W[n + p_Np*id];
    }
  }
}

@kernel void insVelocityHaloScatter2D(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                             const int offset,
                                   @restrict dfloat *  U,
                                   @restrict dfloat *  V,
                             @restrict const  dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){ 
      const int id    = Nelments + offset;
       const int base = p_NVfields*p_Np*e;
       U[n + p_Np*(e+id)] = haloq[n + 0*p_Np + base];
       V[n + p_Np*(e+id)] = haloq[n + 1*p_Np + base];
    }
  }
}

@kernel void insVelocityHaloScatter3D(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                             const int offset,
                                   @restrict dfloat *  U,
                                   @restrict dfloat *  V,
                                   @restrict dfloat *  W,
                             @restrict const  dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){ 
      const int id    = Nelments + offset;
       const int base = p_NVfields*p_Np*e;
       U[n + p_Np*(e+id)] = haloq[n + 0*p_Np + base];
       V[n + p_Np*(e+id)] = haloq[n + 1*p_Np + base];
       W[n + p_Np*(e+id)] = haloq[n + 2*p_Np + base];
    }
  }
}


@kernel void insPressureHaloExtract(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                             @restrict const  dfloat *  P,
                                   @restrict dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){     // for all entries in this element
      const int id   = haloElements[e];
      const int base = p_Np*e;

      haloq[n + base + 0*p_Np] = P[n + p_Np*id];
    }
  }
}


@kernel void insPressureHaloScatter(const int Nelments,
                             const int NhaloElements,
                             @restrict const  int   *  haloElements,
                                   @restrict dfloat *  P,
                             @restrict const  dfloat *  haloq){

  for(int e=0;e<NhaloElements;++e;@outer(0)){ // for all elements
    for(int n=0;n<p_Np;++n;@inner(0)){ 
      const int id   = haloElements[e];
      const int base = p_Np*e;
      P[n + p_Np*(Nelments+e)] = haloq[n + base + 0*p_Np];
    }
  }
}
