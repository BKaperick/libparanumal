kernel void boltzmannFilterDualQuad3D(const iint Nelements,
       	    			      const iint * restrict elementIds,
				      const dfloat * restrict dualMatrix,
				      const iint * restrict cubeFaceNumber,
				      const iint * restrict EToE,
				      const iint dir,
				      const dfloat * restrict qIn,
				      dfloat * restrict qOut) {

  for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
    for (iint fld=0; fld<p_Nfields; ++fld; inner2) {
      for (iint i=0; i<p_Nq; ++i; inner1) {
	for (iint j=0; j<p_Nq; ++j; inner0) {
	  
	  dfloat localMatrix[3*p_Nq];
	  iint eA[3];
	  dfloat qLocal[p_Nfields][p_Nq][p_Nq*3];

	  eA[1] = elementIds[eo]; //center element

	  eA[0] = EToE[eA[1]*p_Nfaces+dir]; //left element
	  eA[2] = EToE[eA[1]*p_Nfaces+2+dir]; //right element
	  
	  //put filter matrix in L1 (one row only)
	  for (iint k = 0; k < 3*p_Nq; ++k) {
	    localMatrix[k] = dualMatrix[i*3*p_Nq + k];
	  }
	  
	  const iint faceC = cubeFaceNumber[eA[1]];
	  const iint faceL = cubeFaceNumber[eA[0]];
	  const iint faceR = cubeFaceNumber[eA[2]];
	  
	  if((faceC == faceL) && (faceC == faceR)) {

	    
	    for (iint k0 = 0; k0 < 3; ++k0) {
	      for (iint k1 = 0; k1 < p_Nq; ++k1) {
		//rows are horizontal
		if (dir == 0) {
		  qLocal[fld][j][k0*p_Nq + k1]
		    = qIn[eA[k0]*p_Nfields*p_Np + fld*p_Np + k1*p_Nq + j];
		}
		//columns are vertical
		else {
		  qLocal[fld][j][k0*p_Nq + k1]
		    = qIn[eA[k0]*p_Nfields*p_Np + fld*p_Np + j*p_Nq + k1];
		}
	      }
	    }
	      
	    dfloat q_new = 0;
	    for (iint k=0;k<3*p_Nq;++k) {
	      q_new += qLocal[fld][j][k]*localMatrix[k];
	    }
	    qOut[eA[1]*p_Nfields*p_Np + fld*p_Np + i*p_Nq + j] = q_new;
	  }
	}
      }
    }
  }
}
