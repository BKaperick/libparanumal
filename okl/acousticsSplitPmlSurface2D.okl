
#define p_isq12 (1.f/occaSqrt(12.f))
#define p_isq6 (1.f/occaSqrt(6.f))

void upwind1D(const dfloat nx, const dfloat ny,
              const dfloat q1M, const dfloat q2M, const dfloat q3M,
              const dfloat q1B, const dfloat q2B, const dfloat q3B,
              dfloat * restrict q1P, dfloat * restrict q2P, dfloat * restrict q3P){
  
  *q1P = 0.5f*(q1B + q1M) - 0.5f*(nx*(q2B-q2M) + ny*(q3B-q3M));
  *q2P = 0.5f*(q2B + q2M) - 0.5f*(nx*(q1B-q1M));
  *q3P = 0.5f*(q3B + q3M) - 0.5f*(ny*(q1B-q1M));
}


void boundaryConditions2D(const int bc,
			  const dfloat  t, const dfloat  x, const dfloat  y, const dfloat  nx, const dfloat  ny,
			  const dfloat  q1M, const dfloat  q2M, const dfloat  q3M,
			  dfloat * restrict q1B, dfloat * restrict q2B, dfloat * restrict q3B){
  if(bc==1){
    *q1B = q1M; 
    *q2B = -q2M;
    *q3B = -q3M;
  }
  if(bc==2){ // wall for non-mean flow
    *q1B = 2.f*p_q1bar - q1M;
    *q2B = 2.f*p_q2bar - q2M;
    *q3B = 2.f*p_q3bar - q3M;
  }
  if(bc==6){ // Ricker source
  }
}



// batch process elements
kernel void acousticsSplitPmlSurface2D(const int Nelements,
				       const dfloat * restrict sgeo,
				       const dfloat * restrict LIFTT,
				       const int   * restrict vmapM,
				       const int   * restrict vmapP,
				       const int   * restrict EToB,
				       const dfloat time,
				       const dfloat * restrict x,
				       const dfloat * restrict y,
				       const dfloat4 * restrict q,
				       dfloat       * restrict rhspmlqx,
				       dfloat       * restrict rhspmlqy){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // shared storage for flux terms
    shared dfloat s_nxdq1[p_NblockS][p_maxNodes];
    shared dfloat s_nxdq2[p_NblockS][p_maxNodes];
    shared dfloat s_nxdq3[p_NblockS][p_maxNodes];

    shared dfloat s_nydq1[p_NblockS][p_maxNodes];
    shared dfloat s_nydq2[p_NblockS][p_maxNodes];
    shared dfloat s_nydq3[p_NblockS][p_maxNodes];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int e = eo + es;
	if(e<Nelements){
	  if(n<p_NfacesNfp){
	    // find face that owns this node
	    const int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    const int sid = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx = sgeo[sid+0];
	    const dfloat ny = sgeo[sid+1];
	    const dfloat sJ = sgeo[sid+2];
	    const dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    const int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
    
	    // load negative and positive trace node values of q
	    const dfloat4 qM = q[idM];
	    const dfloat4 qP = q[idP];

	    const dfloat q1M = qM.x, q2M = qM.y, q3M = qM.z;
	    dfloat q1P = qP.x, q2P = qP.y, q3P = qP.z;

	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny,
				   q1M, q2M, q3M,
				   &q1P, &q2P, &q3P);

	    // compute (q^*)
	    dfloat q1U, q2U, q3U;
	    
	    upwind1D(nx, ny, q1M, q2M, q3M, q1P, q2P, q3P, &q1U, &q2U, &q3U);
	      // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    const dfloat sc = invJ*sJ;

	    s_nxdq1[es][n] = sc*(nx*(q1U-q1M));
	    s_nxdq2[es][n] = sc*(nx*(q2U-q2M));
	    s_nxdq3[es][n] = sc*(nx*(q3U-q3M));

	    s_nydq1[es][n] = sc*(ny*(q1U-q1M));
	    s_nydq2[es][n] = sc*(ny*(q2U-q2M));
	    s_nydq3[es][n] = sc*(ny*(q3U-q3M));
	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	const int e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    const int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat Lnxdq1 = 0.f, Lnxdq2 = 0.f, Lnxdq3 = 0.f;
	    dfloat Lnydq1 = 0.f, Lnydq2 = 0.f, Lnydq3 = 0.f;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_Nfaces)
	    for(int m=0;m<p_NfacesNfp;++m){
	      const dfloat L = LIFTT[n+m*p_Np];
	      Lnxdq1 += L*s_nxdq1[es][m];
	      Lnxdq2 += L*s_nxdq2[es][m];
	      Lnxdq3 += L*s_nxdq3[es][m];
	      
	      Lnydq1 += L*s_nydq1[es][m];
	      Lnydq2 += L*s_nydq2[es][m];
	      Lnydq3 += L*s_nydq3[es][m];
	    }

	    const int base = e*p_Np*p_Nfields+n;
	    rhspmlqx[base+0*p_Np] -= p_sqrtRT*(Lnxdq2);
	    rhspmlqx[base+1*p_Np] -= p_sqrtRT*(Lnxdq1);
	    rhspmlqx[base+2*p_Np] = 0.f;

	    rhspmlqy[base+0*p_Np] -= p_sqrtRT*(Lnydq3);
	    rhspmlqy[base+1*p_Np] = 0.f;
	    rhspmlqy[base+2*p_Np] -= p_sqrtRT*(Lnydq1);
	  }
	}
      }
    }
  }
}

