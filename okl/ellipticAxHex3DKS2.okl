 #if p_Nq < 11
#define sliceThickness 1
#elif p_Nq <= 13
#define sliceThickness 2
#elif p_Nq p_Nq == 14
#define sliceThickness 3
#elif p_Nq <=16
#define sliceThickness 4
#else
#define sliceThickness 6
#endif

#if p_Nq < 11
#define shift p_Nq
#else
#define shift  1024/(p_Nq*p_Nq)
#endif

#define cubeThreadsSliced                             \
	for(iint k=0; k<shift; ++k; inner2)            \
		for(iint j=0; j<p_Nq; ++j; inner1)          \
			for(iint i=0; i<p_Nq; ++i; inner0)

kernel void ellipticAxHex3D_rDir(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict ggeo,
                                 const dfloat * restrict D,
                                 const dfloat lambda,
                                 const dfloat * restrict q,
                                 dfloat * restrict Aq,
                                 dfloat * restrict aux
                                ){
	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
//shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];
	//	exclusive dfloat r_qr[sliceThickness];
		// prefetch q(:,:,:,e) to shared
		cubeThreadsSliced {

		  //  occaUnroll(p_Nq)
		  for (int s=k; s<p_Nq;s+=shift){
		  const iint base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  s_q[s][j][i] = q[base];
		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);



		cubeThreadsSliced {


		  for (int s=k; s<p_Nq;s+=shift){

		  iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(iint n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }



			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];


			  const dfloat qqr = G00*qr + G01*qs + G02*qt;
		//	  r_qr[s/shift] = qqr;
// base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
//s_q2[s][j][i] = qqr;

		  }//cube threads


		}

	
		//synchronize
		barrier(localMemFence);
		cubeThreadsSliced {
		  for (int s=k; s<p_Nq;s+=shift){


		  dfloat tmp = 0.f;
		  for(iint n=0; n<p_Nq; ++n)
			//	 tmp += s_D[n][i]*s_q2[s][j][n];
			  const iint base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
		//	  Aq[base] = tmp;



		  }
		}



	}//e
}//kernel




//e1d end
