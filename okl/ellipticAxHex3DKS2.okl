 
 /*
 #if p_Nq < 11
#define sliceThickness 1
#elif p_Nq <= 13
#define sliceThickness 2
#elif p_Nq p_Nq == 14
#define sliceThickness 3
#elif p_Nq <=16
#define sliceThickness 4
#else
#define sliceThickness 6
#endif

#if p_Nq < 11
#define shift p_Nq
#else
#define shift  1024/(p_Nq*p_Nq)
#endif

#define cubeThreadsSliced                             \
	for(iint k=0; k<shift; ++k; inner2)            \
		for(iint j=0; j<p_Nq; ++j; inner1)          \
			for(iint i=0; i<p_Nq; ++i; inner0)

kernel void ellipticAxHex3D_rDir(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict ggeo,
                                 const dfloat * restrict D,
                                 const dfloat lambda,
                                 const dfloat * restrict q,
                                 dfloat * restrict Aq,
                                 dfloat * restrict aux
                                ){
	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		//shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];
		//	exclusive dfloat r_qr[sliceThickness];
		// prefetch q(:,:,:,e) to shared
		cubeThreadsSliced {

		  //  occaUnroll(p_Nq)
		  for (int s=k; s<p_Nq;s+=shift){
		  const iint base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  s_q[s][j][i] = q[base];
		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);



		cubeThreadsSliced {


		  for (int s=k; s<p_Nq;s+=shift){

		  iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(iint n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }



			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];


			  const dfloat qqr = G00*qr + G01*qs + G02*qt;
			  //	  r_qr[s/shift] = qqr;
			  // base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  //s_q2[s][j][i] = qqr;

		  }//cube threads


		}


		//synchronize
		barrier(localMemFence);
		cubeThreadsSliced {
		  for (int s=k; s<p_Nq;s+=shift){


		  dfloat tmp = 0.f;
		  for(iint n=0; n<p_Nq; ++n)
				  //	 tmp += s_D[n][i]*s_q2[s][j][n];
				  const iint base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  //	  Aq[base] = tmp;



		  }
		}



	}//e
}//kernel
*/
// KASIA TRILINEAR KERNEL 3 (fly kernel 3)
// in this kernel:
//1) i-j marching --> i-k marching --> j-k matching -->
//2) cube load structure (4 x 4 cubes)
//3) geofactors  on the fly, with assumption of nice tensor product structure

#define T 3

kernel void ellipticAxHex3D_trilinear3(const iint Nelements,
                                       const iint * restrict elementList,
                                       const dfloat * restrict ggeo,
                                       const dfloat * restrict D,
                                       const dfloat lambda,
                                       const dfloat * restrict q,
                                       dfloat * restrict Aq,
                                       const dfloat * restrict grad){

	for(iint e=0; e<Nelements; ++e; outer0) {
// rename to make less confusing
		shared dfloat s_tmp1[4][p_Nq][p_Nq];
		shared dfloat s_tmp2[4][p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		shared dfloat s_EXYZ[9][3];
		shared dfloat s_rw[2][p_Nq];

		//new --> we will load 16 cubes per slice, every cube is 4x4x4
		// 16 is heuristic, change it later
		// exactly 1024, will keep every thread busy
		shared dfloat s_slice[16][4][4][4];

		//end of new

		//	exclusive dfloat r_q[p_Nq];
		//	exclusive dfloat r_Aq[p_Nq], r_qt, r_tmpt;
		exclusive int emap;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22;
		exclusive dfloat r_GwJ;

		for (iint k =0; k<4; ++k; inner2){
			for(iint j=0; j<p_Nq; ++j; inner1) {
				for(iint i=0; i<p_Nq; ++i; inner0) {

					emap = elementList[e];
					if (k== 0){
						s_D[i][j] = D[j*p_Nq+i];

						int t = i+j*p_Nq;

						while(t<2*p_Nq){
							s_rw[0][t] = ggeo[t];
							t += p_Nq*p_Nq;
						}

						t = i+j*p_Nq;
						while(t<9*3){ // 54
							s_EXYZ[0][t] = ggeo[2*p_Nq + emap*p_Nverts*9 + t];
							t += p_Nq*p_Nq;
						}
					}
				}
			}
		}//k

		barrier(localMemFence);

		occaUnroll(4)
		for (iint p=0; p<4; ++p)
		{
			// first, load a slice
			for(iint k=0; k<4; ++k; inner2) {
				for(iint j=0; j<p_Nq; ++j; inner1) {
					for(iint i=0; i<p_Nq; ++i; inner0) {
						//load
						const iint base = i + j*p_Nq + k*p_Nq*p_Nq + elementList[e]*p_Np;
						// 4 x 16 x 16
						//cube number
						iint cn = 4*(j/4)+(i/4);
						// i, j inside cube
						s_slice[cn][k][j%4][i%4] =  q[base];
						//	k j i
					}
				}
			}//k




			for(iint k=0; k<4; ++k; inner2) {

				for(iint j=0; j<p_Nq; ++j; inner1) {
					for(iint i=0; i<p_Nq; ++i; inner0) {
						
						const dfloat rn = s_rw[0][i];
						const dfloat sn = s_rw[0][j];
						const dfloat tn = s_rw[0][k];

						const dfloat xr = (1.-tn)*(1.-sn)*(s_EXYZ[0][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[0][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[0][2]);
						const dfloat xs = (1.-tn)*(1.-rn)*(s_EXYZ[1][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[1][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[1][2]);
						const dfloat xt = (1.-rn)*(1.-sn)*(s_EXYZ[2][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[2][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[2][2]);

						const dfloat yr = (1.-tn)*(1.-sn)*(s_EXYZ[3][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[3][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[3][2]);
						const dfloat ys = (1.-tn)*(1.-rn)*(s_EXYZ[4][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[4][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[4][2]);
						const dfloat yt = (1.-rn)*(1.-sn)*(s_EXYZ[5][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[5][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[5][2]);

						const dfloat zr = (1.-tn)*(1.-sn)*(s_EXYZ[6][0]) + (1.-tn)*(1.+sn)*(s_EXYZ[6][1]) + (1.+tn)*(1.-sn)*(s_EXYZ[6][2]);
						const dfloat zs = (1.-tn)*(1.-rn)*(s_EXYZ[7][0]) + (1.-tn)*(1.+rn)*(s_EXYZ[7][1]) + (1.+tn)*(1.-rn)*(s_EXYZ[7][2]);
						const dfloat zt = (1.-rn)*(1.-sn)*(s_EXYZ[8][0]) + (1.+rn)*(1.-sn)*(s_EXYZ[8][1]) + (1.+rn)*(1.+sn)*(s_EXYZ[8][2]);

						
						const dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);
						const dfloat Jinv = 1./J;

						const dfloat rx =  (ys*zt - zs*yt), ry = -(xs*zt - zs*xt), rz =  (xs*yt - ys*xt); // removed Jinv factor to below
						const dfloat sx = -(yr*zt - zr*yt), sy =  (xr*zt - zr*xt), sz = -(xr*yt - yr*xt);
						//	const dfloat tx =  (yr*zs - zr*ys), ty = -(xr*zs - zr*xs), tz =  (xr*ys - yr*xs);

						//	const dfloat JW = J*s_rw[1][i]*s_rw[1][j]*s_rw[1][k];

						
						r_G00 = Jinv*(rx*rx + ry*ry + rz*rz); // removed J factor to below
						r_G01 = Jinv*(rx*sx + ry*sy + rz*sz);
						//	r_G02 = Jinv*(rx*tx + ry*ty + rz*tz);
						r_G11 = Jinv*(sx*sx + sy*sy + sz*sz);
						//	r_G12 = Jinv*(sx*tx + sy*ty + sz*tz);
						//	r_G22 = Jinv*(tx*tx + ty*ty + tz*tz);
						//	r_GwJ = JW;

						// now differentiate in i j  dir
						dfloat qs =0.0f, qr = 0.0f;
						occaUnroll(p_Nq)
						for(iint n=0; n<p_Nq; ++n) {
							iint cn = 4*(j/4)+(n/4);
							//cube numbwe
							qr += s_D[i][n]*s_slice[cn][k][j%4][n%4];
							//s_q[j][n];
							cn = 4*(n/4)+(i/4);
							qs += s_D[j][n]*s_slice[cn][k][n%4][j%4];
							//s_q[n][i];
						}
					  s_tmp1[k][j][i]=qr;
					  //+ r_G01*qs;
					  s_tmp2[k][j][i]=qs;
						
					  }//i
				  }//j
			  }//k
			  barrier(localMemFence);
			for(iint k=0; k<4; ++k; inner2) {
				for(iint j=0; j<p_Nq; ++j; inner1) {
					for(iint i=0; i<p_Nq; ++i; inner0) {
						dfloat Aq1 = 0.0f, Aq2 = 0.0f;

						occaUnroll(p_Nq)
						for(iint n=0; n<p_Nq; ++n) {
							Aq1 += s_D[n][i]*(r_G00*s_tmp1[k][j][n] + r_G01*s_tmp2[k][j][n]);
							Aq2 += s_D[n][j]*(r_G01*s_tmp1[k][n][i] + r_G11*s_tmp2[k][n][i]);
						}

						//r_Aq[k] +=  Aq1 + Aq2 + r_GwJ*lambda*s_q[j][i];
						Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] =  Aq1 + Aq2;

					}
				}
			}
		}//p
		// so now go through i-k slices
		
		
		
		
		
		
		
	}//e
}

