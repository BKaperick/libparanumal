//optimized by KS





@kernel void ellipticAxTri2D(const int Nelements,
    @restrict const  dfloat *  ggeo,
    @restrict const  dfloat *  SrrT,
    @restrict const  dfloat *  SrsT,
    @restrict const  dfloat *  SsrT,
    @restrict const  dfloat *  SssT,
    @restrict const  dfloat *  MM,
    const dfloat lambda,
    @restrict const  dfloat  *  q,
    @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const int id = n + e*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    @barrier("local");


    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }


          const int id = n + e*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}

//v1

@kernel void ellipticAxTri2D_v1(const int Nelements,
    @restrict const  dfloat *  ggeo,
    @restrict const  dfloat *  SrrT,
    @restrict const  dfloat *  SrsT,
    @restrict const  dfloat *  SsrT,
    @restrict const  dfloat *  SssT,
    @restrict const  dfloat *  MM,
    const dfloat lambda,
    @restrict const  dfloat  *  q,
    @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const int id = n + e*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    @barrier("local");


    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }


          const int id = n + e*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}


@kernel void ellipticPartialAxTri2D(const int Nelements,
    @restrict const  int   *  elementList,
    @restrict const  dfloat *  ggeo,
    @restrict const  dfloat *  SrrT,
    @restrict const  dfloat *  SrsT,
    @restrict const  dfloat *  SsrT,
    @restrict const  dfloat *  SssT,
    @restrict const  dfloat *  MM,
    const dfloat lambda,
    @restrict const  dfloat  *  q,
    @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const int element = elementList[e];
          const int id = n + element*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    @barrier("local");


    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }

          const int element = elementList[e];
          const int id = n + element*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}


//Analysis:
// We perform (per thread block)
// Nelements per block x Np x (Np x 5+10) flops
// We load: (Nelements per block) x Np to @shared
// We read (Nelements per block) x Np xNp x 5 times from @shared
// We request: (Nelements per block) x Np x(1+4+Npx5 variables
// We store (Nelements per block) x Np x (1) variables

@kernel void ellipticPartialAxTri2D_v1(const int Nelements,
    @restrict const  int   *  elementList,
    @restrict const  dfloat *  ggeo,
    @restrict const  dfloat *  SrrT,
    @restrict const  dfloat *  SrsT,
    @restrict const  dfloat *  SsrT,
    @restrict const  dfloat *  SssT,
    @restrict const  dfloat *  MM,
    const dfloat lambda,
    @restrict const  dfloat  *  q,
    @restrict dfloat  *  Aq){

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){
    /*
       qrr += SrrT[n+k*p_Np]*s_q[es][k];
       qrs += SrsT[n+k*p_Np]*s_q[es][k];
       qsr += SsrT[n+k*p_Np]*s_q[es][k];
       qss += SssT[n+k*p_Np]*s_q[es][k];

     */
    @shared dfloat s_q[p_NblockV][p_Np];
    



    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const int element = elementList[e];
          const int id = n + element*p_Np;
          s_q[e-eo][n] = q[id];
          
          
        }
      }
    }

    @barrier("local");


    for(int e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }

          const int element = elementList[e];
          const int id = n + element*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}

