
void boundaryConditions2D(iint bc, dfloat time, dfloat x, dfloat y,
        dfloat uM, dfloat vM, dfloat pM,
        dfloat *uP, dfloat *vP, dfloat *pP){
  
  if(1){ //bc==1){
    // assert Neumann for pressure and no penetration for velocity
    *uP = -uM;
    *vP = -vM;
    *pP = pM;
  }
  if(0){ //bc==2){
    dfloat dx = 1.f/occaSqrt(2.f);
    dfloat dy = 1.f/occaSqrt(2.f);
    dfloat omega = 10*M_PI;
    dfloat wave = occaCos(omega*(time-(x*dx+y*dy)));
    dfloat uI = dx*wave;
    dfloat vI = dy*wave;
    dfloat pI = wave;
    
    // scattered field wall
    *uP = -uM -2.f*uI;
    *vP = -vM -2.f*vI;
    *pP = pM;
  }
}

kernel void acousticsbbdgMRABSurface2D_o1(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o1;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o1][2*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o1][2*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o1][2*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o1][2*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o1][2*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o1][2*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o1;++es;inner1){
      for(iint n=0;n<p_maxNodes_o1;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<2*p_Nfaces){
            // find face that owns this node
            const iint face = n/2;
            const iint iid  = n%2;
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o1;++es;inner1){
      for(iint n=0;n<p_maxNodes_o1;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<2*p_Nfaces){
            const iint id = n % 2;  // warning: redundant reads
            const dfloat L0val = L0vals[id+2]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 2){
              utmpflux += L0vals[id+2*2]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*2]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*2]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o1;++es;inner1){
      for(iint n=0;n<p_maxNodes_o1;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<3){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(4)
            for (int m = 0; m < 4; ++m){
              const iint id = n + m*3;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}
    
kernel void acousticsbbdgMRABSurface2D_o2(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o2;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o2][3*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o2][3*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o2][3*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o2][3*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o2][3*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o2][3*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o2;++es;inner1){
      for(iint n=0;n<p_maxNodes_o2;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<3*p_Nfaces){
            // find face that owns this node
            const iint face = n/3;
            const iint iid  = n%3; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o2;++es;inner1){
      for(iint n=0;n<p_maxNodes_o2;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<3*p_Nfaces){
            const iint id = n % 3;  // warning: redundant reads
            const dfloat L0val = L0vals[id+3]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 3){
              utmpflux += L0vals[id+2*3]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*3]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*3]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o2;++es;inner1){
      for(iint n=0;n<p_maxNodes_o2;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<6){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(5)
            for (int m = 0; m < 5; ++m){
              const iint id = n + m*6;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o3(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o3;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o3][4*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o3][4*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o3][4*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o3][4*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o3][4*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o3][4*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o3;++es;inner1){
      for(iint n=0;n<p_maxNodes_o3;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<4*p_Nfaces){
            // find face that owns this node
            const iint face = n/4;
            const iint iid  = n%4; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o3;++es;inner1){
      for(iint n=0;n<p_maxNodes_o3;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<4*p_Nfaces){
            const iint id = n % 4;  // warning: redundant reads
            const dfloat L0val = L0vals[id+4]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 4){
              utmpflux += L0vals[id+2*4]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*4]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*4]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o3;++es;inner1){
      for(iint n=0;n<p_maxNodes_o3;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<10){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(6)
            for (int m = 0; m < 6; ++m){
              const iint id = n + m*10;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o4(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o4;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o4][5*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o4][5*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o4][5*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o4][5*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o4][5*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o4][5*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o4;++es;inner1){
      for(iint n=0;n<p_maxNodes_o4;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<5*p_Nfaces){
            // find face that owns this node
            const iint face = n/5;
            const iint iid  = n%5; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o4;++es;inner1){
      for(iint n=0;n<p_maxNodes_o4;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<5*p_Nfaces){
            const iint id = n % 5;  // warning: redundant reads
            const dfloat L0val = L0vals[id+5]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 5){
              utmpflux += L0vals[id+2*5]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*5]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*5]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o4;++es;inner1){
      for(iint n=0;n<p_maxNodes_o4;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<15){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(7)
            for (int m = 0; m < 7; ++m){
              const iint id = n + m*15;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o5(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o5;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o5][6*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o5][6*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o5][6*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o5][6*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o5][6*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o5][6*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o5;++es;inner1){
      for(iint n=0;n<p_maxNodes_o5;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<6*p_Nfaces){
            // find face that owns this node
            const iint face = n/6;
            const iint iid  = n%6; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o5;++es;inner1){
      for(iint n=0;n<p_maxNodes_o5;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<6*p_Nfaces){
            const iint id = n % 6;  // warning: redundant reads
            const dfloat L0val = L0vals[id+6]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 6){
              utmpflux += L0vals[id+2*6]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*6]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*6]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o5;++es;inner1){
      for(iint n=0;n<p_maxNodes_o5;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<21){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(8)
            for (int m = 0; m < 8; ++m){
              const iint id = n + m*21;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o6(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o6;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o6][7*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o6][7*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o6][7*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o6][7*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o6][7*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o6][7*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o6;++es;inner1){
      for(iint n=0;n<p_maxNodes_o6;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<7*p_Nfaces){
            // find face that owns this node
            const iint face = n/7;
            const iint iid  = n%7; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o6;++es;inner1){
      for(iint n=0;n<p_maxNodes_o6;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<7*p_Nfaces){
            const iint id = n % 7;  // warning: redundant reads
            const dfloat L0val = L0vals[id+7]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 7){
              utmpflux += L0vals[id+2*7]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*7]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*7]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o6;++es;inner1){
      for(iint n=0;n<p_maxNodes_o6;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<28){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(9)
            for (int m = 0; m < 9; ++m){
              const iint id = n + m*28;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o7(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o7;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o7][8*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o7][8*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o7][8*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o7][8*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o7][8*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o7][8*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o7;++es;inner1){
      for(iint n=0;n<p_maxNodes_o7;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<8*p_Nfaces){
            // find face that owns this node
            const iint face = n/8;
            const iint iid  = n%8; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o7;++es;inner1){
      for(iint n=0;n<p_maxNodes_o7;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<8*p_Nfaces){
            const iint id = n % 8;  // warning: redundant reads
            const dfloat L0val = L0vals[id+8]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 8){
              utmpflux += L0vals[id+2*8]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*8]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*8]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o7;++es;inner1){
      for(iint n=0;n<p_maxNodes_o7;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<36){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(10)
            for (int m = 0; m < 10; ++m){
              const iint id = n + m*36;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o8(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o8;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o8][9*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o8][9*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o8][9*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o8][9*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o8][9*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o8][9*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o8;++es;inner1){
      for(iint n=0;n<p_maxNodes_o8;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<9*p_Nfaces){
            // find face that owns this node
            const iint face = n/9;
            const iint iid  = n%9; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o8;++es;inner1){
      for(iint n=0;n<p_maxNodes_o8;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<9*p_Nfaces){
            const iint id = n % 9;  // warning: redundant reads
            const dfloat L0val = L0vals[id+9]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 9){
              utmpflux += L0vals[id+2*9]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*9]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*9]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o8;++es;inner1){
      for(iint n=0;n<p_maxNodes_o8;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<45){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(11)
            for (int m = 0; m < 11; ++m){
              const iint id = n + m*45;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o9(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o9;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o9][10*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o9][10*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o9][10*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o9][10*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o9][10*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o9][10*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o9;++es;inner1){
      for(iint n=0;n<p_maxNodes_o9;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<10*p_Nfaces){
            // find face that owns this node
            const iint face = n/10;
            const iint iid  = n%10; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o9;++es;inner1){
      for(iint n=0;n<p_maxNodes_o9;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<10*p_Nfaces){
            const iint id = n % 10;  // warning: redundant reads
            const dfloat L0val = L0vals[id+10]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 10){
              utmpflux += L0vals[id+2*10]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*10]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*10]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o9;++es;inner1){
      for(iint n=0;n<p_maxNodes_o9;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<55){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(12)
            for (int m = 0; m < 12; ++m){
              const iint id = n + m*55;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}

kernel void acousticsbbdgMRABSurface2D_o10(const iint Nelements,
           const iint   * restrict elementIds,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const iint   * restrict ELids,
           const dfloat * restrict ELvals,
           const iint   * restrict vmapM,
           const iint   * restrict mapP,
           const iint   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           const dfloat * restrict fQM,
           const dfloat * restrict fQP,
           dfloat       * restrict rhsq,
           const iint rhsShift){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS_o10;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS_o10][11*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS_o10][11*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS_o10][11*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS_o10][11*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS_o10][11*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS_o10][11*p_Nfaces];

    // for all face nodes of all elements 
    for(iint es=0;es<p_NblockS_o10;++es;inner1){
      for(iint n=0;n<p_maxNodes_o10;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint et = eo + es;
        if(et<Nelements){
          iint e = elementIds[et];
          if(n<11*p_Nfaces){
            // find face that owns this node
            const iint face = n/11;
            const iint iid  = n%11; 
          
            // load surface geofactors for this face
            const iint sid = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx = sgeo[sid+0];
            const dfloat ny = sgeo[sid+1];
            const dfloat sJ = sgeo[sid+2];
            const dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            const iint id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            const iint idM = id*p_Nfields;
            const iint idP = mapP[id]*p_Nfields;
  
            // load negative and positive trace node values of q
            const dfloat uM = fQM[idM+0], vM = fQM[idM+1], pM = fQM[idM+2];
                  dfloat uP = fQP[idP+0], vP = fQP[idP+1], pP = fQP[idP+2];

            // apply boundary condition
            const iint bc = EToB[face+p_Nfaces*e];
            if(bc>0) {
              const iint idB = vmapM[id];
              boundaryConditions2D(bc, time, x[idB], y[idB], uM, vM, pM, &uP, &vP, &pP);
            }
            
            // compute (q^* - q^-)
            const dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            const dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            const dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(iint es=0;es<p_NblockS_o10;++es;inner1){
      for(iint n=0;n<p_maxNodes_o10;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<11*p_Nfaces){
            const iint id = n % 11;  // warning: redundant reads
            const dfloat L0val = L0vals[id+11]; 
            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < 11){
              utmpflux += L0vals[id+2*11]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*11]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*11]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(iint es=0;es<p_NblockS_o10;++es;inner1){
      for(iint n=0;n<p_maxNodes_o10;++n;inner0){
        iint et = eo + es;
        if(et<Nelements){
          if(n<66){
            const iint e = elementIds[et];
            const iint id = 3*p_Nfields*(p_NpMax*e + n) + p_Nfields*rhsShift;
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(13)
            for (int m = 0; m < 13; ++m){
              const iint id = n + m*66;
              const dfloat ELval = ELvals[id];
              const iint ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}