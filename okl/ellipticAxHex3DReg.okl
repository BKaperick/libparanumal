
//proof of concept: this kernel uses registers, not shared (thus reg)
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)


#define p_gllPad 0
#define p_gjPad 0

//reg1 is a full 2d version without kernel splitting
// interpolation/projection is based on barrier eliminating idea by TW
// the derivative part based on one of the e6 kernels from ellipticAxJex3D.okl




kernel void ellipticAxHex3D_reg1(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive iint emap;
		//	exclusive dfloat r_res;
		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;
		//save the SHARED
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		shared dfloat s_gllD[p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];


				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c)
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}



		//synch threads
		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		//now synch
		barrier(localMemFence);

		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		barrier(localMemFence);

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c)
						tmp += s_I[k][c]*r_q[c];

					s_q[k][j][i] = tmp; // ok since only this thread
					//		Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;
				}
			}
		}



		//===============================================now differentiate once interpolated
		// I think this can be done using a 3-dim blocks (with/without slabbing )

		//for(int e=0; e<Nelements; ++e; outer0){
		/*
		exclusive dfloat r_q[p_gjNq];
			exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_tmp, r_qs, r_qt, r_qr;
			save the SHARED
			shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

			shared dfloat s_gllD[p_gjNq][p_gjNq];
			shared dfloat s_I[p_gjNq][p_Nq];
			// LOAD TO SHAEWS
			exclusive iint emap;
		*/

		for(int k=0; k<p_gjNq; ++k) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			barrier(localMemFence);

			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0, lapqs = 0;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
					}
					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						r_q[n] += s_gllD[k][n]*r_qt;
					}

					r_q[k] += lapqr + lapqs;
				}
			}



		}//k

		//=========== now project =================================================
		// b -> a -> c
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){


				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j)
						tmp += s_I[j][b]*r_q[j];
					s_q[k][b][i] = tmp; // ok since only this thread
				}
			}
		}

		barrier(localMemFence);

		// transform back in a
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i)
							tmp += s_I[i][a]*r_q[i];
						s_q[k][b][a] = tmp; // ok since only this thread
					}
				}
			}
		}

		barrier(localMemFence);

		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k)
						r_q[k] = s_q[k][b][a];

					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k)
							tmp += s_I[k][c]*r_q[k];

						Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}







	}//e
}//kernel

//reg2 is a splitting version combining best strategy for intepolation with smart slabbing
// intepolation and projection is based on the idea of eliminating barriers
// differentiation is based on our best skinny Ax kernel
