
//proof of concept: this @kernel uses registers, not @shared (thus reg)
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)


//#define p_gllPad 0
//#define p_gllPad 0//
//#define p_gjPad 0

#if p_Nq==8 || p_Nq==16
#define p_gllPad 1
#else
#define p_gllPad 0
#endif

#if p_gjNq ==8 || p_gjNq==16
#define p_gjPad 1
#else
#define p_gjPad 0
#endif


// [ Dr' Ds' Dt' ] [G00 G01 G02]  [ Dr ]
//               ] [G01 G11 G12]  [ Ds ]
//               ] [G02 G12 G22]  [ Dt ]

// [ Dr' Ds' ] [G00 G01]  [ Dr ]
//           ] [G01   0]  [ Ds ]

// [ Dr' Dt' ] [  0 G02]  [ Dr ]
//           ] [G02 G22]  [ Dt ]


// [ Ds' Dt' ] [G11 G12]  [ Ds ]
//           ] [G12   0]  [ Dt ]

#define UNROLL0(a) a
#define UNROLL1(a) a UNROLL0(a)
#define UNROLL2(a) a UNROLL1(a)
#define UNROLL3(a) a UNROLL2(a)
#define UNROLL4(a) a UNROLL3(a)
#define UNROLL5(a) a UNROLL4(a)
#define UNROLL6(a) a UNROLL5(a)
#define UNROLL7(a) a UNROLL6(a)
#define UNROLL8(a) a UNROLL7(a)
#define UNROLL9(a) a UNROLL8(a)
#define UNROLL10(a) a UNROLL9(a)
#define UNROLL11(a) a UNROLL10(a)
#define UNROLL12(a) a UNROLL11(a)
#define UNROLL13(a) a UNROLL12(a)
#define UNROLL14(a) a UNROLL13(a)
#define UNROLL15(a) a UNROLL14(a)
#define UNROLL16(a) a UNROLL15(a)

#define UNROLLN(n,a) UNROLL##n(a)


#if p_gjNq==4
#define UNROLLNq(a) UNROLL3(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 1
#define p_Nslab 4
#define p_Bsize 2
#endif



#if p_gjNq==8
#define UNROLLNq(a) UNROLL7(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 2
#define p_Nslab 4
#define p_Bsize 2
#endif


#if p_gjNq==16
#define UNROLLNq(a) UNROLL15(a)
#define p_Bskip 2
#define p_Bmask 3
#define p_Nslabs 4
#define p_Nslab 4
#define p_Bsize 4
#endif

#define p_pad 0

//reg1 is a full 2d version without @kernel splitting
// interpolation/projection is based on barrier eliminating idea by TW
// the derivative part based on one of the e6 @kernels from ellipticAxJex3D.okl


/*
(solver->NglobalGatherElements, solver->o_globalGatherElementList,
                                  solver->o_gjGeo, 
                                  solver->o_gjD2, 
                                  solver->o_gjI, 
                                  lambda, o_q, o_Aq,
                                  solver->o_grad);
*/


@kernel void ellipticAxHex3D_reg1(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict const  dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					//	r_q[k] += lambda*r_GwJ*s_q[k][j][i];


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];

				}
			}

			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f, lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//@kernel

//reg2 is a splitting version combining best strategy for intepolation with smart slabbing
// intepolation and projection is based on the idea of eliminating barriers
// differentiation is based on our best skinny Ax @kernel
/*

@kernel void ellipticAxHex3D_reg2(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict dfloat *  q,
                                 @restrict dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{
	//============================= @kernel 1 (2D)=============================
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		//	@exclusive dfloat r_res;
		@exclusive dfloat r_q[p_gjNq];
		//	@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		//	@shared dfloat s_gllD[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];

		//slab read and LOAD TO SHAEWS
		//@exclusive int emap;
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];


				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c)
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}



		//synch threads
		@barrier("local");


		// transform in b
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}


		@barrier("local");

		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		@barrier("local");

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){


					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c)
						tmp += s_I[k][c]*r_q[c];

					//save interpolated
					//Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] =tmp;
					Ixq[emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i] = tmp;
			//	Aq[emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i] = tmp;
				}
			}
		}
	}//e
	//============================= @kernel 2 (3D)=============================

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// load

		@shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad]; //
		@shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		@exclusive int emap, r_nodeId, r_smemId;
		@exclusive dfloat r_res;

		for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}

		#pragma unroll p_Nslabs
		for(int kslab=0;kslab<p_Nslabs;++kslab){
			for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
				for(int j=0;j<p_gjNq;++j;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						const unsigned int t = i+j*p_gjNq+ks*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = (t>>6)&p_Bmask;
						const unsigned int jB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int kB = kslab;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = iB*4+iT + (p_gjNq+p_pad)*(jB*4+jT) + kT*p_gjNq*(p_gjNq+p_pad);
						s_q[0][0][r_smemId] = Ixq[r_nodeId];

					}
				}
			}


			@barrier("local");

			for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
				@barrier("local");
				for(int j=0;j<p_gjNq;++j;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						// assume specific data layout for G00 and G01
						const unsigned int base = emap*p_gjNp*p_Nggeo+(ks+kslab*p_Nslab)*p_gjNq*p_gjNq+j*p_gjNq+i;
						const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
						const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
						r_res = lambda*gjGeo[base+p_GWJID*p_gjNp]; // lambda*GwJ

						dfloat tmpr = 0, tmps = 0;
						int n;

						n=0;
						UNROLLNq(tmpr += s_DT[n][i]*s_q[ks][j][n];++n;);

						n=0;
						UNROLLNq(tmps += s_D[j][n]*s_q[ks][n][i];++n;);

						s_tmp1[ks][j][i] = r_G00*tmpr + r_G01*tmps;
						s_tmp2[ks][j][i] = r_G01*tmpr;
					}
				}
			}

			@barrier("local");

			for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
				for(int j=0;j<p_gjNq;++j;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){
						dfloat tmpr = 0, tmps = 0;
						int n;
						n=0;
						UNROLLNq(tmpr += s_D[n][i]*s_tmp1[ks][j][n]; ++n;);

						n=0;
						UNROLLNq(tmps += s_D[n][j]*s_tmp2[ks][n][i]; ++n;);

						s_q[ks][j][i] = tmpr+tmps+r_res;
					}
				}
			}


			@barrier("local");

			for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
				for(int j=0;j<p_gjNq;++j;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						q[r_nodeId] = s_q[0][0][r_smemId];
					}
				}
			}
		} // end of kslabbing
	}


	// cannot merge @kernels because of different ordering of access and output

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		@exclusive int emap, r_nodeId, r_smemId, r_res;

		for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}


		#pragma unroll p_Nslabs
		for(int jslab=0;jslab<p_Nslabs;++jslab){

		

			for(int js=0;js<p_Nslab;++js;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						const unsigned int t = i+k*p_gjNq+js*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = (t>>6)&p_Bmask;
						const unsigned int jB = jslab;
						const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = iB*4+iT + (p_gjNq+p_pad)*(kB*4+kT) + p_gjNq*(p_gjNq+p_pad)*jT;
						s_q[0][0][r_smemId] = Ixq[r_nodeId];
						r_res = q[r_nodeId];
					}
				}
			}


			@barrier("local");

			for(int js=0;js<p_Nslab;++js;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						const unsigned int base = emap*p_gjNp*p_Nggeo+(js+jslab*p_Nslab)*p_gjNq*p_gjNq+k*p_gjNq+i; // assume ordering (j,k,i) with i fastest
						const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];
						const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

						dfloat tmpr = 0, tmpt = 0;

						int n=0;
						UNROLLNq(tmpr += s_DT[n][i]*s_q[js][k][n]; tmpt += s_D[k][n]*s_q[js][n][i]; ++n;);

						s_tmp1[js][i][k] =              r_G02*tmpt;
						s_tmp2[js][k][i] = r_G02*tmpr + r_G22*tmpt;
					}
				}
			}

			@barrier("local");

			for(int js=0;js<p_Nslab;++js;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){
						dfloat tmpr = 0, tmpt = 0;
						int n=0;
						UNROLLNq(tmpt += s_D[n][k]*s_tmp2[js][n][i]; tmpr += s_D[n][i]*s_tmp1[js][n][k]; ++n;);

						s_q[js][k][i] = tmpr+tmpt;

					}
				}
			}

			@barrier("local");

			for(int js=0;js<p_Nslab;++js;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int i=0;i<p_gjNq;++i;@inner(0)){

						q[r_nodeId] = r_res + s_q[0][0][r_smemId];
					}
				}
			}
		} // end of jslabbing
	}

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		@exclusive int emap, r_nodeId, r_smemId;
		@exclusive dfloat r_res;

		for(int ks=0;ks<p_Nslab;++ks;@inner(2)){
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}


	#pragma unroll p_Nslabs
		for(int islab=0;islab<p_Nslabs;++islab){

			for(int is=0;is<p_Nslab;++is;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int j=0;j<p_gjNq;++j;@inner(0)){

						const unsigned int t = j+k*p_gjNq+is*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = islab;
						const unsigned int jB = (t>>6)&p_Bmask;
						const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = jB*4+jT + (p_gjNq+p_pad)*(kB*4+kT) + p_gjNq*(p_gjNq+p_pad)*iT;
						s_q[0][0][r_smemId] = Ixq[r_nodeId];

						r_res = q[r_nodeId];
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslab;++is;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int j=0;j<p_gjNq;++j;@inner(0)){

						const unsigned int base = emap*p_gjNp*p_Nggeo+k*p_gjNq+j + p_gjNq*p_gjNq*(is+islab*p_Nslab); // assume ordering (i,k,j)
						const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
						const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];

						dfloat tmps = 0, tmpt = 0;
						int n=0;

						UNROLLNq(tmps += s_DT[n][j]*s_q[is][k][n]; tmpt += s_D[k][n]*s_q[is][n][j];++n;);

						s_tmp1[is][k][j] = r_G11*tmps + r_G12*tmpt;
						s_tmp2[is][k][j] = r_G12*tmps;
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslab;++is;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int j=0;j<p_gjNq;++j;@inner(0)){

						dfloat tmps = 0, tmpt = 0;
						int n=0;
						UNROLLNq(tmps += s_D[n][j]*(s_tmp1[is][k][n]); tmpt += s_D[n][k]*(s_tmp2[is][n][j]);++n;);
						s_q[is][k][j] = tmps+tmpt;
					}
				}
			}

			@barrier("local");

			for(int is=0;is<p_Nslab;++is;@inner(2)){
				for(int k=0;k<p_gjNq;++k;@inner(1)){
					for(int j=0;j<p_gjNq;++j;@inner(0)){

						q[r_nodeId] = r_res + s_q[0][0][r_smemId];
					}
				}
			}
		} // end of islabbing
	}



	//============================= @kernel 3 (2D)=============================



	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared volatile dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gllPad];

		@exclusive dfloat r_q[p_gjNq];

		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];

		//		if(a<p_Nq && b<p_Nq){
					#pragma unroll p_gjNq
					for(int c=0;c<p_gjNq;++c)
						s_q[c][b][a] = q[emap*p_gjNp+c*p_gjNq*p_gjNq+b*p_gjNq+a];
				
			}
		}
		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
						//		if (k<p_Nq && i<p_Nq)
							//	Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");

		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b





	}

}
*/
//reg2 gives WRONG results; consistent and not too far off, but wrong

// reg3 is based on slab1


@kernel void ellipticAxHex3D_reg3(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                ){
	//@kernel 1 interpolate ---------------------------------------------------------

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@exclusive dfloat r_q[p_gjNq];

		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");

		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");


		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}
	}

	//@kernel 2 differntiate --------------------------------------------------------
	//like in slab 1
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@shared dfloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_tmps[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_q[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_D[p_gjNq][p_gjNq+p_gjPad];

		@exclusive dfloat r_q[p_gjNq], r_Aq[p_gjNq], r_qt, r_tmpt;
		@exclusive int emap;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {

				emap = elementList[e];

				const int base = i + j*p_gjNq + emap*p_gjNp;

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					r_q[k] = Ixq[base + k*p_gjNq*p_gjNq];
					r_Aq[k] = 0.f;
				}

				s_D[j][i] = gllD[j*p_gjNq+i];
			}
		}

		@barrier("local");

		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					const int gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					s_q[j][i] = r_q[k];

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		// write result out (local node storage)
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					Ixq[id] = r_Aq[k];
					id += p_gjNq*p_gjNq;

					//			if (i<p_Nq && j <p_Nq && k<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] = r_Aq[k];
				}
			}
		}
	}


	//@kernel 3 project back --------------------------------------------------------
	for(int e=0;e<Nelements;++e;@outer(0)){

		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@exclusive dfloat r_q[p_gjNq];

		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];

				//	if(a<p_Nq && b<p_Nq){
				#pragma unroll p_gjNq
				for(int c=0;c<p_gjNq;++c)
					s_q[c][b][a] = Ixq[emap*p_gjNp+c*p_gjNq*p_gjNq+b*p_gjNq+a];

			}
		}
		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");

		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b





	}//e


}

//reg4 is one @kernel version of reg 3
@kernel void ellipticAxHex3D_reg4(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict const  dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                ){


	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_tmpr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_tmps[p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_D[p_gjNq][p_gjNq+p_gjPad];

		@exclusive dfloat r_Aq[p_gjNq],  r_tmpt;




		//	@shared volatile dfloat s_gllD[p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_D[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");

		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");


		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//		Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}

		@barrier("local");



		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {

				emap = elementList[e];

				const int base = i + j*p_gjNq + emap*p_gjNp;

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}


			}
		}

		@barrier("local");

		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					const int gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					//		s_q[k][j][i] = r_q[k];

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}
		@barrier("local");
		// write result out (local node storage)
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {

					s_q[k][j][i] = r_Aq[k];

				}
			}
		}



		//@kernel 3 project back --------------------------------------------------------

		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");

		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b


	}//e

}




//reg5: this is a version of reg4 but with 2D s_q

@kernel void ellipticAxHex3D_reg5(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                ){


	for(int e=0; e<Nelements; ++e; @outer(0)) {
		//	@exclusive int emap;
		//	@exclusive dfloat r_res;
		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		@shared volatile dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared volatile dfloat s_q2[p_gjNq][p_gjNq];

		@shared dfloat s_tmpr[p_gjNq][p_gjNq+p_pad];
		@shared dfloat s_tmps[p_gjNq][p_gjNq+p_pad];

		@shared dfloat s_D[p_gjNq][p_gjNq+p_pad];

		@exclusive dfloat r_Aq[p_gjNq],  r_tmpt;




		//	@shared volatile dfloat s_gllD[p_gjNq][p_gjNq];
		@shared volatile dfloat s_I[p_gjNq][p_Nq];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gllPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gllPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_D[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");

		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");


		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//		Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}

		@barrier("local");



		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {

				emap = elementList[e];

				const int base = i + j*p_gjNq + emap*p_gjNp;

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}


			}
		}

		@barrier("local");

		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					const int gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					//		s_q[k][j][i] = r_q[k];

					// hide @shared latency behind t-derivative
					dfloat qtk = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			@barrier("local");

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					dfloat qr = 0.f, qs = 0.f;
					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			@barrier("local");

			// second derivatives
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}
		@barrier("local");
		// write result out (local node storage)
		for(int j=0; j<p_gjNq; ++j; @inner(1)) {
			for(int i=0; i<p_gjNq; ++i; @inner(0)) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {

					s_q[k][j][i] = r_Aq[k];

				}
			}
		}



		//@kernel 3 project back --------------------------------------------------------

		@barrier("local");
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");

		// transform back in a
		#pragma unroll p_gjNq
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			@barrier("local");
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b


	}//e

}

//this is VERY BAD, works ok until N=8
@kernel void ellipticAxHex3D_reg6(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		@shared volatile dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared volatile dfloat s_gllD[p_gjNq][p_gjNq];
		@exclusive dfloat r_I[p_gjNq*p_Nq];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gllPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gllPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_qr[b][a] = gjI[a+p_Nq*b];
				}




				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				#pragma unroll p_Nq
				for (int a2=0; a2<p_Nq; ++a2){
					for (int b2=0; b2<p_gjNq; ++b2){
						r_I[a2+p_Nq*b2] =s_qr[b2][a2];
					}
				}



				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += r_I[j*p_Nq+b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += r_I[i*p_Nq+a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += r_I[k*p_Nq+c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					//	r_q[k] += lambda*r_GwJ*s_q[k][j][i];


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];

				}
			}

			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f, lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += r_I[j*p_Nq+b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += r_I[i*p_Nq+a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += r_I[k*p_Nq+c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//@kernel


//reg7


@kernel void ellipticAxHex3D_reg7(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict const  dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5

		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}

					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr;

				}
			}
			//s_qr[j][n];
			//			lapqs += s_gllD[n][j]*s_qs[n][i];

			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_qr[j][i] = r_qs;
				}
			}
			@barrier("local");
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqs += s_gllD[n][j]*s_qr[n][i];
					}
					r_q[k] += lapqs;
					//+ lapqs;
				}
			}


		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//@kernel

// reg8

//reg8 is like reg7 but it has two D matrices, D and DT


@kernel void ellipticAxHex3D_reg8(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{

	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_gllDT[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];

		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];
				s_gllDT[b][a] = gllD[a*p_gjNq+b];

				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5

		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

	
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllDT[n][i]*s_q[k][j][n];
						ds += s_gllDT[n][j]*s_q[k][n][i];
						dt += s_gllDT[n][k]*s_q[n][j][i];
					}

					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						r_q[n] += s_gllDT[n][k]*r_qt;
					}
					r_q[k] += lapqr;

				}
			}
			//s_qr[j][n];
			//			lapqs += s_gllD[n][j]*s_qs[n][i];

			@barrier("local");
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_qr[j][i] = r_qs;
				}
			}
			@barrier("local");
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqs += s_gllD[n][j]*s_qr[n][i];
					}
					r_q[k] += lapqs;
					//+ lapqs;
				}
			}


		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//@kernel

//reg9 is reg1 but with extra DT matrix

@kernel void ellipticAxHex3D_reg9(const int Nelements,
                                 @restrict const  int *  elementList,
                                 @restrict const  dfloat *  gjGeo,
                                 @restrict const  dfloat *  gllD,
                                 @restrict const  dfloat *  gjI,
                                 const dfloat lambda,
                                 @restrict const  dfloat *  q,
                                 @restrict const  dfloat *  Ixq,
                                 @restrict dfloat *  Aq
                                )
{
	for(int e=0; e<Nelements; ++e; @outer(0)) {

		@exclusive dfloat r_q[p_gjNq];
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

		@shared dfloat s_gllD[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_gllDT[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		@shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		@exclusive int emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];
        s_gllDT[b][a] = gllD[a*p_gjNq+b];
				if(a<p_Nq && b<p_Nq){
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		@barrier("local");


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					#pragma unroll p_Nq
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		@barrier("local");
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;@inner(1)){
			for(int j=0;j<p_gjNq;++j;@inner(0)){
				if(c<p_Nq){

					// prefetch to registers
					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						#pragma unroll p_Nq
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		@barrier("local");
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				// prefetch to registers
				#pragma unroll p_Nq
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				#pragma unroll p_gjNq
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		@barrier("local");
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;@inner(1))
				for(int i=0;i<p_gjNq;++i;@inner(0))
					r_q[k] =0.0f;

		@barrier("local");
		//Loop6
		#pragma unroll p_gjNq
		for(int k=0; k<p_gjNq; ++k) {
			@barrier("local");
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {


					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllDT[n][i]*s_q[k][j][n];
						ds += s_gllDT[n][j]*s_q[k][n][i];
						dt += s_gllDT[n][k]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					//	r_q[k] += lambda*r_GwJ*s_q[k][j][i];


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];

				}
			}

			@barrier("local");
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;@inner(1)){
				for(int i=0;i<p_gjNq;++i;@inner(0)){
					dfloat lapqr = 0.0f, lapqs = 0.0f;

					#pragma unroll p_gjNq
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllDT[n][k]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		@barrier("local");

		//Loop 7
		for(int j=0;j<p_gjNq;++j;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){

				#pragma unroll p_gjNq
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		@barrier("local");
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int i=0;i<p_gjNq;++i;@inner(0)){
				#pragma unroll p_gjNq
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				#pragma unroll p_Nq
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					#pragma unroll p_gjNq
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		@barrier("local");
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;@inner(1)){
			for(int b=0;b<p_gjNq;++b;@inner(0)){
				if(b<p_Nq){
					#pragma unroll p_gjNq
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					#pragma unroll p_Nq
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		@barrier("local");
		//@shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;@inner(1)){
			for(int a=0;a<p_gjNq;++a;@inner(0)){
				if(a<p_Nq && b<p_Nq){
					//#pragma unroll p_gjNq
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//#pragma unroll p_Nq
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						#pragma unroll p_gjNq
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//@kernel


//=========== this is here for comparison and testing


@kernel void ellipticPartialAxHex3D_e9(const int Nelements,
                                      @restrict const  int *  elementList,
                                      @restrict const  dfloat *  gjGeo,
                                      @restrict const  dfloat *  gllD,
                                      @restrict const  dfloat *  gjI,
                                      const dfloat lambda,
                                      @restrict dfloat *  q,
                                      @restrict dfloat *  Ixq,
                                      @restrict dfloat *  Aq
                                     ){


	// load q into @shared first
	//@kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@exclusive int emap;
		@exclusive dfloat r_res;
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					int t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						int ta = t%p_Nq;
						int tb = (t/p_Nq)%p_Nq;
						int tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		@barrier("local");
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						#pragma unroll p_Nq
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		@barrier("local");



		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		@barrier("local");

		// t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					#pragma unroll p_Nq
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const int id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//	Aq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// @kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; @outer(0)) {
		@shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	@shared dfloat s_gllD[p_gjNq][p_Nq];
		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		@exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		@exclusive int emap;

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					// D to @shared, q to @shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					int t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const int base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					#pragma unroll p_gjNq
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		@barrier("local");
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		@barrier("local");

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");

		//s direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		@barrier("local");
		//t direction

		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		@barrier("local");
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat tmp = 0.f;
					#pragma unroll p_gjNq
					for(int m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					int base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
					//		Aq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- @kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; @outer(0)) {
		// read q

		@shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		@shared dfloat s_I[p_gjNq][p_Nq];
		@exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		int emap;
		for(int k=0; k<p_gjNq; ++k; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {

					int base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		@barrier("local");


		// t first
		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int j=0; j<p_gjNq; ++j; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][j][i] = r_res;
				}
			}
		}


		// @shared dfloat s_I[p_gjNq][p_Nq];

		// r direction
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int i=0; i<p_gjNq; ++i; @inner(0)) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		@barrier("local");

		for(int c=0; c<p_gjNq; ++c; @inner(2)) {
			for(int b=0; b<p_gjNq; ++b; @inner(1)) {
				for(int a=0; a<p_gjNq; ++a; @inner(0)) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						#pragma unroll p_gjNq
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						int base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //@kernel e9




