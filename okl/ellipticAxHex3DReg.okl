
//proof of concept: this kernel uses registers, not shared (thus reg)
#define p_gjNp (p_gjNq*p_gjNq*p_gjNq)
#define p_gjNq2 (p_gjNq*p_gjNq)
#define p_Nq2 (p_Nq*p_Nq)


#define p_gllPad 0
#define p_gjPad 0




// [ Dr' Ds' Dt' ] [G00 G01 G02]  [ Dr ]
//               ] [G01 G11 G12]  [ Ds ]
//               ] [G02 G12 G22]  [ Dt ]

// [ Dr' Ds' ] [G00 G01]  [ Dr ]
//           ] [G01   0]  [ Ds ]

// [ Dr' Dt' ] [  0 G02]  [ Dr ]
//           ] [G02 G22]  [ Dt ]


// [ Ds' Dt' ] [G11 G12]  [ Ds ]
//           ] [G12   0]  [ Dt ]

#define UNROLL0(a) a
#define UNROLL1(a) a UNROLL0(a)
#define UNROLL2(a) a UNROLL1(a)
#define UNROLL3(a) a UNROLL2(a)
#define UNROLL4(a) a UNROLL3(a)
#define UNROLL5(a) a UNROLL4(a)
#define UNROLL6(a) a UNROLL5(a)
#define UNROLL7(a) a UNROLL6(a)
#define UNROLL8(a) a UNROLL7(a)
#define UNROLL9(a) a UNROLL8(a)
#define UNROLL10(a) a UNROLL9(a)
#define UNROLL11(a) a UNROLL10(a)
#define UNROLL12(a) a UNROLL11(a)
#define UNROLL13(a) a UNROLL12(a)
#define UNROLL14(a) a UNROLL13(a)
#define UNROLL15(a) a UNROLL14(a)
#define UNROLL16(a) a UNROLL15(a)

#define UNROLLN(n,a) UNROLL##n(a)


#if p_gjNq==4
#define UNROLLNq(a) UNROLL3(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 1
#define p_Nslab 4
#define p_Bsize 2
#endif



#if p_gjNq==8
#define UNROLLNq(a) UNROLL7(a)
#define p_Bskip 1
#define p_Bmask 1
#define p_Nslabs 2
#define p_Nslab 4
#define p_Bsize 2
#endif


#if p_gjNq==16
#define UNROLLNq(a) UNROLL15(a)
#define p_Bskip 2
#define p_Bmask 3
#define p_Nslabs 4
#define p_Nslab 4
#define p_Bsize 4
#endif

#define p_pad 0

//reg1 is a full 2d version without kernel splitting
// interpolation/projection is based on barrier eliminating idea by TW
// the derivative part based on one of the e6 kernels from ellipticAxJex3D.okl


/*
(solver->NglobalGatherElements, solver->o_globalGatherElementList,
                                  solver->o_gjGeo, 
                                  solver->o_gjD2, 
                                  solver->o_gjI, 
                                  lambda, o_q, o_Aq,
                                  solver->o_grad);
*/


kernel void ellipticAxHex3D_reg1(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{
	for(int e=0; e<Nelements; ++e; outer0) {

		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		barrier(localMemFence);
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;inner1)
				for(int i=0;i<p_gjNq;++i;inner0)
					r_q[k] =0.0f;

		barrier(localMemFence);
		//Loop6
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {


					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					//	r_q[k] += lambda*r_GwJ*s_q[k][j][i];


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];

				}
			}

			barrier(localMemFence);
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0.0f, lapqs = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		barrier(localMemFence);

		//Loop 7
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){

				occaUnroll(p_gjNq)
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		barrier(localMemFence);
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//kernel

//reg2 is a splitting version combining best strategy for intepolation with smart slabbing
// intepolation and projection is based on the idea of eliminating barriers
// differentiation is based on our best skinny Ax kernel
/*

kernel void ellipticAxHex3D_reg2(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{
	//============================= kernel 1 (2D)=============================
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive iint emap;
		//	exclusive dfloat r_res;
		exclusive dfloat r_q[p_gjNq];
		//	exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt;
		//save the SHARED
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		//	shared dfloat s_gllD[p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];

		//slab read and LOAD TO SHAEWS
		//exclusive iint emap;
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];


				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c)
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq2+b*p_Nq+a];
				}
			}
		}



		//synch threads
		barrier(localMemFence);


		// transform in b
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}


		barrier(localMemFence);

		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}

		barrier(localMemFence);

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){


					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c)
						tmp += s_I[k][c]*r_q[c];

					//save interpolated
					//Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] =tmp;
					Ixq[emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i] = tmp;
			//	Aq[emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i] = tmp;
				}
			}
		}
	}//e
	//============================= kernel 2 (3D)=============================

	for(int e=0; e<Nelements; ++e; outer0) {
		// load

		shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad]; //
		shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		exclusive int emap, r_nodeId, r_smemId;
		exclusive dfloat r_res;

		for(iint ks=0;ks<p_Nslab;++ks;inner2){
			for(iint j=0;j<p_gjNq;++j;inner1){
				for(iint i=0;i<p_gjNq;++i;inner0){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}

		occaUnroll(p_Nslabs)
		for(iint kslab=0;kslab<p_Nslabs;++kslab){
			for(iint ks=0;ks<p_Nslab;++ks;inner2){
				for(iint j=0;j<p_gjNq;++j;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						const unsigned int t = i+j*p_gjNq+ks*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = (t>>6)&p_Bmask;
						const unsigned int jB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int kB = kslab;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = iB*4+iT + (p_gjNq+p_pad)*(jB*4+jT) + kT*p_gjNq*(p_gjNq+p_pad);
						s_q[0][0][r_smemId] = Ixq[r_nodeId];

					}
				}
			}


			barrier(localMemFence);

			for(iint ks=0;ks<p_Nslab;++ks;inner2){
				barrier(localMemFence);
				for(iint j=0;j<p_gjNq;++j;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						// assume specific data layout for G00 and G01
						const unsigned int base = emap*p_gjNp*p_Nggeo+(ks+kslab*p_Nslab)*p_gjNq*p_gjNq+j*p_gjNq+i;
						const dfloat r_G00 = gjGeo[base+p_G00ID*p_gjNp];
						const dfloat r_G01 = gjGeo[base+p_G01ID*p_gjNp];
						r_res = lambda*gjGeo[base+p_GWJID*p_gjNp]; // lambda*GwJ

						dfloat tmpr = 0, tmps = 0;
						int n;

						n=0;
						UNROLLNq(tmpr += s_DT[n][i]*s_q[ks][j][n];++n;);

						n=0;
						UNROLLNq(tmps += s_D[j][n]*s_q[ks][n][i];++n;);

						s_tmp1[ks][j][i] = r_G00*tmpr + r_G01*tmps;
						s_tmp2[ks][j][i] = r_G01*tmpr;
					}
				}
			}

			barrier(localMemFence);

			for(iint ks=0;ks<p_Nslab;++ks;inner2){
				for(iint j=0;j<p_gjNq;++j;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){
						dfloat tmpr = 0, tmps = 0;
						int n;
						n=0;
						UNROLLNq(tmpr += s_D[n][i]*s_tmp1[ks][j][n]; ++n;);

						n=0;
						UNROLLNq(tmps += s_D[n][j]*s_tmp2[ks][n][i]; ++n;);

						s_q[ks][j][i] = tmpr+tmps+r_res;
					}
				}
			}


			barrier(localMemFence);

			for(iint ks=0;ks<p_Nslab;++ks;inner2){
				for(iint j=0;j<p_gjNq;++j;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						q[r_nodeId] = s_q[0][0][r_smemId];
					}
				}
			}
		} // end of kslabbing
	}


	// cannot merge kernels because of different ordering of access and output

	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		exclusive int emap, r_nodeId, r_smemId, r_res;

		for(iint ks=0;ks<p_Nslab;++ks;inner2){
			for(iint j=0;j<p_gjNq;++j;inner1){
				for(iint i=0;i<p_gjNq;++i;inner0){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}


		occaUnroll(p_Nslabs)
		for(iint jslab=0;jslab<p_Nslabs;++jslab){

		

			for(iint js=0;js<p_Nslab;++js;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						const unsigned int t = i+k*p_gjNq+js*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = (t>>6)&p_Bmask;
						const unsigned int jB = jslab;
						const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = iB*4+iT + (p_gjNq+p_pad)*(kB*4+kT) + p_gjNq*(p_gjNq+p_pad)*jT;
						s_q[0][0][r_smemId] = Ixq[r_nodeId];
						r_res = q[r_nodeId];
					}
				}
			}


			barrier(localMemFence);

			for(iint js=0;js<p_Nslab;++js;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						const unsigned int base = emap*p_gjNp*p_Nggeo+(js+jslab*p_Nslab)*p_gjNq*p_gjNq+k*p_gjNq+i; // assume ordering (j,k,i) with i fastest
						const dfloat r_G02 = gjGeo[base+p_G02ID*p_gjNp];
						const dfloat r_G22 = gjGeo[base+p_G22ID*p_gjNp];

						dfloat tmpr = 0, tmpt = 0;

						int n=0;
						UNROLLNq(tmpr += s_DT[n][i]*s_q[js][k][n]; tmpt += s_D[k][n]*s_q[js][n][i]; ++n;);

						s_tmp1[js][i][k] =              r_G02*tmpt;
						s_tmp2[js][k][i] = r_G02*tmpr + r_G22*tmpt;
					}
				}
			}

			barrier(localMemFence);

			for(iint js=0;js<p_Nslab;++js;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){
						dfloat tmpr = 0, tmpt = 0;
						int n=0;
						UNROLLNq(tmpt += s_D[n][k]*s_tmp2[js][n][i]; tmpr += s_D[n][i]*s_tmp1[js][n][k]; ++n;);

						s_q[js][k][i] = tmpr+tmpt;

					}
				}
			}

			barrier(localMemFence);

			for(iint js=0;js<p_Nslab;++js;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint i=0;i<p_gjNq;++i;inner0){

						q[r_nodeId] = r_res + s_q[0][0][r_smemId];
					}
				}
			}
		} // end of jslabbing
	}

	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmp1[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmp2[p_Nslab][p_gjNq][p_gjNq+p_pad];
		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_DT[p_gjNq][p_gjNq+p_pad];

		exclusive int emap, r_nodeId, r_smemId;
		exclusive dfloat r_res;

		for(iint ks=0;ks<p_Nslab;++ks;inner2){
			for(iint j=0;j<p_gjNq;++j;inner1){
				for(iint i=0;i<p_gjNq;++i;inner0){
					emap = elementList[e];
					if(ks==0){
						s_D[j][i] = gllD[j*p_gjNq+i];
						s_DT[i][j] = gllD[j*p_gjNq+i];
					}
				}
			}
		}


	occaUnroll(p_Nslabs)
		for(iint islab=0;islab<p_Nslabs;++islab){

			for(iint is=0;is<p_Nslab;++is;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint j=0;j<p_gjNq;++j;inner0){

						const unsigned int t = j+k*p_gjNq+is*p_gjNq*p_gjNq;
						const unsigned int iT = t&3;
						const unsigned int jT = (t>>2)&3;
						const unsigned int kT = (t>>4)&3;
						const unsigned int iB = islab;
						const unsigned int jB = (t>>6)&p_Bmask;
						const unsigned int kB = (t>>(6+p_Bskip))&p_Bmask;
						const unsigned int id = iT+jT*4+kT*16+64*(iB+jB*p_Bsize+kB*p_Bsize*p_Bsize);
						r_nodeId = id+emap*p_gjNp;
						r_smemId = jB*4+jT + (p_gjNq+p_pad)*(kB*4+kT) + p_gjNq*(p_gjNq+p_pad)*iT;
						s_q[0][0][r_smemId] = Ixq[r_nodeId];

						r_res = q[r_nodeId];
					}
				}
			}

			barrier(localMemFence);

			for(iint is=0;is<p_Nslab;++is;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint j=0;j<p_gjNq;++j;inner0){

						const unsigned int base = emap*p_gjNp*p_Nggeo+k*p_gjNq+j + p_gjNq*p_gjNq*(is+islab*p_Nslab); // assume ordering (i,k,j)
						const dfloat r_G11 = gjGeo[base+p_G11ID*p_gjNp];
						const dfloat r_G12 = gjGeo[base+p_G12ID*p_gjNp];

						dfloat tmps = 0, tmpt = 0;
						int n=0;

						UNROLLNq(tmps += s_DT[n][j]*s_q[is][k][n]; tmpt += s_D[k][n]*s_q[is][n][j];++n;);

						s_tmp1[is][k][j] = r_G11*tmps + r_G12*tmpt;
						s_tmp2[is][k][j] = r_G12*tmps;
					}
				}
			}

			barrier(localMemFence);

			for(iint is=0;is<p_Nslab;++is;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint j=0;j<p_gjNq;++j;inner0){

						dfloat tmps = 0, tmpt = 0;
						int n=0;
						UNROLLNq(tmps += s_D[n][j]*(s_tmp1[is][k][n]); tmpt += s_D[n][k]*(s_tmp2[is][n][j]);++n;);
						s_q[is][k][j] = tmps+tmpt;
					}
				}
			}

			barrier(localMemFence);

			for(iint is=0;is<p_Nslab;++is;inner2){
				for(iint k=0;k<p_gjNq;++k;inner1){
					for(iint j=0;j<p_gjNq;++j;inner0){

						q[r_nodeId] = r_res + s_q[0][0][r_smemId];
					}
				}
			}
		} // end of islabbing
	}



	//============================= kernel 3 (2D)=============================



	for(int e=0;e<Nelements;++e;outer0){

		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

		exclusive dfloat r_q[p_gjNq];

		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];

		//		if(a<p_Nq && b<p_Nq){
					occaUnroll(p_gjNq)
					for(int c=0;c<p_gjNq;++c)
						s_q[c][b][a] = q[emap*p_gjNp+c*p_gjNq*p_gjNq+b*p_gjNq+a];
				
			}
		}
		barrier(localMemFence);
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
						//		if (k<p_Nq && i<p_Nq)
							//	Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);

		// transform back in a
		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k;inner1){
			barrier(localMemFence);
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b





	}

}
*/
//reg2 gives WRONG results; consistent and not too far off, but wrong

// reg3 is based on slab1


kernel void ellipticAxHex3D_reg3(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                ){
	//kernel 1 interpolate ---------------------------------------------------------

	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive iint emap;
		//	exclusive dfloat r_res;
		exclusive dfloat r_q[p_gjNq];

		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);

		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);


		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}
	}

	//kernel 2 differntiate --------------------------------------------------------
	//like in slab 1
	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_tmpr[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmps[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_q[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];

		exclusive dfloat r_q[p_gjNq], r_Aq[p_gjNq], r_qt, r_tmpt;
		exclusive int emap;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

		// prefetch q(i,j,:,e) to register array
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {

				emap = elementList[e];

				const iint base = i + j*p_gjNq + emap*p_gjNp;

				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {
					r_q[k] = Ixq[base + k*p_gjNq*p_gjNq];
					r_Aq[k] = 0.f;
				}

				s_D[j][i] = gllD[j*p_gjNq+i];
			}
		}

		barrier(localMemFence);

		occaUnroll(p_gjNq)
		for(iint k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {

					const iint gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					s_q[j][i] = r_q[k];

					// hide shared latency behind t-derivative
					dfloat qtk = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {


					dfloat qr = 0.f, qs = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[j][n];
						qs += s_D[j][n]*s_q[n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}

		// write result out (local node storage)
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {
					Ixq[id] = r_Aq[k];
					id += p_gjNq*p_gjNq;

					//			if (i<p_Nq && j <p_Nq && k<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] = r_Aq[k];
				}
			}
		}
	}


	//kernel 3 project back --------------------------------------------------------
	for(int e=0;e<Nelements;++e;outer0){

		shared dfloat s_I[p_gjNq][p_Nq+p_gllPad];
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq+p_gjPad];

		exclusive dfloat r_q[p_gjNq];

		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];

				if(a<p_Nq)
					s_I[b][a] = gjI[a+p_Nq*b];

				//	if(a<p_Nq && b<p_Nq){
				occaUnroll(p_gjNq)
				for(int c=0;c<p_gjNq;++c)
					s_q[c][b][a] = Ixq[emap*p_gjNp+c*p_gjNq*p_gjNq+b*p_gjNq+a];

			}
		}
		barrier(localMemFence);
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);

		// transform back in a
		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k;inner1){
			barrier(localMemFence);
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b





	}//e


}

//reg4 is one kernel version of reg 3
kernel void ellipticAxHex3D_reg4(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                ){


	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive iint emap;
		//	exclusive dfloat r_res;
		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		shared dfloat s_tmpr[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmps[p_gjNq][p_gjNq+p_pad];

		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];

		exclusive dfloat r_Aq[p_gjNq],  r_tmpt;




		//	volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_D[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);

		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);


		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//		Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}

		barrier(localMemFence);



		// prefetch q(i,j,:,e) to register array
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {

				emap = elementList[e];

				const iint base = i + j*p_gjNq + emap*p_gjNp;

				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}


			}
		}

		barrier(localMemFence);

		occaUnroll(p_gjNq)
		for(iint k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {

					const iint gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					//		s_q[k][j][i] = r_q[k];

					// hide shared latency behind t-derivative
					dfloat qtk = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {


					dfloat qr = 0.f, qs = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}
		barrier(localMemFence);
		// write result out (local node storage)
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {

					s_q[k][j][i] = r_Aq[k];

				}
			}
		}



		//kernel 3 project back --------------------------------------------------------

		barrier(localMemFence);
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);

		// transform back in a
		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k;inner1){
			barrier(localMemFence);
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b


	}//e

}




//reg5: this is a version of reg4 but with 2D s_q

kernel void ellipticAxHex3D_reg5(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                ){


	for(int e=0; e<Nelements; ++e; outer0) {
		//	exclusive iint emap;
		//	exclusive dfloat r_res;
		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		volatile shared dfloat s_q2[p_gjNq][p_gjNq];

		shared dfloat s_tmpr[p_gjNq][p_gjNq+p_pad];
		shared dfloat s_tmps[p_gjNq][p_gjNq+p_pad];

		shared dfloat s_D[p_gjNq][p_gjNq+p_pad];

		exclusive dfloat r_Aq[p_gjNq],  r_tmpt;




		//	volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
					//    s_I[b][a] =-12.0;
				}


				s_D[b][a] = gllD[b*p_gjNq+a];




				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];

					}
				}
			}
		}



		//synch threads
		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr





		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);

		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);


		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//		Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}

		barrier(localMemFence);



		// prefetch q(i,j,:,e) to register array
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {

				emap = elementList[e];

				const iint base = i + j*p_gjNq + emap*p_gjNp;

				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {
					r_q[k] = s_q[k][j][i];
					r_Aq[k] = 0.f;
				}


			}
		}

		barrier(localMemFence);

		occaUnroll(p_gjNq)
		for(iint k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {

					const iint gbase = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;

					r_G00 = gjGeo[gbase+p_G00ID*p_gjNp];
					r_G01 = gjGeo[gbase+p_G01ID*p_gjNp];
					r_G02 = gjGeo[gbase+p_G02ID*p_gjNp];
					r_G11 = gjGeo[gbase+p_G11ID*p_gjNp];
					r_G12 = gjGeo[gbase+p_G12ID*p_gjNp];
					r_G22 = gjGeo[gbase+p_G22ID*p_gjNp];
					r_GwJ = gjGeo[gbase+p_GWJID*p_gjNp];

					// share k-slice of q
					//		s_q[k][j][i] = r_q[k];

					// hide shared latency behind t-derivative
					dfloat qtk = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qtk += s_D[k][n]*r_q[n];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {


					dfloat qr = 0.f, qs = 0.f;
					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into r_G entries
					s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
					s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
					r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;

					r_Aq[k] += r_GwJ*lambda*r_q[k];

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						r_Aq[n] += s_D[k][n]*r_tmpt;
					}
				}
			}

			barrier(localMemFence);

			// second derivatives
			for(iint j=0; j<p_gjNq; ++j; inner1) {
				for(iint i=0; i<p_gjNq; ++i; inner0) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					occaUnroll(p_gjNq)
					for(iint n=0; n<p_gjNq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					r_Aq[k] +=  Aq1 + Aq2;
				}
			}
		}
		barrier(localMemFence);
		// write result out (local node storage)
		for(iint j=0; j<p_gjNq; ++j; inner1) {
			for(iint i=0; i<p_gjNq; ++i; inner0) {
				int id = emap*p_gjNp + j*p_gjNq + i;
				occaUnroll(p_gjNq)
				for(iint k=0; k<p_gjNq; ++k) {

					s_q[k][j][i] = r_Aq[k];

				}
			}
		}



		//kernel 3 project back --------------------------------------------------------

		barrier(localMemFence);
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);

		// transform back in a
		occaUnroll(p_gjNq)
		for(int k=0;k<p_gjNq;++k;inner1){
			barrier(localMemFence);
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}

		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						//		Aq[emap*p_Np+c*p_Nq2+b*p_Nq+a] = tmp;
						Aq[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a] = tmp;
					}//c
				}//if
			}//a
		}//b


	}//e

}

//this is VERY BAD, works ok until N=8
kernel void ellipticAxHex3D_reg6(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{
	for(int e=0; e<Nelements; ++e; outer0) {

		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_tmp;
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		exclusive dfloat r_I[p_gjNq*p_Nq];
		shared dfloat s_qr[p_gjNq][p_gjNq+p_gjPad];
		shared dfloat s_qs[p_gjNq][p_gjNq+p_gjPad];
		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_qr[b][a] = gjI[a+p_Nq*b];
				}




				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				occaUnroll(p_Nq)
				for (int a2=0; a2<p_Nq; ++a2){
					for (int b2=0; b2<p_gjNq; ++b2){
						r_I[a2+p_Nq*b2] =s_qr[b2][a2];
					}
				}



				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += r_I[j*p_Nq+b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += r_I[i*p_Nq+a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += r_I[k*p_Nq+c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		barrier(localMemFence);
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;inner1)
				for(int i=0;i<p_gjNq;++i;inner0)
					r_q[k] =0.0f;

		barrier(localMemFence);
		//Loop6
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {


					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}


					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					s_qs[j][i] = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					//	r_q[k] += lambda*r_GwJ*s_q[k][j][i];


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];

				}
			}

			barrier(localMemFence);
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0.0f, lapqs = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						lapqs += s_gllD[n][j]*s_qs[n][i];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr + lapqs;
				}
			}
		}//k

		barrier(localMemFence);

		//Loop 7
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){

				occaUnroll(p_gjNq)
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		barrier(localMemFence);
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += r_I[j*p_Nq+b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += r_I[i*p_Nq+a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += r_I[k*p_Nq+c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//kernel


//reg7


kernel void ellipticAxHex3D_reg7(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{
	for(int e=0; e<Nelements; ++e; outer0) {

		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs;
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		volatile shared dfloat s_qr[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];

		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		barrier(localMemFence);
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;inner1)
				for(int i=0;i<p_gjNq;++i;inner0)
					r_q[k] =0.0f;

		barrier(localMemFence);
		//Loop6
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
						dt += s_gllD[k][n]*s_q[n][j][i];
					}

					s_qr[j][i] = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			barrier(localMemFence);
			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_qr[j][n];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr;

				}
			}
			//s_qr[j][n];
			//			lapqs += s_gllD[n][j]*s_qs[n][i];

			barrier(localMemFence);
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_qr[j][i] = r_qs;
				}
			}
			barrier(localMemFence);
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqs = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqs += s_gllD[n][j]*s_qr[n][i];
					}
					r_q[k] += lapqs;
					//+ lapqs;
				}
			}


		}//k

		barrier(localMemFence);

		//Loop 7
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){

				occaUnroll(p_gjNq)
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		barrier(localMemFence);
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b




	}//e
}//kernel

// reg8

//reg7


kernel void ellipticAxHex3D_reg8(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict gjGeo,
                                 const dfloat * restrict gllD,
                                 const dfloat * restrict gjI,
                                 const dfloat lambda,
                                 dfloat * restrict q,
                                 dfloat * restrict Ixq,
                                 dfloat * restrict Aq
                                )
{
	for(int e=0; e<Nelements; ++e; outer0) {

		exclusive dfloat r_q[p_gjNq];
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ, r_qt, r_qs, r_qr, r_qpart[p_gjNq];
		//save the SHARED
		volatile shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];

		volatile shared dfloat s_gllD[p_gjNq][p_gjNq];
		//	volatile shared dfloat s_qr[p_gjNq][p_gjNq];
		volatile shared dfloat s_I[p_gjNq][p_Nq];

		// LOAD TO SHAEWS
		exclusive iint emap;

		// prefetch D and I matrices and zero register storage
		//LOOP 1
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){

				emap = elementList[e];
				//a<p_Nq && b<p_gjNq
				if(a<p_Nq){
					s_I[b][a] = gjI[a+p_Nq*b];
				}


				s_gllD[b][a] = gllD[b*p_gjNq+a];

				if(a<p_Nq && b<p_Nq){
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_q[c][b][a] = q[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a];
					}
				}
			}
		}



		//synch threads

		barrier(localMemFence);


		//============== interpolate in 3 dir ========================
		// b --> a --> c
		// rrrrrrr




		//Loop 2
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && c<p_Nq){
					// prefetch to registers
					occaUnroll(p_Nq)
					for(int b=0;b<p_Nq;++b)
						r_q[b] = s_q[c][b][a];

					// transform in b
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int b=0;b<p_Nq;++b)
							tmp += s_I[j][b]*r_q[b];
						s_q[c][j][a] = tmp; // ok since only this thread
					}
				}
			}
		}//for c

		barrier(localMemFence);
		//Loop 3
		// transform in a
		for(int c=0;c<p_gjNq;++c;inner1){
			for(int j=0;j<p_gjNq;++j;inner0){
				if(c<p_Nq){

					// prefetch to registers
					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a)
						r_q[a] = s_q[c][j][a];

					// transform in a
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i){
						dfloat tmp = 0;
						occaUnroll(p_Nq)
						for(int a=0;a<p_Nq;++a)
							tmp += s_I[i][a]*r_q[a];
						s_q[c][j][i] = tmp; // ok since only this thread
					}
				}
			}
		}



		//now synch
		barrier(localMemFence);
		//Loop4

		// transform in c
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				// prefetch to registers
				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c)
					r_q[c] = s_q[c][j][i];

				// transform in c
				occaUnroll(p_gjNq)
				for(int k=0;k<p_gjNq;++k){



					dfloat tmp = 0;
					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						tmp += s_I[k][c]*r_q[c];

					}



					s_q[k][j][i] = tmp; // ok since only this thread
					//					Ixq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i]=s_q[k][j][i] ;

				}
			}
		}





		//===============================================now differentiate once interpolated
		//Loop 5
		barrier(localMemFence);
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k)
			for(int j=0;j<p_gjNq;++j;inner1)
				for(int i=0;i<p_gjNq;++i;inner0)
				{
					r_q[k] =0.0f;

				}

		barrier(localMemFence);
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dt += s_gllD[k][n]*s_q[n][j][i];
					}
					r_qpart[k] = dt;
				}
			}
		}//k
		barrier(localMemFence);


		//Loop6
		occaUnroll(p_gjNq)
		for(int k=0; k<p_gjNq; ++k) {
			barrier(localMemFence);
			//Loop6-1
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];


					r_G11 = gjGeo[base+p_G11ID*p_gjNp];


					dfloat dr = 0.0f;
					dfloat ds = 0.0f;

					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gllD[i][n]*s_q[k][j][n];
						ds += s_gllD[j][n]*s_q[k][n][i];
					}
					dfloat dt=r_qpart[k];
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;


					r_q[k] += lambda*r_GwJ*s_q[k][j][i];
				}
			}
			barrier(localMemFence);
			barrier(localMemFence);
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qr;
				}
			}


			//Loop 6-2
			// weak diff
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqr = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqr += s_gllD[n][i]*s_q[k][j][n];
						r_q[n] += s_gllD[k][n]*r_qt;
					}
					r_q[k] += lapqr;

				}
			}
			//s_qr[j][n];
			//			lapqs += s_gllD[n][j]*s_qs[n][i];

			barrier(localMemFence);
				for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = 0.0;
				}
			}
			barrier(localMemFence);
			
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qs;
				}
			}
			barrier(localMemFence);
			for(int j=0;j<p_gjNq;++j;inner1){
				for(int i=0;i<p_gjNq;++i;inner0){
					dfloat lapqs = 0.0f;

					occaUnroll(p_gjNq)
					for(int n=0;n<p_gjNq;++n){
						lapqs += s_gllD[n][j]*s_q[k][n][i];
					}
					r_q[k] += lapqs;
					//+ lapqs;
				}
			}


		}//k

		barrier(localMemFence);

		//Loop 7
		for(int j=0;j<p_gjNq;++j;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){

				occaUnroll(p_gjNq)
				for(int k=0; k<p_gjNq; ++k) {
					s_q[k][j][i] = r_q[k];
					//	Aq[emap*p_gjNp+k*p_gjNq*p_gjNq+j*p_gjNq+i] = r_q[k];
				}
			}
		}

		// ALL CORRECT UNTIL THIS POINT
		barrier(localMemFence);
		//=========== now project =================================================
		// b -> c -> a

		//Loop 8
		// transform back in b
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int i=0;i<p_gjNq;++i;inner0){
				occaUnroll(p_gjNq)
				for(int j=0;j<p_gjNq;++j){
					r_q[j] = s_q[k][j][i];

				}

				occaUnroll(p_Nq)
				for(int b=0;b<p_Nq;++b){
					dfloat tmp = 0.0f;
					occaUnroll(p_gjNq)
					for(int j=0;j<p_gjNq;++j){
						tmp += s_I[j][b]*r_q[j];
					}
					s_q[k][b][i] = tmp; // ok since only this thread
					//			if (k<p_Nq && i<p_Nq)
					//			Aq[emap*p_Np+k*p_Nq2+b*p_Nq+i] = tmp;
				}
			}
		}

		barrier(localMemFence);
		//Loop 9
		// transform back in a
		for(int k=0;k<p_gjNq;++k;inner1){
			for(int b=0;b<p_gjNq;++b;inner0){
				if(b<p_Nq){
					occaUnroll(p_gjNq)
					for(int i=0;i<p_gjNq;++i)
						r_q[i] = s_q[k][b][i];

					occaUnroll(p_Nq)
					for(int a=0;a<p_Nq;++a){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int i=0;i<p_gjNq;++i){
							tmp += s_I[i][a]*r_q[i];
						}
						s_q[k][b][a] =tmp;;


						//		if (k<p_Nq)
						//				Aq[emap*p_Np+k*p_Nq2+b*p_Nq+a] = tmp;
					}
				}
			}
		}
		//Loop 10
		barrier(localMemFence);
		//shared dfloat s_I[p_gjNq][p_Nq];
		// transform back in c
		for(int b=0;b<p_gjNq;++b;inner1){
			for(int a=0;a<p_gjNq;++a;inner0){
				if(a<p_Nq && b<p_Nq){
					//occaUnroll(p_gjNq)
					for(int k=0;k<p_gjNq;++k){
						r_q[k] = s_q[k][b][a];
					}

					//occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						dfloat tmp = 0.0f;
						occaUnroll(p_gjNq)
						for(int k=0;k<p_gjNq;++k){
							tmp += s_I[k][c]*r_q[k];

						}

						Aq[emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a] = tmp;
					}//c
				}//if
			}//a
		}//b
	}//e
}//kernel




//=========== this is here for comparison and testing


kernel void ellipticPartialAxHex3D_e9(const iint Nelements,
                                      const iint * restrict elementList,
                                      const dfloat * restrict gjGeo,
                                      const dfloat * restrict gllD,
                                      const dfloat * restrict gjI,
                                      const dfloat lambda,
                                      dfloat * restrict q,
                                      dfloat * restrict Ixq,
                                      dfloat * restrict Aq
                                     ){


	// load q into shared first
	//kernel 1 - interpolate to gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		exclusive iint emap;
		exclusive dfloat r_res;
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_gsI[p_gjNq][p_Nq];

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					r_res =0.0f;
					if (c == 0 && a<p_Nq && b<p_gjNq) {
						s_gsI[b][a] = gjI[b*p_Nq+a];
					}
					emap = elementList[e];
					iint t = a + b*p_gjNq + c*p_gjNq2;
					if (t<p_Np) {
						iint ta = t%p_Nq;
						iint tb = (t/p_Nq)%p_Nq;
						iint tc = t/p_Nq2;
						s_q[tc][tb][ta] = q[emap*p_Np+t];
					}//if
				}//for a
			}// for b
		}//for c
		//synch threads
		barrier(localMemFence);
		//============== interpolate in 3 dir ========================
		// r --> s --> t
		// rrrrrrr
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if (c<p_Nq && b<p_Nq){
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[i][n]*s_q[c][b][n];
						}
					}
					r_res = Iq;			a
				}
			}
		}

		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i] = r_res;
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq) {
						occaUnroll(p_Nq)
						for(int n=0; n<p_Nq; ++n) {
							Iq += s_gsI[j][n]*s_q[c][n][i];
						}
					}
					r_res = Iq;
				}
			}
		}
		barrier(localMemFence);



		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}
		barrier(localMemFence);

		// t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					occaUnroll(p_Nq)
					for(int n=0; n<p_Nq; ++n) {
						Iq += s_gsI[k][n]*s_q[n][j][i];
					}
					//	r_res = Iq;
					//		s_q[k][j][i] = Iq;
					emap = elementList[e];
					const iint id = emap*p_gjNp + k*p_gjNq*p_gjNq+ j*p_gjNq + i;
					Ixq[id] = Iq;
					//	Aq[id] = Iq;
					//s_q[k][j][i];
				}
			}
		}
	}// for e

	// at this point q is interpolated in all 3 dim.
	// ------------KERNEL 2 -------------->

	// kernel 2 differentiate on gj hex
	for(int e=0; e<Nelements; ++e; outer0) {
		shared dfloat s_gjD[p_gjNq][p_gjNq];
		//	shared dfloat s_gllD[p_gjNq][p_Nq];
		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		exclusive dfloat r_qr, r_qs, r_qt, r_tmp;
		exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		exclusive iint emap;

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					// D to shared, q to shared,
					if (k==0 ) {
						s_gjD[j][i] = gllD[j*p_gjNq+i];
					}
					emap = elementList[e];
					iint t = i + j*p_gjNq + k*p_gjNq2;
					s_q[k][j][i] = Ixq[emap*p_gjNp+t];
				}//for i
			}//for j
		}//for k
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					//load geofactors for my (k,j,i)
					//		emap = elementList[e];
					const iint base = emap*p_Nggeo*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					//geofactors for k j i thread
					r_GwJ = gjGeo[base+p_GWJID*p_gjNp];
					r_G00 = gjGeo[base+p_G00ID*p_gjNp];
					r_G01 = gjGeo[base+p_G01ID*p_gjNp];
					r_G02 = gjGeo[base+p_G02ID*p_gjNp];

					r_G11 = gjGeo[base+p_G11ID*p_gjNp];
					r_G12 = gjGeo[base+p_G12ID*p_gjNp];
					r_G22 = gjGeo[base+p_G22ID*p_gjNp];
					// now, put together dq/dr, qq/ds, dq/dt and dq/dI

					dfloat dr = 0.0f;
					dfloat ds = 0.0f;
					dfloat dt = 0.0f;
					occaUnroll(p_gjNq)
					for (int n = 0; n<p_gjNq; ++n) {
						dr += s_gjD[i][n] * s_q[k][j][n];
						ds += s_gjD[j][n]*s_q[k][n][i];
						dt += s_gjD[k][n]*s_q[n][j][i];
					}
					r_qr = r_G00*dr + r_G01*ds + r_G02*dt;
					r_qs = r_G01*dr + r_G11*ds + r_G12*dt;
					r_qt = r_G02*dr + r_G12*ds + r_G22*dt;

					r_tmp = r_GwJ*s_q[k][j][i]*lambda;
				}
			}
		}
		barrier(localMemFence);
		// Multiply by D^T, size p_Nq x p_gjNq
		// D size p_gjNq x p_Nq

		// r direction
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qr;
				}
			}
		}
		barrier(localMemFence);

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][i]*s_q[k][j][m];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);

		//s direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qs;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][j]*s_q[k][m][i];
					}
					r_tmp +=tmp;
				}
			}
		}
		barrier(localMemFence);
		//t direction

		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[k][j][i] = r_qt;
				}
			}
		}
		barrier(localMemFence);
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat tmp = 0.f;
					occaUnroll(p_gjNq)
					for(iint m=0; m<p_gjNq; ++m) {
						tmp += s_gjD[m][k]*s_q[m][j][i];
					}
					r_tmp +=tmp;
					iint base = emap*p_gjNp + k*p_gjNq*p_gjNq + j*p_gjNq + i;
					Ixq[base] = r_tmp;
					//		Aq[base] = r_tmp;
				}
			}
		}
	}//for e

	//-------------------- kernel 3 interpolate back to gll hex ------------------->

	for(int e=0; e<Nelements; ++e; outer0) {
		// read q

		shared dfloat s_q[p_gjNq][p_gjNq][p_gjNq];
		shared dfloat s_I[p_gjNq][p_Nq];
		exclusive dfloat r_res = 0.0f, r_Aq=0.0f;
		iint emap;
		for(int k=0; k<p_gjNq; ++k; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {

					iint base = k*p_gjNq*p_gjNq + j*p_gjNq + i;
					emap =elementList[e];
					s_q[k][j][i] = Ixq[emap*p_gjNp+base];
					if(i<p_Nq &&  k == 0 && j<p_gjNq) {
						s_I[j][i] = gjI[j*p_Nq+i];
					}
				}
			}
		}
		barrier(localMemFence);


		// t first
		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					dfloat Iq = 0.0f;
					if(c<p_Nq){
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							// k--> c
							Iq += s_I[m][c]*s_q[m][j][i];
						}
					}
					r_res = Iq;
				}
			}
		}

		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int j=0; j<p_gjNq; ++j; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][j][i] = r_res;
				}
			}
		}


		// shared dfloat s_I[p_gjNq][p_Nq];

		// r direction
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					if(c<p_Nq && b<p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][b]*s_q[c][m][i];
						}
						r_res = Iq;
					}
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int i=0; i<p_gjNq; ++i; inner0) {
					s_q[c][b][i]= r_res;
				}
			}
		}
		barrier(localMemFence);

		for(int c=0; c<p_gjNq; ++c; inner2) {
			for(int b=0; b<p_gjNq; ++b; inner1) {
				for(int a=0; a<p_gjNq; ++a; inner0) {
					if (c<p_Nq && b<p_Nq && a< p_Nq){
						dfloat Iq = 0.0f;
						occaUnroll(p_gjNq)
						for(int m=0; m<p_gjNq; ++m) {
							Iq += s_I[m][a]*s_q[c][b][m];
						}
						emap = elementList[e];
						iint base = emap*p_Np + c*p_Nq*p_Nq + b*p_Nq + a;
						Aq[base] = Iq;
					}
				}
			}
		}
	}//e
} //kernel e9




