

// ref0 starting kernel for optimization
// Do not use const, restrict, multiple element in a block
// Read vector from global without shared but save to shared after interpolation
kernel void insSubCycleCubatureVolume2D_v0(
	 				      iint Nelements,
					      dfloat * vgeo,
					      dfloat * cubDrWT,
					      dfloat * cubDsWT,
					      dfloat * cubInterpT,
					      dfloat * U,
					      dfloat * V,
					      dfloat * Ud,
					      dfloat * Vd,
								dfloat * rhsU,
								dfloat * rhsV){

  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

	shared dfloat s_cF11[p_cubNp];
	shared dfloat s_cF12[p_cubNp];
	shared dfloat s_cF21[p_cubNp];
	shared dfloat s_cF22[p_cubNp];
	
	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
		if(e<Nelements && n<p_cubNp){

		dfloat cU = 0.f,  cV = 0.f;
		dfloat cUd = 0.f, cVd = 0.f;
    
			for(iint i=0;i<p_Np;++i){
			  dfloat cIni = cubInterpT[n+i*p_cubNp];
			  iint  id   = e*p_Np + i;  // global id  
			  cU  += cIni*U[id];
			  cV  += cIni*V[id];
			  cUd += cIni*Ud[id];
			  cVd += cIni*Vd[id];				
			}
		//
		s_cF11[n] = cU*cUd;
		s_cF12[n] = cV*cUd;
		s_cF21[n] = cU*cVd;
		s_cF22[n] = cV*cVd;
		}
	}

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	


		if(e<Nelements && n<p_Np){	  
		// prefetch geometric factors (constant on triangle)
		dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		// compute 'r' and 's' derivatives of (q_m) at node n
		dfloat df11dr = 0.f, df11ds = 0.f; 
		dfloat df12dr = 0.f, df12ds = 0.f; 
		dfloat df21dr = 0.f, df21ds = 0.f; 
		dfloat df22dr = 0.f, df22ds = 0.f; 


			for(iint i=0;i<p_cubNp;++i){
				dfloat cDrWni = cubDrWT[n+i*p_Np];
				dfloat cDsWni = cubDsWT[n+i*p_Np];
				// Fetch to shared, used twice
				dfloat cF11 = s_cF11[i];  // makew them global
				dfloat cF12 = s_cF12[i];
				dfloat cF21 = s_cF21[i];
				dfloat cF22 = s_cF22[i];

				df11dr += cDrWni*cF11;
				df11ds += cDsWni*cF11;

				df12dr += cDrWni*cF12;
				df12ds += cDsWni*cF12;

				df21dr += cDrWni*cF21;
				df21ds += cDsWni*cF21;

				df22dr += cDrWni*cF22;
				df22ds += cDsWni*cF22;
				}

			dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
			dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

			iint id = e*p_Np+n;

			rhsU[id]   = -rhsu; // note  change in sign
			rhsV[id]   = -rhsv;		  
		}
	}	


}
}



// Add shared memory for global read of U vectors
kernel void insSubCycleCubatureVolume2D_v1(
	 				      iint Nelements,
					      dfloat * vgeo,
					      dfloat * cubDrWT,
					      dfloat * cubDsWT,
					      dfloat * cubInterpT,
					      dfloat * U,
					      dfloat * V,
					      dfloat * Ud,
					      dfloat * Vd,
								dfloat * rhsU,
								dfloat * rhsV){

  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

	 // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_Np];
    shared dfloat s_V[p_Np];
    shared dfloat s_Ud[p_Np];
    shared dfloat s_Vd[p_Np];

    shared dfloat s_cF11[p_cubNp];
    shared dfloat s_cF12[p_cubNp];
    shared dfloat s_cF21[p_cubNp];
    shared dfloat s_cF22[p_cubNp];

		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
			if(e<Nelements && n<p_Np){ 
			  iint id = e*p_Np+n;
			  s_U[n]  = U[id];
			  s_V[n]  = V[id];
			  s_Ud[n] = Ud[id];
			  s_Vd[n] = Vd[id];	
			}
		}

		barrier(localMemFence);
	
	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
		if(e<Nelements && n<p_cubNp){

		dfloat cU = 0.f,  cV = 0.f;
		dfloat cUd = 0.f, cVd = 0.f;

			for(iint i=0;i<p_Np;++i){
			  dfloat cIni = cubInterpT[n+i*p_cubNp];
			  cU  += cIni*s_U[i];
			  cV  += cIni*s_V[i];
			  cUd += cIni*s_Ud[i];
			  cVd += cIni*s_Vd[i];				
			}
		//
		s_cF11[n] = cU*cUd;
		s_cF12[n] = cV*cUd;
		s_cF21[n] = cU*cVd;
		s_cF22[n] = cV*cVd;
		}
	}

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	


		if(e<Nelements && n<p_Np){	  
		// prefetch geometric factors (constant on triangle)
		dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		// compute 'r' and 's' derivatives of (q_m) at node n
		dfloat df11dr = 0.f, df11ds = 0.f; 
		dfloat df12dr = 0.f, df12ds = 0.f; 
		dfloat df21dr = 0.f, df21ds = 0.f; 
		dfloat df22dr = 0.f, df22ds = 0.f; 


			for(iint i=0;i<p_cubNp;++i){
				dfloat cDrWni = cubDrWT[n+i*p_Np];
				dfloat cDsWni = cubDsWT[n+i*p_Np];
				// Fetch to shared, used twice
				dfloat cF11 = s_cF11[i];  // makew them global
				dfloat cF12 = s_cF12[i];
				dfloat cF21 = s_cF21[i];
				dfloat cF22 = s_cF22[i];

				df11dr += cDrWni*cF11;
				df11ds += cDsWni*cF11;

				df12dr += cDrWni*cF12;
				df12ds += cDsWni*cF12;

				df21dr += cDrWni*cF21;
				df21ds += cDsWni*cF21;

				df22dr += cDrWni*cF22;
				df22ds += cDsWni*cF22;
				}

			dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
			dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

			iint id = e*p_Np+n;

			rhsU[id]   = -rhsu; // note  change in sign
			rhsV[id]   = -rhsv;		  
		}
	}	


}
}





//Add constants 
kernel void insSubCycleCubatureVolume2D_v2(
	 				      const iint Nelements,
					      const dfloat * restrict vgeo,
					      const dfloat * restrict cubDrWT,
					      const dfloat * restrict cubDsWT,
					      const dfloat * restrict cubInterpT,
					      const dfloat * restrict U,
					      const dfloat * restrict V,
					      const dfloat * restrict Ud,
					      const dfloat * restrict Vd,
											dfloat * restrict rhsU,
											dfloat * restrict rhsV){

  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

	 // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_Np];
    shared dfloat s_V[p_Np];
    shared dfloat s_Ud[p_Np];
    shared dfloat s_Vd[p_Np];

    shared dfloat s_cF11[p_cubNp];
    shared dfloat s_cF12[p_cubNp];
    shared dfloat s_cF21[p_cubNp];
    shared dfloat s_cF22[p_cubNp];

		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
			if(e<Nelements && n<p_Np){ 
			  const iint id = e*p_Np+n;
			  s_U[n]  = U[id];
			  s_V[n]  = V[id];
			  s_Ud[n] = Ud[id];
			  s_Vd[n] = Vd[id];	
			}
		}

		barrier(localMemFence);
	
	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
		if(e<Nelements && n<p_cubNp){

		dfloat cU = 0.f,  cV = 0.f;
		dfloat cUd = 0.f, cVd = 0.f;

			for(iint i=0;i<p_Np;++i){
			  dfloat cIni = cubInterpT[n+i*p_cubNp];
			  cU  += cIni*s_U[i];
			  cV  += cIni*s_V[i];
			  cUd += cIni*s_Ud[i];
			  cVd += cIni*s_Vd[i];				
			}
		//
		s_cF11[n] = cU*cUd;
		s_cF12[n] = cV*cUd;
		s_cF21[n] = cU*cVd;
		s_cF22[n] = cV*cVd;
		}
	}

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	


		if(e<Nelements && n<p_Np){	  
		// prefetch geometric factors (constant on triangle)
		const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		// compute 'r' and 's' derivatives of (q_m) at node n
		dfloat df11dr = 0.f, df11ds = 0.f; 
		dfloat df12dr = 0.f, df12ds = 0.f; 
		dfloat df21dr = 0.f, df21ds = 0.f; 
		dfloat df22dr = 0.f, df22ds = 0.f; 


			for(iint i=0;i<p_cubNp;++i){
				const dfloat cDrWni = cubDrWT[n+i*p_Np];
				const dfloat cDsWni = cubDsWT[n+i*p_Np];
				// Fetch to shared, used twice
				const dfloat cF11 = s_cF11[i];  // makew them global
				const dfloat cF12 = s_cF12[i];
				const dfloat cF21 = s_cF21[i];
				const dfloat cF22 = s_cF22[i];

				df11dr += cDrWni*cF11;
				df11ds += cDsWni*cF11;

				df12dr += cDrWni*cF12;
				df12ds += cDsWni*cF12;

				df21dr += cDrWni*cF21;
				df21ds += cDsWni*cF21;

				df22dr += cDrWni*cF22;
				df22ds += cDsWni*cF22;
				}

			const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
			
			const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

			const iint id = e*p_Np+n;

			rhsU[id]   = -rhsu; // note  change in sign
			rhsV[id]   = -rhsv;		  
		}
	}	


}
}




// Add unrolling
kernel void insSubCycleCubatureVolume2D_v3(
	 				      const iint Nelements,
					      const dfloat * restrict vgeo,
					      const dfloat * restrict cubDrWT,
					      const dfloat * restrict cubDsWT,
					      const dfloat * restrict cubInterpT,
					      const dfloat * restrict U,
					      const dfloat * restrict V,
					      const dfloat * restrict Ud,
					      const dfloat * restrict Vd,
											dfloat * restrict rhsU,
											dfloat * restrict rhsV){

  for(iint e=0;e<Nelements;++e;outer0){  // for all elements

	 // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_Np];
    shared dfloat s_V[p_Np];
    shared dfloat s_Ud[p_Np];
    shared dfloat s_Vd[p_Np];

    shared dfloat s_cF11[p_cubNp];
    shared dfloat s_cF12[p_cubNp];
    shared dfloat s_cF21[p_cubNp];
    shared dfloat s_cF22[p_cubNp];

		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
			if(e<Nelements && n<p_Np){ 
			  const iint id = e*p_Np+n;
			  s_U[n]  = U[id];
			  s_V[n]  = V[id];
			  s_Ud[n] = Ud[id];
			  s_Vd[n] = Vd[id];	
			}
		}

		barrier(localMemFence);
	
	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
		if(e<Nelements && n<p_cubNp){

		dfloat cU = 0.f,  cV = 0.f;
		dfloat cUd = 0.f, cVd = 0.f;
     
      occaUnroll(p_Np)
			for(iint i=0;i<p_Np;++i){
			  dfloat cIni = cubInterpT[n+i*p_cubNp];
			  cU  += cIni*s_U[i];
			  cV  += cIni*s_V[i];
			  cUd += cIni*s_Ud[i];
			  cVd += cIni*s_Vd[i];				
			}
		//
		s_cF11[n] = cU*cUd;
		s_cF12[n] = cV*cUd;
		s_cF21[n] = cU*cVd;
		s_cF22[n] = cV*cVd;
		}
	}

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

	for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	


		if(e<Nelements && n<p_Np){	  
		// prefetch geometric factors (constant on triangle)
		const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
		const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
		const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
		const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
		// compute 'r' and 's' derivatives of (q_m) at node n
		dfloat df11dr = 0.f, df11ds = 0.f; 
		dfloat df12dr = 0.f, df12ds = 0.f; 
		dfloat df21dr = 0.f, df21ds = 0.f; 
		dfloat df22dr = 0.f, df22ds = 0.f; 

      occaUnroll(p_cubNp)
			for(iint i=0;i<p_cubNp;++i){
				const dfloat cDrWni = cubDrWT[n+i*p_Np];
				const dfloat cDsWni = cubDsWT[n+i*p_Np];
				// Fetch to shared, used twice
				const dfloat cF11 = s_cF11[i];  // makew them global
				const dfloat cF12 = s_cF12[i];
				const dfloat cF21 = s_cF21[i];
				const dfloat cF22 = s_cF22[i];

				df11dr += cDrWni*cF11;
				df11ds += cDsWni*cF11;

				df12dr += cDrWni*cF12;
				df12ds += cDsWni*cF12;

				df21dr += cDrWni*cF21;
				df21ds += cDsWni*cF21;

				df22dr += cDrWni*cF22;
				df22ds += cDsWni*cF22;
				}

			const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
			const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

			const iint id = e*p_Np+n;

			rhsU[id]   = -rhsu; // note  change in sign
			rhsV[id]   = -rhsv;		  
		}
	}	


}
}



// Add multiple elements per block
kernel void insSubCycleCubatureVolume2D_v4(const iint Nelements,
					const dfloat * restrict vgeo,
					const dfloat * restrict cubDrWT,
					const dfloat * restrict cubDsWT,
					const dfloat * restrict cubInterpT,
					const dfloat * restrict U,
					const dfloat * restrict V,
					const dfloat * restrict Ud,
					const dfloat * restrict Vd,
						  dfloat * restrict rhsU,
						  dfloat * restrict rhsV){

  for(iint eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_cubNblockV][p_Np];
    shared dfloat s_V[p_cubNblockV][p_Np];
    shared dfloat s_Ud[p_cubNblockV][p_Np];
    shared dfloat s_Vd[p_cubNblockV][p_Np];

    shared dfloat s_cF11[p_cubNblockV][p_cubNp];
    shared dfloat s_cF12[p_cubNblockV][p_cubNp];
    shared dfloat s_cF21[p_cubNblockV][p_cubNp];
    shared dfloat s_cF22[p_cubNblockV][p_cubNp];
    //
    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements && n<p_Np){ 
				  const iint id = e*p_Np+n;
				  s_U[es][n]  = U[id];
				  s_V[es][n]  = V[id];
				  s_Ud[es][n] = Ud[id];
				  s_Vd[es][n] = Vd[id];

	}		
      }
    }

    barrier(localMemFence);

    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
	iint e = eo+es; // element in block
	if(e<Nelements && n<p_cubNp){

	  dfloat cU = 0.f,  cV = 0.f;
	  dfloat cUd = 0.f, cVd = 0.f;

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      dfloat cIni = cubInterpT[n+i*p_cubNp];
	      cU  += cIni*s_U[es][i];
	      cV  += cIni*s_V[es][i];
	      cUd += cIni*s_Ud[es][i];
	      cVd += cIni*s_Vd[es][i];				
	    }
	  //
	  s_cF11[es][n] = cU*cUd;
	  s_cF12[es][n] = cV*cUd;
	  s_cF21[es][n] = cU*cVd;
	  s_cF22[es][n] = cV*cVd;
	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_cubNblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	
	iint e = eo+es;

	if(e<Nelements && n<p_Np){	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat df11dr = 0.f, df11ds = 0.f; 
	  dfloat df12dr = 0.f, df12ds = 0.f; 
	  dfloat df21dr = 0.f, df21ds = 0.f; 
	  dfloat df22dr = 0.f, df22ds = 0.f; 

	  occaUnroll(p_cubNp)
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
	      const dfloat cDsWni = cubDsWT[n+i*p_Np];
	      // Fetch to shared, used twice
	      const dfloat cF11 = s_cF11[es][i];
	      const dfloat cF12 = s_cF12[es][i];
	      const dfloat cF21 = s_cF21[es][i];
	      const dfloat cF22 = s_cF22[es][i];

	      df11dr += cDrWni*cF11;
	      df11ds += cDsWni*cF11;

	      df12dr += cDrWni*cF12;
	      df12ds += cDsWni*cF12;

	      df21dr += cDrWni*cF21;
	      df21ds += cDsWni*cF21;

	      df22dr += cDrWni*cF22;
	      df22ds += cDsWni*cF22;
	    }

	  const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
	  const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

	  const iint id = e*p_Np+n;

	  rhsU[id]   = -rhsu; // note  change in sign
	  rhsV[id]   = -rhsv;		  
	}
      }
    }

  }

}




// Use less shared memory, with one more memory fence
kernel void insSubCycleCubatureVolume2D_v5(const iint Nelements,
					const dfloat * restrict vgeo,
					const dfloat * restrict cubDrWT,
					const dfloat * restrict cubDsWT,
					const dfloat * restrict cubInterpT,
					const dfloat * restrict U,
					const dfloat * restrict V,
					const dfloat * restrict Ud,
					const dfloat * restrict Vd,
					dfloat * restrict rhsU,
					dfloat * restrict rhsV){
  
  for(iint eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_cubNblockV][p_cubNp];
    shared dfloat s_V[p_cubNblockV][p_cubNp];
    shared dfloat s_Ud[p_cubNblockV][p_cubNp];
    shared dfloat s_Vd[p_cubNblockV][p_cubNp];

		#define s_cF11 s_U
		#define s_cF12 s_V
		#define s_cF21 s_Ud
		#define s_cF22 s_Vd

    exclusive dfloat cU, cV, cUd, cVd;

	//
	for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
		iint e = eo+es; // element in block
			if(e<Nelements && n<p_Np){ 
				const iint id = e*p_Np+n;
				s_U[es][n]  = U[id];
				s_V[es][n]  = V[id];
				s_Ud[es][n] = Ud[id];
				s_Vd[es][n] = Vd[id];
			}		
		}
	}
    
    barrier(localMemFence);
    
	for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
			iint e = eo+es; // element in block
			if(e<Nelements && n<p_cubNp){

				cU = 0.f;  cV = 0.f;
				cUd = 0.f; cVd = 0.f;

				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					dfloat cIni = cubInterpT[n+i*p_cubNp];
					cU  += cIni*s_U[es][i];
					cV  += cIni*s_V[es][i];
					cUd += cIni*s_Ud[es][i];
					cVd += cIni*s_Vd[es][i];				
				}
			}
		}
	}

    barrier(localMemFence);

	for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
			iint e = eo+es; // element in block
			if(e<Nelements && n<p_cubNp){
				//
				s_cF11[es][n] = cU*cUd;
				s_cF12[es][n] = cV*cUd;
				s_cF21[es][n] = cU*cVd;
				s_cF22[es][n] = cV*cVd;
			}
		}
	}

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

	for(iint es=0;es<p_cubNblockV;++es;inner1){
		for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	
		iint e = eo+es;

			if(e<Nelements && n<p_Np){	  
			// prefetch geometric factors (constant on triangle)
			const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
			const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
			const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
			const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

			// compute 'r' and 's' derivatives of (q_m) at node n
			dfloat df11dr = 0.f, df11ds = 0.f; 
			dfloat df12dr = 0.f, df12ds = 0.f; 
			dfloat df21dr = 0.f, df21ds = 0.f; 
			dfloat df22dr = 0.f, df22ds = 0.f; 

			occaUnroll(p_cubNp)
				for(iint i=0;i<p_cubNp;++i){
					const dfloat cDrWni = cubDrWT[n+i*p_Np];
					const dfloat cDsWni = cubDsWT[n+i*p_Np];

					const dfloat cF11 = s_cF11[es][i];
					const dfloat cF12 = s_cF12[es][i];
					const dfloat cF21 = s_cF21[es][i];
					const dfloat cF22 = s_cF22[es][i];

					df11dr += cDrWni*cF11;
					df11ds += cDsWni*cF11;

					df12dr += cDrWni*cF12;
					df12ds += cDsWni*cF12;

					df21dr += cDrWni*cF21;
					df21ds += cDsWni*cF21;

					df22dr += cDrWni*cF22;
					df22ds += cDsWni*cF22;
				}

				
				const iint id = e*p_Np+n;

				rhsU[id]   = -(drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds); // note  change in sign
				rhsV[id]   = -(drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds);		  
				}
			}
		}
	}

#undef s_cF11
#undef s_cF12
#undef s_cF21
#undef s_cF22
}

#if p_N<=4
#define p_Nmult 4
#endif

#if p_N>4 && p_N<=9
#define p_Nmult 3
#endif

#if p_N>9
#define p_Nmult 1
#endif

#define p_cubNpad 0
//#define p_Nmult 2

// TW tweaks
kernel void insSubCycleCubatureVolume2D_v6(const iint Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict cubDrWT,
					   const dfloat * restrict cubDsWT,
					   const dfloat * restrict cubInterpT,
					   const dfloat * restrict U,
					   const dfloat * restrict V,
					   const dfloat * restrict Ud,
					   const dfloat * restrict Vd,
					   dfloat * restrict rhsU,
					   dfloat * restrict rhsV){

  for(iint eo=0;eo<Nelements;eo+=(p_cubNblockV*p_Nmult);outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_Nmult][p_cubNblockV][p_Np];
    shared dfloat  s_V[p_Nmult][p_cubNblockV][p_Np];
    shared dfloat s_Ud[p_Nmult][p_cubNblockV][p_Np];
    shared dfloat s_Vd[p_Nmult][p_cubNblockV][p_Np];
    
    shared dfloat s_cF11[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
    shared dfloat s_cF12[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
    shared dfloat s_cF21[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
    shared dfloat s_cF22[p_Nmult][p_cubNblockV][p_cubNp+p_cubNpad];
    
    //
    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block      
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
	
	occaUnroll(p_Nmult)
	  for(iint em=0;em<p_Nmult;++em){
	    const int e = eo + es*p_Nmult + em;
	    const int id = e*p_Np + n;
	    
	    if(e<Nelements && n<p_Np){
	      
	      // prefetch geometric factors (constant on triangle)
	      const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	      const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	      const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	      const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	      
	      const dfloat Un = U[id];
	      const dfloat Vn = V[id];
	      
	      s_Ud[em][es][n] = Ud[id];
	      s_Vd[em][es][n] = Vd[id];
	      
	      s_U[em][es][n] = drdx*Un + drdy*Vn; // rotate velocity 
	      s_V[em][es][n] = dsdx*Un + dsdy*Vn; // 
	    }
	    else{
	      s_U[em][es][n] = 0;
	      s_V[em][es][n] = 0;
	      s_Ud[em][es][n] = 0;
	      s_Vd[em][es][n] = 0;
	    }
	  }
      }
    }
    
    barrier(localMemFence);
    
    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element

	dfloat cU[p_Nmult], cV[p_Nmult], cUd[p_Nmult], cVd[p_Nmult];
	
	occaUnroll(p_Nmult)
	  for(iint em=0;em<p_Nmult;++em){
	    cU[em] = 0.f;
	    cV[em] = 0.f;
	    cUd[em] = 0.f; 
	    cVd[em] = 0.f;
	  }
	
	occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat cIni = cubInterpT[n+i*p_cubNp];
	    occaUnroll(p_Nmult)
	      for(iint em=0;em<p_Nmult;++em){
		cU[em]  += cIni*s_U[em][es][i];
		cV[em]  += cIni*s_V[em][es][i];
		cUd[em] += cIni*s_Ud[em][es][i];
		cVd[em] += cIni*s_Vd[em][es][i];				
	      }
	  }
	
	//
	occaUnroll(p_Nmult)
	  for(iint em=0;em<p_Nmult;++em){
	    s_cF11[em][es][n] = cU[em]*cUd[em];
	    s_cF12[em][es][n] = cV[em]*cUd[em];
	    s_cF21[em][es][n] = cU[em]*cVd[em];
	    s_cF22[em][es][n] = cV[em]*cVd[em];
	  }
      }
    }
    
    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint es=0;es<p_cubNblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	
	
	if(n<p_Np){	  
	  dfloat fluxU[p_Nmult], fluxV[p_Nmult];
	  
	  occaUnroll(p_Nmult)
	    for(iint em=0;em<p_Nmult;++em){
	      fluxU[em] = 0;
	      fluxV[em] = 0;
	    }
	  
	  occaUnroll(p_cubNp)
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
	      const dfloat cDsWni = cubDsWT[n+i*p_Np];
	      
	      occaUnroll(p_Nmult)
		for(iint em=0;em<p_Nmult;++em){  
		  const dfloat cF11 = s_cF11[em][es][i];
		  const dfloat cF12 = s_cF12[em][es][i];
		  const dfloat cF21 = s_cF21[em][es][i];
		  const dfloat cF22 = s_cF22[em][es][i];
		  
		  fluxU[em] += cDrWni*cF11;
		  fluxU[em] += cDsWni*cF12;
		  fluxV[em] += cDrWni*cF21;
		  fluxV[em] += cDsWni*cF22;
		}
	    }

	  occaUnroll(p_Nmult)
	    for(iint em=0;em<p_Nmult;++em){
	      iint e = eo+es*p_Nmult+em;
	      if(e<Nelements){
		const iint id = e*p_Np+n;
		
		rhsU[id]   = -fluxU[em]; // note  change in sign
		rhsV[id]   = -fluxV[em];		  
	      }
	    }
	}
      }
    }
  }
}






#define p_NblockV 4

#define p_Nout 1

#if ((p_Np)<(p_cubNp))
#define p_Nout 2
#endif
#if ((p_Np*2)<(p_cubNp))
#define p_Nout 3
#endif
#if ((p_Np*3)<(p_cubNp))
#define p_Nout 4
#endif

kernel void insSubCycleCubatureVolume2D_v7(const iint Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict cubDrWT,
					   const dfloat * restrict cubDsWT,
					   const dfloat * restrict cubInterpT,
					   const dfloat * restrict U,
					   const dfloat * restrict V,
					   const dfloat * restrict Ud,
					   const dfloat * restrict Vd,
					   dfloat * restrict rhsU,
					   dfloat * restrict rhsV){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_NblockV][p_Np];
    shared dfloat  s_V[p_NblockV][p_Np];
    shared dfloat s_Ud[p_NblockV][p_Np];
    shared dfloat s_Vd[p_NblockV][p_Np];
    
    shared dfloat s_cF11[p_NblockV][p_cubNp];
    shared dfloat s_cF12[p_NblockV][p_cubNp];
    shared dfloat s_cF21[p_NblockV][p_cubNp];
    shared dfloat s_cF22[p_NblockV][p_cubNp];
    
    //
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block      
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	const int e = eo + es;
	const int id = e*p_Np + n;
	
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	  
	  const dfloat Un = U[id];
	  const dfloat Vn = V[id];
	  
	  s_Ud[es][n] = Ud[id];
	  s_Vd[es][n] = Vd[id];
	  
	  s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
	  s_V[es][n] = dsdx*Un + dsdy*Vn; // 
	}
      }
    }
    
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint t=0;t<p_Np;++t;inner0){     // for all nodes in this element
	dfloat cU[p_Nout], cV[p_Nout], cUd[p_Nout], cVd[p_Nout];

	occaUnroll(p_Nout)
	  for(iint nout=0;nout<p_Nout;++nout){
	    cU[nout] = 0.f;
	    cV[nout] = 0.f;
	    cUd[nout] = 0.f; 
	    cVd[nout] = 0.f;
	  }

	occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    
	    const dfloat Ui = s_U[es][i];
	    const dfloat Vi = s_V[es][i];
	    const dfloat Udi = s_Ud[es][i];
	    const dfloat Vdi = s_Vd[es][i];
	    
	    occaUnroll(p_Nout)
	      for(iint nout=0;nout<p_Nout;++nout){
					const int n = p_Np*nout + t;
					if(n<p_cubNp){
		 			 const dfloat cIni = cubInterpT[n+i*p_cubNp];
					  
					  cU[nout]  += cIni*Ui;
					  cV[nout]  += cIni*Vi;
					  cUd[nout] += cIni*Udi;
					  cVd[nout] += cIni*Vdi;
					}
	      }
	  }
	
	occaUnroll(p_Nout)
	  for(iint nout=0;nout<p_Nout;++nout){
	    const int n = p_Np*nout + t;
	    if(n<p_cubNp){
	      s_cF11[es][n] = cU[nout]*cUd[nout];
	      s_cF12[es][n] = cV[nout]*cUd[nout];
	      s_cF21[es][n] = cU[nout]*cVd[nout];
	      s_cF22[es][n] = cV[nout]*cVd[nout];
	    }
	  }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){    	
	iint e = eo+es;
	if(e<Nelements){
	  
	  dfloat fluxU = 0, fluxV = 0;
	  
	  occaUnroll(p_cubNp)
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
	      const dfloat cDsWni = cubDsWT[n+i*p_Np];
	      
	      const dfloat cF11 = s_cF11[es][i];
	      const dfloat cF12 = s_cF12[es][i];
	      const dfloat cF21 = s_cF21[es][i];
	      const dfloat cF22 = s_cF22[es][i];
	      
	      fluxU += cDrWni*cF11;
	      fluxU += cDsWni*cF12;
	      fluxV += cDrWni*cF21;
	      fluxV += cDsWni*cF22;
	    }
	  
	  const iint id = e*p_Np+n;
	  
	  rhsU[id]   = -fluxU; // note  change in sign
	  rhsV[id]   = -fluxV;		  
	}
      }
    }
  }
}


// TW tweaks
kernel void insSubCycleCubatureVolume2D_v8(const iint Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict cubDrWT,
					   const dfloat * restrict cubDsWT,
					   const dfloat * restrict cubInterpT,
					   const dfloat * restrict U,
					   const dfloat * restrict V,
					   const dfloat * restrict Ud,
					   const dfloat * restrict Vd,
					   dfloat * restrict rhsU,
					   dfloat * restrict rhsV){

#define p_NblockE 1

  for(iint eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_NblockE][p_Np];
    shared dfloat  s_V[p_NblockE][p_Np];
    shared dfloat s_Ud[p_NblockE][p_Np];
    shared dfloat s_Vd[p_NblockE][p_Np];

    shared dfloat s_cF11[p_NblockE][p_cubNp];
    shared dfloat s_cF12[p_NblockE][p_cubNp];
    shared dfloat s_cF21[p_NblockE][p_cubNp];
    shared dfloat s_cF22[p_NblockE][p_cubNp];
    
    //
    for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element

      occaUnroll(p_NblockE)
	for(iint es=0;es<p_NblockE;++es){
	  const int e = eo + es;
	  const int id = e*p_Np + n;
	  
	  if(e<Nelements && n<p_Np){
	    
	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	    
	    const dfloat Un = U[id];
	    const dfloat Vn = V[id];
	    
	    s_Ud[es][n] = Ud[id];
	    s_Vd[es][n] = Vd[id];
	    
	    s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
	    s_V[es][n] = dsdx*Un + dsdy*Vn; // 
	  }
	  else{
	    s_U[es][n] = 0;
	    s_V[es][n] = 0;
	    s_Ud[es][n] = 0;
	    s_Vd[es][n] = 0;
	  }
	}
    }
    
    barrier(localMemFence);

    for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
      
      dfloat cU[p_NblockE], cV[p_NblockE], cUd[p_NblockE], cVd[p_NblockE];

      occaUnroll(p_NblockE)
	for(iint es=0;es<p_NblockE;++es){      
	  cU[es] = 0.f;
	  cV[es] = 0.f;
	  cUd[es] = 0.f; 
	  cVd[es] = 0.f;
	}
      
      occaUnroll(p_Np)
	for(iint i=0;i<p_Np;++i){
	  const dfloat cIni = cubInterpT[n+i*p_cubNp];
	  
	  // block here to minimize fetches of cubInterpT
	  occaUnroll(p_NblockE)
	    for(iint es=0;es<p_NblockE;++es){      
	      cU[es]  += cIni*s_U[es][i];
	      cV[es]  += cIni*s_V[es][i];
	      cUd[es] += cIni*s_Ud[es][i];
	      cVd[es] += cIni*s_Vd[es][i];				
	    }
	}
      
      //
      occaUnroll(p_NblockE)
	for(iint es=0;es<p_NblockE;++es){      
	  s_cF11[es][n] = cU[es]*cUd[es];
	  s_cF12[es][n] = cV[es]*cUd[es];
	  s_cF21[es][n] = cU[es]*cVd[es];
	  s_cF22[es][n] = cV[es]*cVd[es];
	}
    }
    
    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	
      
      if(n<p_Np){	  
	dfloat fluxU[p_NblockE], fluxV[p_NblockE];
	
	occaUnroll(p_NblockE)
	  for(iint es=0;es<p_NblockE;++es){      
	    fluxU[es] = 0;
	    fluxV[es] = 0;
	  }
	
	  occaUnroll(p_cubNp)
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
	      const dfloat cDsWni = cubDsWT[n+i*p_Np];
	      
	      occaUnroll(p_NblockE)
		for(iint es=0;es<p_NblockE;++es){      
		  const dfloat cF11 = s_cF11[es][i];
		  const dfloat cF12 = s_cF12[es][i];
		  const dfloat cF21 = s_cF21[es][i];
		  const dfloat cF22 = s_cF22[es][i];
		  
		  fluxU[es] += cDrWni*cF11;
		  fluxU[es] += cDsWni*cF12;
		  fluxV[es] += cDrWni*cF21;
		  fluxV[es] += cDsWni*cF22;
		}
	    }
	  
	  occaUnroll(p_NblockE)
	    for(iint es=0;es<p_NblockE;++es){      
	      const iint e = eo+es;
	      if(e<Nelements){
		const iint id = e*p_Np+n;
		
		rhsU[id]   = -fluxU[es]; // note  change in sign
		rhsV[id]   = -fluxV[es];		  
	      }
	    }
      }
    }
  }
}


// TW tweaks
kernel void insSubCycleCubatureVolume2D_v9(const iint Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict cubDrWT,
					   const dfloat * restrict cubDsWT,
					   const dfloat * restrict cubInterpT,
					   const dfloat * restrict U,
					   const dfloat * restrict V,
					   const dfloat * restrict Ud,
					   const dfloat * restrict Vd,
					   dfloat * restrict rhsU,
					   dfloat * restrict rhsV){

#define p_NblockE 2

  for(iint eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_NblockE][p_Np];
    shared dfloat  s_V[p_NblockE][p_Np];
    shared dfloat s_Ud[p_NblockE][p_Np];
    shared dfloat s_Vd[p_NblockE][p_Np];

    shared dfloat s_cF11[p_NblockE][p_cubNp];
    shared dfloat s_cF12[p_NblockE][p_cubNp];
    shared dfloat s_cF21[p_NblockE][p_cubNp];
    shared dfloat s_cF22[p_NblockE][p_cubNp];
    
    //
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      occaUnroll(p_NblockE)
	for(iint es=0;es<p_NblockE;++es){
	  const int e = eo + es;
	  const int id = e*p_Np + n;
	  
	  if(e<Nelements){
	    
	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	    
	    const dfloat Un = U[id];
	    const dfloat Vn = V[id];
	    
	    s_Ud[es][n] = Ud[id];
	    s_Vd[es][n] = Vd[id];
	    
	    s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
	    s_V[es][n] = dsdx*Un + dsdy*Vn; // 
	  }
	  else{
	    s_U[es][n] = 0;
	    s_V[es][n] = 0;
	    s_Ud[es][n] = 0;
	    s_Vd[es][n] = 0;
	  }
	}
    }
    
    barrier(localMemFence);

    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      for(int m=n;m<p_cubNp;m+=p_Np){
	
	dfloat cU0 = 0.f, cV0 = 0.f, cUd0 = 0.f, cVd0 = 0.f;
	dfloat cU1 = 0.f, cV1 = 0.f, cUd1 = 0.f, cVd1 = 0.f;
	int es;

	//	occaUnroll(p_Np)
	for(iint i=0;i<p_Np;++i){
	    const dfloat cIni = cubInterpT[m+i*p_cubNp];
	    
	    // block here to minimize fetches of cubInterpT
	    es = 0;
	    cU0  += cIni*s_U[es][i];
	    cV0  += cIni*s_V[es][i];
	    cUd0 += cIni*s_Ud[es][i];
	    cVd0 += cIni*s_Vd[es][i];				
	    ++es;
	    cU1  += cIni*s_U[es][i];
	    cV1  += cIni*s_V[es][i];
	    cUd1 += cIni*s_Ud[es][i];
	    cVd1 += cIni*s_Vd[es][i];				
	  }
	
	//
	es = 0;
	s_cF11[es][m] = cU0*cUd0;
	s_cF12[es][m] = cV0*cUd0;
	s_cF21[es][m] = cU0*cVd0;
	s_cF22[es][m] = cV0*cVd0;
	++es;
	s_cF11[es][m] = cU1*cUd1;
	s_cF12[es][m] = cV1*cUd1;
	s_cF21[es][m] = cU1*cVd1;
	s_cF22[es][m] = cV1*cVd1;
      }
    }
    
    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint n=0;n<p_Np;++n;inner0){    	
      
      dfloat fluxU0 = 0, fluxV0 = 0;
      dfloat fluxU1 = 0, fluxV1 = 0;
      
      occaUnroll(p_cubNp)
	for(iint i=0;i<p_cubNp;++i){
	  const dfloat cDrWni = cubDrWT[n+i*p_Np];
	  const dfloat cDsWni = cubDsWT[n+i*p_Np];
	  
	  {
	    int es = 0;
	    const dfloat cF11 = s_cF11[es][i];
	    const dfloat cF12 = s_cF12[es][i];
	    const dfloat cF21 = s_cF21[es][i];
	    const dfloat cF22 = s_cF22[es][i];
	    
	    fluxU0 += cDrWni*cF11;
	    fluxU0 += cDsWni*cF12;
	    fluxV0 += cDrWni*cF21;
	    fluxV0 += cDsWni*cF22;
	  }

	  {
	    int es = 1;
	    const dfloat cF11 = s_cF11[es][i];
	    const dfloat cF12 = s_cF12[es][i];
	    const dfloat cF21 = s_cF21[es][i];
	    const dfloat cF22 = s_cF22[es][i];
	    
	    fluxU1 += cDrWni*cF11;
	    fluxU1 += cDsWni*cF12;
	    fluxV1 += cDrWni*cF21;
	    fluxV1 += cDsWni*cF22;
	  }
	}
      
      iint e = eo+0;
      if(e<Nelements){
	const iint id = e*p_Np+n;
	
	rhsU[id]   = -fluxU0; 
	rhsV[id]   = -fluxV0;		  
      }
      e = eo+1;
      if(e<Nelements){
	const iint id = e*p_Np+n;
	
	rhsU[id]   = -fluxU1; 
	rhsV[id]   = -fluxV1;		  
      }
    }
  }
}


// TW tweaks
kernel void insSubCycleCubatureVolume2D_v10(const iint Nelements,
					   const dfloat * restrict vgeo,
					   const dfloat * restrict cubDrWT,
					   const dfloat * restrict cubDsWT,
					   const dfloat * restrict cubInterpT,
					   const dfloat * restrict U,
					   const dfloat * restrict V,
					   const dfloat * restrict Ud,
					   const dfloat * restrict Vd,
					   dfloat * restrict rhsU,
					   dfloat * restrict rhsV){

#define p_NblockE 2

  for(iint eo=0;eo<Nelements;eo+=p_NblockE;outer0){  // for all elements
    
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat  s_U[p_NblockE][p_Np];
    shared dfloat  s_V[p_NblockE][p_Np];
    shared dfloat s_Ud[p_NblockE][p_Np];
    shared dfloat s_Vd[p_NblockE][p_Np];

    shared dfloat s_cF11[p_NblockE][p_cubNp];
    shared dfloat s_cF12[p_NblockE][p_cubNp];
    shared dfloat s_cF21[p_NblockE][p_cubNp];
    shared dfloat s_cF22[p_NblockE][p_cubNp];
    
    //
    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      occaUnroll(p_NblockE)
	for(iint es=0;es<p_NblockE;++es){
	  const int e = eo + es;
	  const int id = e*p_Np + n;
	  
	  if(e<Nelements){
	    
	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	    
	    const dfloat Un = U[id];
	    const dfloat Vn = V[id];
	    
	    s_Ud[es][n] = Ud[id];
	    s_Vd[es][n] = Vd[id];
	    
	    s_U[es][n] = drdx*Un + drdy*Vn; // rotate velocity 
	    s_V[es][n] = dsdx*Un + dsdy*Vn; // 
	  }
	  else{
	    s_U[es][n] = 0;
	    s_V[es][n] = 0;
	    s_Ud[es][n] = 0;
	    s_Vd[es][n] = 0;
	  }
	}
    }
    
    barrier(localMemFence);

    for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

      dfloat cU[p_NblockE], cV[p_NblockE], cUd[p_NblockE], cVd[p_NblockE];
      
      for(int m=n;m<p_cubNp;m+=p_Np){
	
	occaUnroll(p_NblockE)
	  for(int es = 0; es<p_NblockE;++es){
	    cU[es] = 0;
	    cV[es] = 0;
	    cUd[es] = 0;
	    cVd[es] = 0;
	  }

	for(iint i=0;i<p_Np;++i){
	    const dfloat cIni = cubInterpT[m+i*p_cubNp];
	    
	    // block here to minimize fetches of cubInterpT
	    int es = 0;
	    cU[es]  += cIni*s_U[es][i];
	    cV[es]  += cIni*s_V[es][i];
	    cUd[es] += cIni*s_Ud[es][i];
	    cVd[es] += cIni*s_Vd[es][i];				
	    ++es;
	    cU[es]  += cIni*s_U[es][i];
	    cV[es]  += cIni*s_V[es][i];
	    cUd[es] += cIni*s_Ud[es][i];
	    cVd[es] += cIni*s_Vd[es][i];				
	}
	
	occaUnroll(p_NblockE)
	  for(int es = 0; es<p_NblockE;++es){
	    s_cF11[es][m] = cU[es]*cUd[es];
	    s_cF12[es][m] = cV[es]*cUd[es];
	    s_cF21[es][m] = cU[es]*cVd[es];
	    s_cF22[es][m] = cV[es]*cVd[es];
	  }
      }
    }
    
    // Make sure all node data is loaded into shared
    barrier(localMemFence);
    
    for(iint n=0;n<p_Np;++n;inner0){    	
      
      dfloat fluxU[p_NblockE], fluxV[p_NblockE];
      
      occaUnroll(p_NblockE)
	for(int es = 0; es<p_NblockE;++es){	  
	  fluxU[es] = 0;
	  fluxV[es] = 0;
	}
      
      occaUnroll(p_cubNp)
	for(iint i=0;i<p_cubNp;++i){
	  const dfloat cDrWni = cubDrWT[n+i*p_Np];
	  const dfloat cDsWni = cubDsWT[n+i*p_Np];

	  int es = 0;
	  {
	    const dfloat cF11 = s_cF11[es][i];
	    const dfloat cF12 = s_cF12[es][i];
	    const dfloat cF21 = s_cF21[es][i];
	    const dfloat cF22 = s_cF22[es][i];
	    
	    fluxU[es] += cDrWni*cF11;
	    fluxU[es] += cDsWni*cF12;
	    fluxV[es] += cDrWni*cF21;
	    fluxV[es] += cDsWni*cF22;
	    ++es;
	  }
	  {
	    const dfloat cF11 = s_cF11[es][i];
	    const dfloat cF12 = s_cF12[es][i];
	    const dfloat cF21 = s_cF21[es][i];
	    const dfloat cF22 = s_cF22[es][i];
	    
	    fluxU[es] += cDrWni*cF11;
	    fluxU[es] += cDsWni*cF12;
	    fluxV[es] += cDrWni*cF21;
	    fluxV[es] += cDsWni*cF22;
	    ++es;
	  }
	}
      
      occaUnroll(p_NblockE)
	for(int es = 0; es<p_NblockE;++es){	  
	  iint e = eo+es;
	  if(e<Nelements){
	    const iint id = e*p_Np+n;
	    
	    rhsU[id]   = -fluxU[es]; 
	    rhsV[id]   = -fluxV[es];		  
	  }
	}
    }
  }
}




// compute div(NU)  = div(uxu) in collocation way
kernel void insSubCycleCubatureVolume2D(const iint Nelements,
					const dfloat * restrict vgeo,
					const dfloat * restrict cubDrWT,
					const dfloat * restrict cubDsWT,
					const dfloat * restrict cubInterpT,
					const dfloat * restrict U,
					const dfloat * restrict V,
					const dfloat * restrict Ud,
					const dfloat * restrict Vd,
						  dfloat * restrict rhsU,
						  dfloat * restrict rhsV){

  for(iint eo=0;eo<Nelements;eo+=p_cubNblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_cubNblockV][p_Np];
    shared dfloat s_V[p_cubNblockV][p_Np];
    shared dfloat s_Ud[p_cubNblockV][p_Np];
    shared dfloat s_Vd[p_cubNblockV][p_Np];

    shared dfloat s_cF11[p_cubNblockV][p_cubNp];
    shared dfloat s_cF12[p_cubNblockV][p_cubNp];
    shared dfloat s_cF21[p_cubNblockV][p_cubNp];
    shared dfloat s_cF22[p_cubNblockV][p_cubNp];
    //
    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements && n<p_Np){ 
				  const iint id = e*p_Np+n;
				  s_U[es][n]  = U[id];
				  s_V[es][n]  = V[id];
				  s_Ud[es][n] = Ud[id];
				  s_Vd[es][n] = Vd[id];

	}		
      }
    }

    barrier(localMemFence);

    for(iint es=0;es<p_cubNblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){     // for all nodes in this element
	iint e = eo+es; // element in block
	if(e<Nelements && n<p_cubNp){

	  dfloat cU = 0.f,  cV = 0.f;
	  dfloat cUd = 0.f, cVd = 0.f;

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      dfloat cIni = cubInterpT[n+i*p_cubNp];
	      cU  += cIni*s_U[es][i];
	      cV  += cIni*s_V[es][i];
	      cUd += cIni*s_Ud[es][i];
	      cVd += cIni*s_Vd[es][i];				
	    }
	  //
	  s_cF11[es][n] = cU*cUd;
	  s_cF12[es][n] = cV*cUd;
	  s_cF21[es][n] = cU*cVd;
	  s_cF22[es][n] = cV*cVd;
	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_cubNblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolumeCub;++n;inner0){    	
	iint e = eo+es;

	if(e<Nelements && n<p_Np){	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat df11dr = 0.f, df11ds = 0.f; 
	  dfloat df12dr = 0.f, df12ds = 0.f; 
	  dfloat df21dr = 0.f, df21ds = 0.f; 
	  dfloat df22dr = 0.f, df22ds = 0.f; 

	  occaUnroll(p_cubNp)
	    for(iint i=0;i<p_cubNp;++i){
	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
	      const dfloat cDsWni = cubDsWT[n+i*p_Np];
	      // Fetch to shared, used twice
	      const dfloat cF11 = s_cF11[es][i];
	      const dfloat cF12 = s_cF12[es][i];
	      const dfloat cF21 = s_cF21[es][i];
	      const dfloat cF22 = s_cF22[es][i];

	      df11dr += cDrWni*cF11;
	      df11ds += cDsWni*cF11;

	      df12dr += cDrWni*cF12;
	      df12ds += cDsWni*cF12;

	      df21dr += cDrWni*cF21;
	      df21ds += cDsWni*cF21;

	      df22dr += cDrWni*cF22;
	      df22ds += cDsWni*cF22;
	    }

	  const dfloat rhsu = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
	  const dfloat rhsv = drdx*df21dr + dsdx*df21ds + drdy*df22dr + dsdy*df22ds;

	  const iint id = e*p_Np+n;

	  rhsU[id]   = -rhsu; // note  change in sign
	  rhsV[id]   = -rhsv;		  
	}
      }
    }

  }

}






kernel void insSubCycleCubatureSurface2D_v0(
									iint Nelements,
					        dfloat * sgeo,
					        dfloat * intInterpT, // interpolate to integration nodes
					        dfloat * intLIFTT, // lift from integration to interpolation nodes
					        iint   * vmapM,
					        iint   * vmapP,
					        iint   * EToB,
					        dfloat time,
					        dfloat * intx, // integration nodes
					        dfloat * inty,
					        dfloat * U,
					        dfloat * V,
					        dfloat * Ud,
					        dfloat * Vd,
					 				dfloat * rhsU,
					 				dfloat * rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

  	shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];

    for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

			if(e<Nelements){
 				if(n<(p_Nfaces*p_intNfp)){

					iint face = n/p_intNfp; // find face that owns this integration node

			    // load surface geofactors for this face
			    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
			    dfloat nx   = sgeo[sid+p_NXID];
			    dfloat ny   = sgeo[sid+p_NYID];
			    dfloat sJ   = sgeo[sid+p_SJID];
			    dfloat invJ = sgeo[sid+p_IJID];

			    dfloat iUM  = 0.f, iVM  = 0.f;
			    dfloat iUP  = 0.f, iVP  = 0.f;
			    dfloat iUdM = 0.f, iVdM = 0.f;
			    dfloat iUdP = 0.f, iVdP = 0.f;

			    // local block interpolation (face nodes to integration nodes)
			    //occaUnroll(p_Nfp)
			      for(iint m=0;m<p_Nfp;++m){
							dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

              iint id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
              iint idM = vmapM[id];
              iint idP = vmapP[id];
              //
							iUM  += iInm*U[idM];
							iVM  += iInm*V[idM];
							iUdM += iInm*Ud[idM];
							iVdM += iInm*Vd[idM];

							iUP  += iInm*U[idP];
							iVP  += iInm*V[idP];
							iUdP += iInm*Ud[idP];
							iVdP += iInm*Vd[idP];
			      }

	    		// apply boundary conditions
			    iint bc = EToB[face+p_Nfaces*e];

			    if(bc>0){
			      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
			    }


			    // Find max normal velocity on the face
			    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
			    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
			    dfloat unmax = (unm > unp) ? unm : unp;

			    // evaluate "flux" terms: LLF
			    dfloat sc = invJ * sJ ;

			    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
						                        +ny*(iVP*iUdP + iVM*iUdM) 
						                        +unmax*(iUdM-iUdP) ));

			    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																		+ ny*(iVP*iVdP + iVM*iVdM) 
																		+ unmax*(iVdM-iVdP) ));
  			}
			}
  }

    barrier(localMemFence);

	// lift from surface integration to volume nodes
		for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
			if(e<Nelements){
				if(n<p_Np){
					iint id = n + p_Np*e;
					// prefetch volume rhs
					dfloat rhsu = rhsU[id];
					dfloat rhsv = rhsV[id];

					//occaUnroll(p_intNfpNfaces)
					for(iint m=0;m<p_intNfpNfaces;++m){
					// RefMassMatrix^{-1}*cInterp^t*cWeight
						dfloat L = intLIFTT[n+m*p_Np];

						rhsu += L*s_iFluxU[m];
						rhsv += L*s_iFluxV[m];
					}

					rhsU[id] = rhsu;  // 
					rhsV[id] = rhsv;  //  
				}
			}
		}
	}
}





kernel void insSubCycleCubatureSurface2D_v1(
									iint Nelements,
					        dfloat * sgeo,
					        dfloat * intInterpT, // interpolate to integration nodes
					        dfloat * intLIFTT, // lift from integration to interpolation nodes
					        iint   * vmapM,
					        iint   * vmapP,
					        iint   * EToB,
					        dfloat time,
					        dfloat * intx, // integration nodes
					        dfloat * inty,
					        dfloat * U,
					        dfloat * V,
					        dfloat * Ud,
					        dfloat * Vd,
					 				dfloat * rhsU,
					 				dfloat * rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];


		for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
			if(e<Nelements){
				if(n<(p_Nfaces*p_Nfp)){
					// indices of negative and positive traces of face node
					iint id  = e*p_Nfp*p_Nfaces + n;

					iint idM = vmapM[id];
					iint idP = vmapP[id];

					if(idP<0) idP = idM;
						// load negative and positive trace node values of velocity
						s_UM[n] = U[idM];
						s_VM[n] = V[idM];
						s_UP[n] = U[idP];
						s_VP[n] = V[idP];

						s_UdM[n] = Ud[idM];
						s_VdM[n] = Vd[idM];
						s_UdP[n] = Ud[idP];
						s_VdP[n] = Vd[idP];

					}
				}
    }

    barrier(localMemFence);

  
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

				if(e<Nelements){
	 				if(n<(p_Nfaces*p_intNfp)){

						iint face = n/p_intNfp; // find face that owns this integration node

				    // load surface geofactors for this face
				    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
				    dfloat nx   = sgeo[sid+p_NXID];
				    dfloat ny   = sgeo[sid+p_NYID];
				    dfloat sJ   = sgeo[sid+p_SJID];
				    dfloat invJ = sgeo[sid+p_IJID];

				    dfloat iUM  = 0.f, iVM  = 0.f;
				    dfloat iUP  = 0.f, iVP  = 0.f;
				    dfloat iUdM = 0.f, iVdM = 0.f;
				    dfloat iUdP = 0.f, iVdP = 0.f;

				    // local block interpolation (face nodes to integration nodes)
				    //occaUnroll(p_Nfp)
				      for(iint m=0;m<p_Nfp;++m){
								dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
								iint fm = face*p_Nfp+m;

								iUM  += iInm*s_UM[fm];
								iVM  += iInm*s_VM[fm];
								iUdM += iInm*s_UdM[fm];
								iVdM += iInm*s_VdM[fm];

								iUP  += iInm*s_UP[fm];
								iVP  += iInm*s_VP[fm];
								iUdP += iInm*s_UdP[fm];
								iVdP += iInm*s_VdP[fm];
				      }

		    		// apply boundary conditions
				    iint bc = EToB[face+p_Nfaces*e];

				    if(bc>0){
				      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
				    }


				    // Find max normal velocity on the face
				    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
				    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
				    dfloat unmax = (unm > unp) ? unm : unp;

				    // evaluate "flux" terms: LLF
				    dfloat sc = invJ * sJ ;

				    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
							                        +ny*(iVP*iUdP + iVM*iUdM) 
							                        +unmax*(iUdM-iUdP) ));

				    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																			+ ny*(iVP*iVdP + iVM*iVdM) 
																			+ unmax*(iVdM-iVdP) ));
	  			}
				}
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
				if(e<Nelements){
					if(n<p_Np){
						iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						//occaUnroll(p_intNfpNfaces)
						for(iint m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[m];
							rhsv += L*s_iFluxV[m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
}





kernel void insSubCycleCubatureSurface2D_v2(
									const iint Nelements,
					        const dfloat * restrict sgeo,
					        const dfloat * restrict intInterpT, // interpolate to integration nodes
					        const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					        const iint   * restrict vmapM,
					        const iint   * restrict vmapP,
					        const iint   * restrict EToB,
					        const dfloat time,
					        const dfloat * restrict intx, // integration nodes
					        const dfloat * restrict inty,
					        const dfloat * restrict U,
					        const dfloat * restrict V,
					        const dfloat * restrict Ud,
					        const dfloat * restrict Vd,
					 							dfloat * restrict rhsU,
					 							dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];


		for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
			if(e<Nelements){
				if(n<(p_Nfaces*p_Nfp)){
					// indices of negative and positive traces of face node
					const iint id  = e*p_Nfp*p_Nfaces + n;

					iint idM = vmapM[id];
					iint idP = vmapP[id];

					if(idP<0) idP = idM;
						// load negative and positive trace node values of velocity
						s_UM[n] = U[idM];
						s_VM[n] = V[idM];
						s_UP[n] = U[idP];
						s_VP[n] = V[idP];

						s_UdM[n] = Ud[idM];
						s_VdM[n] = Vd[idM];
						s_UdP[n] = Ud[idP];
						s_VdP[n] = Vd[idP];

					}
				}
    }

    barrier(localMemFence);

  
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

				if(e<Nelements){
	 				if(n<(p_Nfaces*p_intNfp)){

						const iint face = n/p_intNfp; // find face that owns this integration node

				    // load surface geofactors for this face
				    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
				    const dfloat nx   = sgeo[sid+p_NXID];
				    const dfloat ny   = sgeo[sid+p_NYID];
				    const dfloat sJ   = sgeo[sid+p_SJID];
				    const dfloat invJ = sgeo[sid+p_IJID];

				    dfloat iUM  = 0.f, iVM  = 0.f;
				    dfloat iUP  = 0.f, iVP  = 0.f;
				    dfloat iUdM = 0.f, iVdM = 0.f;
				    dfloat iUdP = 0.f, iVdP = 0.f;

				    // local block interpolation (face nodes to integration nodes)
				    //occaUnroll(p_Nfp)
				      for(iint m=0;m<p_Nfp;++m){
								const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
								const iint fm = face*p_Nfp+m;

								iUM  += iInm*s_UM[fm];
								iVM  += iInm*s_VM[fm];
								iUdM += iInm*s_UdM[fm];
								iVdM += iInm*s_VdM[fm];

								iUP  += iInm*s_UP[fm];
								iVP  += iInm*s_VP[fm];
								iUdP += iInm*s_UdP[fm];
								iVdP += iInm*s_VdP[fm];
				      }

		    		// apply boundary conditions
				    const iint bc = EToB[face+p_Nfaces*e];

				    if(bc>0){
				      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
				    }


				    // Find max normal velocity on the face
				    const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
				    const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
				    const dfloat unmax = (unm > unp) ? unm : unp;

				    // evaluate "flux" terms: LLF
				    const dfloat sc = invJ * sJ ;

				    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
							                        +ny*(iVP*iUdP + iVM*iUdM) 
							                        +unmax*(iUdM-iUdP) ));

				    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																			+ ny*(iVP*iVdP + iVM*iVdM) 
																			+ unmax*(iVdM-iVdP) ));
	  			}
				}
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
				if(e<Nelements){
					if(n<p_Np){
						const iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						//occaUnroll(p_intNfpNfaces)
						for(iint m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							const dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[m];
							rhsv += L*s_iFluxV[m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
}


kernel void insSubCycleCubatureSurface2D_v3(
									const iint Nelements,
					        const dfloat * restrict sgeo,
					        const dfloat * restrict intInterpT, // interpolate to integration nodes
					        const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					        const iint   * restrict vmapM,
					        const iint   * restrict vmapP,
					        const iint   * restrict EToB,
					        const dfloat time,
					        const dfloat * restrict intx, // integration nodes
					        const dfloat * restrict inty,
					        const dfloat * restrict U,
					        const dfloat * restrict V,
					        const dfloat * restrict Ud,
					        const dfloat * restrict Vd,
					 							dfloat * restrict rhsU,
					 							dfloat * restrict rhsV){
  // for all elements
  for(iint e=0;e<Nelements;++e;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NfacesNfp];
    shared dfloat s_VM[p_NfacesNfp];
    shared dfloat s_UP[p_NfacesNfp];
    shared dfloat s_VP[p_NfacesNfp];

    shared dfloat s_UdM[p_NfacesNfp];
    shared dfloat s_VdM[p_NfacesNfp];
    shared dfloat s_UdP[p_NfacesNfp];
    shared dfloat s_VdP[p_NfacesNfp];

    shared dfloat s_iFluxU[p_intNfpNfaces];
    shared dfloat s_iFluxV[p_intNfpNfaces];


		for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
			if(e<Nelements){
				if(n<(p_Nfaces*p_Nfp)){
					// indices of negative and positive traces of face node
					const iint id  = e*p_Nfp*p_Nfaces + n;

					iint idM = vmapM[id];
					iint idP = vmapP[id];

					if(idP<0) idP = idM;
						// load negative and positive trace node values of velocity
						s_UM[n] = U[idM];
						s_VM[n] = V[idM];
						s_UP[n] = U[idP];
						s_VP[n] = V[idP];

						s_UdM[n] = Ud[idM];
						s_VdM[n] = Vd[idM];
						s_UdP[n] = Ud[idP];
						s_VdP[n] = Vd[idP];

					}
				}
    }

    barrier(localMemFence);

  
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

				if(e<Nelements){
	 				if(n<(p_Nfaces*p_intNfp)){

						const iint face = n/p_intNfp; // find face that owns this integration node

				    // load surface geofactors for this face
				    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
				    const dfloat nx   = sgeo[sid+p_NXID];
				    const dfloat ny   = sgeo[sid+p_NYID];
				    const dfloat sJ   = sgeo[sid+p_SJID];
				    const dfloat invJ = sgeo[sid+p_IJID];

				    dfloat iUM  = 0.f, iVM  = 0.f;
				    dfloat iUP  = 0.f, iVP  = 0.f;
				    dfloat iUdM = 0.f, iVdM = 0.f;
				    dfloat iUdP = 0.f, iVdP = 0.f;

				    // local block interpolation (face nodes to integration nodes)
				    occaUnroll(p_Nfp)
				      for(iint m=0;m<p_Nfp;++m){
								const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
								const iint fm = face*p_Nfp+m;

								iUM  += iInm*s_UM[fm];
								iVM  += iInm*s_VM[fm];
								iUdM += iInm*s_UdM[fm];
								iVdM += iInm*s_VdM[fm];

								iUP  += iInm*s_UP[fm];
								iVP  += iInm*s_VP[fm];
								iUdP += iInm*s_UdP[fm];
								iVdP += iInm*s_VdP[fm];
				      }

		    		// apply boundary conditions
				    const iint bc = EToB[face+p_Nfaces*e];

				    if(bc>0){
				      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
				    }


				    // Find max normal velocity on the face
				    const dfloat unm   = occaFabs(nx*iUM + ny*iVM);
				    const dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
				    const dfloat unmax = (unm > unp) ? unm : unp;

				    // evaluate "flux" terms: LLF
				    const dfloat sc = invJ * sJ ;

				    s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
							                        +ny*(iVP*iUdP + iVM*iUdM) 
							                        +unmax*(iUdM-iUdP) ));

				    s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																			+ ny*(iVP*iVdP + iVM*iVdM) 
																			+ unmax*(iVdM-iVdP) ));
	  			}
				}
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){
				if(e<Nelements){
					if(n<p_Np){
						const iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						occaUnroll(p_intNfpNfaces)
						for(iint m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							const dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[m];
							rhsv += L*s_iFluxV[m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
}


kernel void insSubCycleCubatureSurface2D_v4(const iint Nelements,
					 const dfloat * restrict sgeo,
					 const dfloat * restrict intInterpT, // interpolate to integration nodes
					 const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					 const iint   * restrict vmapM,
					 const iint   * restrict vmapP,
					 const iint   * restrict EToB,
					 const dfloat time,
					 const dfloat * restrict intx, // integration nodes
					 const dfloat * restrict inty,
					 const dfloat * restrict U,
					 const dfloat * restrict V,
					 const dfloat * restrict Ud,
					 const dfloat * restrict Vd,
					 dfloat * restrict rhsU,
					 dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const iint id  = e*p_Nfp*p_Nfaces + n;

	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM;
	    // load negative and positive trace node values of velocity
	    s_UM[es][n] = U[idM];
	    s_VM[es][n] = V[idM];
	    s_UP[es][n] = U[idP];
	    s_VP[es][n] = V[idP];

	    s_UdM[es][n] = Ud[idM];
	    s_VdM[es][n] = Vd[idM];
	    s_UdP[es][n] = Ud[idP];
	    s_VdP[es][n] = Vd[idP];

	  }
	}
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const iint face = n/p_intNfp; // find face that owns this integration node

	    // load surface geofactors for this face
	    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];

	    dfloat iUM  = 0.f, iVM  = 0.f;
	    dfloat iUP  = 0.f, iVP  = 0.f;
	    dfloat iUdM = 0.f, iVdM = 0.f;
	    dfloat iUdP = 0.f, iVdP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    occaUnroll(p_Nfp)
	      for(iint m=0;m<p_Nfp;++m){
					const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
					const iint fm = face*p_Nfp+m;

					iUM  += iInm*s_UM[es][fm];
					iVM  += iInm*s_VM[es][fm];
					iUdM += iInm*s_UdM[es][fm];
					iVdM += iInm*s_VdM[es][fm];

					iUP  += iInm*s_UP[es][fm];
					iVP  += iInm*s_VP[es][fm];
					iUdP += iInm*s_UdP[es][fm];
					iVdP += iInm*s_VdP[es][fm];
	      }

	    // apply boundary conditions
	    iint bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    }


	    // Find max normal velocity on the face
	    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	    dfloat unmax = (unm > unp) ? unm : unp;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ;

	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				                        +ny*(iVP*iUdP + iVM*iUdM) 
				                        +unmax*(iUdM-iUdP) ));

	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																+ ny*(iVP*iVdP + iVM*iVdM) 
																+ unmax*(iVdM-iVdP) ));
	  }
	}
      }
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
		for(iint es=0;es<p_cubNblockS;++es;inner1){
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

				const iint e = eo + es;

				if(e<Nelements){
					if(n<p_Np){
						iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						occaUnroll(p_intNfpNfaces)
						for(int m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							const dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[es][m];
							rhsv += L*s_iFluxV[es][m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
  }

}






kernel void insSubCycleCubatureSurface2D_v5(const iint Nelements,
					 const dfloat * restrict sgeo,
					 const dfloat * restrict intInterpT, // interpolate to integration nodes
					 const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					 const iint   * restrict vmapM,
					 const iint   * restrict vmapP,
					 const iint   * restrict EToB,
					 const dfloat time,
					 const dfloat * restrict intx, // integration nodes
					 const dfloat * restrict inty,
					 const dfloat * restrict U,
					 const dfloat * restrict V,
					 const dfloat * restrict Ud,
					 const dfloat * restrict Vd,
					 dfloat * restrict rhsU,
					 dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const iint id  = e*p_Nfp*p_Nfaces + n;

	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM;
	    // load negative and positive trace node values of velocity
	    s_UM[es][n] = U[idM];
	    s_VM[es][n] = V[idM];
	    s_UP[es][n] = U[idP];
	    s_VP[es][n] = V[idP];

	    s_UdM[es][n] = Ud[idM];
	    s_VdM[es][n] = Vd[idM];
	    s_UdP[es][n] = Ud[idP];
	    s_VdP[es][n] = Vd[idP];

	  }
	}
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const iint face = n/p_intNfp; // find face that owns this integration node

	    // load surface geofactors for this face
	    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];

	    dfloat iUM  = 0.f, iVM  = 0.f;
	    dfloat iUP  = 0.f, iVP  = 0.f;
	    dfloat iUdM = 0.f, iVdM = 0.f;
	    dfloat iUdP = 0.f, iVdP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    occaUnroll(p_Nfp)
	      for(iint m=0;m<p_Nfp;++m){
					const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
					const iint fm = face*p_Nfp+m;

					iUM  += iInm*s_UM[es][fm];
					iVM  += iInm*s_VM[es][fm];
					iUdM += iInm*s_UdM[es][fm];
					iVdM += iInm*s_VdM[es][fm];

					iUP  += iInm*s_UP[es][fm];
					iVP  += iInm*s_VP[es][fm];
					iUdP += iInm*s_UdP[es][fm];
					iVdP += iInm*s_VdP[es][fm];
	      }

	    // apply boundary conditions
	    iint bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    }


	    // Find max normal velocity on the face
	    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	    dfloat unmax = (unm > unp) ? unm : unp;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ;

	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				                        +ny*(iVP*iUdP + iVM*iUdM) 
				                        +unmax*(iUdM-iUdP) ));

	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																+ ny*(iVP*iVdP + iVM*iVdM) 
																+ unmax*(iVdM-iVdP) ));
	  }
	}
      }
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
		for(iint es=0;es<p_cubNblockS;++es;inner1){
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

				const iint e = eo + es;

				if(e<Nelements){
					if(n<p_Np){
						iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						occaUnroll(p_intNfpNfaces)
						for(int m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							const dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[es][m];
							rhsv += L*s_iFluxV[es][m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
  }

}













kernel void insSubCycleCubatureSurface2D(const iint Nelements,
					 const dfloat * restrict sgeo,
					 const dfloat * restrict intInterpT, // interpolate to integration nodes
					 const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					 const iint   * restrict vmapM,
					 const iint   * restrict vmapP,
					 const iint   * restrict EToB,
					 const dfloat time,
					 const dfloat * restrict intx, // integration nodes
					 const dfloat * restrict inty,
					 const dfloat * restrict U,
					 const dfloat * restrict V,
					 const dfloat * restrict Ud,
					 const dfloat * restrict Vd,
					 dfloat * restrict rhsU,
					 dfloat * restrict rhsV){
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_Nfp)){
	    // indices of negative and positive traces of face node
	    const iint id  = e*p_Nfp*p_Nfaces + n;

	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM;
	    // load negative and positive trace node values of velocity
	    s_UM[es][n] = U[idM];
	    s_VM[es][n] = V[idM];
	    s_UP[es][n] = U[idP];
	    s_VP[es][n] = V[idP];

	    s_UdM[es][n] = Ud[idM];
	    s_VdM[es][n] = Vd[idM];
	    s_UdP[es][n] = Ud[idP];
	    s_VdP[es][n] = Vd[idP];

	  }
	}
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_cubNblockS;++es;inner1){
      for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){ 

	iint e = eo + es;

	if(e<Nelements){
	  if(n<(p_Nfaces*p_intNfp)){

	    const iint face = n/p_intNfp; // find face that owns this integration node

	    // load surface geofactors for this face
	    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	    const dfloat nx   = sgeo[sid+p_NXID];
	    const dfloat ny   = sgeo[sid+p_NYID];
	    const dfloat sJ   = sgeo[sid+p_SJID];
	    const dfloat invJ = sgeo[sid+p_IJID];

	    dfloat iUM  = 0.f, iVM  = 0.f;
	    dfloat iUP  = 0.f, iVP  = 0.f;
	    dfloat iUdM = 0.f, iVdM = 0.f;
	    dfloat iUdP = 0.f, iVdP = 0.f;

	    // local block interpolation (face nodes to integration nodes)
	    occaUnroll(p_Nfp)
	      for(iint m=0;m<p_Nfp;++m){
					const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
					const iint fm = face*p_Nfp+m;

					iUM  += iInm*s_UM[es][fm];
					iVM  += iInm*s_VM[es][fm];
					iUdM += iInm*s_UdM[es][fm];
					iVdM += iInm*s_VdM[es][fm];

					iUP  += iInm*s_UP[es][fm];
					iVP  += iInm*s_VP[es][fm];
					iUdP += iInm*s_UdP[es][fm];
					iVdP += iInm*s_VdP[es][fm];
	      }

	    // apply boundary conditions
	    iint bc = EToB[face+p_Nfaces*e];

	    if(bc>0){
	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    }


	    // Find max normal velocity on the face
	    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
	    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
	    dfloat unmax = (unm > unp) ? unm : unp;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ;

	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
				                        +ny*(iVP*iUdP + iVM*iUdM) 
				                        +unmax*(iUdM-iUdP) ));

	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
																+ ny*(iVP*iVdP + iVM*iVdM) 
																+ unmax*(iVdM-iVdP) ));
	  }
	}
      }
    }

    barrier(localMemFence);

		// lift from surface integration to volume nodes
		for(iint es=0;es<p_cubNblockS;++es;inner1){
			for(iint n=0;n<p_maxNodesSurfaceCub;++n;inner0){

				const iint e = eo + es;

				if(e<Nelements){
					if(n<p_Np){
						iint id = n + p_Np*e;
						// prefetch volume rhs
						dfloat rhsu = rhsU[id];
						dfloat rhsv = rhsV[id];

						occaUnroll(p_intNfpNfaces)
						for(int m=0;m<p_intNfpNfaces;++m){
						// RefMassMatrix^{-1}*cInterp^t*cWeight
							const dfloat L = intLIFTT[n+m*p_Np];

							rhsu += L*s_iFluxU[es][m];
							rhsv += L*s_iFluxV[es][m];
						}

						rhsU[id] = rhsu;  // 
						rhsV[id] = rhsv;  //  
					}
				}
			}
		}
  }

}



// kernel void insSubCycleCubatureSurface2D_v1(const iint Nelements,
// 					 const dfloat * restrict sgeo,
// 					 const dfloat * restrict intInterpT, // interpolate to integration nodes
// 					 const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
// 					 const iint   * restrict vmapM,
// 					 const iint   * restrict vmapP,
// 					 const iint   * restrict EToB,
// 					 const dfloat time,
// 					 const dfloat * restrict intx, // integration nodes
// 					 const dfloat * restrict inty,
// 					 const dfloat * restrict U,
// 					 const dfloat * restrict V,
// 					 const dfloat * restrict Ud,
// 					 const dfloat * restrict Vd,
// 					 dfloat * restrict rhsU,
// 					 dfloat * restrict rhsV){
//   // for all elements
//   for(iint eo=0;eo<Nelements;eo+=p_cubNblockS;outer0){

//     // shared storage for flux terms
//     shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
//     shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

//     shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
//     shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

//     // for all face nodes of all elements
//     for(iint es=0;es<p_cubNblockS;++es;inner1){
//       for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){

// 	// iint e = eo + es;

// 	// if(e<Nelements){
// 	//   if(n<(p_Nfaces*p_Nfp)){
// 	//     // indices of negative and positive traces of face node
// 	//     const iint id  = e*p_Nfp*p_Nfaces + n;

// 	//     iint idM = vmapM[id];
// 	//     iint idP = vmapP[id];

// 	//     if(idP<0) idP = idM;
// 	//     // load negative and positive trace node values of velocity
// 	//     s_UM[es][n] = U[idM];
// 	//     s_VM[es][n] = V[idM];
// 	//     s_UP[es][n] = U[idP];
// 	//     s_VP[es][n] = V[idP];

// 	//     s_UdM[es][n] = Ud[idM];
// 	//     s_VdM[es][n] = Vd[idM];
// 	//     s_UdP[es][n] = Ud[idP];
// 	//     s_VdP[es][n] = Vd[idP];

// 	//   }
// 	// }
//  //      }
//  //    }

//  //    barrier(localMemFence);

//     // interpolate to surface integration nodes
//     for(iint es=0;es<p_cubNblockS;++es;inner1){
//       for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){ 

// 	iint e = eo + es;

// 	if(e<Nelements){
// 	  if(n<(p_Nfaces*p_intNfp)){

// 	    const iint face = n/p_intNfp; // find face that owns this integration node

// 	    // load surface geofactors for this face
// 	    const iint sid    = p_Nsgeo*(e*p_Nfaces+face);
// 	    const dfloat nx   = sgeo[sid+p_NXID];
// 	    const dfloat ny   = sgeo[sid+p_NYID];
// 	    const dfloat sJ   = sgeo[sid+p_SJID];
// 	    const dfloat invJ = sgeo[sid+p_IJID];

//       const iint idm = n+e*p_Nfaces*p_intNfp; 



// 			dfloat iUM  = U[idm];
// 			dfloat iUP  = U[idp];
// 			dfloat iUdM = Ud[idm];
// 			dfloat iUdP = Ud[idp];

// 			dfloat iVM  = V[idm];
// 			dfloat iVP  = V[idp];
// 			dfloat iVdM = Vd[idm];
// 			dfloat iVdP = Vd[idp];

// 	    // // local block interpolation (face nodes to integration nodes)
// 	    // occaUnroll(p_Nfp)
// 	    //   for(iint m=0;m<p_Nfp;++m){
// 					// const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
// 					// const iint fm = face*p_Nfp+m;

// 					// iUM  += iInm*s_UM[es][fm];
// 					// iVM  += iInm*s_VM[es][fm];
// 					// iUdM += iInm*s_UdM[es][fm];
// 					// iVdM += iInm*s_VdM[es][fm];

// 					// iUP  += iInm*s_UP[es][fm];
// 					// iVP  += iInm*s_VP[es][fm];
// 					// iUdP += iInm*s_UdP[es][fm];
// 					// iVdP += iInm*s_VdP[es][fm];
// 	    //   }

// 	    // apply boundary conditions
// 	    iint bc = EToB[face+p_Nfaces*e];

// 	    if(bc>0){
// 	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
// 	    }


// 	    // Find max normal velocity on the face
// 	    dfloat unm   = occaFabs(nx*iUM + ny*iVM);
// 	    dfloat unp   = occaFabs(nx*iUP + ny*iVP);    
// 	    dfloat unmax = (unm > unp) ? unm : unp;

// 	    // evaluate "flux" terms: LLF
// 	    const dfloat sc = invJ * sJ ;

// 	    s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
// 				                        +ny*(iVP*iUdP + iVM*iUdM) 
// 				                        +unmax*(iUdM-iUdP) ));

// 	    s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
// 																+ ny*(iVP*iVdP + iVM*iVdM) 
// 																+ unmax*(iVdM-iVdP) ));
// 	  }
// 	}
//       }
//     }

//     barrier(localMemFence);

// 		// lift from surface integration to volume nodes
// 		for(iint es=0;es<p_cubNblockS;++es;inner1){
// 			for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){

// 				const iint e = eo + es;

// 				if(e<Nelements){
// 					if(n<p_Np){
// 						iint id = n + p_Np*e;
// 						// prefetch volume rhs
// 						dfloat rhsu = rhsU[id];
// 						dfloat rhsv = rhsV[id];

// 						occaUnroll(p_intNfpNfaces)
// 						for(int m=0;m<p_intNfpNfaces;++m){
// 						// RefMassMatrix^{-1}*cInterp^t*cWeight
// 							const dfloat L = intLIFTT[n+m*p_Np];

// 							rhsu += L*s_iFluxU[es][m];
// 							rhsv += L*s_iFluxV[es][m];
// 						}

// 						rhsU[id] = rhsu;  // 
// 						rhsV[id] = rhsv;  //  
// 					}
// 				}
// 			}
// 		}
//   }

// }


























kernel void insSubCycleRKUpdate2D(const iint Nelements,
				  const dfloat activate_advection, 
				  const dfloat dt,	
				  const dfloat rka,
				  const dfloat rkb,
				  const dfloat * restrict rhsU,
				  const dfloat * restrict rhsV,
				  dfloat  * restrict resU,
				  dfloat  * restrict resV,
				  dfloat  * restrict U,
				  dfloat  * restrict V){

  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){

      const iint id = n + e*p_Np;

      dfloat resu =  resU[id];
      dfloat resv =  resV[id];
      dfloat rhsu = -rhsU[id];// -Nu
      dfloat rhsv = -rhsV[id];// -Nu

      // If not axtivated zero it out
      rhsu *= activate_advection;
      rhsv *= activate_advection;
      
      dfloat u = U[id];
      dfloat v = V[id];

      resu = rka*resu + dt*rhsu;
      resv = rka*resv + dt*rhsv;

      u += rkb*resu;
      v += rkb*resv;

      resU[id] = resu;
      resV[id] = resv;

      U[id] = u;
      V[id] = v;
    }
  }
}


kernel void insSubCycleExt2D(const iint Nelements,
			     const iint index,
			     const iint offset,
			     const dfloat c0,
			     const dfloat c1,
			     const dfloat c2,	
			     const dfloat * restrict U,
			     const dfloat * restrict V,
			     dfloat * restrict Ue,
			     dfloat * restrict Ve){

  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){

      const iint index0 = (index+0)%3;
      const iint index1 = (index+2)%3; //back one step
      const iint index2 = (index+1)%3; //back two steps

      const iint id0   = n + p_Np*(e+index0*offset);
      const iint id1   = n + p_Np*(e+index1*offset);
      const iint id2   = n + p_Np*(e+index2*offset);

      //U 
      const dfloat Um0  = U[id0];
      const dfloat Um1  = U[id1];
      const dfloat Um2  = U[id2];

      const dfloat Vm0  = V[id0];
      const dfloat Vm1  = V[id1];
      const dfloat Vm2  = V[id2];
      
      const iint id = n+e*p_Np;
      Ue[id] = c0*Um0 + c1*Um1 + c2*Um2;
      Ve[id] = c0*Vm0 + c1*Vm1 + c2*Vm2;
    }
  }
}









// ===========================================================================================================

// compute div(NU)  = div(uxu) in collocation way
kernel void insSubCycleVolume2D(const iint Nelements,
				const dfloat * restrict vgeo,
				const dfloat * restrict DrT,
				const dfloat * restrict DsT,
				const dfloat * restrict Ux,
				const dfloat * restrict Uy,
				const dfloat * restrict Px,
				const dfloat * restrict Py,
				dfloat * restrict rhsUx,
				dfloat * restrict rhsUy){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_F11[p_NblockV][p_Np];
    shared dfloat s_F12[p_NblockV][p_Np];
    shared dfloat s_F21[p_NblockV][p_Np];
    shared dfloat s_F22[p_NblockV][p_Np];
    //
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	iint e = eo+es; // element in block
	if(e<Nelements){ 
	  const iint id = e*p_Np+n;

	  const dfloat ux = Ux[id];
	  const dfloat uy = Uy[id];
	  const dfloat px = Px[id];
	  const dfloat py = Py[id];
	  //
	  s_F11[es][n] = ux*px;
	  s_F12[es][n] = uy*px;

	  s_F21[es][n] = ux*py;
	  s_F22[es][n] = uy*py;
	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){    	
	iint e = eo+es; 
	if(e<Nelements){	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat df11dr = 0.f, df11ds = 0.f; 
	  dfloat df12dr = 0.f, df12ds = 0.f; 
	  dfloat df21dr = 0.f, df21ds = 0.f; 
	  dfloat df22dr = 0.f, df22ds = 0.f; 
	  //
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){

	      const dfloat Drni = DrT[n+i*p_Np];
	      const dfloat Dsni = DsT[n+i*p_Np];

	      df11dr += Drni*s_F11[es][i];
	      df11ds += Dsni*s_F11[es][i];

	      df12dr += Drni*s_F12[es][i];
	      df12ds += Dsni*s_F12[es][i];

	      df21dr += Drni*s_F21[es][i];
	      df21ds += Dsni*s_F21[es][i];

	      df22dr += Drni*s_F22[es][i];
	      df22ds += Dsni*s_F22[es][i];

	    }

	  dfloat rhsux   = drdx*df11dr + dsdx*df11ds 
	    + drdy*df12dr + dsdy*df12ds;

	  dfloat rhsuy   = drdx*df21dr + dsdx*df21ds 
	    + drdy*df22dr + dsdy*df22ds;

	  const iint id = e*p_Np+n;
	  // Compute div(uxu)
	  rhsUx[id]   = rhsux;
	  rhsUy[id]   = rhsuy;		 
	}
      }
    }
  }
}



//
kernel void insSubCycleSurface2D(const iint Nelements,
				 const dfloat * restrict sgeo,
				 const dfloat * restrict LIFTT,
				 const iint   * restrict vmapM,
				 const iint   * restrict vmapP,
				 const iint   * restrict EToB,
				 const dfloat time,
				 const dfloat * restrict x,
				 const dfloat * restrict y,
				 const dfloat * restrict Ux,
				 const dfloat * restrict Uy,
				 const dfloat * restrict Px,
				 const dfloat * restrict Py,
				 dfloat * restrict rhsUx,
				 dfloat * restrict rhsUy){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	iint e = eo + es;
	if(e<Nelements){
	  if(n<p_Nfp*p_Nfaces){
	    // find face that owns this node
	    iint face = n/p_Nfp;
	    // load surface geofactors for this face
	    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
	    dfloat nx   = sgeo[sid+p_NXID];
	    dfloat ny   = sgeo[sid+p_NYID];
	    dfloat sJ   = sgeo[sid+p_SJID];
	    dfloat invJ = sgeo[sid+p_IJID];

	    // indices of negative and positive traces of face node
	    iint id  = e*p_Nfp*p_Nfaces + n;
	    iint idM = vmapM[id];
	    iint idP = vmapP[id];

	    if(idP<0) idP = idM; // 
	    // load negative and positive trace node values of Ux, Uy, Pr
	    dfloat  uxM = Ux[idM], uxP = Ux[idP];
	    dfloat  uyM = Uy[idM], uyP = Uy[idP];

	    dfloat  pxM = Px[idM], pxP = Px[idP];
	    dfloat  pyM = Py[idM], pyP = Py[idP];

	    // apply boundary condition
	    iint bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      insAdvectionBoundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, pxM, pyM, &pxP, &pxP);
	    // Find max normal velocity on the face
	    dfloat unM   = occaFabs(nx*uxM + ny*uyM);
	    dfloat unP   = occaFabs(nx*uxP + ny*uyP);    
	    dfloat unMax = (unM > unP) ? unM : unP;

	    // evaluate "flux" terms: LLF
	    const dfloat sc = invJ * sJ ; 
	    s_fluxUx[es][n] = sc*(.5f*( nx*(uxP*pxP - uxM*pxM) 
					+ ny*(uyP*pxP - uyM*pxM) 
					+ unMax*(pxM-pxP) ));
	    s_fluxUy[es][n] = sc*(.5f*( nx*(uxP*pyP - uxM*pyP) 
					+ ny*(uyP*pyP - uyM*pyM) 
					+ unMax*(pyM-pyP) ));
	  }
	}
      }
    }

    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
	iint e = eo + es;
	if(e<Nelements){
	  if(n<p_Np){
	    iint id = e*p_Np + n;
	    //
	    dfloat rhsux = rhsUx[id];
	    dfloat rhsuy = rhsUy[id];
	    // Lift
	    occaUnroll(p_NfacesNfp)
	      for(int m=0;m<p_Nfaces*p_Nfp;++m){
		dfloat L = LIFTT[n+m*p_Np];
		//
		rhsux  += L*s_fluxUx[es][m];
		rhsuy  += L*s_fluxUy[es][m];
	      }
	    // M^-1* (div(u*u)) + Lift*(F*-F))
	    rhsUx[id] = -rhsux;
	    rhsUy[id] = -rhsuy;
	  }
	}
      }
    }
  }


}








