
void boundaryConditions2D(int bc, dfloat time, dfloat x, dfloat y,
        dfloat uM, dfloat vM, dfloat pM,
        dfloat *uP, dfloat *vP, dfloat *pP){
  
  if(1){ //bc==1){
    // assert Neumann for pressure and no penetration for velocity
    *uP = -uM;
    *vP = -vM;
    *pP = pM;
  }
  if(0){ //bc==2){
    dfloat dx = 1.f/occaSqrt(2.f);
    dfloat dy = 1.f/occaSqrt(2.f);
    dfloat omega = 10*M_PI;
    dfloat wave = occaCos(omega*(time-(x*dx+y*dy)));
    dfloat uI = dx*wave;
    dfloat vI = dy*wave;
    dfloat pI = wave;
    
    // scattered field wall
    *uP = -uM -2.f*uI;
    *vP = -vM -2.f*vI;
    *pP = pM;
  }
}

kernel void acousticsSurface2Dbbdg(const int Nelements,
           const int   * restrict Elements,
           const int   * restrict N,
           const dfloat * restrict sgeo,
           const dfloat * restrict L0vals,
           const int   * restrict ELids,
           const dfloat * restrict ELvals,
           const dfloat * restrict BBLower,
           const int   * restrict BBRaiseids,
           const dfloat * restrict BBRaiseVals,  
           const int   * restrict vmapM,
           const int   * restrict vmapP,
           const int   * restrict EToE,
           const int   * restrict EToB,
           const dfloat time,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict q,
           dfloat       * restrict rhsq){
  
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxu_copy[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxv_copy[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxp_copy[p_NblockS][p_Nfp*p_Nfaces];

    // storage for unknown order neighbouring faces
    shared dfloat s_scratchu[p_NblockS][p_Nfpp1*p_Nfaces];
    shared dfloat s_scratchv[p_NblockS][p_Nfpp1*p_Nfaces];
    shared dfloat s_scratchp[p_NblockS][p_Nfpp1*p_Nfaces];

    //load neighbours face info
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        int et = eo + es;
        if(et<Nelements){
          int e = Elements[et];
          if(n<p_Nfpp1*p_Nfaces){
            int f = n / p_Nfpp1;

            // load element and face number of neighbour
            int eP = EToE[e*p_Nfaces+f];

            if (eP<0) eP = e;
            const int  NP = N[eP]; 
            
            int id  = e*p_Nfaces*p_NfpMax + n;
            int idP = vmapP[id];
            int qidP = p_Nfields*idP;
            
            if ( (n % p_Nfpp1) <= NP) {
              //load qP into scratch
              s_scratchu[es][n] = q[qidP+0];
              s_scratchv[es][n] = q[qidP+1];
              s_scratchp[es][n] = q[qidP+2];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //project info to proper order space and store in flux_copy
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        int et = eo + es;
        if(et<Nelements){
          if (n<p_Nfp*p_Nfaces) {
            int e = Elements[et];
            int f  = n / p_Nfp;
            int id = n % p_Nfp;

            // load element and face number of neighbour
            int eP = EToE[e*p_Nfaces+f];
            if (eP<0) eP = e; //boundary
            int NP = N[eP]; 

            if (NP < p_N) { 
              s_fluxu_copy[es][n] = 0.0;
              s_fluxv_copy[es][n] = 0.0;
              s_fluxp_copy[es][n] = 0.0;
              for (int m=0;m<2;m++){ //apply raise operator sparsly
                dfloat BBRaiseVal = BBRaiseVals[p_Nfp*id+m];
                int BBRaiseid = BBRaiseids[p_Nfp*id+m];
                s_fluxu_copy[es][n] += BBRaiseVal*s_scratchu[es][f*p_Nfpp1 + BBRaiseid];
                s_fluxv_copy[es][n] += BBRaiseVal*s_scratchv[es][f*p_Nfpp1 + BBRaiseid];
                s_fluxp_copy[es][n] += BBRaiseVal*s_scratchp[es][f*p_Nfpp1 + BBRaiseid];
              }
            } else if (NP > p_N) { 
              s_fluxu_copy[es][n] = 0.0;
              s_fluxv_copy[es][n] = 0.0;
              s_fluxp_copy[es][n] = 0.0;
              for (int m=0;m<p_Nfpp1;m++){
                s_fluxu_copy[es][n] += BBLower[p_Nfpp1*id+m]*s_scratchu[es][f*p_Nfpp1 + m];
                s_fluxv_copy[es][n] += BBLower[p_Nfpp1*id+m]*s_scratchv[es][f*p_Nfpp1 + m];
                s_fluxp_copy[es][n] += BBLower[p_Nfpp1*id+m]*s_scratchp[es][f*p_Nfpp1 + m];
              }
            } else { //equal order neighbor
              s_fluxu_copy[es][n] = s_scratchu[es][f*p_Nfpp1 + id];
              s_fluxv_copy[es][n] = s_scratchv[es][f*p_Nfpp1 + id];
              s_fluxp_copy[es][n] = s_scratchp[es][f*p_Nfpp1 + id];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements 
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        int et = eo + es;
        if(et<Nelements){
          int e = Elements[et];
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            int face = n/p_Nfp;
            int iid  = n%p_Nfp;
          
            // load surface geofactors for this face
            int sid = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx = sgeo[sid+0];
            dfloat ny = sgeo[sid+1];
            dfloat sJ = sgeo[sid+2];
            dfloat invJ = sgeo[sid+3];

            // indices of negative and positive traces of face node
            int id  = e*p_NfpMax*p_Nfaces + face*p_NfpMax + iid;
            int idM = vmapM[id];
            int qidM = idM*p_Nfields;
  
            // load negative and positive trace node values of q
            dfloat uM = q[qidM+0], vM = q[qidM+1], pM = q[qidM+2];
            
            dfloat uP = s_fluxu_copy[es][n];
            dfloat vP = s_fluxv_copy[es][n];
            dfloat pP = s_fluxp_copy[es][n];

            // apply boundary condition
            int bc = EToB[face+p_Nfaces*e];
            if(bc>0)  boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);
            
            // compute (q^* - q^-)
            dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
            dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
            dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
            
            // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
            s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
            s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
            s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);  
          }
        }
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // apply L0 to fluxes. use fact that L0 = tridiagonal in 2D
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        int et = eo + es;
        if(et<Nelements){
          if(n<p_Nfp*p_Nfaces){

            int id = n % p_Nfp;  // warning: redundant reads
            dfloat L0val = L0vals[id+p_Nfp]; 

            
            dfloat utmpflux = L0val * s_fluxu[es][n];
            dfloat vtmpflux = L0val * s_fluxv[es][n];
            dfloat ptmpflux = L0val * s_fluxp[es][n];

            if (id > 0){    
              utmpflux += L0vals[id]*s_fluxu[es][n-1]; // add previous term
              vtmpflux += L0vals[id]*s_fluxv[es][n-1]; // add previous term
              ptmpflux += L0vals[id]*s_fluxp[es][n-1]; // add previous term
            }
            if (id < p_Nfp-1){
              utmpflux += L0vals[id+2*p_Nfp]*s_fluxu[es][n+1];// add next term
              vtmpflux += L0vals[id+2*p_Nfp]*s_fluxv[es][n+1];// add next term
              ptmpflux += L0vals[id+2*p_Nfp]*s_fluxp[es][n+1];// add next term
            }
            s_fluxu_copy[es][n] = utmpflux;
            s_fluxv_copy[es][n] = vtmpflux;
            s_fluxp_copy[es][n] = ptmpflux;
          }
        }
      }
    }

    barrier(localMemFence);

    // apply lift reduction and accumulate RHS
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
        int et = eo + es;
        if(et<Nelements){
          if(n<p_Np){
            int e = Elements[et];
            int id = p_Nfields*(p_NpMax*e + n);
            
            // load RHS
            dfloat rhsqnu = rhsq[id+0];
            dfloat rhsqnv = rhsq[id+1];
            dfloat rhsqnp = rhsq[id+2];

            // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
            occaUnroll(p_max_EL_nnz)
            for (int m = 0; m < p_max_EL_nnz; ++m){
              int id = n + m*p_Np;
              dfloat ELval = ELvals[id];
              int ELid = ELids[id];
              rhsqnu += ELval * s_fluxu_copy[es][ELid];
              rhsqnv += ELval * s_fluxv_copy[es][ELid];
              rhsqnp += ELval * s_fluxp_copy[es][ELid];
            }
            
            // store incremented rhs
            rhsq[id+0] = rhsqnu;
            rhsq[id+1] = rhsqnv;
            rhsq[id+2] = rhsqnp;  
          }
        }
      }
    }
  }
}
    