
// e1c - like e6, just no interpolation. 2d i-j "slabs".
/*
kernel void ellipticAxHex3D_e1c(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt, r_tmpt;
		exclusive int emap;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				emap = elementList[e];

				const int base = i + j*p_Nq + emap*p_Np;
				for (int k=0; k<p_Nq; k++){

					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					s_Aq[k][j][i] = 0.f;

				}

				s_D[j][i] = D[j*p_Nq+i];
			}
		}

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					dfloat qtk = 0.f;
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][j][i];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {

						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into G entries
					s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
					r_tmpt           = G02*qr + G12*qs + G22*r_qt;

					s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

					for(int n=0; n<p_Nq; ++n) {
						s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
					}
				}
			}


			barrier(localMemFence);

			// second derivatives

			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					s_Aq[k][j][i] +=  Aq1 + Aq2;
				}
			}
		}//for k ()

		barrier(localMemFence);

		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {

				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = s_Aq[k][j][i];
				}
			}
		}
	}

} //e1c


*/

/*


//e1c0 -> version with k as internal loop


// e1c - like e6, just no interpolation. 2d i-j "slabs".

kernel void ellipticAxHex3D_e1c0(const int Nelements,
                                 const int * restrict elementList,
                                 const dfloat * restrict ggeo,
                                 const dfloat * restrict D,
                                 const dfloat lambda,
                                 const dfloat * restrict q,
                                 dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];

		exclusive int emap;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				emap = elementList[e];

				const int base = i + j*p_Nq + emap*p_Np;
				for (int k=0; k<p_Nq; k++){

					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					s_Aq[k][j][i] = 0.f;
				}

				s_D[j][i] = D[j*p_Nq+i];

			}
		}

		barrier(localMemFence);



		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				for(int k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][j][i];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}

		barrier(localMemFence);

		// process k-slice (first r- and s-derivatives)
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				for(int k=0; k<p_Nq; ++k) {
					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

					dfloat qr = 0.f, qs = 0.f;
					for(int n=0; n<p_Nq; ++n) {

						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into G entries
					s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];


					s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

					for(int n=0; n<p_Nq; ++n) {
						s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}


		barrier(localMemFence);

		// second derivatives

		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				for(int k=0; k<p_Nq; ++k) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}

					s_Aq[k][j][i] +=  Aq1 + Aq2;
				}
			}
		}
		//	}//for k ()

		barrier(localMemFence);

		// write result out (local node storage)
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {

				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = s_Aq[k][j][i];
				}
			}
		}
	}

} //e1c
*/
// e1d - slab version of e0 (cross between e0 and e1)

// 10 10 10 -> slice thickness 1
// no slices  = (int) 1024/(p_Nq^2)
// sliceThickness = ceil(p_N1/no slices)

// 11 11 8 -> slice thickness 2
// 11 = 2 +2 + 1 + 1 + 1+ 1 +1 +1 +1
// k=0 {0, 8}, k=1 {1,9} k =2 {2, 10} 
 

// 12 12 7 -> slice thickness  2
// 12 = 2 + 2 + 2 +2 +2 +1 +1

// 13 13 6
// 13 = 3 + 2 +2 + 2+ 2 +2 

// 14 14 5
// 14 = 3+ 3 +3 +3 +2

// 15 15 4
// 15 = 4 + 4 + 4 + 3

// 16 16 4
// 16 = 4 + 4 + 4 +4

// 17 17 3
// 17 = 6 + 6 +5 

// k = 0..., p_Nq/sliceThickness
// i = 0 ... p_Nq-1, j = 0,..., p_Nq-1


#if p_Nq < 11
#define sliceThickness 1
#elif p_Nq <= 13
#define sliceThickness 2
#elif p_Nq p_Nq == 14
#define sliceThickness 3
#elif p_Nq <=16
#define sliceThickness 4
#else
#define sliceThickness 6
#endif

#if p_Nq < 11
#define shift p_Nq
#else
#define shift  1024/(p_Nq*p_Nq)
#endif

#define cubeThreadsSliced                             \
	for(int k=0; k<shift; ++k; inner2)            \
		for(int j=0; j<p_Nq; ++j; inner1)          \
			for(int i=0; i<p_Nq; ++i; inner0)

kernel void ellipticAxHex3D_e1d(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq,
                                dfloat * restrict aux
                               ){
	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_q2[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_qr[sliceThickness], r_qs[sliceThickness], r_qt[sliceThickness], r_Aq[sliceThickness];


		// prefetch q(:,:,:,e) to shared
		cubeThreadsSliced {

		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  //  while (s<p_Nq){
		  occaUnroll(p_Nq)
		  for (int s=k; s<p_Nq;s+=shift){
		  const int base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  s_q[s][j][i] = q[base];		
		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
		
		//	for (int s=k; s<p_Nq;s+=shift){
	//	for (int sws=0; sws<p_Nq;sws+=shift){
	
			cubeThreadsSliced {
		//	  int s = sws+k;

      for (int s=k; s<p_Nq;s+=shift){

			  const int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(int n=0; n<p_Nq; ++n) {
			    qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }
//save these values to main?
//then load them from main instead of loading from registers which seems to be expensive?
			 // r_qr[s/shift] = qr;
			  //r_qs[s/shift] = qs;
			  //r_qt[s/shift] = qt;

			  //r_Aq[s/shift] = GwJ*lambda*s_q[s][j][i];
			  //	  s++;
			  //	  s+=shift;
			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
			  const dfloat G11 = ggeo[base+p_G11ID*p_Np];
			 
			  
			  
			  const dfloat G22 = ggeo[base+p_G22ID*p_Np];
			
			  const dfloat G12 = ggeo[base+p_G12ID*p_Np];
			  
		    const dfloat qqr = G00*qr + G01*qs + G02*qt;
		    const dfloat qqs = G01*qr + G11*qs + G12*qt;
		    const dfloat qqt = G02*qr + G12*qs + G22*qt;
		    
		    
			  for (int n=0; n<p_Nq; n++)
			  {
          /*  s_q2[s][j][n] += s_D[i][n]*qqr;
            s_q2[s][n][i] += s_D[j][n]*qqs;
            s_q2[n][j][i] += s_D[j][n]*qqt;
            */
            // YOU ARE IN s, j, i
            // s_D[n][i]*s_tmpr[k][j][n];
            int base2 = n + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
            Aq[base2]+= s_D[n][i]*qqr;
            base2 = i + n*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
            
            Aq[base2]+= s_D[n][j]*qqs;
              base2 = i + j*p_Nq + n*p_Nq*p_Nq + elementList[e]*p_Np;
             Aq[base2]+= s_D[s][n]*qqt;
				}

			}//cube threads
		}//for sws



		// r term ----->
		
	//	for (int sws=0; sws<p_Nq;sws+=shift){
			barrier(localMemFence);

			cubeThreadsSliced {
			//  int s = sws+k;
for (int s=k; s<p_Nq;s+=shift){
			  //while (s<(k+sliceThickness)&&(s<p_Nq)){
			  //  while (s<p_Nq){

			  const int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

	//		  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
		//	  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			//  const dfloat G02 = ggeo[base+p_G02ID*p_Np];

			//  aux[base] = G00*r_qr[s/shift]+ G01*r_qs[s/shift];+ G02*r_qt[s/shift];
		//very cheap
//= G00+G01+G02;

//s_q[s][j][i]  = G00*aux[base];
//12-i-j-k;
//r_qr[s/shift]+ r_qs[s/shift]+r_qt[s/shift];
		//  s++;

			  //	  s+=shift;

			}

		}
}
}
															 /*
		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  int s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  for(int n=0; n<p_Nq; ++n)
			  tmp += s_D[n][i]*s_q[s][j][n];

			  r_Aq[s/shift] += tmp;
			  //  s++;


			}
		}

	// s term ---->
	barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  int s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  const int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;



			  const  dfloat G11 = ggeo[base+p_G11ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G12 = ggeo[base+p_G12ID*p_Np];

			  s_q[s][j][i] = G01*r_qr[s/shift] + G11*r_qs[s/shift] + G12*r_qt[s/shift];
			  //  s++;
			  //s+=sliceThickness;


			}
		}

		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  int s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  for(int n=0; n<p_Nq; ++n)
			  tmp += s_D[n][j]*s_q[s][n][i];

			  r_Aq[s/shift] += tmp;
			  //  s++;
			  //	s+=sliceThickness;


			}
		}

	// t term ---->
	barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  int s = sws+k;


			  //  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  const int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  const dfloat G22 = ggeo[base+p_G22ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
			  const dfloat G12 = ggeo[base+p_G12ID*p_Np];

			  s_q[s][j][i] = G02*r_qr[s/shift] + G12*r_qs[s/shift] + G22*r_qt[s/shift];
			  //	  s++;
			  //  s+=sliceThickness;


			}
		}

		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  int s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  for(int n=0; n<p_Nq; ++n)
			  tmp += s_D[n][s]*s_q[n][j][i];

			  r_Aq[s/shift] += tmp;

			  int base =  elementList[e]*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = r_Aq[s/shift];
			  //  if (e==0)
			  //{
			  //	printf("ind %d s =  %d, i= %d, j= %d, k=%d \n", (s+1)*(i+1)*(j+1), s, i, j, k);
			  //}
			  // printf("k= %d s= %d, shift = %d, sliceThickness = %d s over shift = %d \n",k, s, shift, sliceThickness,c);
			  //  s++;
			  //	s+=sliceThickness;


			}
		}
}
}
*/
//e1d end

//e1e optimiXYZ[2]d e1d
/*
kernel void ellipticAxHex3D_e1e(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	

	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_Aq[sliceThickness+1];
		exclusive int emap, s, base;

		//r_qs[sliceThickness+1];
		//	r_qt[sliceThickness+1],
		//	r_Aq[sliceThickness+1];

		shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qt[p_Nq][p_Nq][p_Nq];


		// prefetch q(:,:,:,e) to shared
		//if N=8, sliceThickness =2, this part costs 21 regs
		cubeThreadsSliced {
		  s = k;
emap = elementList[e];


		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){
		  base = i + j*p_Nq + s*p_Nq*p_Nq + emap*p_Np;


			  s_q[s][j][i] = q[base];
			  //  s++;
			  s+=shift;

		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
//this part costs 60 registers !!!
		cubeThreadsSliced {

		  s =k;
dfloat  GwJ, G00, G01, G02, G11, G12, G22;
 dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  //  while (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){
		    int base = emap*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  GwJ = ggeo[base+p_GWJID*p_Np];
			 G00 = ggeo[base+p_G00ID*p_Np];
			  G01 = ggeo[base+p_G01ID*p_Np];
			 G02 = ggeo[base+p_G02ID*p_Np];
			  G11 = ggeo[base+p_G11ID*p_Np];

			   G12 = ggeo[base+p_G12ID*p_Np];
			  G22 = ggeo[base+p_G22ID*p_Np];



			  qr = 0.f, qs = 0.f, qt = 0.f;

			  for(int n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }

			  s_qr[s][j][i] = G00*qr + G01*qs + G02*qt;
			  s_qs[s][j][i] = G01*qr + G11*qs + G12*qt;
			  s_qt[s][j][i] = G02*qr + G12*qs + G22*qt;


			  r_Aq[s/shift]= GwJ*lambda*s_q[s][j][i];
			 	  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = qr;
			  
			  Aq[base] = qt;
			  s+=shift;


		  }//while
		}

		// r term ----->
		barrier(localMemFence);
// 8 registers only
		cubeThreadsSliced {
		 s=k;
 dfloat tmp = 0.f;

		  //while (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){

		  tmp = 0.f;
		  occaUnroll(p_Nq)
			  for(int m=0; m<p_Nq; ++m) {
				  tmp += s_D[m][i]*s_qr[s][j][m];
				  tmp += s_D[m][j]*s_qs[s][m][i];
				  tmp += s_D[m][s]*s_qt[m][j][i];
			  }
			  //	s_Aq[s][j][i]+=tmp;
			  tmp+= r_Aq[s/shift];
			 // int emap = elementList[e];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = tmp;
			  s+=shift;
		  }
		}
	}
}//e1e end



kernel void ellipticAxHex3D_e1f(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){



	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_Aq[sliceThickness+1];
		exclusive int emap, s, base;

		//r_qs[sliceThickness+1];
		//	r_qt[sliceThickness+1],
		//	r_Aq[sliceThickness+1];

		shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qt[p_Nq][p_Nq][p_Nq];


		// prefetch q(:,:,:,e) to shared
		//if N=8, sliceThickness =2, this part costs 21 regs
		cubeThreadsSliced {

		  emap = elementList[e];


		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){
		  base = i + j*p_Nq + s*p_Nq*p_Nq + emap*p_Np;


		  s_q[s][j][i] = q[base];
			  //  s++;


		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
		//this part costs 60 registers !!!
		cubeThreadsSliced {


		  dfloat  GwJ, G00, G01, G02, G11, G12, G22;
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  //  while (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){
		  int base = emap*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  GwJ = ggeo[base+p_GWJID*p_Np];
			  G00 = ggeo[base+p_G00ID*p_Np];
			  G01 = ggeo[base+p_G01ID*p_Np];
			  G02 = ggeo[base+p_G02ID*p_Np];
			  G11 = ggeo[base+p_G11ID*p_Np];

			  G12 = ggeo[base+p_G12ID*p_Np];
			  G22 = ggeo[base+p_G22ID*p_Np];



			  qr = 0.f, qs = 0.f, qt = 0.f;

			  for(int n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }

			  s_qr[s][j][i] = G00*qr + G01*qs + G02*qt;
			  s_qs[s][j][i] = G01*qr + G11*qs + G12*qt;
			  s_qt[s][j][i] = G02*qr + G12*qs + G22*qt;


			  r_Aq[s/shift]= GwJ*lambda*s_q[s][j][i];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			 



		  }//while
		}

		// r term ----->
		barrier(localMemFence);
		// 8 registers only
		cubeThreadsSliced {

		  dfloat tmp = 0.f;

		  //while (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){

		  tmp = 0.f;
		  occaUnroll(p_Nq)
			  for(int m=0; m<p_Nq; ++m) {
				  tmp += s_D[m][i]*s_qr[s][j][m];
				  tmp += s_D[m][j]*s_qs[s][m][i];
				  tmp += s_D[m][s]*s_qt[m][j][i];
			  }
			  //	s_Aq[s][j][i]+=tmp;
			  tmp+= r_Aq[s/shift];
			  // int emap = elementList[e];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = tmp;

		  }
		}
	}
}//e1f end

*/
//e1g = sliced e1c
#if p_Nq<8
#define MAXY 8
#elif p_Nq <12
#define MAXY 12
#elif p_Nq<16
#define MAXY 16
#else
#define MAXY 24
#endif

#if p_Nq<=8
#define MAXX 8
#elif p_Nq<16
#define MAXX 16
#else
#define MAXX 18
#endif

kernel void ellipticAxHex3D_e1g(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){
	for(int e=0; e<Nelements; ++e; outer0){
		shared dfloat s_D[p_Nq][p_Nq];

//		exclusive dfloat r_q[p_Nq];

		shared dfloat s_qr[p_Nq][p_Nq];
	//	shared dfloat s_qs[p_Nq][p_Nq];

		shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];
		shared dfloat s_tmp[p_Nq][p_Nq];

		exclusive int emap;
	//	exclusive dfloat r_qt;

		// prefetch D and part of q
		for(int b=0;b<MAXY;++b;inner1){
			for(int a=0;a<MAXX;++a;inner0){
				if (b<p_Nq && a<p_Nq){
					emap = elementList[e];


					s_D[b][a] = D[b*p_Nq+a];
					//s_D[j][i] = D[j*p_Nq+i];

					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_tmpq[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
				//		r_q[c] = 0.0f;
					}
				}

			}
		}

		barrier(localMemFence);


		// scan through k slices



		occaUnroll(p_Nq)
		for(int k=0;k<p_Nq;++k){

			barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

						//just loading geofactors from global is 1/3 of cost of the kernel (very slow) --> every thread does it p_Nq (so up to MAXX) times
						// this equals up to 7*MAXX reads

						// cant increase shared any more
						// we use truckloads of registers already


			//			const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
						const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
						const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
						const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];

			//			const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
				//		const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
			//			const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];



						// differentiate
						dfloat qr = 0, qs = 0, qt = 0;
						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;++n){
							qr += s_D[i][n]*s_tmpq[k][j][n];
							qs += s_D[j][n]*s_tmpq[k][n][i];
							qt += s_D[k][n]*s_tmpq[n][j][i];
						}

						// apply chain rule (notice the swtich of indices in i,j)
						s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
				//		s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					//	r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

						//r_q[k] += lambda*r_GwJ*s_tmpq[k][j][i];


						//occaUnroll()
						//for(int n=0; n<p_Nq; ++n) {
						//	s_Aq[n][j][i] += s_D[k][n]*r_tmpt;

						//r_q[n] += s_D[k][n]*r_qt;
						//		}

					}
				}
			}

			barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
					//	dfloat lapqr = 0, lapqs = 0;
s_tmp[j][i] = 0.0f;

						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;++n){
							s_tmp[j][i] += s_D[n][i]*s_qr[j][n];
				//			lapqs += s_D[n][j]*s_qs[n][i];
				//			r_q[n] += s_D[k][n]*r_qt;
						}
						
							int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
						Aq[base] = s_tmp[j][i];
						//+lapqs;
						//r_q[k];
//r_q[k] = lapqr;
					//	r_q[k] += lapqr + lapqs;
					
						// base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
						//Aq[base] += (lapqr + lapqs);
					}
				}
			}
		}//k
/*
		occaUnroll(p_Nq)
		for (int k=0; k<p_Nq; k++){
			for(int j=0; j<MAXY; ++j; inner1) {
				for(int i=0; i<MAXX; ++i; inner0) {
					if (i<p_Nq && j<p_Nq){

		//				int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
			//			Aq[base] = r_q[k];
					}
				}
			}
		}*/

	}
} //e1q
/*

//block split - not finished, not likely to be fast

#define cubeThreads                             \
	for(int k=0; k<p_Nq; ++k; inner2)            \
		for(int j=0; j<p_Nq; ++j; inner1)          \
			for(int i=0; i<p_Nq; ++i; inner0)


kernel void ellipticAxHex3D_bs0(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq,
                                dfloat * restrict grad){

	for(int eo=0; eo<3*Nelements; ++eo; outer0) {


		//	shared dfloat s_D[p_Nq][p_Nq];
		//	shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		exclusive dfloat emap;
		shared dfloat r_D[p_Nq][p_Nq];
		shared dfloat r_q[p_Nq][p_Nq][p_Nq];
		//r_Aq;
		//	exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;
		//	exclusive dfloat r_Aq;
		// prefetch q(:,:,:,e) to shared
		cubeThreads {
		  emap = elementList[(int) (eo/3)];
		  const int base = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np;
		  if(k==0) // fetch D to shared
		  r_D[j][i] = D[j*p_Nq+i];

		  r_q[k][j][i] = q[base];

		}
		barrier(localMemFence);

		cubeThreads {
		  dfloat tmp =0.0f;
		  if (eo%3 == 0)
	  {
		  //  s_q[k] = q[base];
		  occaUnroll(p_Nq)
			  for(int n=0; n<p_Nq; ++n) {
				  tmp += r_D[i][n]*r_q[k][j][n];
			  }

		  }
		  if (eo%3 == 1)
	  {
		  occaUnroll(p_Nq)
			  for(int n=0; n<p_Nq; ++n) {
				  tmp += r_D[j][n]*r_q[k][n][i];
			  }
			  const int base = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np;
			  grad[base] = tmp;

		  }
		  if (eo%3 == 2)
	  {

		  occaUnroll(p_Nq)
			  for(int n=0; n<p_Nq; ++n) {
				  tmp += r_D[k][n]*r_q[n][j][i] ;
			  }
			  const int base = i + j*p_Nq + k*p_Nq*p_Nq + emap*p_Np;
			  Aq[base] = tmp;

		  }
		}



		//	barrier(localMemFence);


		/*
				cubeThreads {

				  //  const int base = elementList[e]*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

				  // assumes w*J built into G entries


				  const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

				  r_GwJ = ggeo[base+p_GWJID*p_Np];

				  r_G00 = ggeo[base+p_G00ID*p_Np];
				  r_G01 = ggeo[base+p_G01ID*p_Np];
				  r_G02 = ggeo[base+p_G02ID*p_Np];

				  r_G11 = ggeo[base+p_G11ID*p_Np];
				  r_G12 = ggeo[base+p_G12ID*p_Np];
				  r_G22 = ggeo[base+p_G22ID*p_Np];


				  dfloat qr = 0.f;
				  dfloat qs = 0.f, qt = 0.f;

				  occaUnroll(p_Nq)
				  for(int n=0; n<p_Nq; ++n) {
				    qr += s_D[i][n]*s_q[k][j][n];
					  qs += s_D[j][n]*s_q[k][n][i];
					  qt += s_D[k][n]*s_q[n][j][i];
				  }
				  
		 
				  s_qr[k][j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
				  s_qs[k][j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
				  s_qt[k][j][i] = r_G02*qr + r_G12*qs + r_G22*qt;
				  
				  
				  r_Aq = r_GwJ*lambda*s_q[k][j][i];
				}


				// r term ----->


				barrier(localMemFence);

				cubeThreads {
				  dfloat tmp = 0.0f;

				  occaUnroll(p_Nq)
				  for(int n=0; n<p_Nq; ++n){
				    tmp += s_D[n][i]*s_qr[k][j][n];
					  tmp += s_D[n][j]*s_qs[k][n][i];
					  tmp += s_D[n][k]*s_qt[n][j][i];
				  }

				  //  r_Aq += tmp;
				  //  s_Aq[k][j][i] +=tmp;
				  r_Aq += tmp;
				  int base =  emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

				  Aq[base] = r_Aq;
				  //r_Aq;
				  //s_Aq[k][j][i];

				}
	}
}//e0b end

*/
//CUBOID KS







// e1h - e1g + global instead of shared
// works

kernel void ellipticAxHex3D_e1h(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){
	for(int e=0; e<Nelements; ++e; outer0){
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_q[p_Nq];

		//	shared dfloat s_qr[p_Nq][p_Nq];
		//shared dfloat s_qs[p_Nq][p_Nq];
		exclusive dfloat r_qr, r_qs;

		shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];
    shared dfloat s_aux[p_Nq][p_Nq];
		exclusive int emap;
		exclusive dfloat r_qt;

		// prefetch D and part of q
		for(int b=0;b<MAXY;++b;inner1){
			for(int a=0;a<MAXX;++a;inner0){
				if (b<p_Nq && a<p_Nq){
					emap = elementList[e];


					s_D[b][a] = D[b*p_Nq+a];


					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){
						s_tmpq[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
						r_q[c] = 0.0f;
					}
				}

			}
		}

		barrier(localMemFence);


		// scan through k slices

		

		occaUnroll(p_Nq)
		for(int k=0;k<p_Nq;++k){

			//		barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

						//just loading geofactors from global is 1/3 of cost of the kernel (very slow) --> every thread does it p_Nq (so up to MAXX) times
						// this equals up to 7*MAXX reads

						// cant increase shared any more
						// we use truckloads of registers already


						const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
						const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
						const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
						const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];

						const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
						const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
						const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
			


						// differentiate
						dfloat qr = 0, qs = 0, qt = 0;
						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;++n){
							qr += s_D[i][n]*s_tmpq[k][j][n];
							qs += s_D[j][n]*s_tmpq[k][n][i];
							qt += s_D[k][n]*s_tmpq[n][j][i];
						}

						// apply chain rule (notice the swtich of indices in i,j)
						//	s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
						//	s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					//	r_qr = r_G00*qr + r_G01*qs + r_G02*qt;
					s_aux[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
						r_qs = r_G01*qr + r_G11*qs + r_G12*qt;
						r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

						r_q[k] += lambda*r_GwJ*s_tmpq[k][j][i];

					}
				}
			}
		
		barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						dfloat tmp=0.0f;
						for (int n=0; n<p_Nq; ++n){
							tmp += s_D[n][i]*s_aux[j][n];;
						}
						r_q[k] +=tmp;
					}
				}
			}
		

		
	
	barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						s_aux[j][i] = r_qs;
					}
				}
			}
		
		
	
		
			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						dfloat tmp =0.0f;
						for (int n=0; n<p_Nq; ++n){
							tmp += s_D[n][j]*s_aux[n][i];
							r_q[n] += s_D[k][n]*r_qt;
							//r_q[n] += s_D[k][n]*r_qt;
						}
						r_q[k] +=tmp;
			
					}
				}
			}
		}
			occaUnroll(p_Nq)
for (int k=0; k<p_Nq; k++){
		for(int j=0; j<MAXY; ++j; inner1) {
			for(int i=0; i<MAXX; ++i; inner0) {
				if (i<p_Nq && j<p_Nq){

					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = r_q[k];
				}
			}
	}
	}
	}
																}

		/*
		barrier(localMemFence);

		for(int j=0;j<MAXY;++j;inner1){
			for(int i=0;i<MAXX;++i;inner0){
				if (i<p_Nq && j<p_Nq){
					dfloat lapqr = 0, lapqs = 0;


					occaUnroll(p_Nq)
					for(int n=0;n<p_Nq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
						r_q[n] += s_D[k][n]*r_qt;
					}

					r_q[k] += lapqr + lapqs;
					// base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					//Aq[base] += (lapqr + lapqs);
				}
			}
	}
	}//k
		for (int k=0; k<p_Nq; k++){
		for(int j=0; j<MAXY; ++j; inner1) {
			for(int i=0; i<MAXX; ++i; inner0) {
				if (i<p_Nq && j<p_Nq){

					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = r_q[k];
				}
			}
	}
	}

	}
} //e1q

*/

#if (p_Nq==16 || p_Nq==8)
#define p_pad 1
#else
#define p_pad 0
#endif

kernel void ellipticAxHex3D_e1i(const int Nelements,
                                const int * restrict elementList,
                                const double* restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){
<<<<<<< HEAD
	for(int e=0; e<Nelements; ++e; outer0){
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive double2 r_q[p_Nq];
			shared dfloat s_qr[p_Nq][p_Nq];
			shared dfloat s_qs[p_Nq][p_Nq];
		//shared dfloat s_1[p_Nq][p_Nq];
	//	double2 r_qrqs;
		shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];

		exclusive int emap;
		exclusive dfloat r_qt;
		exclusive double2 qt, qr, qs;
// just this part: 32 registets
		// prefetch D and part of q
		for(int b=0;b<MAXY;++b;inner1){
			for(int a=0;a<MAXX;++a;inner0){
				if (b<p_Nq && a<p_Nq){
					emap = elementList[e];
					s_D[b][a] = D[b*p_Nq+a];
			

      
		//		occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;c++){
//this LOAD is 24 registers for N=16
					s_tmpq[c][b][a] = q[emap*p_Np+(c*p_Nq*p_Nq+b*p_Nq+a)];
					//loading to registers DOES not cost registers  (but is not fast, loading to SHARED faster)
					
		
		
	          if (c<(p_Nq+1)/2)
						{
							r_q[c].x = 0.0f;
							r_q[c].y = 0.0f;
						}//if
					}//c
					
				
				}//if
=======
  for(int e=0; e<Nelements; ++e; outer0){
    shared dfloat s_D[p_Nq][p_Nq+p_pad];

    exclusive double r_q[p_Nq];

    shared dfloat s_qr[p_Nq][p_Nq];
    shared dfloat s_qs[p_Nq][p_Nq];
    //shared dfloat s_1[p_Nq][p_Nq];
    //	double2 r_qrqs;
    shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];

    exclusive int emap;
    exclusive dfloat r_qt;
    exclusive double qt, qr, qs ;

    // prefetch D and part of q
    for(int b=0;b<MAXY;++b;inner1){
      for(int a=0;a<MAXX;++a;inner0){
	if (b<p_Nq && a<p_Nq){
	  emap = elementList[e];
	  s_D[b][a] = D[b*p_Nq+a];
          
	  occaUnroll(p_Nq)
	    for(int c=0;c<p_Nq;++c){
>>>>>>> 77894dfab146d06fc8f86a1f95cedd14dbd25d18

	      s_tmpq[c][b][a] = q[emap*p_Np+(c*p_Nq*p_Nq+b*p_Nq+a)];
	      
	      r_q[c] = 0;
	    }//c
	}
      }//b
    }

    barrier(localMemFence);

    // scan through k slices

    occaUnroll(p_Nq)
      for(int k=0;k<p_Nq;++k){

	barrier(localMemFence);

	for(int j=0;j<MAXY;++j;inner1){
	  for(int i=0;i<MAXX;++i;inner0){
	    if (i<p_Nq && j<p_Nq){
	      const int base = emap*4*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	      //+ +8*(k*p_Nq*p_Nq + j*p_Nq +i) ;

	      //just loading geofactors from global is 1/3 of cost of the kernel (very slow) --> every thread does it p_Nq (so up to MAXX) times
	      // this equals up to 7*MAXX reads

	      // cant increase shared any more
	      // we use truckloads of registers already

<<<<<<< HEAD
			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						const int base = emap*8*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
			//		const int base = emap*8*p_Np +8*(k*p_Nq*p_Nq + j*p_Nq + i);
					//+ +8*(k*p_Nq*p_Nq + j*p_Nq +i) ;

						//just loading geofactors from global is 1/3 of cost of the kernel (very slow) --> every thread does it p_Nq (so up to MAXX) times
						// this equals up to 7*MAXX reads

						// cant increase shared any more
						// we use truckloads of registers already
            // these loads costs time, but they DO NOT increase number of registers

						//		const dfloat r_G00 = ggeo[base+p_G00ID*p_Np].x;
						//gjGeod2[8*gjNp*e + 8*n + 0 ] 
			/*			const double2 G00G01 = {ggeo[base  + 0], ggeo[base +1] };
						const double2 G02G11 = {ggeo[base  + 2], ggeo[base +3] };
						const double2 G12G22 = {ggeo[base  + 4], ggeo[base +5] };
						const double2 GwJ    = {ggeo[base  + 6], ggeo[base +7] };*/
	          const double2 G00G01 = {ggeo[base+p_G00ID*p_Np],ggeo[base+p_G01ID*p_Np]};
						const double2 G02G11 = {ggeo[base+p_G02ID*p_Np],ggeo[base+p_G11ID*p_Np]};
						const double2 G12G22 = {ggeo[base+p_G12ID*p_Np], ggeo[base+p_G22ID*p_Np]};
				    const double2 GwJ =    {ggeo[base+p_GWJID*p_Np], ggeo[base+7*p_Np]};

		/*        
						const double2 G00G01 = {ggeo[base+p_G00ID*p_Np],ggeo[base+p_G01ID*p_Np]};
						const double2 G02G11 = {ggeo[base+p_G02ID*p_Np],ggeo[base+p_G11ID*p_Np]};
						const double2 G12G22 = {ggeo[base+p_G12ID*p_Np], ggeo[base+p_G22ID*p_Np]};
				    const double2 GwJ =    {ggeo[base+p_GWJID*p_Np], 0.0f};
*/

						// differentiate
					//	dfloat qr = 0.0f, qs = 0.0f, qt = 0.0f;
				
					//, qt ;
					qr.x = 0.0f;
					qs.x = 0.0f;
					qt.x = 0.0f;
					occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;++n){
							qr.x += s_D[i][n]*s_tmpq[k][j][n];
							qs.x += s_D[j][n]*s_tmpq[k][n][i];
							qt.x += s_D[k][n]*s_tmpq[n][j][i];
						}

						// apply chain rule (notice the swtich of indices in i,j)
						/*
								s_aux[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
						r_qs = r_G01*qr + r_G11*qs + r_G12*qt;
						r_qt = r_G02*qr + r_G12*qs + r_G22*qt;
						*/
						
						
						s_qr[j][i] = G00G01.x*qr.x + G00G01.y*qs.x + G02G11.x*qt.x;
						s_qs[j][i] = G00G01.y*qr.x + G02G11.y*qs.x + G12G22.x*qt.x;
						r_qt = G02G11.x*qr.x + G12G22.x*qs.x + G12G22.y*qt.x;

						if (k%2 == 0){
							     r_q[k/2].x += lambda*GwJ.x*s_tmpq[k][j][i];
						}
						else{
										r_q[(k-1)/2].y += lambda*GwJ.x*s_tmpq[k][j][i];
						}
					}
				}
			}//j
barrier(localMemFence);
			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;i+=2;inner0){
					if (i<p_Nq && j<p_Nq){
						dfloat lapqr = 0.0f;
						dfloat lapqs = 0.0f;
						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;n+=2){
							lapqr += s_D[n][i]*s_qr[j][n];
							lapqs += s_D[n][j]*s_qs[n][i];
							r_q[n/2].x += s_D[k][n]*r_qt;
						}

						occaUnroll(p_Nq)
						for(int n=1;n<p_Nq;n+=2){

							lapqr += s_D[n][i]*s_qr[j][n];
							lapqs += s_D[n][j]*s_qs[n][i];
							r_q[(n-1)/2].y += s_D[k][n]*r_qt;
						}

						if (k%2 == 0){
							r_q[k/2].x += lapqr+ lapqs;
						
						}
						else{
							r_q[(k-1)/2].y += lapqr+ lapqs;
							
						}
						

					}//if
				}//i
			}
		}//k

	
		
		barrier(localMemFence);
		
		// no advantage in splitting in two loops unless N=4 (DO NOT TRY AGAIN)
		// this loop alone costs 32 registers!!! for N=16
		
		//loading from SHARED is cheap (both in terms of time and registers)
		// so counterintuitive: LOAD TO REGISTERS, LOAD BACK FROM SHARED?
	//	occaUnroll(p_Nq)
int base;
		for (int k=0; k<p_Nq; k+=1){
			for(int j=0; j<MAXY; ++j; inner1) {
				for(int i=0; i<MAXX; ++i; inner0) {
					if (i<p_Nq && j<p_Nq){

				//		int 
	base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
	
	//	base++;

						if (k%2 == 0){

							Aq[base] =r_q[k/2].x;
					} 

						else{
						Aq[base] =r_q[(k-1)/2].y;
						}
					}// if
				}
			}
		}//k
		
	
		

	}//e
}

// This is e1j - where we compute geofactors on the fly

// how rn, sn, tn are laid out in the memory

// notes to myself:
// 1. enforcing 2d loads/stores in a 2d thread structure is BAD for performance
// 2. if you do 1., load from shared to global at the end, otherwise # registers grows like crazy
// 3. all internal (per thread) variables are very cheap
// 4. From shared to registers is cheap as long as the loop does something other, too
// how geofactors are LAID OUT
/*

for(int k=0; k<gjNq; k+=2) {
		// per element, load coordinated and weights
		gjGeod2[k ]  = mesh->gjr[k];
		gjGeod2[k +1]  = mesh->gjw[k];
	}
for(int e=0; e<mesh->Nelements; ++e) {
	
	int id = e*mesh->Nverts;
	for (int k= 0; k<8; k++)
	{
		gjGeod2[2*gjNq + e*mesh->Nelements + k] = mesh->EX[id+k]; 				
		gjGeod2[2*gjNq + mesh->Nelements*8 + e*mesh->Nelements + k] = mesh->EY[id+k];		
		gjGeod2[2*gjNq + mesh->Nelements*16+ e*mesh->Nelements + k] = mesh->EZ[id+k];
	} 
}

*/				


// e1j start

kernel void ellipticAxHex3D_e1j(const int Nelements,
                                const int * restrict elementList,
                                const double * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){
	for(int e=0; e<Nelements; ++e; outer0){
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive double2 r_q[p_Nq];

		shared dfloat gjr[p_Nq];
		shared dfloat gjw[p_Nq];
		shared dfloat XYZ[3][8];



		shared dfloat s_qr[p_Nq][p_Nq];
		shared dfloat s_qs[p_Nq][p_Nq];
		//shared dfloat s_1[p_Nq][p_Nq];
		//	double2 r_qrqs;
		shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];

		exclusive int emap;
		exclusive dfloat r_qt;
		exclusive double2 qt, qr, qs ;

		// prefetch D and part of q
		for(int b=0;b<MAXY;++b;inner1){
			for(int a=0;a<MAXX;++a;inner0){
				if (b<p_Nq && a<p_Nq){
					emap = elementList[e];
					//these loads cost us shared, BUT NOT registers
					if (a == 0 )
					{
						gjr[b] = ggeo[b*2];
						gjw[b] = ggeo[b*2+1];
					}
					if (a<3 && b<8 ) /* we always run 8 or more threads per dimension so no worries */
					{
						XYZ[a][b] = ggeo[emap*Nelements*8*(a) + emap*Nelements + (b)];
					}

					s_D[b][a] = D[b*p_Nq+a];

					occaUnroll(p_Nq)
					for(int c=0;c<p_Nq;++c){

						s_tmpq[c][b][a] = q[emap*p_Np+(c*p_Nq*p_Nq+b*p_Nq+a)];



						if (c<(p_Nq+1)/2)
						{
							r_q[c].x = 0.0f;
							r_q[c].y = 0.0f;

						}//if
					}//c

				}//if

			}//b
		}

		barrier(localMemFence);


		// scan through k slices



		occaUnroll(p_Nq)
		for(int k=0;k<p_Nq;++k){

			barrier(localMemFence);

			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;++i;inner0){
					if (i<p_Nq && j<p_Nq){
						// this part is super expensive since it adds registers like CRAZY
						// do the magic
						const dfloat rn = gjr[i];
						const dfloat sn = gjr[j];
						const dfloat tn = gjr[k];


						const dfloat xr = 0.125*( (1-tn)*(1-sn)*(XYZ[0][1]-XYZ[0][0]) + (1-tn)*(1+sn)*(XYZ[0][2]-XYZ[0][3]) + (1+tn)*(1-sn)*(XYZ[0][5]-XYZ[0][4]) + (1+tn)*(1+sn)*(XYZ[0][6]-XYZ[0][7]) );
						const dfloat xs = 0.125*( (1-tn)*(1-rn)*(XYZ[0][3]-XYZ[0][0]) + (1-tn)*(1+rn)*(XYZ[0][2]-XYZ[0][1]) + (1+tn)*(1-rn)*(XYZ[0][7]-XYZ[0][4]) + (1+tn)*(1+rn)*(XYZ[0][6]-XYZ[0][5]) );
						const  dfloat xt = 0.125*( (1-rn)*(1-sn)*(XYZ[0][4]-XYZ[0][0]) + (1+rn)*(1-sn)*(XYZ[0][5]-XYZ[0][1]) + (1+rn)*(1+sn)*(XYZ[0][6]-XYZ[0][2]) + (1-rn)*(1+sn)*(XYZ[0][7]-XYZ[0][3]) );

						const dfloat yr = 0.125*( (1-tn)*(1-sn)*(XYZ[1][1]-XYZ[1][0]) + (1-tn)*(1+sn)*(XYZ[1][2]-XYZ[1][3]) + (1+tn)*(1-sn)*(XYZ[1][5]-XYZ[1][4]) + (1+tn)*(1+sn)*(XYZ[1][6]-XYZ[1][7]) );
						const dfloat ys = 0.125*( (1-tn)*(1-rn)*(XYZ[1][3]-XYZ[1][0]) + (1-tn)*(1+rn)*(XYZ[1][2]-XYZ[1][1]) + (1+tn)*(1-rn)*(XYZ[1][7]-XYZ[1][4]) + (1+tn)*(1+rn)*(XYZ[1][6]-XYZ[1][5]) );
						const dfloat yt = 0.125*( (1-rn)*(1-sn)*(XYZ[1][4]-XYZ[1][0]) + (1+rn)*(1-sn)*(XYZ[1][5]-XYZ[1][1]) + (1+rn)*(1+sn)*(XYZ[1][6]-XYZ[1][2]) + (1-rn)*(1+sn)*(XYZ[1][7]-XYZ[1][3]) );

						const  dfloat zr = 0.125*( (1-tn)*(1-sn)*(XYZ[2][1]-XYZ[2][0]) + (1-tn)*(1+sn)*(XYZ[2][2]-XYZ[2][3]) + (1+tn)*(1-sn)*(XYZ[2][5]-XYZ[2][4]) + (1+tn)*(1+sn)*(XYZ[2][6]-XYZ[2][7]) );
						const  dfloat zs = 0.125*( (1-tn)*(1-rn)*(XYZ[2][3]-XYZ[2][0]) + (1-tn)*(1+rn)*(XYZ[2][2]-XYZ[2][1]) + (1+tn)*(1-rn)*(XYZ[2][7]-XYZ[2][4]) + (1+tn)*(1+rn)*(XYZ[2][6]-XYZ[2][5]) );
						const  dfloat zt = 0.125*( (1-rn)*(1-sn)*(XYZ[2][4]-XYZ[2][0]) + (1+rn)*(1-sn)*(XYZ[2][5]-XYZ[2][1]) + (1+rn)*(1+sn)*(XYZ[2][6]-XYZ[2][2]) + (1-rn)*(1+sn)*(XYZ[2][7]-XYZ[2][3]) );


						//	 compute geometric factors for affine coordinate transform
						const  dfloat J = xr*(ys*zt-zs*yt) - yr*(xs*zt-zs*xt) + zr*(xs*yt-ys*xt);


						const dfloat rx =  (ys*zt - zs*yt)/J, ry = -(xs*zt - zs*xt)/J, rz =  (xs*yt - ys*xt)/J;
						const dfloat sx = -(yr*zt - zr*yt)/J, sy =  (xr*zt - zr*xt)/J, sz = -(xr*yt - yr*xt)/J;
						const dfloat tx =  (yr*zs - zr*ys)/J, ty = -(xr*zs - zr*xs)/J, tz =  (xr*ys - yr*xs)/J;

						dfloat JW = J*gjw[i]*gjw[j]*gjw[k];

						//store second order geometric factors

						const double2 G00G01 = {JW*(rx*rx + ry*ry + rz*rz), JW*(rx*sx + ry*sy + rz*sz)};
						const double2 G02G11 = {JW*(rx*tx + ry*ty + rz*tz), JW*(sx*sx + sy*sy + sz*sz) };
						const double2 G12G22 = {JW*(sx*tx + sy*ty + sz*tz), JW*(tx*tx + ty*ty + tz*tz)} ;
						/* for testing
						const double2 G00G01 ={0.0, 1.0};
						const double2 G02G11 ={0.9, 0.7};
						const double2 G12G22 ={2.1, 0.77};
						const dfloat JW = 0.2;
						*/

						//end of the magic
						// differentiate
						//	dfloat qr = 0.0f, qs = 0.0f, qt = 0.0f;

						qr.x = 0.0f;
						qs.x = 0.0f;
						qt.x = 0.0f;
						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;++n){
							qr.x += s_D[i][n]*s_tmpq[k][j][n];
							qs.x += s_D[j][n]*s_tmpq[k][n][i];
							qt.x += s_D[k][n]*s_tmpq[n][j][i];
						}

						// apply chain rule (notice the swtich of indices in i,j)
						s_qr[j][i] = G00G01.x*qr.x + G00G01.y*qs.x + G02G11.x*qt.x;
						s_qs[j][i] = G00G01.y*qr.x + G02G11.y*qs.x + G12G22.x*qt.x;
						r_qt = G02G11.x*qr.x + G12G22.x*qs.x + G12G22.y*qt.x;


						if (k%2 == 0){
							r_q[k/2].x += lambda*JW*s_tmpq[k][j][i];
						}
						else{
							r_q[(k-1)/2].y += lambda*JW*s_tmpq[k][j][i];
						}
					}
				}
			}
			barrier(localMemFence);
			for(int j=0;j<MAXY;++j;inner1){
				for(int i=0;i<MAXX;i+=2;inner0){
					if (i<p_Nq && j<p_Nq){
						dfloat lapqr = 0.0f;
						dfloat  lapqs = 0.0f;
						occaUnroll(p_Nq)
						for(int n=0;n<p_Nq;n+=2){
							lapqr += s_D[n][i]*s_qr[j][n];
							lapqs += s_D[n][i]*s_qs[n][i];
							r_q[n/2].x += s_D[k][n]*r_qt;
						}

						occaUnroll(p_Nq)
						for(int n=1;n<p_Nq;n+=2){

							lapqr += s_D[n][i]*s_qr[j][n];
							lapqs += s_D[n][i]*s_qs[n][i];
							r_q[(n-1)/2].y += s_D[k][n]*r_qt;
						}

						if (k%2 == 0){
							r_q[k/2].x += lapqr+ lapqs;

						}
						else{
							r_q[(k-1)/2].y += lapqr+ lapqs;

						}


					}
				}
			}
		}//k
=======

	      //		const dfloat r_G00 = ggeo[base+p_G00ID*p_Np].x;
	      const double2 G00G01 = ggeo[base+0*p_Np];
	      const double2 G02G11 = ggeo[base+1*p_Np];
	      const double2 G12G22 = ggeo[base+2*p_Np];
	      const double2 GwJ =    ggeo[base+3*p_Np];

	      //	const dfloat r_G01 = ggeo[base+p_G00ID*p_Np].y;


	      // differentiate
	      //	dfloat qr = 0.0f, qs = 0.0f, qt = 0.0f;
				
	      //, qt ;
	      qr = 0.0f;
	      qs = 0.0f;
	      qt = 0.0f;
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
		  qr += s_D[i][n]*s_tmpq[k][j][n];
		  qs += s_D[j][n]*s_tmpq[k][n][i];
		  qt += s_D[k][n]*s_tmpq[n][j][i];
		}
>>>>>>> 77894dfab146d06fc8f86a1f95cedd14dbd25d18

	      // apply chain rule (notice the swtich of indices in i,j)
	      s_qr[j][i] = G00G01.x*qr + G00G01.y*qs + G02G11.x*qt;
	      s_qs[j][i] = G00G01.y*qr + G02G11.y*qs + G12G22.x*qt;
	      r_qt = G02G11.x*qr + G12G22.x*qs + G12G22.y*qt;

<<<<<<< HEAD
		barrier(localMemFence);

		occaUnroll(p_Nq)
		for (int k=0; k<p_Nq; k+=1){
			for(int j=0; j<MAXY; ++j; inner1) {
				for(int i=0; i<MAXX; ++i; inner0) {
					if (i<p_Nq && j<p_Nq){
=======
	      r_q[k] += lambda*GwJ.x*s_tmpq[k][j][i];
	    }
	  }
	}
	barrier(localMemFence);
	for(int j=0;j<MAXY;++j;inner1){
	  for(int i=0;i<MAXX;i+=2;inner0){
	    if (i<p_Nq && j<p_Nq){
	      dfloat lapqr = 0.0f;
	      dfloat  lapqs = 0.0f;
	      occaUnroll(p_Nq)
		for(int n=0;n<p_Nq;++n){
		  lapqr += s_D[n][i]*s_qr[j][n];
		  lapqs += s_D[n][i]*s_qs[n][i];
		  r_q[n] += s_D[k][n]*r_qt;
		}
>>>>>>> 77894dfab146d06fc8f86a1f95cedd14dbd25d18

	      r_q[k] += lapqr+ lapqs;
	    }
	  }
	}
      }//k

    //new code
    //end of new code

    barrier(localMemFence);

<<<<<<< HEAD
						else{
							Aq[base] =r_q[(k-1)/2].y;
						}
=======
      for(int j=0; j<MAXY; ++j; inner1) {
	for(int i=0; i<MAXX; ++i; inner0) {
	  if (i<p_Nq && j<p_Nq){
	    occaUnroll(p_Nq)
>>>>>>> 77894dfab146d06fc8f86a1f95cedd14dbd25d18

	    for (int k=0; k<p_Nq; ++k){
	      int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
	      Aq[base] = r_q[k];
	    }
	  }
	}
      }//k

  }//e
}


// e1j end


// e1k
// load only one slice to shared at a time
// very slow (a lot of registers needed)


kernel void ellipticAxHex3D_e1k(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(int e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq];
		shared dfloat s_q0[p_Nq][p_Nq];
		shared dfloat s_q1[p_Nq][p_Nq];
		//we want this
//		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt, r_tmpt;
		exclusive dfloat r_qk[p_Nq];
		exclusive int emap;

		// prefetch q(i,j,:,e) to register array
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {
				emap = elementList[e];



				const int base = i + j*p_Nq + emap*p_Np;
				s_q0[j][i] = q[base + 0*p_Nq*p_Nq];
				for (int k=0; k<p_Nq; k++){


					Aq[i + j*p_Nq + emap*p_Np+ (k)*p_Nq*p_Nq] = 0.f;
					r_qk[k] = q[base +  k*p_Nq*p_Nq];

				}

				s_D[j][i] = D[j*p_Nq+i];
			}
		}

		barrier(localMemFence);

		for(int k=0; k<p_Nq; ++k) {

			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					dfloat qtk = 0.f;
					for(int n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*r_qk[n];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					const int base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

					dfloat qr = 0.f, qs = 0.f;
					if (!k%2){//use q0
						for(int n=0; n<p_Nq; ++n) {

							qr += s_D[i][n]*s_q0[j][n];
							qs += s_D[j][n]*s_q0[n][i];
						}

					}
					else {//use q1
						for(int n=0; n<p_Nq; ++n) {
							qr += s_D[i][n]*s_q1[j][n];
							qs += s_D[j][n]*s_q1[n][i];
						}
					}



					// assumes w*J built into G entries
					s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
					r_tmpt           = G02*qr + G12*qs + G22*r_qt;

//s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i]
	
					for(int n=0; n<p_Nq; ++n) {
						Aq[i + j*p_Nq + emap*p_Np+ n*p_Nq*p_Nq] += s_D[k][n]*r_tmpt;
					}
					if (!k%2){//using q0, so load q1
						Aq[i + j*p_Nq + emap*p_Np+ (k)*p_Nq*p_Nq] += GwJ*lambda*s_q0[j][i];
						if (k+1<p_Nq){
							s_q1[j][i] = q[i + j*p_Nq + emap*p_Np+ (k+1)*p_Nq*p_Nq];

						}

					}
					else
					{
						//using q1 so load q0
						//min difference
						Aq[i + j*p_Nq + emap*p_Np+ (k)*p_Nq*p_Nq] += GwJ*lambda*s_q1[j][i];
						if (k+1<p_Nq){
							s_q0[j][i] = q[i + j*p_Nq + emap*p_Np+ (k+1)*p_Nq*p_Nq];

						}
					}
				}
			}//j


			barrier(localMemFence);

			// second derivatives

			for(int j=0; j<p_Nq; ++j; inner1) {
				for(int i=0; i<p_Nq; ++i; inner0) {

					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					for(int n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}
//makes no difference
					Aq[i + j*p_Nq + emap*p_Np+ (k)*p_Nq*p_Nq] +=  Aq1 + Aq2;
				}
			}//j
		}//for k ()

		barrier(localMemFence);

		// write result out (local node storage)
		/*
		for(int j=0; j<p_Nq; ++j; inner1) {
			for(int i=0; i<p_Nq; ++i; inner0) {

				for (int k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = s_Aq[k][j][i];
				}//k
			}//i
		}//j
		*/
	}//e

} //e1c

//this is a splitting kernerl that only performs differentiation in the r direction


 kernel void ellipticAxHex3D_rDir(const int Nelements,
                                const int * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq,
                                dfloat * restrict aux
                               ){
	for(int e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
	
		shared dfloat s_D[p_Nq][p_Nq];

		// prefetch q(:,:,:,e) to shared
		cubeThreadsSliced {

		//  occaUnroll(p_Nq)
		  for (int s=k; s<p_Nq;s+=shift){
		  const int base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
			  s_q[s][j][i] = q[base];		
		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
		
	
	
			cubeThreadsSliced {
	

      for (int s=k; s<p_Nq;s+=shift){

			  const int base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(int n=0; n<p_Nq; ++n) {
			    qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }


	
			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
		
			  
		    const dfloat qqr = G00*qr + G01*qs + G02*qt;
		 
		    
		    
			  for (int n=0; n<p_Nq; n++)
			  {
        
            int base2 = n + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;
            Aq[base2]+= s_D[n][i]*qqr;        
				}

			}//cube threads
		}//for sws
}//e
															 }


		
//e1d end


