
// e1c - like e6, just no interpolation. 2d i-j "slabs".
/*
kernel void ellipticAxHex3D_e1c(const iint Nelements,
                                const iint * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	for(iint e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt, r_tmpt;
		exclusive int emap;

		// prefetch q(i,j,:,e) to register array
		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {
				emap = elementList[e];

				const iint base = i + j*p_Nq + emap*p_Np;
				for (iint k=0; k<p_Nq; k++){

					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					s_Aq[k][j][i] = 0.f;

				}

				s_D[j][i] = D[j*p_Nq+i];
			}
		}

		barrier(localMemFence);

		for(iint k=0; k<p_Nq; ++k) {

			for(iint j=0; j<p_Nq; ++j; inner1) {
				for(iint i=0; i<p_Nq; ++i; inner0) {

					dfloat qtk = 0.f;
					for(iint n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][j][i];
					}
					r_qt = qtk;
				}
			}

			barrier(localMemFence);

			// process k-slice (first r- and s-derivatives)
			for(iint j=0; j<p_Nq; ++j; inner1) {
				for(iint i=0; i<p_Nq; ++i; inner0) {

					const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

					dfloat qr = 0.f, qs = 0.f;
					for(iint n=0; n<p_Nq; ++n) {

						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into G entries
					s_tmpr[j][i] = G00*qr + G01*qs + G02*r_qt;
					s_tmps[j][i] = G01*qr + G11*qs + G12*r_qt;
					r_tmpt           = G02*qr + G12*qs + G22*r_qt;

					s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

					for(iint n=0; n<p_Nq; ++n) {
						s_Aq[n][j][i] += s_D[k][n]*r_tmpt;
					}
				}
			}


			barrier(localMemFence);

			// second derivatives

			for(iint j=0; j<p_Nq; ++j; inner1) {
				for(iint i=0; i<p_Nq; ++i; inner0) {

					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					for(iint n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[j][n];
						Aq2 += s_D[n][j]*s_tmps[n][i];
					}

					s_Aq[k][j][i] +=  Aq1 + Aq2;
				}
			}
		}//for k ()

		barrier(localMemFence);

		// write result out (local node storage)
		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {

				for (iint k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = s_Aq[k][j][i];
				}
			}
		}
	}

} //e1c







//e1c0 -> version with k as internal loop


// e1c - like e6, just no interpolation. 2d i-j "slabs".

kernel void ellipticAxHex3D_e1c0(const iint Nelements,
                                 const iint * restrict elementList,
                                 const dfloat * restrict ggeo,
                                 const dfloat * restrict D,
                                 const dfloat lambda,
                                 const dfloat * restrict q,
                                 dfloat * restrict Aq){

	for(iint e=0; e<Nelements; ++e; outer0){

		shared dfloat s_tmpr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_tmps[p_Nq][p_Nq][p_Nq];
		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_Aq[p_Nq][p_Nq][p_Nq];

		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat  r_qt[p_Nq], r_tmpt[p_Nq];

		exclusive int emap;

		// prefetch q(i,j,:,e) to register array
		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {
				emap = elementList[e];

				const iint base = i + j*p_Nq + emap*p_Np;
				for (iint k=0; k<p_Nq; k++){

					s_q[k][j][i] = q[base + k*p_Nq*p_Nq];
					s_Aq[k][j][i] = 0.f;
				}

				s_D[j][i] = D[j*p_Nq+i];

			}
		}

		barrier(localMemFence);



		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {
				for(iint k=0; k<p_Nq; ++k) {
					dfloat qtk = 0.f;
					for(iint n=0; n<p_Nq; ++n) {
						qtk += s_D[k][n]*s_q[n][j][i];
						//   qtk += s_D[j][n]*s_q[n][j][i];
					}
					r_qt[k] = qtk;
					//	s_Aq[k][j][i] =qtk;
				}
			}
		}

		barrier(localMemFence);

		// process k-slice (first r- and s-derivatives)
		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {
				for(iint k=0; k<p_Nq; ++k) {
					const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

					const dfloat G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat G02 = ggeo[base+p_G02ID*p_Np];
					const dfloat G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat G22 = ggeo[base+p_G22ID*p_Np];
					const dfloat GwJ = ggeo[base+p_GWJID*p_Np];

					dfloat qr = 0.f, qs = 0.f;
					for(iint n=0; n<p_Nq; ++n) {

						qr += s_D[i][n]*s_q[k][j][n];
						qs += s_D[j][n]*s_q[k][n][i];
					}

					// assumes w*J built into G entries
					s_tmpr[k][j][i] = G00*qr + G01*qs + G02*r_qt[k];
					s_tmps[k][j][i] = G01*qr + G11*qs + G12*r_qt[k];
					r_tmpt[k]           = G02*qr + G12*qs + G22*r_qt[k];


					s_Aq[k][j][i] += GwJ*lambda*s_q[k][j][i];

					for(iint n=0; n<p_Nq; ++n) {
						s_Aq[n][j][i] += s_D[k][n]*r_tmpt[k];
					}
				}
			}
		}


		barrier(localMemFence);

		// second derivatives

		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {
				for(iint k=0; k<p_Nq; ++k) {
					dfloat Aq1 = 0.0f, Aq2 = 0.0f;

					for(iint n=0; n<p_Nq; ++n) {
						Aq1 += s_D[n][i]*s_tmpr[k][j][n];
						Aq2 += s_D[n][j]*s_tmps[k][n][i];
					}

					s_Aq[k][j][i] +=  Aq1 + Aq2;
				}
			}
		}
		//	}//for k ()

		barrier(localMemFence);

		// write result out (local node storage)
		for(iint j=0; j<p_Nq; ++j; inner1) {
			for(iint i=0; i<p_Nq; ++i; inner0) {

				for (iint k=0; k<p_Nq; k++){
					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = s_Aq[k][j][i];
				}
			}
		}
	}

} //e1c
*/
// e1d - slab version of e0 (cross between e0 and e1)

#define sliceThickness 4
// k = 0..., p_Nq/sliceThickness
// i = 0 ... p_Nq-1, j = 0,..., p_Nq-1
#define shift ((p_Nq)/sliceThickness)

#define cubeThreadsSliced                             \
	for(iint k=0; k<shift; ++k; inner2)            \
		for(iint j=0; j<p_Nq; ++j; inner1)          \
			for(iint i=0; i<p_Nq; ++i; inner0)

kernel void ellipticAxHex3D_e1d(const iint Nelements,
                                const iint * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq,
                                dfloat * restrict grad
                               ){
	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_qr[sliceThickness+1], r_qs[sliceThickness+1], r_qt[sliceThickness+1], r_Aq[sliceThickness+1];


		// prefetch q(:,:,:,e) to shared
		cubeThreadsSliced {

		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  //  while (s<p_Nq){
		  occaUnroll(p_Nq)
		  for (int s=k; s<p_Nq;s+=shift){
		  const iint base = i + j*p_Nq + s*p_Nq*p_Nq + elementList[e]*p_Np;


			  s_q[s][j][i] = q[base];
			  //  s++;
			  //	  s+=shift;

		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
		occaUnroll(p_Nq)
		//	for (int s=k; s<p_Nq;s+=shift){
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;



			  //  while (s<(k+sliceThickness)&&(s<p_Nq)){
			  //  while (s<p_Nq){

			  const iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  const dfloat GwJ = ggeo[base+p_GWJID*p_Np];



			  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

			  for(iint n=0; n<p_Nq; ++n) {
			  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }

			  r_qr[s/shift] = qr;
			  r_qs[s/shift] = qs;
			  r_qt[s/shift] = qt;

			  r_Aq[s/shift] = GwJ*lambda*s_q[s][j][i];
			  //	  s++;
			  //	  s+=shift;


			}//while
		}

		// r term ----->
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			barrier(localMemFence);

			cubeThreadsSliced {
			  iint s = sws+k;

			  //while (s<(k+sliceThickness)&&(s<p_Nq)){
			  //  while (s<p_Nq){

			   iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  const dfloat G00 = ggeo[base+p_G00ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
   base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  grad[base]= G00*r_qr[s/shift] + G01*r_qs[s/shift] + G02*r_qt[s/shift];
			  //  s++;

			  //	  s+=shift;

			}

		}

		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  iint base;
			  for(iint n=0; n<p_Nq; ++n){
			  base = elementList[e]*p_Nggeo*p_Np + n*p_Nq*p_Nq + j*p_Nq + i;

				  tmp += s_D[n][i]*grad[base];
			  }

			  r_Aq[s/shift] += tmp;
			  //  s++;


			}
		}

		// s term ---->
		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;



			  const  dfloat G11 = ggeo[base+p_G11ID*p_Np];
			  const dfloat G01 = ggeo[base+p_G01ID*p_Np];
			  const dfloat G12 = ggeo[base+p_G12ID*p_Np];

   base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  grad[base] = G01*r_qr[s/shift] + G11*r_qs[s/shift] + G12*r_qt[s/shift];
			  //  s++;
			  //s+=sliceThickness;


			}
		}

		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  iint base;
			  for(iint n=0; n<p_Nq; ++n){
			  base = elementList[e]*p_Nggeo*p_Np + n*p_Nq*p_Nq + j*p_Nq + i;

				  tmp += s_D[n][j]*grad[base];
			  }

			  r_Aq[s/shift] += tmp;
			  //  s++;
			  //	s+=sliceThickness;


			}
		}

		// t term ---->
		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;


			  //  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  iint base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  const dfloat G22 = ggeo[base+p_G22ID*p_Np];
			  const dfloat G02 = ggeo[base+p_G02ID*p_Np];
			  const dfloat G12 = ggeo[base+p_G12ID*p_Np];
			base = elementList[e]*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  grad[base]= G02*r_qr[s/shift] + G12*r_qs[s/shift] + G22*r_qt[s/shift];
			  //	  s++;
			  //  s+=sliceThickness;


			}
		}

		barrier(localMemFence);
		occaUnroll(p_Nq)
		for (int sws=0; sws<p_Nq;sws+=shift){
			cubeThreadsSliced {
			  iint s = sws+k;

			  //	  while (s<(k+sliceThickness)&&(s<p_Nq)){

			  dfloat tmp = 0.f;
			  iint base;
			  for(iint n=0; n<p_Nq; ++n){
			  base = 	elementList[e]*p_Np + n*p_Nq*p_Nq + j*p_Nq + i;
				  tmp += s_D[n][s]*grad[base];
			  }

			  r_Aq[s/shift] += tmp;

			  base =  elementList[e]*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = r_Aq[s/shift];
			  //  if (e==0)
			  //{
			  //	printf("ind %d s =  %d, i= %d, j= %d, k=%d \n", (s+1)*(i+1)*(j+1), s, i, j, k);
			  //}
			  // printf("k= %d s= %d, shift = %d, sliceThickness = %d s over shift = %d \n",k, s, shift, sliceThickness,c);
			  //  s++;
			  //	s+=sliceThickness;


			}
		}
	}
}//e1d end
/*
//e1e optimized e1d

kernel void ellipticAxHex3D_e1e(const iint Nelements,
                                const iint * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){

	

	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_Aq[sliceThickness+1];
		exclusive iint emap, s, base;

		//r_qs[sliceThickness+1];
		//	r_qt[sliceThickness+1],
		//	r_Aq[sliceThickness+1];

		shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qt[p_Nq][p_Nq][p_Nq];


		// prefetch q(:,:,:,e) to shared
		//if N=8, sliceThickness =2, this part costs 21 regs
		cubeThreadsSliced {
		  s = k;
emap = elementList[e];


		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){
		  base = i + j*p_Nq + s*p_Nq*p_Nq + emap*p_Np;


			  s_q[s][j][i] = q[base];
			  //  s++;
			  s+=shift;

		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
//this part costs 60 registers !!!
		cubeThreadsSliced {

		  s =k;
dfloat  GwJ, G00, G01, G02, G11, G12, G22;
 dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  //  while (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){
		    iint base = emap*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

			  // assumes w*J built into G entries
			  GwJ = ggeo[base+p_GWJID*p_Np];
			 G00 = ggeo[base+p_G00ID*p_Np];
			  G01 = ggeo[base+p_G01ID*p_Np];
			 G02 = ggeo[base+p_G02ID*p_Np];
			  G11 = ggeo[base+p_G11ID*p_Np];

			   G12 = ggeo[base+p_G12ID*p_Np];
			  G22 = ggeo[base+p_G22ID*p_Np];



			  qr = 0.f, qs = 0.f, qt = 0.f;

			  for(iint n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }

			  s_qr[s][j][i] = G00*qr + G01*qs + G02*qt;
			  s_qs[s][j][i] = G01*qr + G11*qs + G12*qt;
			  s_qt[s][j][i] = G02*qr + G12*qs + G22*qt;


			  r_Aq[s/shift]= GwJ*lambda*s_q[s][j][i];
			 	  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = qr;
			  
			  Aq[base] = qt;
			  s+=shift;


		  }//while
		}

		// r term ----->
		barrier(localMemFence);
// 8 registers only
		cubeThreadsSliced {
		 s=k;
 dfloat tmp = 0.f;

		  //while (s<(k+sliceThickness)&&(s<p_Nq)){
		  while (s<p_Nq){

		  tmp = 0.f;
		  occaUnroll(p_Nq)
			  for(iint m=0; m<p_Nq; ++m) {
				  tmp += s_D[m][i]*s_qr[s][j][m];
				  tmp += s_D[m][j]*s_qs[s][m][i];
				  tmp += s_D[m][s]*s_qt[m][j][i];
			  }
			  //	s_Aq[s][j][i]+=tmp;
			  tmp+= r_Aq[s/shift];
			 // iint emap = elementList[e];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = tmp;
			  s+=shift;
		  }
		}
	}
}//e1e end



kernel void ellipticAxHex3D_e1f(const iint Nelements,
                                const iint * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){



	for(iint e=0; e<Nelements; ++e; outer0) {

		shared dfloat s_q[p_Nq][p_Nq][p_Nq];
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_Aq[sliceThickness+1];
		exclusive iint emap, s, base;

		//r_qs[sliceThickness+1];
		//	r_qt[sliceThickness+1],
		//	r_Aq[sliceThickness+1];

		shared dfloat s_qs[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qr[p_Nq][p_Nq][p_Nq];
		shared dfloat s_qt[p_Nq][p_Nq][p_Nq];


		// prefetch q(:,:,:,e) to shared
		//if N=8, sliceThickness =2, this part costs 21 regs
		cubeThreadsSliced {

		  emap = elementList[e];


		  //  while  (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){
		  base = i + j*p_Nq + s*p_Nq*p_Nq + emap*p_Np;


		  s_q[s][j][i] = q[base];
			  //  s++;


		  }
		  if(k==0) // fetch D to shared
		  s_D[j][i] = D[j*p_Nq+i];

		}


		barrier(localMemFence);
		//this part costs 60 registers !!!
		cubeThreadsSliced {


		  dfloat  GwJ, G00, G01, G02, G11, G12, G22;
		  dfloat qr = 0.f, qs = 0.f, qt = 0.f;

		  //  while (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){
		  iint base = emap*p_Nggeo*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;

		  // assumes w*J built into G entries
		  GwJ = ggeo[base+p_GWJID*p_Np];
			  G00 = ggeo[base+p_G00ID*p_Np];
			  G01 = ggeo[base+p_G01ID*p_Np];
			  G02 = ggeo[base+p_G02ID*p_Np];
			  G11 = ggeo[base+p_G11ID*p_Np];

			  G12 = ggeo[base+p_G12ID*p_Np];
			  G22 = ggeo[base+p_G22ID*p_Np];



			  qr = 0.f, qs = 0.f, qt = 0.f;

			  for(iint n=0; n<p_Nq; ++n) {
				  qr += s_D[i][n]*s_q[s][j][n];
				  qs += s_D[j][n]*s_q[s][n][i];
				  qt += s_D[s][n]*s_q[n][j][i];
			  }

			  s_qr[s][j][i] = G00*qr + G01*qs + G02*qt;
			  s_qs[s][j][i] = G01*qr + G11*qs + G12*qt;
			  s_qt[s][j][i] = G02*qr + G12*qs + G22*qt;


			  r_Aq[s/shift]= GwJ*lambda*s_q[s][j][i];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			 



		  }//while
		}

		// r term ----->
		barrier(localMemFence);
		// 8 registers only
		cubeThreadsSliced {

		  dfloat tmp = 0.f;

		  //while (s<(k+sliceThickness)&&(s<p_Nq)){
		  for (s=k; s<p_Nq;s+=shift){

		  tmp = 0.f;
		  occaUnroll(p_Nq)
			  for(iint m=0; m<p_Nq; ++m) {
				  tmp += s_D[m][i]*s_qr[s][j][m];
				  tmp += s_D[m][j]*s_qs[s][m][i];
				  tmp += s_D[m][s]*s_qt[m][j][i];
			  }
			  //	s_Aq[s][j][i]+=tmp;
			  tmp+= r_Aq[s/shift];
			  // iint emap = elementList[e];
			  base = emap*p_Np + s*p_Nq*p_Nq + j*p_Nq + i;
			  Aq[base] = tmp;

		  }
		}
	}
}//e1f end

*/
//e1g = sliced e1c

kernel void ellipticAxHex3D_e1g(const iint Nelements,
                                const iint * restrict elementList,
                                const dfloat * restrict ggeo,
                                const dfloat * restrict D,
                                const dfloat lambda,
                                const dfloat * restrict q,
                                dfloat * restrict Aq){
	for(iint e=0; e<Nelements; ++e; outer0){
		shared dfloat s_D[p_Nq][p_Nq];

		exclusive dfloat r_q[p_Nq];

		shared dfloat s_qr[p_Nq][p_Nq];
		shared dfloat s_qs[p_Nq][p_Nq];

		shared dfloat s_tmpq[p_Nq][p_Nq][p_Nq];

		exclusive iint emap;
		exclusive dfloat r_qt;

		// prefetch D and part of q
		for(int b=0;b<p_Nq;++b;inner1){
			for(int a=0;a<p_Nq;++a;inner0){

				emap = elementList[e];


				s_D[b][a] = D[b*p_Nq+a];
				//s_D[j][i] = D[j*p_Nq+i];

				occaUnroll(p_Nq)
				for(int c=0;c<p_Nq;++c){
					s_tmpq[c][b][a] = q[emap*p_Np+c*p_Nq*p_Nq+b*p_Nq+a];
					r_q[c] = 0.0f;
				}

			}
		}

		barrier(localMemFence);


		// scan through k slices

		occaUnroll(p_Nq)


		for(int k=0;k<p_Nq;++k){

			barrier(localMemFence);

			for(int j=0;j<p_Nq;++j;inner1){
				for(int i=0;i<p_Nq;++i;inner0){

					const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
					const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
					const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
					const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
					const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];

					const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
					const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
					const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
					/*
												qr += s_D[i][n]*s_q[k][j][n];
											qs += s_D[j][n]*s_q[k][n][i];
											s_D[k][n]*s_q[n][j][i];
					*/
					// differentiate
					dfloat qr = 0, qs = 0, qt = 0;
					occaUnroll(p_Nq)
					for(int n=0;n<p_Nq;++n){
						qr += s_D[i][n]*s_tmpq[k][j][n];
						qs += s_D[j][n]*s_tmpq[k][n][i];
						qt += s_D[k][n]*s_tmpq[n][j][i];
					}

					// apply chain rule (notice the swtich of indices in i,j)
					s_qr[j][i] = r_G00*qr + r_G01*qs + r_G02*qt;
					s_qs[j][i] = r_G01*qr + r_G11*qs + r_G12*qt;
					r_qt = r_G02*qr + r_G12*qs + r_G22*qt;

					r_q[k] += lambda*r_GwJ*s_tmpq[k][j][i];


					//occaUnroll()
					//for(iint n=0; n<p_Nq; ++n) {
					//	s_Aq[n][j][i] += s_D[k][n]*r_tmpt;

					//r_q[n] += s_D[k][n]*r_qt;
					//		}

				}
			}

			barrier(localMemFence);

			for(int j=0;j<p_Nq;++j;inner1){
				for(int i=0;i<p_Nq;++i;inner0){
					dfloat lapqr = 0, lapqs = 0;
					/*
							  tmp += s_D[m][i]*s_qr[s][j][m];
									  tmp += s_D[m][j]*s_qs[s][m][i];
									  tmp += s_D[m][s]*s_qt[m][j][i];
					*/ 
					//    int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					//		 Aq[base]= r_q[k];
					occaUnroll(p_Nq)
					for(int n=0;n<p_Nq;++n){
						lapqr += s_D[n][i]*s_qr[j][n];
						lapqs += s_D[n][j]*s_qs[n][i];
						r_q[n] += s_D[k][n]*r_qt;

						//		 base = emap*p_Np +n*p_Nq*p_Nq+ j*p_Nq + i;
						//	 Aq[base] += s_D[k][n]*r_qt;

					}

					r_q[k] += lapqr + lapqs;

					// base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					//Aq[base] += (lapqr + lapqs);
				}
			}
		}//k
		for (iint k=0; k<p_Nq; k++){
			for(iint j=0; j<p_Nq; ++j; inner1) {
				for(iint i=0; i<p_Nq; ++i; inner0) {


					int base = emap*p_Np +k*p_Nq*p_Nq+ j*p_Nq + i;
					Aq[base] = r_q[k];
				}
			}
		}

	}
} //e1q





