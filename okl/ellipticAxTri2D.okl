 
kernel void ellipticAxTri2D(const int Nelements,
        const dfloat * restrict ggeo,
        const dfloat * restrict SrrT,
        const dfloat * restrict SrsT,
        const dfloat * restrict SsrT,
        const dfloat * restrict SssT,
        const dfloat * restrict MM,
        const dfloat lambda,
        const dfloat  * restrict q,
        dfloat  * restrict Aq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          //prefetch q
          const iint id = n + e*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    barrier(localMemFence);


    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          const iint es = e-eo;
          const iint gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          occaUnroll(p_Np)
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }


          const iint id = n + e*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}