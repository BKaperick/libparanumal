 
kernel void ellipticAxTri2D(const int Nelements,
        const dfloat * restrict ggeo,
        const dfloat * restrict SrrT,
        const dfloat * restrict SrsT,
        const dfloat * restrict SsrT,
        const dfloat * restrict SssT,
        const dfloat * restrict MM,
        const dfloat lambda,
        const dfloat  * restrict q,
        dfloat  * restrict Aq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          //prefetch q
          const int id = n + e*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    barrier(localMemFence);


    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          occaUnroll(p_Np)
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }


          const int id = n + e*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}
//Analysis:
// We perform (per thread block)
// Nelements per block x Np x (Np x 5+10) flops
// We load: (Nelements per block) x Np to shared
// We read (Nelements per block) x Np xNp x 5 times from shared
// We request: (Nelements per block) x Np x(1+4+Npx5 variables
// We store (Nelements per block) x Np x (1) variables


kernel void ellipticPartialAxTri2D(const int Nelements,
        const int   * restrict elementList,
        const dfloat * restrict ggeo,
        const dfloat * restrict SrrT,
        const dfloat * restrict SrsT,
        const dfloat * restrict SsrT,
        const dfloat * restrict SssT,
        const dfloat * restrict MM,
        const dfloat lambda,
        const dfloat  * restrict q,
        dfloat  * restrict Aq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          //prefetch q
          const int element = elementList[e];
          const int id = n + element*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    barrier(localMemFence);


    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if (e<Nelements) {
          const int es = e-eo;
          const int gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          occaUnroll(p_Np)
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }

          const int element = elementList[e];
          const int id = n + element*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}
