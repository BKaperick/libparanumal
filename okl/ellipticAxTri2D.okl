 
@kernel void ellipticAxTri2D(const dlong Nelements,
        @restrict const  dfloat *  ggeo,
        @restrict const  dfloat *  SrrT,
        @restrict const  dfloat *  SrsT,
        @restrict const  dfloat *  SsrT,
        @restrict const  dfloat *  SssT,
        @restrict const  dfloat *  MM,
        const dfloat lambda,
        @restrict const  dfloat  *  q,
        @restrict dfloat  *  Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const dlong id = n + e*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    @barrier("local");


    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const dlong es = e-eo;
          const dlong gid = e*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }


          const dlong id = n + e*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}
//Analysis:
// We perform (per thread block)
// Nelements per block x Np x (Np x 5+10) flops
// We load: (Nelements per block) x Np to @shared
// We read (Nelements per block) x Np xNp x 5 times from @shared
// We request: (Nelements per block) x Np x(1+4+Npx5 variables
// We store (Nelements per block) x Np x (1) variables


@kernel void ellipticPartialAxTri2D(const dlong Nelements,
        @restrict const  dlong   *  elementList,
        @restrict const  dfloat *  ggeo,
        @restrict const  dfloat *  SrrT,
        @restrict const  dfloat *  SrsT,
        @restrict const  dfloat *  SsrT,
        @restrict const  dfloat *  SssT,
        @restrict const  dfloat *  MM,
        const dfloat lambda,
        @restrict const  dfloat  *  q,
        @restrict dfloat  *  Aq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){

    @shared dfloat s_q[p_NblockV][p_Np];

    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          //prefetch q
          const dlong element = elementList[e];
          const dlong id = n + element*p_Np;
          s_q[e-eo][n] = q[id];
        }
      }
    }

    @barrier("local");


    for(dlong e=eo;e<eo+p_NblockV;++e;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        if (e<Nelements) {
          const dlong es = e-eo;
          const dlong element = elementList[e];
          const dlong gid = element*p_Nggeo;

          const dfloat Grr = ggeo[gid + p_G00ID];
          const dfloat Grs = ggeo[gid + p_G01ID];
          const dfloat Gss = ggeo[gid + p_G11ID];
          const dfloat J   = ggeo[gid + p_GWJID];

          dfloat qrr = 0.;
          dfloat qrs = 0.;
          dfloat qsr = 0.;
          dfloat qss = 0.;
          dfloat qM = 0.;

          #pragma unroll p_Np
            for (int k=0;k<p_Np;k++) {
              qrr += SrrT[n+k*p_Np]*s_q[es][k];
              qrs += SrsT[n+k*p_Np]*s_q[es][k];
              qsr += SsrT[n+k*p_Np]*s_q[es][k];
              qss += SssT[n+k*p_Np]*s_q[es][k];
              qM  += MM[n+k*p_Np]*s_q[es][k];
            }
            
          const dlong id = n + element*p_Np;

          Aq[id] = Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
        }
      }
    }
  }
}
