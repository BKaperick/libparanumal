

@kernel void boltzmannLSIMEXImplicitSolve3D(const int Nelements,
					       @restrict const  int *  elementIds,
					       const dfloat dt,	
					       const dfloat akk,
					       @restrict const  dfloat  *  cubInterpT,
					       @restrict const  dfloat  *  cubProjectT,
					       @restrict const  dfloat4 *  qex,
					             @restrict dfloat4 *  qim){

for(int e=0;e<Nelements;++e;@outer(0)){
	for(int n=0;n<p_Np;++n;@inner(0)){

	const int element = elementIds[e];
    const int base = 3*(n + element*p_Np);

	dfloat N5=0.f, N6= 0.f,  N7=0.f, N8=0.f, N9=0.f, N10=0.f;

	// Read explicit part 
	dfloat4 qexa = qex[base+0], qexb = qex[base+1], qexc = qex[base+2];
	//
	dfloat qex1 = qexa.x;
	dfloat qex2 = qexa.y;
	dfloat qex3 = qexa.z;
	dfloat qex4 = qexa.w;
    //
	dfloat qex5 = qexb.x;
	dfloat qex6 = qexb.y; 
	dfloat qex7 = qexb.z;
	dfloat qex8 = qexb.w;
    //
	dfloat qex9  = qexc.x;
	dfloat qex10 = qexc.y; 
	 
	// First iteration, Qim = Qex; 
	dfloat qim5  = qex5;
	dfloat qim6  = qex6; 
	dfloat qim7  = qex7;
	dfloat qim8  = qex8; 
	dfloat qim9  = qex9;
	dfloat qim10 = qex10;

    // hold inverse density
    dfloat  iqex1 = 1.f/qex1;

     // BGK relaxation approximation to the Boltzmann collision operator
    dfloat N5c  = -(qex2*qex3*iqex1);
    dfloat N6c  = -(qex2*qex4*iqex1);
    dfloat N7c  = -(qex3*qex4*iqex1);
    dfloat N8c  = -(p_invsqrt2*qex2*qex2*iqex1);
    dfloat N9c  = -(p_invsqrt2*qex3*qex3*iqex1);
    dfloat N10c = -(p_invsqrt2*qex4*qex4*iqex1);
    //         
      if(akk>0){ // No need to solve, just update
		dfloat cc  = akk * dt * p_tauInv;
		dfloat icc = 1.0f/(cc+1.0f); 
		//akk*dt*N(Y)
		N5  = -cc*( qim5  + N5c);
		N6  = -cc*( qim6  + N6c);
		N7  = -cc*( qim7  + N7c);
		N8  = -cc*( qim8  + N8c);
		N9  = -cc*( qim9  + N9c);
		N10 = -cc*( qim10 + N10c);
        // z0 = y + akk*dt*N(Y);
		qim5  = qex5  +  N5 ;
		qim6  = qex6  +  N6 ;
    qim7  = qex7  +  N7 ;
		qim8  = qex8  +  N8 ;
    qim9  = qex9  +  N9 ;
		qim10 = qex10 +  N10 ;
        //akk*dt*N(Y)
		N5  = -cc*( qim5  + N5c);
		N6  = -cc*( qim6  + N6c);
		N7  = -cc*( qim7  + N7c);
		N8  = -cc*( qim8  + N8c);
		N9  = -cc*( qim9  + N9c);
		N10 = -cc*( qim10 + N10c);

		//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
	 	qim5  += (qex5 - qim5 + N5)*icc;
		qim6  += (qex6 - qim6 + N6)*icc;
		qim7  += (qex7 - qim7 + N7)*icc;
		qim8  += (qex8 - qim8 + N8)*icc;
		qim9  += (qex9 - qim9 + N9)*icc;
		qim10 += (qex10- qim10+ N10)*icc;

	}

	N5  = -p_tauInv*( qim5  + N5c );
	N6  = -p_tauInv*( qim6  + N6c );
	N7  = -p_tauInv*( qim7  + N7c );
	N8  = -p_tauInv*( qim8  + N8c );
	N9  = -p_tauInv*( qim9  + N9c );
	N10 = -p_tauInv*( qim10 + N10c );

	dfloat4 tmp;


	tmp.x = 0.f;
	tmp.y = 0.f;
	tmp.z = 0.f;
	tmp.w = 0.f;
	qim[base+0] = tmp;

	tmp.x = N5;
	tmp.y = N6;
	tmp.z = N7;
	tmp.w = N8;
	qim[base+1] = tmp;

	tmp.x = N9 ;
	tmp.y = N10;
	tmp.z = 0.f;
	tmp.w = 0.f;
	qim[base+2] = tmp;

	}
}
  

}




@kernel void boltzmannLSIMEXImplicitSolveCub3D(const int Nelements,
						  @restrict const  int *  elementIds,
						  const dfloat dt, 
						  const dfloat akk,
						  @restrict const  dfloat *  cubInterpT,
						  @restrict const  dfloat *  cubProjectT,
						  @restrict const  dfloat4 *  qex,
						        @restrict dfloat4 *  qim){ 

  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

     // @shared memory for q at nodes
    @shared dfloat s_q[p_NblockV][10][p_Np];

    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    @shared dfloat s_cubN5[p_NblockV][p_cubNp];
    @shared dfloat s_cubN6[p_NblockV][p_cubNp];
    @shared dfloat s_cubN7[p_NblockV][p_cubNp];
    @shared dfloat s_cubN8[p_NblockV][p_cubNp];
    @shared dfloat s_cubN9[p_NblockV][p_cubNp];
    @shared dfloat s_cubN10[p_NblockV][p_cubNp];

    @exclusive int element;
    //
    @exclusive dfloat N5c, N6c, N7c, N8c, N9c, N10c;
    //
    @exclusive dfloat qim5 =0.f, qim6 = 0.f, qim7=0.f ; 
    @exclusive dfloat qim8 =0.f, qim9 = 0.f, qim10=0.f; 

    @exclusive dfloat qex5 =0.f, qex6 = 0.f, qex7=0.f ; 
    @exclusive dfloat qex8 =0.f, qex9 = 0.f, qex10=0.f; 

    // prefetch q to @shared
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){    
	
        int e = eo+es; // element in block
        if(e<Nelements){
	  
	  element = elementIds[e];
	  if(n<p_Np){
	    const int id = 3*(element*p_Np+n);
	    dfloat4 qan = qex[id+0], qbn = qex[id+1], qcn =  qex[id+2] ;    
	    s_q[es][0][n] = qan.x;
	    s_q[es][1][n] = qan.y;
	    s_q[es][2][n] = qan.z;
	    s_q[es][3][n] = qan.w;
	    //
	    s_q[es][4][n] = qbn.x;
	    s_q[es][5][n] = qbn.y;
	    s_q[es][6][n] = qbn.z;
	    s_q[es][7][n] = qbn.w;
	    //
	    s_q[es][8][n] = qcn.x;
	    s_q[es][9][n] = qcn.y;
	    } 
	  
	}
      }
    }
    
    // make sure all node data is loaded into @shared
    @barrier("local");

    // interpolate q to cubature
    for(int es=0;es<p_NblockV;++es;@inner(1)){
      for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){

		int e = eo+es; // element in block
		if(e<Nelements){

			if(n<p_cubNp){
				dfloat qe1 = 0.f, qe2 = 0.f, qe3 = 0.f, qe4 = 0.f, qe5  = 0.f;
	            dfloat qe6 = 0.f, qe7 = 0.f, qe8 = 0.f, qe9 = 0.f, qe10 = 0.f;
				
				#pragma unroll p_Np
				for(int m=0;m<p_Np;++m){

				const dfloat Icn  = cubInterpT[m*p_cubNp+n];
				qe1  += Icn*s_q[es][0][m];
				qe2  += Icn*s_q[es][1][m];
				qe3  += Icn*s_q[es][2][m];
				qe4  += Icn*s_q[es][3][m];
				qe5  += Icn*s_q[es][4][m];
				qe6  += Icn*s_q[es][5][m];
				qe7  += Icn*s_q[es][6][m];
				qe8  += Icn*s_q[es][7][m];
				qe9  += Icn*s_q[es][8][m];
				qe10 += Icn*s_q[es][9][m];
	      }
        
       
    	dfloat  iqe1 = 1.f/qe1;
		// BGK relaxation approximation to the Boltzmann collision operator
		N5c  = -(qe2*qe3*iqe1);
		N6c  = -(qe2*qe4*iqe1);
		N7c  = -(qe3*qe4*iqe1);
		N8c  = -(p_invsqrt2*qe2*qe2*iqe1);
		N9c  = -(p_invsqrt2*qe3*qe3*iqe1);
		N10c = -(p_invsqrt2*qe4*qe4*iqe1);
		//
		qex5  = qe5;
		qex6  = qe6;
		qex7  = qe7;
		qex8  = qe8;
		qex9  = qe9;
		qex10 = qe10;

		qim5  = qe5;
		qim6  = qe6;
		qim7  = qe7;
		qim8  = qe8;
		qim9  = qe9;
		qim10 = qe10;

	  }
	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    
      // partial projection to nodes from cubature-sub-group
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
	  int e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_cubNp){
			if(akk>0){ 	
				dfloat cc  = akk * dt * p_tauInv;
				dfloat icc = 1.0f/(cc+1.0f); 
				//akk*dt*N(Y)
				dfloat N5  = -cc*( qim5  + N5c);
				dfloat N6  = -cc*( qim6  + N6c);
				dfloat N7  = -cc*( qim7  + N7c);
				dfloat N8  = -cc*( qim8  + N8c);
				dfloat N9  = -cc*( qim9  + N9c);
				dfloat N10 = -cc*( qim10 + N10c);
				// z0 = y + akk*dt*N(Y);
				qim5  = qex5  +  N5 ;
				qim6  = qex6  +  N6 ;
				qim7  = qex7  +  N7 ;
				qim8  = qex8  +  N8 ;
				qim9  = qex9  +  N9 ;
				qim10 = qex10 +  N10 ;
				//akk*dt*N(Y)
				N5  = -cc*( qim5  + N5c);
				N6  = -cc*( qim6  + N6c);
				N7  = -cc*( qim7  + N7c);
				N8  = -cc*( qim8  + N8c);
				N9  = -cc*( qim9  + N9c);
				N10 = -cc*( qim10 + N10c);

				//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
				qim5  += (qex5 - qim5 + N5)*icc;
				qim6  += (qex6 - qim6 + N6)*icc;
				qim7  += (qex7 - qim7 + N7)*icc;
				qim8  += (qex8 - qim8 + N8)*icc;
				qim9  += (qex9 - qim9 + N9)*icc;
				qim10 += (qex10- qim10+ N10)*icc;
			}
		// BGK relaxation approximation to the Boltzmann collision operator
		s_cubN5[es][n]  = -p_tauInv*(qim5 + N5c);
		s_cubN6[es][n]  = -p_tauInv*(qim6 + N6c);
		s_cubN7[es][n]  = -p_tauInv*(qim7 + N7c);
		s_cubN8[es][n]  = -p_tauInv*(qim8 + N8c);
		s_cubN9[es][n]  = -p_tauInv*(qim9 + N9c);
		s_cubN10[es][n] = -p_tauInv*(qim10+ N10c);
	    }
	  }
	}
      }
      
      // make sure all cubature node data is loaded into @shared
    @barrier("local");
      
      // partial projection to nodes from cubature-sub-group
      for(int es=0;es<p_NblockV;++es;@inner(1)){
	for(int n=0;n<p_maxNodesVolume;++n;@inner(0)){
	  int e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_Np){
	    // use temporaries for part sums for N4,N5,N6 because of @exclusives
	    dfloat N5 = 0.f, N6 = 0.f, N7 = 0.f, N8 = 0.f, N9 = 0.f, N10 = 0.f;
	    for(int i=0;i<p_cubNp;++i){
	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
	      N5  += Pnc*s_cubN5[es][i];
	      N6  += Pnc*s_cubN6[es][i];
	      N7  += Pnc*s_cubN7[es][i];
	      N8  += Pnc*s_cubN8[es][i];
	      N9  += Pnc*s_cubN9[es][i];
	      N10 += Pnc*s_cubN10[es][i];
	    }

	     const int base = 3*(element*p_Np+n);
	      	      
	  dfloat4 tmp;

		tmp.x = 0.f;
		tmp.y = 0.f;
		tmp.z = 0.f;
		tmp.w = 0.f;
		qim[base+0] = tmp;

		tmp.x = N5;
		tmp.y = N6;
		tmp.z = N7;
		tmp.w = N8;
		qim[base+1] = tmp;

		tmp.x = N9 ;
		tmp.y = N10;
		tmp.z = 0.f;
		tmp.w = 0.f;
		qim[base+2] = tmp;
	      
	    }
	  }
	}
      }
  }
}

