#define RXID 0  
#define RYID 1  
#define RZID 2  
#define SXID 3
#define SYID 4
#define SZID 5
#define TXID 6
#define TYID 7
#define TZID 8

kernel void boltzmannVolume3D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    const dfloat *  restrict vgeo,
				    const dfloat *  restrict DrT,
				    const dfloat *  restrict DsT,
				    const dfloat *  restrict DtT,
				    const dfloat4 * restrict q,
				          dfloat4 * restrict rhsq){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][10][p_Np];
    exclusive iint element;

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	iint e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const iint id = element*p_Np+n;
	  dfloat4 qan = q[2*id];
	  dfloat4 qbn = q[2*id+1];
	  dfloat4 qcn = q[2*id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[e*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[e*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[e*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[e*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[e*p_Nvgeo + TZID];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr = 0.f, dq2dr = 0.f, dq3dr = 0.f, dq4dr = 0.f, dq5dr  = 0.f;
	  dfloat dq6dr = 0.f, dq7dr = 0.f, dq8dr = 0.f, dq9dr = 0.f, dq10dr = 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds  = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds = 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt= 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt = 0.f;
	 

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  

	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy + dq4dz);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx + dq5dy + dq6dz);	
	  dfloat rhsq3 = -p_sqrtRT*(dq5dx + dq1dy + p_sqrt2*dq9dy + dq7dz);	
	  dfloat rhsq4 = -p_sqrtRT*(dq6dx + dq7dy + dq1dz + p_sqrt2*dq10dz);

	  dfloat rhsq5 = -p_sqrtRT*(dq3dx + dq2dy);	
	  dfloat rhsq6 = -p_sqrtRT*(dq4dx + dq2dz);
	  dfloat rhsq7 = -p_sqrtRT*(dq4dy + dq3dz);
	 //
      dfloat rhsq8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
	  dfloat rhsq9  = -p_sqrtRT*(p_sqrt2*dq3dy);
	  dfloat rhsq10 = -p_sqrtRT*(p_sqrt2*dq4dz);


	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq5  -= p_tauInv*(s_q[es][4][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq6  -= p_tauInv*(s_q[es][5][n] - (s_q[es][1][n]*s_q[es][3][n]/s_q[es][0][n]));
	  rhsq7  -= p_tauInv*(s_q[es][6][n] - (s_q[es][2][n]*s_q[es][3][n]/s_q[es][0][n]));
	  rhsq8  -= p_tauInv*(s_q[es][7][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  rhsq9  -= p_tauInv*(s_q[es][8][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq10 -= p_tauInv*(s_q[es][9][n] - p_invsqrt2*(s_q[es][3][n]*s_q[es][3][n]/s_q[es][0][n]));

	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q3bar;
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	  const int id = 2*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id +0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

      tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}



