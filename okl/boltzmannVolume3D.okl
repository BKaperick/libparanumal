#define RXID 0  
#define RYID 1  
#define RZID 2  
#define SXID 3
#define SYID 4
#define SZID 5
#define TXID 6
#define TYID 7
#define TZID 8
//
#define QXID1  0  
#define QXID2  1  
#define QXID3  2
#define QXID4  3  
#define QXID5  4  
#define QXID6  5  
#define QXID8  6 
//
#define QYID1  7  
#define QYID2  8  
#define QYID3  9
#define QYID4  10  
#define QYID5  11  
#define QYID7  12  
#define QYID9  13 
//
#define QZID1  14  
#define QZID2  15  
#define QZID3  16
#define QZID4  17  
#define QZID6  18  
#define QZID7  19  
#define QZID10 20   


@kernel void boltzmannVolume3D(const int Nelements,
				    @restrict const  int *  elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    @restrict const  dfloat *   vgeo,
				    @restrict const  dfloat *   DrT,
				    @restrict const  dfloat *   DsT,
				    @restrict const  dfloat *   DtT,
				    @restrict const  dfloat4 *  q,
				          @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }

   // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  

	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy + dq4dz);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx + dq5dy + dq6dz);	
	  dfloat rhsq3 = -p_sqrtRT*(dq5dx + dq1dy + p_sqrt2*dq9dy + dq7dz);	
	  dfloat rhsq4 = -p_sqrtRT*(dq6dx + dq7dy + dq1dz + p_sqrt2*dq10dz);

	  dfloat rhsq5 = -p_sqrtRT*(dq3dx + dq2dy);	
	  dfloat rhsq6 = -p_sqrtRT*(dq4dx + dq2dz);
	  dfloat rhsq7 = -p_sqrtRT*(dq4dy + dq3dz);
	 //
      dfloat rhsq8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
	  dfloat rhsq9  = -p_sqrtRT*(p_sqrt2*dq3dy);
	  dfloat rhsq10 = -p_sqrtRT*(p_sqrt2*dq4dz);


	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq5  -= p_tauInv*(s_q[es][4][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq6  -= p_tauInv*(s_q[es][5][n] - (s_q[es][1][n]*s_q[es][3][n]/s_q[es][0][n]));
	  rhsq7  -= p_tauInv*(s_q[es][6][n] - (s_q[es][2][n]*s_q[es][3][n]/s_q[es][0][n]));
	  rhsq8  -= p_tauInv*(s_q[es][7][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  rhsq9  -= p_tauInv*(s_q[es][8][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq10 -= p_tauInv*(s_q[es][9][n] - p_invsqrt2*(s_q[es][3][n]*s_q[es][3][n]/s_q[es][0][n]));

	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q4bar;
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	  const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

      tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}



@kernel void boltzmannSAVolume3D(const int Nelements,
				    @restrict const  int *  elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    @restrict const  dfloat *   vgeo,
				    @restrict const  dfloat *   DrT,
				    @restrict const  dfloat *   DsT,
				    @restrict const  dfloat *   DtT,
				    @restrict const  dfloat4 *  q,
				          @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  

	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy + dq4dz);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx + dq5dy + dq6dz);	
	  dfloat rhsq3 = -p_sqrtRT*(dq5dx + dq1dy + p_sqrt2*dq9dy + dq7dz);	
	  dfloat rhsq4 = -p_sqrtRT*(dq6dx + dq7dy + dq1dz + p_sqrt2*dq10dz);

	  dfloat rhsq5 = -p_sqrtRT*(dq3dx + dq2dy);	
	  dfloat rhsq6 = -p_sqrtRT*(dq4dx + dq2dz);
	  dfloat rhsq7 = -p_sqrtRT*(dq4dy + dq3dz);
	 //
      dfloat rhsq8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
	  dfloat rhsq9  = -p_sqrtRT*(p_sqrt2*dq3dy);
	  dfloat rhsq10 = -p_sqrtRT*(p_sqrt2*dq4dz);


	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq5  += p_tauInv*(s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]);
	  rhsq6  += p_tauInv*(s_q[es][1][n]*s_q[es][3][n]/s_q[es][0][n]);
	  rhsq7  += p_tauInv*(s_q[es][2][n]*s_q[es][3][n]/s_q[es][0][n]);
	  rhsq8  += p_tauInv*p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]);
	  rhsq9  += p_tauInv*p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]);
	  rhsq10 += p_tauInv*p_invsqrt2*(s_q[es][3][n]*s_q[es][3][n]/s_q[es][0][n]);

	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q3bar;
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	  const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

      tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}




@kernel void boltzmannVolumeCub3D(const int Nelements,
				    @restrict const  int *  elementIds,
				    const dfloat ramp,
				    const dfloat drampdt,
				    @restrict const  dfloat *   vgeo,
				    @restrict const  dfloat *   DrT,
				    @restrict const  dfloat *   DsT,
				    @restrict const  dfloat *   DtT,
				    @restrict const  dfloat4 *  q,
				          @restrict dfloat4 *  rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }

    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	  #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  

	  // transport operator
	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy + dq4dz);
	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx + dq5dy + dq6dz);	
	  dfloat rhsq3 = -p_sqrtRT*(dq5dx + dq1dy + p_sqrt2*dq9dy + dq7dz);	
	  dfloat rhsq4 = -p_sqrtRT*(dq6dx + dq7dy + dq1dz + p_sqrt2*dq10dz);

	  dfloat rhsq5 = -p_sqrtRT*(dq3dx + dq2dy);	
	  dfloat rhsq6 = -p_sqrtRT*(dq4dx + dq2dz);
	  dfloat rhsq7 = -p_sqrtRT*(dq4dy + dq3dz);
	 //
      dfloat rhsq8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
	  dfloat rhsq9  = -p_sqrtRT*(p_sqrt2*dq3dy);
	  dfloat rhsq10 = -p_sqrtRT*(p_sqrt2*dq4dz);

	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q3bar;
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	  const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

      tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}



@kernel void boltzmannPmlVolume3D(const int Nelements,
				      @restrict const  int *  elementIds,
				      const dfloat ramp,
				      const dfloat drampdt,
				      @restrict const  dfloat *  vgeo,
				      @restrict const  dfloat *  sigmax,
				      @restrict const  dfloat *  sigmay,
				      @restrict const  dfloat *  sigmaz,
				      @restrict const  dfloat *  DrT,
				      @restrict const  dfloat *  DsT,
				      @restrict const  dfloat *  DtT,
				      @restrict const  dfloat4 *  q,
				      @restrict const  dfloat *  pmlq,
				            @restrict dfloat4 *  rhsq,
				            @restrict dfloat *  rhspmlq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }
    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];
	  const dfloat sigmaze = sigmaz[element*p_Np+n];
      //
	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaze = sigmaze + sigmaxe*p_pmlAlpha + sigmaye*p_pmlAlpha;

	  int base = element*p_Np*p_pmlNfields+n;
  // No-Need to Qx7 Qx9 Qx10
  	dfloat pmlqx1 = pmlq[base+QXID1*p_Np];
    dfloat pmlqx2 = pmlq[base+QXID2*p_Np];
    dfloat pmlqx3 = pmlq[base+QXID3*p_Np];
    dfloat pmlqx4 = pmlq[base+QXID4*p_Np];
    dfloat pmlqx5 = pmlq[base+QXID5*p_Np];
    dfloat pmlqx6 = pmlq[base+QXID6*p_Np];
    dfloat pmlqx8 = pmlq[base+QXID8*p_Np];  
    // No-Need to Qy6 Qy8 Qy10
		dfloat pmlqy1 = pmlq[base+QYID1*p_Np];
		dfloat pmlqy2 = pmlq[base+QYID2*p_Np];
		dfloat pmlqy3 = pmlq[base+QYID3*p_Np];
		dfloat pmlqy4 = pmlq[base+QYID4*p_Np];
		dfloat pmlqy5 = pmlq[base+QYID5*p_Np];
		dfloat pmlqy7 = pmlq[base+QYID7*p_Np];
		dfloat pmlqy9 = pmlq[base+QYID9*p_Np];
    // No-Need to Qz5 Qz8 Qz9
    dfloat pmlqz1  = pmlq[base+QZID1 *p_Np];
    dfloat pmlqz2  = pmlq[base+QZID2 *p_Np];
    dfloat pmlqz3  = pmlq[base+QZID3 *p_Np];
    dfloat pmlqz4  = pmlq[base+QZID4 *p_Np];
    dfloat pmlqz6  = pmlq[base+QZID6 *p_Np];
    dfloat pmlqz7  = pmlq[base+QZID7 *p_Np];
    dfloat pmlqz10 = pmlq[base+QZID10*p_Np];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	   #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  
	  //

	  // A*dq/dx
	  dfloat Aqx1  = -p_sqrtRT*(dq2dx);
	  dfloat Aqx2  = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx);	
	  dfloat Aqx3  = -p_sqrtRT*(dq5dx);	
	  dfloat Aqx4  = -p_sqrtRT*(dq6dx);
	  dfloat Aqx5  = -p_sqrtRT*(dq3dx);	
	  dfloat Aqx6  = -p_sqrtRT*(dq4dx);
    dfloat Aqx8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
    
    // B*dq/dy
	  dfloat Bqy1 = -p_sqrtRT*(dq3dy);
	  dfloat Bqy2 = -p_sqrtRT*(dq5dy);	
	  dfloat Bqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq9dy);	
	  dfloat Bqy4 = -p_sqrtRT*(dq7dy);
	  dfloat Bqy5 = -p_sqrtRT*(dq2dy);	
	  dfloat Bqy7 = -p_sqrtRT*(dq4dy);	
	  dfloat Bqy9 = -p_sqrtRT*(p_sqrt2*dq3dy);

	   // C*dq/dz
	  dfloat Cqz1 = -p_sqrtRT*(dq4dz);
	  dfloat Cqz2 = -p_sqrtRT*(dq6dz);	
	  dfloat Cqz3 = -p_sqrtRT*(dq7dz);	
	  dfloat Cqz4 = -p_sqrtRT*(dq1dz + p_sqrt2*dq10dz);
	  dfloat Cqz6 = -p_sqrtRT*( dq2dz);
	  dfloat Cqz7 = -p_sqrtRT*(dq3dz);
	  dfloat Cqz10 = -p_sqrtRT*(p_sqrt2*dq4dz);
                
      
      // Rhs for qx    	  
	  rhspmlq[base+QXID1*p_Np] = -msigmaxe*(pmlqx1) + Aqx1;
	  rhspmlq[base+QXID2*p_Np] = -msigmaxe*(pmlqx2) + Aqx2;
	  rhspmlq[base+QXID3*p_Np] = -msigmaxe*(pmlqx3) + Aqx3;
	  rhspmlq[base+QXID4*p_Np] = -msigmaxe*(pmlqx4) + Aqx4;
	  rhspmlq[base+QXID5*p_Np] = -msigmaxe*(pmlqx5) + Aqx5;
	  rhspmlq[base+QXID6*p_Np] = -msigmaxe*(pmlqx6) + Aqx6;
	  rhspmlq[base+QXID8*p_Np] = -msigmaxe*(pmlqx8) + Aqx8;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QYID1*p_Np] = -msigmaye*(pmlqy1) + Bqy1;
	  rhspmlq[base+QYID2*p_Np] = -msigmaye*(pmlqy2) + Bqy2;
	  rhspmlq[base+QYID3*p_Np] = -msigmaye*(pmlqy3) + Bqy3;
	  rhspmlq[base+QYID4*p_Np] = -msigmaye*(pmlqy4) + Bqy4;
	  rhspmlq[base+QYID5*p_Np] = -msigmaye*(pmlqy5) + Bqy5;
	  rhspmlq[base+QYID7*p_Np] = -msigmaye*(pmlqy7) + Bqy7;
	  rhspmlq[base+QYID9*p_Np] = -msigmaye*(pmlqy9) + Bqy9;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QZID1 *p_Np] = -msigmaze*(pmlqz1 ) + Cqz1 ;
	  rhspmlq[base+QZID2 *p_Np] = -msigmaze*(pmlqz2 ) + Cqz2 ;
	  rhspmlq[base+QZID3 *p_Np] = -msigmaze*(pmlqz3 ) + Cqz3 ;
	  rhspmlq[base+QZID4 *p_Np] = -msigmaze*(pmlqz4 ) + Cqz4 ;
	  rhspmlq[base+QZID6 *p_Np] = -msigmaze*(pmlqz6 ) + Cqz6 ;
	  rhspmlq[base+QZID7 *p_Np] = -msigmaze*(pmlqz7 ) + Cqz7 ;
	  rhspmlq[base+QZID10*p_Np] = -msigmaze*(pmlqz10) + Cqz10;

	  // BGK relaxation approximation to the Boltzmann collision operator
    dfloat rhsq1  = 0.f;
	  dfloat rhsq2  = 0.f;
	  dfloat rhsq3  = 0.f;
	  dfloat rhsq4  = 0.f;
	  dfloat rhsq5  = -p_tauInv*(s_q[es][4][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat rhsq6  = -p_tauInv*(s_q[es][5][n] - (s_q[es][1][n]*s_q[es][3][n]/s_q[es][0][n]));
	  dfloat rhsq7  = -p_tauInv*(s_q[es][6][n] - (s_q[es][2][n]*s_q[es][3][n]/s_q[es][0][n]));
	  dfloat rhsq8  = -p_tauInv*(s_q[es][7][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  dfloat rhsq9  = -p_tauInv*(s_q[es][8][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat rhsq10 = -p_tauInv*(s_q[es][9][n] - p_invsqrt2*(s_q[es][3][n]*s_q[es][3][n]/s_q[es][0][n]));

	  // BGK relaxation approximation to the Boltzmann collision operator
    rhsq1  += -msigmaxe*(pmlqx1)-msigmaye*(pmlqy1)-msigmaze*(pmlqz1)+Aqx1+Bqy1+Cqz1;
	  rhsq2  += -msigmaxe*(pmlqx2)-msigmaye*(pmlqy2)-msigmaze*(pmlqz2)+Aqx2+Bqy2+Cqz2;
	  rhsq3  += -msigmaxe*(pmlqx3)-msigmaye*(pmlqy3)-msigmaze*(pmlqz3)+Aqx3+Bqy3+Cqz3;
	  rhsq4  += -msigmaxe*(pmlqx4)-msigmaye*(pmlqy4)-msigmaze*(pmlqz4)+Aqx4+Bqy4+Cqz4;
	  rhsq5  += -msigmaxe*(pmlqx5)-msigmaye*(pmlqy5)                  +Aqx5+Bqy5     ;
	  rhsq6  += -msigmaxe*(pmlqx6)                  -msigmaze*(pmlqz6) +Aqx6     +Cqz6;
	  rhsq7  +=                   -msigmaye*(pmlqy7)-msigmaze*(pmlqz7)     +Bqy7+Cqz7;
	  rhsq8  += -msigmaxe*(pmlqx8)                                    +Aqx8          ;
	  rhsq9  +=                   -msigmaye*(pmlqy9)                       +Bqy9     ;
	  rhsq10 +=                                     -msigmaze*(pmlqz10)         +Cqz10;
	  //
	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q4bar; 
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	   const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

    tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}



@kernel void boltzmannPmlVolumeCub3D(const int Nelements,
				      @restrict const  int *  elementIds,
				      const dfloat ramp,
				      const dfloat drampdt,
				      @restrict const  dfloat *  vgeo,
				      @restrict const  dfloat *  sigmax,
				      @restrict const  dfloat *  sigmay,
				      @restrict const  dfloat *  sigmaz,
				      @restrict const  dfloat *  DrT,
				      @restrict const  dfloat *  DsT,
				      @restrict const  dfloat *  DtT,
				      @restrict const  dfloat4 *  q,
				      @restrict const  dfloat *  pmlq,
				            @restrict dfloat4 *  rhsq,
				            @restrict dfloat *  rhspmlq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }
    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];
	  const dfloat sigmaze = sigmaz[element*p_Np+n];
      //
	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaze = sigmaze + sigmaxe*p_pmlAlpha + sigmaye*p_pmlAlpha;

	  int base = element*p_Np*p_pmlNfields+n;
  // No-Need to Qx7 Qx9 Qx10
  	dfloat pmlqx1 = pmlq[base+QXID1*p_Np];
    dfloat pmlqx2 = pmlq[base+QXID2*p_Np];
    dfloat pmlqx3 = pmlq[base+QXID3*p_Np];
    dfloat pmlqx4 = pmlq[base+QXID4*p_Np];
    dfloat pmlqx5 = pmlq[base+QXID5*p_Np];
    dfloat pmlqx6 = pmlq[base+QXID6*p_Np];
    dfloat pmlqx8 = pmlq[base+QXID8*p_Np];  
    // No-Need to Qy6 Qy8 Qy10
		dfloat pmlqy1 = pmlq[base+QYID1*p_Np];
		dfloat pmlqy2 = pmlq[base+QYID2*p_Np];
		dfloat pmlqy3 = pmlq[base+QYID3*p_Np];
		dfloat pmlqy4 = pmlq[base+QYID4*p_Np];
		dfloat pmlqy5 = pmlq[base+QYID5*p_Np];
		dfloat pmlqy7 = pmlq[base+QYID7*p_Np];
		dfloat pmlqy9 = pmlq[base+QYID9*p_Np];
    // No-Need to Qz5 Qz8 Qz9
    dfloat pmlqz1  = pmlq[base+QZID1 *p_Np];
    dfloat pmlqz2  = pmlq[base+QZID2 *p_Np];
    dfloat pmlqz3  = pmlq[base+QZID3 *p_Np];
    dfloat pmlqz4  = pmlq[base+QZID4 *p_Np];
    dfloat pmlqz6  = pmlq[base+QZID6 *p_Np];
    dfloat pmlqz7  = pmlq[base+QZID7 *p_Np];
    dfloat pmlqz10 = pmlq[base+QZID10*p_Np];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	   #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  
	  //

	  // A*dq/dx
	  dfloat Aqx1  = -p_sqrtRT*(dq2dx);
	  dfloat Aqx2  = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx);	
	  dfloat Aqx3  = -p_sqrtRT*(dq5dx);	
	  dfloat Aqx4  = -p_sqrtRT*(dq6dx);
	  dfloat Aqx5  = -p_sqrtRT*(dq3dx);	
	  dfloat Aqx6  = -p_sqrtRT*(dq4dx);
    dfloat Aqx8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
    
    // B*dq/dy
	  dfloat Bqy1 = -p_sqrtRT*(dq3dy);
	  dfloat Bqy2 = -p_sqrtRT*(dq5dy);	
	  dfloat Bqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq9dy);	
	  dfloat Bqy4 = -p_sqrtRT*(dq7dy);
	  dfloat Bqy5 = -p_sqrtRT*(dq2dy);	
	  dfloat Bqy7 = -p_sqrtRT*(dq4dy);	
	  dfloat Bqy9 = -p_sqrtRT*(p_sqrt2*dq3dy);

	   // C*dq/dz
	  dfloat Cqz1 = -p_sqrtRT*(dq4dz);
	  dfloat Cqz2 = -p_sqrtRT*(dq6dz);	
	  dfloat Cqz3 = -p_sqrtRT*(dq7dz);	
	  dfloat Cqz4 = -p_sqrtRT*(dq1dz + p_sqrt2*dq10dz);
	  dfloat Cqz6 = -p_sqrtRT*( dq2dz);
	  dfloat Cqz7 = -p_sqrtRT*(dq3dz);
	  dfloat Cqz10 = -p_sqrtRT*(p_sqrt2*dq4dz);
                
      
      // Rhs for qx    	  
	  rhspmlq[base+QXID1*p_Np] = -msigmaxe*(pmlqx1) + Aqx1;
	  rhspmlq[base+QXID2*p_Np] = -msigmaxe*(pmlqx2) + Aqx2;
	  rhspmlq[base+QXID3*p_Np] = -msigmaxe*(pmlqx3) + Aqx3;
	  rhspmlq[base+QXID4*p_Np] = -msigmaxe*(pmlqx4) + Aqx4;
	  rhspmlq[base+QXID5*p_Np] = -msigmaxe*(pmlqx5) + Aqx5;
	  rhspmlq[base+QXID6*p_Np] = -msigmaxe*(pmlqx6) + Aqx6;
	  rhspmlq[base+QXID8*p_Np] = -msigmaxe*(pmlqx8) + Aqx8;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QYID1*p_Np] = -msigmaye*(pmlqy1) + Bqy1;
	  rhspmlq[base+QYID2*p_Np] = -msigmaye*(pmlqy2) + Bqy2;
	  rhspmlq[base+QYID3*p_Np] = -msigmaye*(pmlqy3) + Bqy3;
	  rhspmlq[base+QYID4*p_Np] = -msigmaye*(pmlqy4) + Bqy4;
	  rhspmlq[base+QYID5*p_Np] = -msigmaye*(pmlqy5) + Bqy5;
	  rhspmlq[base+QYID7*p_Np] = -msigmaye*(pmlqy7) + Bqy7;
	  rhspmlq[base+QYID9*p_Np] = -msigmaye*(pmlqy9) + Bqy9;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QZID1 *p_Np] = -msigmaze*(pmlqz1 ) + Cqz1 ;
	  rhspmlq[base+QZID2 *p_Np] = -msigmaze*(pmlqz2 ) + Cqz2 ;
	  rhspmlq[base+QZID3 *p_Np] = -msigmaze*(pmlqz3 ) + Cqz3 ;
	  rhspmlq[base+QZID4 *p_Np] = -msigmaze*(pmlqz4 ) + Cqz4 ;
	  rhspmlq[base+QZID6 *p_Np] = -msigmaze*(pmlqz6 ) + Cqz6 ;
	  rhspmlq[base+QZID7 *p_Np] = -msigmaze*(pmlqz7 ) + Cqz7 ;
	  rhspmlq[base+QZID10*p_Np] = -msigmaze*(pmlqz10) + Cqz10;

	  // BGK relaxation approximation to the Boltzmann collision operator
    dfloat rhsq1  = -msigmaxe*(pmlqx1)-msigmaye*(pmlqy1)-msigmaze*(pmlqz1)+Aqx1+Bqy1+Cqz1;
	  dfloat rhsq2  = -msigmaxe*(pmlqx2)-msigmaye*(pmlqy2)-msigmaze*(pmlqz2)+Aqx2+Bqy2+Cqz2;
	  dfloat rhsq3  = -msigmaxe*(pmlqx3)-msigmaye*(pmlqy3)-msigmaze*(pmlqz3)+Aqx3+Bqy3+Cqz3;
	  dfloat rhsq4  = -msigmaxe*(pmlqx4)-msigmaye*(pmlqy4)-msigmaze*(pmlqz4)+Aqx4+Bqy4+Cqz4;
	  dfloat rhsq5  = -msigmaxe*(pmlqx5)-msigmaye*(pmlqy5)                  +Aqx5+Bqy5     ;
	  dfloat rhsq6  = -msigmaxe*(pmlqx6)                  -msigmaze*(pmlqz6) +Aqx6     +Cqz6;
	  dfloat rhsq7  =                   -msigmaye*(pmlqy7)-msigmaze*(pmlqz7)     +Bqy7+Cqz7;
	  dfloat rhsq8  = -msigmaxe*(pmlqx8)                                    +Aqx8          ;
	  dfloat rhsq9  =                   -msigmaye*(pmlqy9)                       +Bqy9     ;
	  dfloat rhsq10 =                                     -msigmaze*(pmlqz10)         +Cqz10;
	  //
	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q4bar; 
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	   const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

    tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}

@kernel void boltzmannSAPmlVolume3D(const int Nelements,
				      @restrict const  int *  elementIds,
				      const dfloat ramp,
				      const dfloat drampdt,
				      @restrict const  dfloat *  vgeo,
				      @restrict const  dfloat *  sigmax,
				      @restrict const  dfloat *  sigmay,
				      @restrict const  dfloat *  sigmaz,
				      @restrict const  dfloat *  DrT,
				      @restrict const  dfloat *  DsT,
				      @restrict const  dfloat *  DtT,
				      @restrict const  dfloat4 *  q,
				      @restrict const  dfloat *  pmlq,
				            @restrict dfloat4 *  rhsq,
				            @restrict dfloat *  rhspmlq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;@outer(0)){  // for all elements

    @shared dfloat s_q[p_NblockV][10][p_Np];
    @exclusive int element;

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element

	int e = eo+es; // element in block

	if(e<Nelements){
	  element = elementIds[e];

	  const int id = 3*(element*p_Np+n);
	  dfloat4 qan = q[id+0];
	  dfloat4 qbn = q[id+1];
	  dfloat4 qcn = q[id+2];
	  //
	  s_q[es][0][n]  = qan.x;
	  s_q[es][1][n]  = qan.y;
	  s_q[es][2][n]  = qan.z;
	  s_q[es][3][n]  = qan.w;

	  s_q[es][4][n]  = qbn.x;
	  s_q[es][5][n]  = qbn.y;
	  s_q[es][6][n]  = qbn.z;
	  s_q[es][7][n]  = qbn.w;
     
	  s_q[es][8][n]  = qcn.x;
	  s_q[es][9][n]  = qcn.y;

	}
      }
    }
    // make sure all node data is loaded into @shared
    @barrier("local");

    for(int es=0;es<p_NblockV;++es;@inner(1)){// for all elements in block
      for(int n=0;n<p_Np;++n;@inner(0)){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
	  const dfloat drdz = vgeo[element*p_Nvgeo + RZID];
	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];
	  const dfloat dsdz = vgeo[element*p_Nvgeo + SZID];
	  const dfloat dtdx = vgeo[element*p_Nvgeo + TXID];
	  const dfloat dtdy = vgeo[element*p_Nvgeo + TYID];
	  const dfloat dtdz = vgeo[element*p_Nvgeo + TZID];

	  const dfloat sigmaxe = sigmax[element*p_Np+n];
	  const dfloat sigmaye = sigmay[element*p_Np+n];
	  const dfloat sigmaze = sigmaz[element*p_Np+n];
      //
	  const dfloat msigmaxe = sigmaxe + sigmaye*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaye = sigmaye + sigmaxe*p_pmlAlpha + sigmaze*p_pmlAlpha;
	  const dfloat msigmaze = sigmaze + sigmaxe*p_pmlAlpha + sigmaye*p_pmlAlpha;

	  int base = element*p_Np*p_pmlNfields+n;
  // No-Need to Qx7 Qx9 Qx10
  	dfloat pmlqx1 = pmlq[base+QXID1*p_Np];
    dfloat pmlqx2 = pmlq[base+QXID2*p_Np];
    dfloat pmlqx3 = pmlq[base+QXID3*p_Np];
    dfloat pmlqx4 = pmlq[base+QXID4*p_Np];
    dfloat pmlqx5 = pmlq[base+QXID5*p_Np];
    dfloat pmlqx6 = pmlq[base+QXID6*p_Np];
    dfloat pmlqx8 = pmlq[base+QXID8*p_Np];  
    // No-Need to Qy6 Qy8 Qy10
		dfloat pmlqy1 = pmlq[base+QYID1*p_Np];
		dfloat pmlqy2 = pmlq[base+QYID2*p_Np];
		dfloat pmlqy3 = pmlq[base+QYID3*p_Np];
		dfloat pmlqy4 = pmlq[base+QYID4*p_Np];
		dfloat pmlqy5 = pmlq[base+QYID5*p_Np];
		dfloat pmlqy7 = pmlq[base+QYID7*p_Np];
		dfloat pmlqy9 = pmlq[base+QYID9*p_Np];
    // No-Need to Qz5 Qz8 Qz9
    dfloat pmlqz1  = pmlq[base+QZID1 *p_Np];
    dfloat pmlqz2  = pmlq[base+QZID2 *p_Np];
    dfloat pmlqz3  = pmlq[base+QZID3 *p_Np];
    dfloat pmlqz4  = pmlq[base+QZID4 *p_Np];
    dfloat pmlqz6  = pmlq[base+QZID6 *p_Np];
    dfloat pmlqz7  = pmlq[base+QZID7 *p_Np];
    dfloat pmlqz10 = pmlq[base+QZID10*p_Np];

	  // compute 'r', 's', 't' derivatives of (q_m) at node n
	  dfloat dq1dr= 0.f, dq2dr= 0.f, dq3dr= 0.f, dq4dr= 0.f, dq5dr = 0.f;
	  dfloat dq6dr= 0.f, dq7dr= 0.f, dq8dr= 0.f, dq9dr= 0.f, dq10dr= 0.f;
	  
	  dfloat dq1ds= 0.f, dq2ds= 0.f, dq3ds= 0.f, dq4ds= 0.f, dq5ds = 0.f;
	  dfloat dq6ds= 0.f, dq7ds= 0.f, dq8ds= 0.f, dq9ds= 0.f, dq10ds= 0.f;

	  dfloat dq1dt= 0.f, dq2dt= 0.f, dq3dt= 0.f, dq4dt= 0.f, dq5dt = 0.f;
	  dfloat dq6dt= 0.f, dq7dt= 0.f, dq8dt= 0.f, dq9dt= 0.f, dq10dt= 0.f;
	 

	   #pragma unroll p_Np
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni  = DrT[n+i*p_Np];
	    const dfloat Dsni  = DsT[n+i*p_Np];
	    const dfloat Dtni  = DtT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq1dt += Dtni*s_q[es][0][i];
       
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq2dt += Dtni*s_q[es][1][i];

	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq3dt += Dtni*s_q[es][2][i];

	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq4dt += Dtni*s_q[es][3][i];

	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq5dt += Dtni*s_q[es][4][i];

	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	    dq6dt += Dtni*s_q[es][5][i];

	    dq7dr += Drni*s_q[es][6][i];
	    dq7ds += Dsni*s_q[es][6][i];
	    dq7dt += Dtni*s_q[es][6][i];

	    dq8dr += Drni*s_q[es][7][i];
	    dq8ds += Dsni*s_q[es][7][i];
	    dq8dt += Dtni*s_q[es][7][i];

	    dq9dr += Drni*s_q[es][8][i];
	    dq9ds += Dsni*s_q[es][8][i];
	    dq9dt += Dtni*s_q[es][8][i];

	    dq10dr += Drni*s_q[es][9][i];
	    dq10ds += Dsni*s_q[es][9][i];
	    dq10dt += Dtni*s_q[es][9][i];

	  }

	  dfloat dq1dx  = drdx*dq1dr  + dsdx*dq1ds  + dtdx*dq1dt;
	  dfloat dq2dx  = drdx*dq2dr  + dsdx*dq2ds  + dtdx*dq2dt;
	  dfloat dq3dx  = drdx*dq3dr  + dsdx*dq3ds  + dtdx*dq3dt;
	  dfloat dq4dx  = drdx*dq4dr  + dsdx*dq4ds  + dtdx*dq4dt;
	  dfloat dq5dx  = drdx*dq5dr  + dsdx*dq5ds  + dtdx*dq5dt;
	  dfloat dq6dx  = drdx*dq6dr  + dsdx*dq6ds  + dtdx*dq6dt;
	  //dfloat dq7dx  = drdx*dq7dr  + dsdx*dq7ds  + dtdx*dq7dt;
	  dfloat dq8dx  = drdx*dq8dr  + dsdx*dq8ds  + dtdx*dq8dt;
	  //dfloat dq9dx  = drdx*dq9dr  + dsdx*dq9ds  + dtdx*dq9dt;
	  //dfloat dq10dx = drdx*dq10dr + dsdx*dq10ds + dtdx*dq10dt;

	  dfloat dq1dy  = drdy*dq1dr  + dsdy*dq1ds  + dtdy*dq1dt;
	  dfloat dq2dy  = drdy*dq2dr  + dsdy*dq2ds  + dtdy*dq2dt;
	  dfloat dq3dy  = drdy*dq3dr  + dsdy*dq3ds  + dtdy*dq3dt;
	  dfloat dq4dy  = drdy*dq4dr  + dsdy*dq4ds  + dtdy*dq4dt;
	  dfloat dq5dy  = drdy*dq5dr  + dsdy*dq5ds  + dtdy*dq5dt;
	  //dfloat dq6dy  = drdy*dq6dr  + dsdy*dq6ds  + dtdy*dq6dt;
	  dfloat dq7dy  = drdy*dq7dr  + dsdy*dq7ds  + dtdy*dq7dt;
	 // dfloat dq8dy  = drdy*dq8dr  + dsdy*dq8ds  + dtdy*dq8dt;
	  dfloat dq9dy  = drdy*dq9dr  + dsdy*dq9ds  + dtdy*dq9dt;
	 // dfloat dq10dy = drdy*dq10dr + dsdy*dq10ds + dtdy*dq10dt;

	  dfloat dq1dz  = drdz*dq1dr  + dsdz*dq1ds  + dtdz*dq1dt;
	  dfloat dq2dz  = drdz*dq2dr  + dsdz*dq2ds  + dtdz*dq2dt;
	  dfloat dq3dz  = drdz*dq3dr  + dsdz*dq3ds  + dtdz*dq3dt;
	  dfloat dq4dz  = drdz*dq4dr  + dsdz*dq4ds  + dtdz*dq4dt;
	  //dfloat dq5dz  = drdz*dq5dr  + dsdz*dq5ds  + dtdz*dq5dt;
	  dfloat dq6dz  = drdz*dq6dr  + dsdz*dq6ds  + dtdz*dq6dt;
	  dfloat dq7dz  = drdz*dq7dr  + dsdz*dq7ds  + dtdz*dq7dt;
	//  dfloat dq8dz  = drdz*dq8dr  + dsdz*dq8ds  + dtdz*dq8dt;
	 // dfloat dq9dz  = drdz*dq9dr  + dsdz*dq9ds  + dtdz*dq9dt;
	  dfloat dq10dz = drdz*dq10dr + dsdz*dq10ds + dtdz*dq10dt;
	  
	  //

	  // A*dq/dx
	  dfloat Aqx1  = -p_sqrtRT*(dq2dx);
	  dfloat Aqx2  = -p_sqrtRT*(dq1dx + p_sqrt2*dq8dx);	
	  dfloat Aqx3  = -p_sqrtRT*(dq5dx);	
	  dfloat Aqx4  = -p_sqrtRT*(dq6dx);
	  dfloat Aqx5  = -p_sqrtRT*(dq3dx);	
	  dfloat Aqx6  = -p_sqrtRT*(dq4dx);
    dfloat Aqx8  = -p_sqrtRT*(p_sqrt2*dq2dx);	
    
    // B*dq/dy
	  dfloat Bqy1 = -p_sqrtRT*(dq3dy);
	  dfloat Bqy2 = -p_sqrtRT*(dq5dy);	
	  dfloat Bqy3 = -p_sqrtRT*(dq1dy + p_sqrt2*dq9dy);	
	  dfloat Bqy4 = -p_sqrtRT*(dq7dy);
	  dfloat Bqy5 = -p_sqrtRT*(dq2dy);	
	  dfloat Bqy7 = -p_sqrtRT*(dq4dy);	
	  dfloat Bqy9 = -p_sqrtRT*(p_sqrt2*dq3dy);

	   // C*dq/dz
	  dfloat Cqz1 = -p_sqrtRT*(dq4dz);
	  dfloat Cqz2 = -p_sqrtRT*(dq6dz);	
	  dfloat Cqz3 = -p_sqrtRT*(dq7dz);	
	  dfloat Cqz4 = -p_sqrtRT*(dq1dz + p_sqrt2*dq10dz);
	  dfloat Cqz6 = -p_sqrtRT*( dq2dz);
	  dfloat Cqz7 = -p_sqrtRT*(dq3dz);
	  dfloat Cqz10 = -p_sqrtRT*(p_sqrt2*dq4dz);
                
      
      // Rhs for qx    	  
	  rhspmlq[base+QXID1*p_Np] = -msigmaxe*(pmlqx1) + Aqx1;
	  rhspmlq[base+QXID2*p_Np] = -msigmaxe*(pmlqx2) + Aqx2;
	  rhspmlq[base+QXID3*p_Np] = -msigmaxe*(pmlqx3) + Aqx3;
	  rhspmlq[base+QXID4*p_Np] = -msigmaxe*(pmlqx4) + Aqx4;
	  rhspmlq[base+QXID5*p_Np] = -msigmaxe*(pmlqx5) + Aqx5;
	  rhspmlq[base+QXID6*p_Np] = -msigmaxe*(pmlqx6) + Aqx6;
	  rhspmlq[base+QXID8*p_Np] = -msigmaxe*(pmlqx8) + Aqx8;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QYID1*p_Np] = -msigmaye*(pmlqy1) + Bqy1;
	  rhspmlq[base+QYID2*p_Np] = -msigmaye*(pmlqy2) + Bqy2;
	  rhspmlq[base+QYID3*p_Np] = -msigmaye*(pmlqy3) + Bqy3;
	  rhspmlq[base+QYID4*p_Np] = -msigmaye*(pmlqy4) + Bqy4;
	  rhspmlq[base+QYID5*p_Np] = -msigmaye*(pmlqy5) + Bqy5;
	  rhspmlq[base+QYID7*p_Np] = -msigmaye*(pmlqy7) + Bqy7;
	  rhspmlq[base+QYID9*p_Np] = -msigmaye*(pmlqy9) + Bqy9;
	  //
	   // Rhs for qx    	  
	  rhspmlq[base+QZID1 *p_Np] = -msigmaze*(pmlqz1 ) + Cqz1 ;
	  rhspmlq[base+QZID2 *p_Np] = -msigmaze*(pmlqz2 ) + Cqz2 ;
	  rhspmlq[base+QZID3 *p_Np] = -msigmaze*(pmlqz3 ) + Cqz3 ;
	  rhspmlq[base+QZID4 *p_Np] = -msigmaze*(pmlqz4 ) + Cqz4 ;
	  rhspmlq[base+QZID6 *p_Np] = -msigmaze*(pmlqz6 ) + Cqz6 ;
	  rhspmlq[base+QZID7 *p_Np] = -msigmaze*(pmlqz7 ) + Cqz7 ;
	  rhspmlq[base+QZID10*p_Np] = -msigmaze*(pmlqz10) + Cqz10;

	  // BGK relaxation approximation to the Boltzmann collision operator
    dfloat rhsq1  = 0.f;
	  dfloat rhsq2  = 0.f;
	  dfloat rhsq3  = 0.f;
	  dfloat rhsq4  = 0.f;
	  dfloat rhsq5  = p_tauInv*( (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat rhsq6  = p_tauInv*( (s_q[es][1][n]*s_q[es][3][n]/s_q[es][0][n]));
	  dfloat rhsq7  = p_tauInv*( (s_q[es][2][n]*s_q[es][3][n]/s_q[es][0][n]));
	  dfloat rhsq8  = p_tauInv*( p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  dfloat rhsq9  = p_tauInv*( p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
	  dfloat rhsq10 = p_tauInv*( p_invsqrt2*(s_q[es][3][n]*s_q[es][3][n]/s_q[es][0][n]));

	  // BGK relaxation approximation to the Boltzmann collision operator
    rhsq1  += -msigmaxe*(pmlqx1)-msigmaye*(pmlqy1)-msigmaze*(pmlqz1)+Aqx1+Bqy1+Cqz1;
	  rhsq2  += -msigmaxe*(pmlqx2)-msigmaye*(pmlqy2)-msigmaze*(pmlqz2)+Aqx2+Bqy2+Cqz2;
	  rhsq3  += -msigmaxe*(pmlqx3)-msigmaye*(pmlqy3)-msigmaze*(pmlqz3)+Aqx3+Bqy3+Cqz3;
	  rhsq4  += -msigmaxe*(pmlqx4)-msigmaye*(pmlqy4)-msigmaze*(pmlqz4)+Aqx4+Bqy4+Cqz4;
	  rhsq5  += -msigmaxe*(pmlqx5)-msigmaye*(pmlqy5)                  +Aqx5+Bqy5     ;
	  rhsq6  += -msigmaxe*(pmlqx6)                  -msigmaze*(pmlqz6) +Aqx6     +Cqz6;
	  rhsq7  +=                   -msigmaye*(pmlqy7)-msigmaze*(pmlqz7)     +Bqy7+Cqz7;
	  rhsq8  += -msigmaxe*(pmlqx8)                                    +Aqx8          ;
	  rhsq9  +=                   -msigmaye*(pmlqy9)                       +Bqy9     ;
	  rhsq10 +=                                     -msigmaze*(pmlqz10)         +Cqz10;
	  //
	  // add mean flow forcing
	  rhsq2  += drampdt*p_q2bar;
	  rhsq3  += drampdt*p_q3bar;
	  rhsq4  += drampdt*p_q4bar; 
	  // 
	  rhsq5  += 2.f*ramp*drampdt*p_q5bar;
	  rhsq6  += 2.f*ramp*drampdt*p_q6bar;
	  rhsq7  += 2.f*ramp*drampdt*p_q7bar;
	  rhsq8  += 2.f*ramp*drampdt*p_q8bar;
	  rhsq9  += 2.f*ramp*drampdt*p_q9bar;
	  rhsq10 += 2.f*ramp*drampdt*p_q10bar;

	   const int id = 3*(element*p_Np+n);	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[id+0] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = rhsq7;
	  tmp.w = rhsq8;

	  rhsq[id+1] = tmp;

    tmp.x = rhsq9;
	  tmp.y = rhsq10;
	  tmp.z = 0.f;
	  tmp.w = 0.f;
	  rhsq[id+2] = tmp;

	}
      }
    }
  }
}