kernel void ellipticRhsBCIpdgTet3D(const int Nelements,
            const iint * restrict vmapM,
            const iint * restrict vmapP,
            const dfloat tau,
            const dfloat t,
            const dfloat * restrict x,
            const dfloat * restrict y,
            const dfloat * restrict z,
            const dfloat * restrict vgeo,
            const dfloat * restrict sgeo,
            const iint   * restrict EToB,
            const dfloat * restrict DrT,
            const dfloat * restrict DsT,
            const dfloat * restrict DtT,
            const dfloat * restrict LIFTT,
            const dfloat * restrict MM,
            dfloat * restrict rhs){
  
  for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dqdx[p_Np];
    shared  dfloat s_dqdy[p_Np];
    shared  dfloat s_dqdz[p_Np];
    shared  dfloat s_lapq[p_Np];
    shared  dfloat s_nxdq[p_NfacesNfp];
    shared  dfloat s_nydq[p_NfacesNfp];
    shared  dfloat s_nzdq[p_NfacesNfp];
    shared  dfloat s_lapflux[p_NfacesNfp];
    shared  dfloat s_Lnxdq[p_Np];
    shared  dfloat s_Lnydq[p_Np];
    shared  dfloat s_Lnzdq[p_Np];

    exclusive iint idM;
    exclusive dfloat nx, ny, nz, sJ, invJ, hinv;
    
    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id];          

        // find face that owns this node
        const iint face = n/p_Nfp;

        dfloat dudxP=0, dudyP=0, dudzP=0, uP=0;         
        
        // load surface geofactors for this face
        iint sid = p_Nsgeo*(e*p_Nfaces+face);
        nx = sgeo[sid+p_NXID];
        ny = sgeo[sid+p_NYID];
        nz = sgeo[sid+p_NZID];
        sJ = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        const int bc = EToB[face+p_Nfaces*e];
        if(bc>0) {
          ellipticBoundaryConditions3D(bc, t, x[idM], y[idM], z[idM], nx, ny, nz, \
                                        0.f, 0.f, 0.f, 0.f,               \
                                        uP, dudxP, dudyP, dudzP);
        }  
        
        const dfloat dq = uP;
        const dfloat half = 1.f;
        
        s_nxdq[n] = half*sJ*invJ*nx*dq;
        s_nydq[n] = half*sJ*invJ*ny*dq;
        s_nzdq[n] = half*sJ*invJ*nz*dq;

        s_lapflux[n] = half*sJ*invJ*(-nx*dudxP-ny*dudyP-nz*dudzP-tau*hinv*dq);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_Nmax;++n;inner0){

      if(n<p_Np){
        const int gid = e*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat drdz = vgeo[gid + p_RZID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];
        const dfloat dsdz = vgeo[gid + p_SZID];
        const dfloat dtdx = vgeo[gid + p_TXID];
        const dfloat dtdy = vgeo[gid + p_TYID];
        const dfloat dtdz = vgeo[gid + p_TZID]; 
        
        dfloat Lnxdq = 0;
        dfloat Lnydq = 0;
        dfloat Lnzdq = 0;
        
        occaUnroll(p_NfacesNfp)
          for(iint i=0;i<p_NfacesNfp;++i){
            Lnxdq += LIFTT[n+i*p_Np]*s_nxdq[i];
            Lnydq += LIFTT[n+i*p_Np]*s_nydq[i];
            Lnzdq += LIFTT[n+i*p_Np]*s_nzdq[i];
          }

        dfloat dqdx = s_dqdx[n] + Lnxdq;
        dfloat dqdy = s_dqdy[n] + Lnydq;
        dfloat dqdz = s_dqdz[n] + Lnzdq;

        s_dqdx[n] = drdx*dqdx + drdy*dqdy + drdz*dqdz; // abuse of notation
        s_dqdy[n] = dsdx*dqdx + dsdy*dqdy + dsdz*dqdz;
        s_dqdz[n] = dtdx*dqdx + dtdy*dqdy + dtdz*dqdz;

        s_Lnxdq[n] = Lnxdq;
        s_Lnydq[n] = Lnydq;
        s_Lnzdq[n] = Lnzdq;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_NfacesNfp){
        iint id = idM%p_Np;
        s_lapflux[n] += sJ*invJ*(nx*s_Lnxdq[id]+ny*s_Lnydq[id]+nz*s_Lnzdq[id]);
      }

      if(n<p_Np){
        dfloat lapr = 0, laps = 0, lapt = 0;

        occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            lapr += DrT[n+i*p_Np]*s_dqdx[i];
            laps += DsT[n+i*p_Np]*s_dqdy[i];
            lapt += DtT[n+i*p_Np]*s_dqdz[i];
          }

        s_lapq[n] -= (lapr+laps+lapt);
      }
      
    }
    
    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
        dfloat lap = 0;
        
        // lift remaining surface terms
        occaUnroll(p_NfacesNfp)
          for(int i=0;i<p_NfacesNfp;++i){
            lap += LIFTT[n+i*p_Np]*s_lapflux[i];
          }
        
        s_lapq[n] += lap;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
        const dfloat J = vgeo[e*p_Nvgeo + p_JID];
        
        dfloat Mlapq = 0;

        // multiply by mass matrix
        occaUnroll(p_Np)
          for(int i=0;i<p_Np;++i){
            Mlapq += MM[n+i*p_Np]*s_lapq[i];
          }
        
        const iint id = e*p_Np+n;
        rhs[id] -=  J*Mlapq;
      }
    }
  }
}
