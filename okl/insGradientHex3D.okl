// Compute Gradient in Strong Form
kernel void insGradientVolumeHex3D(const dlong Nelements,
                                    const dfloat * restrict vgeo,
                                    const dfloat * restrict D,
                                    const dlong offset,
                                    const dfloat * restrict P,
                                          dfloat * restrict Px,
                                          dfloat * restrict Py,
                                          dfloat * restrict Pz){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_P[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_Nq;++k;inner2){ 
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){    
            const dlong e = eo+es; // element in block
            if(e<Nelements){ 
              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq+i;

              s_P[es][k][j][i]  = P[id];

              if (es==0 && k==0)
                s_D[j][i] = D[j*p_Nq+i];
            }
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_Nq;++k;inner2){ 
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){  
            const dlong e = eo+es; 
            if(e<Nelements){ 
              const dlong gid = e*p_Np*p_Nvgeo +k*p_Nq*p_Nq +j*p_Nq +i;
              const dfloat drdx = vgeo[gid + p_RXID*p_Np];
              const dfloat drdy = vgeo[gid + p_RYID*p_Np];
              const dfloat drdz = vgeo[gid + p_RZID*p_Np];
              const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
              const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
              const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
              const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
              const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
              const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

              // compute 'r' and 's' derivatives of (q_m) at node n
              dfloat dpdr  = 0.f, dpds  = 0.f, dpdt  = 0.f;

              occaUnroll(p_Nq)
                for(int n=0;n<p_Nq;++n){
                  const dfloat Dr = s_D[i][n];
                  const dfloat Ds = s_D[j][n];
                  const dfloat Dt = s_D[k][n];

                  dpdr += Dr*s_P[es][k][j][n];
                  dpds += Ds*s_P[es][k][n][i];
                  dpdt += Dt*s_P[es][n][j][i];
                }

              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
              Px[id] = drdx*dpdr + dsdx*dpds + dtdx*dpdt;
              Py[id] = drdy*dpdr + dsdy*dpds + dtdy*dpdt;
              Py[id] = drdz*dpdr + dsdz*dpds + dtdz*dpdt;
            }
          }
        }
      }
    }
  }  
}

// taken from the lines if(solverID==1){ ..  }
#if 0
   /* dfloat PPo = 0.f; */                                              \
   /* dfloat to  = time-dt; */                                          \
   /* insGradientBoundaryConditions2D(bc,to, x[idM], y[idM], nx, ny, PM, &PPo); */  \
   /* PP = PP-c0*PPo; */                                                \
#endif

#define surfaceTerms(sk,face,i, j, k)                                   \
{                                                                       \
  dlong idM, idP;                                                       \
  if(solverID == 1){                                                    \
    idM = vmapM[sk];                                                    \
    idP = vmapP[sk];                                                    \
  } else {                                                              \
    idM = vmapM[sk]+p_Np*index*offset;                                  \
    idP = vmapP[sk]+p_Np*index*offset;                                  \
  }                                                                     \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat  PM = P[idM];                                            \
        dfloat  PP = P[idP];                                            \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    idM = vmapM[sk];                                                    \
    insPressureDirichletConditions3D(bc, time, x[idM], y[idM], z[idM], nx, ny, nz, PM, &PP);\
    if(solverID==1){                                                    \
      PP = PM;                                                          \
    }                                                                   \
    PP = 2.f*PP - PM;                                                   \
  }                                                                     \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxPx[es][k][j][i]  = sc*(.5f*nx*(PP-PM));                         \
  s_fluxPy[es][k][j][i]  = sc*(.5f*ny*(PP-PM));                         \
  s_fluxPz[es][k][j][i]  = sc*(.5f*nz*(PP-PM));                         \
}

kernel void insGradientSurfaceHex3D(const dlong Nelements,
                                     const dfloat * restrict sgeo,
                                     const dlong  * restrict vmapM,
                                     const dlong  * restrict vmapP,
                                     const int   * restrict EToB,
                                     const dfloat * restrict x,
                                     const dfloat * restrict y,
                                     const dfloat * restrict z,
                                     const dfloat time,
                                     const dfloat dt,
                                     const dfloat c0,
                                     const dfloat c1,
                                     const dfloat c2,
                                     const int index,
                                     const dlong offset,
                                     const int solverID,
                                     const dfloat * restrict POld,
                                     const dfloat * restrict P,
                                           dfloat * restrict Px,
                                           dfloat * restrict Py,
                                           dfloat * restrict Pz){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxPx[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_fluxPy[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_fluxPz[p_NblockS][p_Nq][p_Nq][p_Nq];

    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){
            s_fluxPx[es][k][j][i] = 0.;
            s_fluxPy[es][k][j][i] = 0.;
            s_fluxPz[es][k][j][i] = 0.;
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i;
            const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i;

            surfaceTerms(sk0,0,i,j,0     );
            surfaceTerms(sk5,5,i,j,p_Nq-1);
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i;
            const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i;

            surfaceTerms(sk1,1,i,0     ,k);
            surfaceTerms(sk3,3,i,p_Nq-1,k);
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 2 & 4
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
        for(int j=0;j<p_Nq;++j;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j;
            const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j;

            surfaceTerms(sk2,2,p_Nq-1,j,k);
            surfaceTerms(sk4,4,0     ,j,k);
          }
        }
      }
    }

    barrier(localMemFence);


    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            occaUnroll(p_Nq)
            for(int k=0;k<p_Nq;++k){
              dlong id;
              if (solverID==1) { //no offset
                id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
              } else {
                id = (e+index*offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
              }

              Px[id] += s_fluxPx[es][k][j][i];
              Py[id] += s_fluxPy[es][k][j][i];
              Pz[id] += s_fluxPz[es][k][j][i];
            }
          }
        }
      }
    }
  }
}

