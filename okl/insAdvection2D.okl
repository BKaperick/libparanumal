
// compute div(NU)  = div(uxu) in collocation way
kernel void insAdvectionVolume2D(const iint Nelements,
				 const dfloat * restrict vgeo,
				 const dfloat * restrict DrT,
				 const dfloat * restrict DsT,
				 const iint offset,
				 const dfloat * restrict U,
				 const dfloat * restrict V,
				 dfloat * restrict NU,
				 dfloat * restrict NV){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_F11[p_NblockV][p_Np];
    shared dfloat s_F12[p_NblockV][p_Np];
    shared dfloat s_F22[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){ 
      	  const iint id = (e+offset)*p_Np+n;
      	  const dfloat u = U[id];
      	  const dfloat v = V[id];

      	  s_F11[es][n] = u*u;
      	  s_F12[es][n] = u*v;
      	  s_F22[es][n] = v*v;
      	}
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_Np;++n;inner0){    	
      	iint e = eo+es; 
      	if(e<Nelements){	  
      	  // prefetch geometric factors (constant on triangle)
      	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
      	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
      	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
      	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      	  // compute 'r' and 's' derivatives of (q_m) at node n
      	  dfloat df11dr = 0.f, df11ds = 0.f; 
      	  dfloat df12dr = 0.f, df12ds = 0.f; 
      	  dfloat df22dr = 0.f, df22ds = 0.f; 

      	  occaUnroll(p_Np)
      	    for(iint i=0;i<p_Np;++i){
      	      const dfloat Drni = DrT[n+i*p_Np];
      	      const dfloat Dsni = DsT[n+i*p_Np];

      	      df11dr += Drni*s_F11[es][i];
      	      df11ds += Dsni*s_F11[es][i];

      	      df12dr += Drni*s_F12[es][i];
      	      df12ds += Dsni*s_F12[es][i];

      	      df22dr += Drni*s_F22[es][i];
      	      df22ds += Dsni*s_F22[es][i];
      	    }

      	  // NU = del(u1xu1)/ dx + del(u1xu2)/dy
      	  dfloat nu = drdx*df11dr + dsdx*df11ds 
	                 + drdy*df12dr + dsdy*df12ds;
      	  // NV = del(u2xu1)/ dx + del(u2xu2)/dy
      	  dfloat nv = drdx*df12dr + dsdx*df12ds 
	                  + drdy*df22dr + dsdy*df22ds;

      	  // Update
      	  const iint id = (e+offset)*p_Np+n;
      	  NU[id] = nu;
      	  NV[id] = nv;		 
      	}
      }
    }
  }
}

kernel void insAdvectionSurface2D(const iint Nelements,
				  const dfloat * restrict sgeo,
				  const dfloat * restrict LIFTT,
				  const iint   * restrict vmapM,
				  const iint   * restrict vmapP,
				  const iint   * restrict EToB,
				  const dfloat time,
				  const dfloat * restrict x,
				  const dfloat * restrict y,
          const iint offset,
          const dfloat * restrict U,
          const dfloat * restrict V,
				  dfloat * restrict NU,
				  dfloat * restrict NV){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxNy[p_NblockS][p_Nfp*p_Nfaces];
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
      	iint e = eo + es;
      	if(e<Nelements){
      	  if(n<p_Nfp*p_Nfaces){
      	    // find face that owns this node
      	    iint face = n/p_Nfp;
      	    // load surface geofactors for this face
      	    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
      	    dfloat nx   = sgeo[sid+p_NXID];
      	    dfloat ny   = sgeo[sid+p_NYID];
      	    dfloat sJ   = sgeo[sid+p_SJID];
      	    dfloat invJ = sgeo[sid+p_IJID];

      	    // indices of negative and positive traces of face node
      	    iint id  = e*p_Nfp*p_Nfaces + n;
      	    iint idM = vmapM[id]+offset*p_Np;
      	    iint idP = vmapP[id]+offset*p_Np;

      	    if(idP<0) idP = idM; // 
      	    // load negative and positive trace node values of U, V, Pr
      	    dfloat  uM = U[idM], uP = U[idP];
      	    dfloat  vM = V[idM], vP = V[idP];

      	    // apply boundary condition
      	    iint bc = EToB[face+p_Nfaces*e];
      	    if(bc>0){
              idM = vmapM[id];
      	      insAdvectionBoundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, uM, vM, &uP, &vP);
            }

      	    // Find max normal velocity on the face
      	    dfloat unM   = occaFabs(nx*uM + ny*vM);
      	    dfloat unP   = occaFabs(nx*uP + ny*vP);    
      	    dfloat unMax = (unM > unP) ? unM : unP;
             // evaluate "flux" terms: LLF
      	    const dfloat sc = invJ * sJ ; 
      	    s_fluxNx[es][n] = sc*(.5f*( nx*(uP*uP - uM*uM) 
      					                     + ny*(uP*vP - uM*vM) 	
                                     + unMax*(uM-uP) ));
      	    s_fluxNy[es][n] = sc*(.5f*( nx*(vP*uP - vM*uM) 
      					                       + ny*(vP*vP - vM*vM)	
                                       + unMax*(vM-vP) ));
      	  }
      	}
      }
    }


    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
      	iint e = eo + es;
      	if(e<Nelements){
      	  if(n<p_Np){
      	    iint id = (e+offset)*p_Np + n;

      	    dfloat rhsnu = NU[id];
      	    dfloat rhsnv = NV[id];
      	    // Lift
      	    occaUnroll(p_NfacesNfp)
      	      for(int m=0;m<p_Nfaces*p_Nfp;++m){
            		dfloat L = LIFTT[n+m*p_Np];

            		rhsnu  += L*s_fluxNx[es][m];
            		rhsnv  += L*s_fluxNy[es][m];
      	      }

      	    NU[id] = rhsnu;
      	    NV[id] = rhsnv;
      	  }
      	}
      }
    }
  }
}


// compute div(NU)  = div(uxu) in collocation way
kernel void insAdvectionCubatureVolume2D(const iint Nelements,
					 const dfloat * restrict vgeo,
					 const dfloat * restrict cubDrWT,
					 const dfloat * restrict cubDsWT,
					 const dfloat * restrict cubInterpT,
					 const iint offset,
					 const dfloat * restrict U,
					 const dfloat * restrict V,
					 dfloat * restrict NU,
					 dfloat * restrict NV){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // Hold Flux Vector on Shared, use symmetry f21 = f12
    shared dfloat s_U[p_NblockV][p_Np];
    shared dfloat s_V[p_NblockV][p_Np];
    shared dfloat s_cF11[p_NblockV][p_cubNp];
    shared dfloat s_cF12[p_NblockV][p_cubNp];
    shared dfloat s_cF22[p_NblockV][p_cubNp];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){      // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements){
          if(n<p_Np){ 
        	  const iint id = (e+offset)*p_Np+n;
        	  s_U[es][n] = U[id];
        	  s_V[es][n] = V[id];
      	 }
        } 
      }
    }

    barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; // element in block
      	if(e<Nelements && n<p_cubNp){
        	  dfloat cU = 0, cV = 0;
            occaUnroll(p_Np)
        	  for(iint i=0;i<p_Np;++i){
        	    dfloat cIni = cubInterpT[n+i*p_cubNp];
        	    cU += cIni*s_U[es][i];
        	    cV += cIni*s_V[es][i];
        	  }

      	  s_cF11[es][n] = cU*cU;
      	  s_cF12[es][n] = cU*cV;
      	  s_cF22[es][n] = cV*cV;
      	 }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){     // for all nodes in this element
      	iint e = eo+es; 
      	if(e<Nelements && n<p_Np){	  
      	  // prefetch geometric factors (constant on triangle)
      	  const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
      	  const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
      	  const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
      	  const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];
      	  // compute 'r' and 's' derivatives of (q_m) at node n
      	  dfloat df11dr = 0.f, df11ds = 0.f; 
      	  dfloat df12dr = 0.f, df12ds = 0.f; 
      	  dfloat df22dr = 0.f, df22ds = 0.f; 

      	  occaUnroll(p_cubNp)
      	    for(iint i=0;i<p_cubNp;++i){
      	      const dfloat cDrWni = cubDrWT[n+i*p_Np];
      	      const dfloat cDsWni = cubDsWT[n+i*p_Np];

      	      df11dr += cDrWni*s_cF11[es][i];
      	      df11ds += cDsWni*s_cF11[es][i];

      	      df12dr += cDrWni*s_cF12[es][i];
      	      df12ds += cDsWni*s_cF12[es][i];

      	      df22dr += cDrWni*s_cF22[es][i];
      	      df22ds += cDsWni*s_cF22[es][i];
      	    }

      	  dfloat nu   = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
      	  dfloat nv   = drdx*df12dr + dsdx*df12ds + drdy*df22dr + dsdy*df22ds;

      	  // Update
      	  const iint id = (e+offset)*p_Np+n;
      	  NU[id] = -nu; // note  change in sign
      	  NV[id] = -nv;		  
      	}
      }
    }
  }
}


kernel void insAdvectionCubatureSurface2D(const iint Nelements,
					  const dfloat * restrict sgeo,
					  const dfloat * restrict intInterpT, // interpolate to integration nodes
					  const dfloat * restrict intLIFTT, // lift from integration to interpolation nodes
					  const iint   * restrict vmapM,
					  const iint   * restrict vmapP,
					  const iint   * restrict EToB,
					  const dfloat time,
					  const dfloat * restrict intx, // integration nodes
					  const dfloat * restrict inty,
					  const iint offset,
					  const dfloat * restrict U,
					  const dfloat * restrict V,
					  dfloat * restrict NU,
					  dfloat * restrict NV){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_UM[p_NblockS][p_NfacesNfp];
    shared dfloat s_VM[p_NblockS][p_NfacesNfp];
    shared dfloat s_UP[p_NblockS][p_NfacesNfp];
    shared dfloat s_VP[p_NblockS][p_NfacesNfp];
    shared dfloat s_iFluxNx[p_NblockS][p_intNfpNfaces];
    shared dfloat s_iFluxNy[p_NblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){
      	iint e = eo + es;
      	if(e<Nelements && n<(p_Nfaces*p_Nfp)){
    	    const iint id  = e*p_Nfp*p_Nfaces + n;
          iint idM = vmapM[id]+offset*p_Np;
          iint idP = vmapP[id]+offset*p_Np;

    	    if(idP<0) idP = idM;

    	    // load negative and positive trace node values of velocity
    	    s_UM[es][n] = U[idM];
    	    s_VM[es][n] = V[idM];
    	    s_UP[es][n] = U[idP];
    	    s_VP[es][n] = V[idP];
  	  }
      }
    }

    barrier(localMemFence);

    // interpolate to surface integration nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){ 
      	iint e = eo + es;
      	if(e<Nelements && n<(p_Nfaces*p_intNfp)){
      	    const iint face = n/p_intNfp; // find face that owns this integration node

      	    // load surface geofactors for this face
      	    const iint sid = p_Nsgeo*(e*p_Nfaces+face);
      	    const dfloat nx   = sgeo[sid+p_NXID];
      	    const dfloat ny   = sgeo[sid+p_NYID];
      	    const dfloat sJ   = sgeo[sid+p_SJID];
      	    const dfloat invJ = sgeo[sid+p_IJID];

      	    dfloat iUM = 0.f, iVM = 0.f;
      	    dfloat iUP = 0.f, iVP = 0.f;

      	    // local block interpolation (face nodes to integration nodes)
            occaUnroll(p_Nfp)
      	    for(iint m=0;m<p_Nfp;++m){
      	      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
      	      const iint fm = face*p_Nfp+m;
      	      iUM += iInm*s_UM[es][fm];
      	      iVM += iInm*s_VM[es][fm];

      	      iUP += iInm*s_UP[es][fm];
      	      iVP += iInm*s_VP[es][fm];
      	    }

      	    // apply boundary condition
      	    iint bc = EToB[face+p_Nfaces*e];


      	    if(bc>0){
      	      insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp],inty[n+e*p_Nfaces*p_intNfp] , nx, ny, iUM,iVM, &iUP, &iVP);
      	    }

      	    // Find max normal velocity on the face
      	    dfloat unM   = occaFabs(nx*iUM + ny*iVM);
      	    dfloat unP   = occaFabs(nx*iUP + ny*iVP);    
      	    dfloat unMax = (unM > unP) ? unM : unP;

      	    // evaluate "flux" terms: LLF
      	    const dfloat sc = invJ * sJ ;  // notice sign changes in flux because of weak form
      	    s_iFluxNx[es][n] = sc*(.5f*(   nx*(iUP*iUP + iUM*iUM) 
      					   + ny*(iUP*iVP + iUM*iVM) 
      					   + unMax*(iUM-iUP) ));
      	    s_iFluxNy[es][n] = sc*(.5f*(   nx*(iVP*iUP + iVM*iUM) 
      					   + ny*(iVP*iVP + iVM*iVM) 
      					   + unMax*(iVM-iVP) ));
      	  }
      }
    }

    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // lift from surface integration to volume nodes
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxSurfaceNodes;++n;inner0){
      	const iint e = eo + es;
      	if(e<Nelements && n<p_Np ){
      	    iint id = n + p_Np*(e+offset);
      	    // prefetch volume rhs
      	    dfloat NUn = NU[id];
      	    dfloat NVn = NV[id];
            occaUnroll(p_intNfp*p_Nfaces)
      	    for(int m=0;m<(p_intNfp*p_Nfaces);++m){
      	      // RefMassMatrix^{-1}*cInterp^t*cWeight
      	      const dfloat L = intLIFTT[n+m*p_Np];

      	      NUn += L*s_iFluxNx[es][m];
      	      NVn += L*s_iFluxNy[es][m];
      	    }

      	    NU[id] = NUn;
      	    NV[id] = NVn;
      	  }
      }
    }
  }
}


kernel void insAdvectionUpdateSS2D(const iint Nelements,
                              const iint index,
                              const iint offset,
                              const dfloat dt,
                              const dfloat g0,
                              const dfloat a0,
                              const dfloat a1,
                              const dfloat a2,
                              const dfloat b0,
                              const dfloat b1,
                              const dfloat b2,
                              const dfloat * restrict U,
                              const dfloat * restrict V,
                              const dfloat * restrict NU,
                              const dfloat * restrict NV,
                                    dfloat * restrict Ut,
                                    dfloat * restrict Vt){

  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint id  = n + e*p_Np;
      //hard coded for 3 stages
      const iint index0 = (index+0)%3;
      const iint index1 = (index+2)%3; //back one step
      const iint index2 = (index+1)%3; //back two steps

      const iint id0 = n + (e+index0*offset)*p_Np;
      const iint id1 = n + (e+index1*offset)*p_Np;
      const iint id2 = n + (e+index2*offset)*p_Np;

      Ut[id] = ( b0*U[id0] + b1*U[id1] + b2*U[id2]- dt*(a0*NU[id0] + a1*NU[id1] + a2*NU[id2]) )/g0;
      Vt[id] = ( b0*V[id0] + b1*V[id1] + b2*V[id2]- dt*(a0*NV[id0] + a1*NV[id1] + a2*NV[id2]) )/g0;
    }
  }
}
