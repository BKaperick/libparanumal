#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3
//
#define UXID 0
#define UYID 1

kernel void insAdvectionVolume2D(
	                const iint Nelements,
	                const dfloat * restrict vgeo,
				    const dfloat * restrict DrT,
				    const dfloat * restrict DsT,
				    const dfloat * restrict U,
				          dfloat * restrict rhsU
				          ){
  
  //for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
 //   // Hold Flux Vector on Shared
 //   shared dfloat s_FxUx[p_NblockV][p_Np];
 //   shared dfloat s_FxUy[p_NblockV][p_Np];
 //   shared dfloat s_FyUx[p_NblockV][p_Np];
 //   shared dfloat s_FyUy[p_NblockV][p_Np];

 //    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
 //      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	// 	iint e = eo+es; // element in block
	// 	if(e<Nelements){ 
	// 	 const iint id = e*p_Np+n;
	// 	 const dfloat ux = U[id + UXID*p_NtotalDofs];
	// 	 const dfloat uy = U[id + UYID*p_NtotalDofs];
	// 	 //
	// 	  s_FxUx[es][n] = ux*ux;
	// 	  s_FxUy[es][n] = ux*uy;
 //          s_FyUx[es][n] = uy*ux;
 //          s_FyUy[es][n] = uy*uy;
	// }
 //      }
 //    }

 //     // make sure all node data is loaded into shared
 //    barrier(localMemFence);


 //    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
 //      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	// iint e = eo+es; // element in block
	// if(e<Nelements){	  
	//   // prefetch geometric factors (constant on triangle)
	//   const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	//   const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	//   const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	//   const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	//   // compute 'r' and 's' derivatives of (q_m) at node n
 //      dfloat df11dr = 0.f, df11ds = 0.f, df12dr = 0.f, df12ds = 0.f; 
 //      dfloat df21dr = 0.f, df21ds = 0.f, df22dr = 0.f, df22ds = 0.f; 

	//   occaUnroll(p_Np)
	//   for(iint i=0;i<p_Np;++i){
	//     const dfloat Drni = DrT[n+i*p_Np];
	//     const dfloat Dsni = DsT[n+i*p_Np];
	//     // 
	//     df11dr += Drni*s_FxUx[es][i];
	//     df11ds += Dsni*s_FxUx[es][i];
	//     //
	//     df12dr += Drni*s_FxUy[es][i];
	//     df12ds += Dsni*s_FxUy[es][i];
	//     // 
	//     df21dr += Drni*s_FyUx[es][i];
	//     df21ds += Dsni*s_FyUx[es][i];
	//     // 
	//     df22dr += Drni*s_FyUy[es][i];
	//     df22ds += Dsni*s_FyUy[es][i];
	//   }
	  
	//   // chain rule
	//   dfloat df11dx = drdx*df11dr + dsdx*df11ds;
	//   dfloat df12dy = drdy*df12dr + dsdy*df12ds;

 //      // chain rule
	//   dfloat df21dx = drdx*df21dr + dsdx*df21ds;
	//   dfloat df22dy = drdy*df22dr + dsdy*df22ds;
	//    //   
 //     const iint id = e*p_Np+n;

	//  rhsU[id + UXID*p_NtotalDofs] = df11dx + df12dy;
	//  rhsU[id + UYID*p_NtotalDofs] = df21dx + df22dy;
	 
	// }
 //      }
    // }
 // }
}








// kernel void insAdvectionVolumeCub2D(
// 	                const dfloat * restrict vgeo,
// 				    const dfloat * restrict DrT,
// 				    const dfloat * restrict DsT,
// 				    const dfloat * restrict U,
// 				          dfloat * restrict rhsU){
  
//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     shared dfloat s_q[p_NblockV][6][p_Np];
//     exclusive iint element;

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

// 	iint e = eo+es; // element in block

// 	if(e<Nelements){
// 	  element = elementIds[e];

// 	  const iint id = element*p_Np+n;
// 	  dfloat4 qan = q[2*id];
// 	  dfloat4 qbn = q[2*id+1];

// 	  s_q[es][0][n] = qan.x;
// 	  s_q[es][1][n] = qan.y;
// 	  s_q[es][2][n] = qan.z;
// 	  s_q[es][3][n] = qan.w;

// 	  s_q[es][4][n] = qbn.x;
// 	  s_q[es][5][n] = qbn.y;

// 	}
//       }
//     }

//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
	  
// 	  // prefetch geometric factors (constant on triangle)
// 	  const dfloat drdx = vgeo[element*p_Nvgeo + RXID];
// 	  const dfloat drdy = vgeo[element*p_Nvgeo + RYID];
// 	  const dfloat dsdx = vgeo[element*p_Nvgeo + SXID];
// 	  const dfloat dsdy = vgeo[element*p_Nvgeo + SYID];

// 	  // compute 'r' and 's' derivatives of (q_m) at node n
// 	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
// 	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

// 	  occaUnroll(p_Np)
// 	  for(iint i=0;i<p_Np;++i){
// 	    const dfloat Drni = DrT[n+i*p_Np];
// 	    const dfloat Dsni = DsT[n+i*p_Np];
	    
// 	    // differentiate q components with respect to 'r' and 's'
// 	    dq1dr += Drni*s_q[es][0][i];
// 	    dq1ds += Dsni*s_q[es][0][i];
// 	    dq2dr += Drni*s_q[es][1][i];
// 	    dq2ds += Dsni*s_q[es][1][i];
// 	    dq3dr += Drni*s_q[es][2][i];
// 	    dq3ds += Dsni*s_q[es][2][i];
// 	    dq4dr += Drni*s_q[es][3][i];
// 	    dq4ds += Dsni*s_q[es][3][i];
// 	    dq5dr += Drni*s_q[es][4][i];
// 	    dq5ds += Dsni*s_q[es][4][i];
// 	    dq6dr += Drni*s_q[es][5][i];
// 	    dq6ds += Dsni*s_q[es][5][i];
// 	  }
	  
// 	  // chain rule
// 	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
// 	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
// 	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
// 	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
// 	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
// 	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
// 	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
// 	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
// 	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
// 	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
// 	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
// 	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
// 	  // transport operator
// 	  dfloat rhsq1 = -p_sqrtRT*(dq2dx + dq3dy);
// 	  dfloat rhsq2 = -p_sqrtRT*(dq1dx + p_sqrt2*dq5dx + dq4dy);	
// 	  dfloat rhsq3 = -p_sqrtRT*(dq4dx + dq1dy + p_sqrt2*dq6dy);	
// 	  dfloat rhsq4 = -p_sqrtRT*(dq3dx + dq2dy);		
// 	  dfloat rhsq5 = -p_sqrtRT*p_sqrt2*dq2dx;			
// 	  dfloat rhsq6 = -p_sqrtRT*p_sqrt2*dq3dy;                   

// 	  // BGK relaxation approximation to the Boltzmann collision operator
// 	  rhsq4 -= p_tauInv*(s_q[es][3][n] - (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
// 	  rhsq5 -= p_tauInv*(s_q[es][4][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
// 	  rhsq6 -= p_tauInv*(s_q[es][5][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));

// 	  // add mean flow forcing
// 	  rhsq2 += drampdt*p_q2bar;
// 	  rhsq3 += drampdt*p_q3bar;
// 	  rhsq4 += 2.f*ramp*drampdt*p_q4bar;
// 	  rhsq5 += 2.f*ramp*drampdt*p_q5bar;
// 	  rhsq6 += 2.f*ramp*drampdt*p_q6bar;

// 	  const int id = element*p_Np+n;	  
// 	  dfloat4 tmp;
// 	  tmp.x = rhsq1;
// 	  tmp.y = rhsq2;
// 	  tmp.z = rhsq3;
// 	  tmp.w = rhsq4;

// 	  rhsq[2*id] = tmp;

// 	  tmp.x = rhsq5;
// 	  tmp.y = rhsq6;
// 	  tmp.z = 0.f;
// 	  tmp.w = 0.f;

// 	  rhsq[2*id+1] = tmp;
// 	}
//       }
//     }
//   }
// }



