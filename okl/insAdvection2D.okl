#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3
//
#define UXID 0
#define UYID 1




void boundaryConditions2D(const iint bc,
			              const dfloat  t, const dfloat  x, const dfloat  y,
			              const dfloat  nx, const dfloat  ny,
			              const dfloat  uxM, const dfloat  uyM, 
			              dfloat * restrict uxB, dfloat * restrict uyB){

  if(bc==1){ // Wall 
    *uxB = -uxM; 
    *uyB = -uyM;
  }
  if(bc==2){ // Inflow
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
  if(bc==3){ // Outflow 
  // do nothing 
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

    *uxB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uyB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
}



kernel void insAdvectionVolume2D(
	                const iint Nelements,
	                const dfloat * restrict vgeo,
				    const dfloat * restrict DrT,
				    const dfloat * restrict DsT,
				    const dfloat * restrict U,
				          dfloat * restrict rhsU
				          ){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
   // Hold Flux Vector on Shared
   shared dfloat s_FxUx[p_NblockV][p_Np];
   shared dfloat s_FxUy[p_NblockV][p_Np];
   //shared dfloat s_FyUx[p_NblockV][p_Np];
   shared dfloat s_FyUy[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

		iint e = eo+es; // element in block
		if(e<Nelements){ 
		 const iint id = e*p_Np+n;
		 const dfloat ux = U[id + UXID*p_NtotalDofs];
		 const dfloat uy = U[id + UYID*p_NtotalDofs];
		 //
		  s_FxUx[es][n] = ux*ux;
		  s_FxUy[es][n] = ux*uy;
         // s_FyUx[es][n] = uy*ux;
          s_FyUy[es][n] = uy*uy;
	}
      }
    }

     // make sure all node data is loaded into shared
    barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	iint e = eo+es; // element in block
	if(e<Nelements){	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
      dfloat df11dr = 0.f, df11ds = 0.f, df12dr = 0.f, df12ds = 0.f; 
      dfloat df21dr = 0.f, df21ds = 0.f, df22dr = 0.f, df22ds = 0.f; 

	  occaUnroll(p_Np)
	  for(iint i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    // 
	    df11dr += Drni*s_FxUx[es][i];
	    df11ds += Dsni*s_FxUx[es][i];
	    //
	    df12dr += Drni*s_FxUy[es][i];
	    df12ds += Dsni*s_FxUy[es][i];
	    // // 
	    // df21dr += Drni*s_FyUx[es][i];
	    // df21ds += Dsni*s_FyUx[es][i];
	    // 
	    df22dr += Drni*s_FyUy[es][i];
	    df22ds += Dsni*s_FyUy[es][i];
	  }
	  
	  // chain rule
	  dfloat df11dx = drdx*df11dr + dsdx*df11ds;
	  dfloat df12dy = drdy*df12dr + dsdy*df12ds;

      // chain rule
	  dfloat df21dx = drdx*df12dr + dsdx*df12ds; // Use Symmetry of Nonlinear Term: f21 =f12
	  dfloat df22dy = drdy*df22dr + dsdy*df22ds;
	   //   
     // Update RhsU
     const iint id = e*p_Np+n;

	 rhsU[id + UXID*p_NtotalDofs] = df11dx + df12dy;
	 rhsU[id + UYID*p_NtotalDofs] = df21dx + df22dy;
	 
	}
      }
    }
 }
}






kernel void insAdvectionSurface2D(const iint Nelements,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const iint   * restrict vmapM,
				     const iint   * restrict vmapP,
				     const iint   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat * restrict U,
				           dfloat * restrict rhsU){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];   
     // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	   iint e = eo + es;
	    if(e<Nelements){
	      if(n<p_Nfp*p_Nfaces){
		    // find face that owns this node
		    iint face = n/p_Nfp;
		    // load surface geofactors for this face
		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
		    dfloat nx   = sgeo[sid+0];
		    dfloat ny   = sgeo[sid+1];
		    //
		    dfloat sJ   = sgeo[sid+2];
		    dfloat invJ = sgeo[sid+3];
		   
		    // indices of negative and positive traces of face node
		    iint id  = e*p_Nfp*p_Nfaces + n;
		    iint idM = vmapM[id];
		    iint idP = vmapP[id];

		   if(idP<0) idP = idM;
		  
	  // load negative and positive trace node values of q
	     dfloat  uxm = U[idM + UXID*p_NtotalDofs];
	     dfloat  uxp = U[idP + UXID*p_NtotalDofs];
	     //
		   dfloat  uym = U[idM + UYID*p_NtotalDofs];
		   dfloat  uyp = U[idP + UYID*p_NtotalDofs];

		    // apply boundary condition
		    iint bc = EToB[face+p_Nfaces*e];
		    if(bc>0)
		      boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym, &uxp, &uyp);


        // Find max normal velocity
		    dfloat unm   = occaFabs(nx*uxm + ny*uym);
		    dfloat unp   = occaFabs(nx*uxp + ny*uyp);
            
        dfloat unmax = (unm > unp) ? unm : unp;

        // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
				s_fluxUx[es][n] = -0.5f*( nx*(uxm*uxm-uxp*uxp) + (uxm*uym-uxp*uyp) - unmax*(uxm-uxp) );
				s_fluxUy[es][n] = -0.5f*( nx*(uym*uxm-uyp*uxp) + (uym*uym-uyp*uyp) - unmax*(uym-uyp) );
	   


       	 }
    		}
			}
		}
    
     #if 0
    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	         if(n<p_Nfp*p_Nfaces){
	         	  iint face = n/p_Nfp;
	         	  if(face<Nface)
	         	    if(s_maxVel[es][0 + face*p_Nfp] < s_maxVel[es][n])
	         	  	   s_maxVel[es][0 + face*p_Nfp] = s_maxVel[es][n];
	         }
	       }
	     }
	   #endif


    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
	      iint e = eo + es;
	       if(e<Nelements){
	          if(n<p_Np){
				     iint id = e*p_Np + n;
             dfloat rhsux = rhsU[id + UXID*p_NtotalDofs];
             dfloat rhsuy = rhsU[id + UYID*p_NtotalDofs];
				    // Lift
				    occaUnroll(p_NfacesNfp)
				      for(int m=0;m<p_NfacesNfp;++m){
								dfloat L = LIFTT[n+m*p_Np];
								rhsux  += L*s_fluxUx[es][m];
								rhsuy  += L*s_fluxUy[es][m];
	      	 }
	  
	      rhsU[id + UXID*p_NtotalDofs] = rhsux;
        rhsU[id + UYID*p_NtotalDofs] = rhsuy;
	  }
	}
      }
    }
  }


}



kernel void insAdvectionUpdate2D(const iint Nelements,
				                      const dfloat dt,	
				                      const dfloat a0,
				                      const dfloat a1,
				                      const dfloat b0,
				                      const dfloat b1,
				                      const dfloat g0,
				                      const dfloat * restrict U,
				                      const dfloat * restrict UO,
				                      const dfloat * restrict rhsU,
				                            dfloat * restrict NU,
				                            dfloat * restrict UI){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
     
     const iint id = e*p_Np+n;
     //
		 const dfloat ux  = U[id + UXID*p_NtotalDofs];
		 const dfloat uy  = U[id + UYID*p_NtotalDofs];
		 //
		 const dfloat uxo = UO[id + UXID*p_NtotalDofs];
		 const dfloat uyo = UO[id + UYID*p_NtotalDofs];
     //
     const dfloat nux = rhsU[id + UXID*p_NtotalDofs];
		 const dfloat nuy = rhsU[id + UYID*p_NtotalDofs];
     //
     const dfloat nuxo = NU[id + UXID*p_NtotalDofs];
		 const dfloat nuyo = NU[id + UYID*p_NtotalDofs];
     //
     NU[id+ UXID*p_NtotalDofs] = nux;
     NU[id+ UYID*p_NtotalDofs] = nuy;
     //
     UI[id+ UXID*p_NtotalDofs] = ((a0*ux+a1*uxo)-dt*(b0*nux+b1*nuxo))/g0 ;
     UI[id+ UXID*p_NtotalDofs] = ((a0*uy+a1*uyo)-dt*(b0*nuy+b1*nuyo))/g0 ;

    }
  }
}

