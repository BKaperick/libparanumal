
// Computes volume contribution of div(UI)
kernel void insPoissonRhsForcingHex3D(const dlong Nelements,
                                   const dfloat * restrict vgeo,
                                   const dfloat dt,
                                   const dfloat g0,
                                    dfloat * restrict rhs){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        const dlong e = eo+es; // element in block
        if(e<Nelements){
          const dlong gid = n + e*p_Np*p_Nvgeo;
          const dfloat JW = vgeo[gid + p_JWID*p_Np];

          const dlong id = e*p_Np+n;
          rhs[id] = -JW*g0*rhs[id]/dt;
        }
      }
    }
  }
}

#define surfaceTermsIpdg(sk,face,i, j, k)                               \
{                                                                       \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];                          \
  const dfloat hinv= sgeo[sk*p_Nsgeo+p_IHID];                           \
                                                                        \
  dfloat dpdxP=0.f, dpdyP=0.f, dpdzP=0.f, pP=0.f;                       \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    const dlong idM = vmapM[sk];                                        \
    insPressureDirichletConditions3D(bc,time, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, &pP);\
    insPressureNeumannConditions3D(bc,time, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, 0.f, 0.f, &dpdxP, &dpdyP, &dpdzP);\
    if(pressure_solve==0){                                              \
      dfloat pPm1, dpdxPm1, dpdyPm1, dpdzPm1;                           \
      insPressureDirichletConditions3D(bc,time-dt, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, &pPm1);\
      insPressureNeumannConditions3D(bc,time-dt, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, 0.f, 0.f, &dpdxPm1, &dpdyPm1, &dpdzPm1);\
      pP = pP - pPm1;                                                   \
      dpdxP = dpdxP - dpdxPm1;                                          \
      dpdyP = dpdyP - dpdyPm1;                                          \
      dpdzP = dpdzP - dpdzPm1;                                          \
    }                                                                   \
  }                                                                     \
                                                                        \
  const dfloat dp = pP;                                                 \
                                                                        \
  s_dpdx[k][j][i] += WsJ*nx*dp;                                         \
  s_dpdy[k][j][i] += WsJ*ny*dp;                                         \
  s_dpdz[k][j][i] += WsJ*nz*dp;                                         \
                                                                        \
  s_rhsp[k][j][i] -= WsJ*(nx*dpdxP + ny*dpdyP + nz*dpdzP + tau*dp*hinv);\
}

// Actually solves for Pr increamnet not presssure
kernel void insPoissonRhsIpdgBCHex3D(const dlong Nelements,
                                      const int pressure_solve,
                                      const dlong  * restrict vmapM,
                                      const dfloat tau,
                                      const dfloat time,
                                      const dfloat dt,
                                      const dfloat * restrict x,
                                      const dfloat * restrict y,
                                      const dfloat * restrict z,
                                      const dfloat * restrict vgeo,
                                      const dfloat * restrict sgeo,
                                      const int    * restrict EToB,
                                      const dfloat * restrict D,
                                            dfloat * restrict rhsP){
  
  for(dlong e=0;e<Nelements;++e;outer0){

    shared dfloat s_dpdx[p_Nq][p_Nq][p_Nq];
    shared dfloat s_dpdy[p_Nq][p_Nq][p_Nq];
    shared dfloat s_dpdz[p_Nq][p_Nq][p_Nq];
    shared dfloat s_rhsp[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    // loop over slabs
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){          
          s_dpdx[k][j][i] = 0.f;
          s_dpdy[k][j][i] = 0.f;
          s_dpdz[k][j][i] = 0.f;
          s_rhsp[k][j][i] = 0.f;
        }

        s_D[j][i] = D[j*p_Nq+i];
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i;

        surfaceTermsIpdg(sk0,0,i,j,0     );
        surfaceTermsIpdg(sk5,5,i,j,p_Nq-1);
      }
    }


    barrier(localMemFence);

    // for all face nodes of all elements
    // face 1 & 3
    for(int k=0;k<p_Nq;++k;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i;

        surfaceTermsIpdg(sk1,1,i,0     ,k);
        surfaceTermsIpdg(sk3,3,i,p_Nq-1,k);
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 2 & 4
    for(int k=0;k<p_Nq;++k;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j;

        surfaceTermsIpdg(sk2,2,p_Nq-1,j,k);
        surfaceTermsIpdg(sk4,4,0     ,j,k);
      }
    }

    barrier(localMemFence);

    // prescale by geofacs
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        // does need the nasty geofacs
        for(int k=0;k<p_Nq;++k){
          const dlong gid = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np*p_Nvgeo;

          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          const dfloat drdz = vgeo[gid + p_RZID*p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

          const dfloat dpdx = s_dpdx[k][j][i];
          const dfloat dpdy = s_dpdy[k][j][i];
          const dfloat dpdz = s_dpdz[k][j][i];

          s_dpdx[k][j][i] = (drdx*dpdx + drdy*dpdy + drdz*dpdz);
          s_dpdy[k][j][i] = (dsdx*dpdx + dsdy*dpdy + dsdz*dpdz);
          s_dpdz[k][j][i] = (dtdx*dpdx + dtdy*dpdy + dtdz*dpdz);
        }
      }
    }

    barrier(localMemFence);

    // loop over slabs
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          dfloat dpr = 0, dps = 0, dpt = 0;

          occaUnroll(p_Nq)
          for(int n=0;n<p_Nq;++n){
            const dfloat Dr = s_D[i][n];
            const dfloat Ds = s_D[j][n];
            const dfloat Dt = s_D[k][n];

            dpr += Dr*s_dpdx[k][j][n];
            dps += Ds*s_dpdy[k][n][i];
            dpt += Dt*s_dpdz[n][j][i];
          }

          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          rhsP[id] -= s_rhsp[k][j][i]  + dpr + dps + dpt;
        }
      }
    }
  }
}

#define surfaceTerms(sk,face,i, j, k)                                   \
{                                                                       \
  const dlong idM = vmapM[sk];                                          \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];                          \
                                                                        \
  dfloat dpdxP=0.f, dpdyP=0.f, dpdzP=0.f, pP=0.f;                       \
                                                                        \
  const int bc = mapB[idM];                                             \
  if(bc>0) {                                                            \
    insPressureDirichletConditions3D(bc,time, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, &pP);\
    insPressureNeumannConditions3D(bc,time, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, 0.f, 0.f, &dpdxP, &dpdyP, &dpdyP);\
    if(pressure_solve==0){                                              \
      dfloat pPm1, dpdxPm1, dpdyPm1, dpdzPm1;                           \
      insPressureDirichletConditions3D(bc,time-dt, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, &pPm1);\
      insPressureNeumannConditions3D(bc,time-dt, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, 0.f, 0.f, &dpdxPm1, &dpdyPm1, &dpdzPm1);\
      pP = pP - pPm1;                                                   \
      dpdxP = dpdxP - dpdxPm1;                                          \
      dpdyP = dpdyP - dpdyPm1;                                          \
      dpdzP = dpdzP - dpdzPm1;                                          \
    }                                                                   \
  }                                                                     \
                                                                        \
  s_p  [k][j][i]  = pP;                                                 \
  s_ndp[k][j][i] -= WsJ*(nx*dpdxP + ny*dpdyP + nz*dpdzP);               \
}

//RHS contributions for continuous solver
kernel void insPoissonRhsBCHex3D(const dlong Nelements,
                              const int pressure_solve,
                              const dfloat * restrict ggeo,
                              const dfloat * restrict sgeo,
                              const dfloat * restrict D,
                              const dlong  * restrict vmapM,
                              const dfloat time,
                              const dfloat dt,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const dfloat * restrict z,
                              const int    * restrict mapB,
                                   dfloat  * restrict rhsP){
  
  for(dlong e=0;e<Nelements;e++;outer0){
    shared dfloat s_p[p_Nq][p_Nq][p_Nq];
    shared dfloat s_ndp[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_pr[p_Nq], r_ps[p_Nq], r_pt[p_Nq], r_rhsp[p_Nq];
    exclusive dfloat r_G00[p_Nq], r_G01[p_Nq], r_G02[p_Nq], r_G11[p_Nq];
    exclusive dfloat r_G12[p_Nq], r_G22[p_Nq], r_GwJ[p_Nq];

    // loop over slabs
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          s_p  [k][j][i] = 0.;
          s_ndp[k][j][i] = 0.;
        }
        
        s_D[j][i] = D[j*p_Nq+i];
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i;

        surfaceTerms(sk0,0,i,j,0     );
        surfaceTerms(sk5,5,i,j,p_Nq-1);
      }
    }


    barrier(localMemFence);

    // for all face nodes of all elements
    // face 1 & 3
    for(int k=0;k<p_Nq;++k;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i;

        surfaceTerms(sk1,1,i,0     ,k);
        surfaceTerms(sk3,3,i,p_Nq-1,k);
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 2 & 4
    for(int k=0;k<p_Nq;++k;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j;

        surfaceTerms(sk2,2,p_Nq-1,j,k);
        surfaceTerms(sk4,4,0     ,j,k);
      }
    }

    barrier(localMemFence);
    
    // loop over slabs
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          const dlong base = e*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

          // assumes w*J built into G entries
          r_GwJ[k] = ggeo[base+p_GWJID*p_Np];
          r_G00[k] = ggeo[base+p_G00ID*p_Np];
          r_G01[k] = ggeo[base+p_G01ID*p_Np];
          r_G02[k] = ggeo[base+p_G02ID*p_Np];
          r_G11[k] = ggeo[base+p_G11ID*p_Np];
          r_G12[k] = ggeo[base+p_G12ID*p_Np];
          r_G22[k] = ggeo[base+p_G22ID*p_Np];

          dfloat pr = 0.f, ps = 0.f, pt = 0.f;
          
          occaUnroll(p_Nq)
            for(int n=0; n<p_Nq; ++n){
              const dfloat Dr = s_D[i][n];
              const dfloat Ds = s_D[j][n];
              const dfloat Dt = s_D[k][n];

              pr += Dr*s_p[k][j][n];
              ps += Ds*s_p[k][n][i];
              pt += Dt*s_p[n][j][i];
            }
          
          r_pr[k] = pr; r_ps[k] = ps; r_pt[k] = pt; 
        }
      }
    }

    // r term ----->
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          s_p[k][j][i] = r_G00[k]*r_pr[k] + r_G01[k]*r_ps[k] + r_G02[k]*r_pt[k];
        }
      }
    }
      
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          dfloat ptmp = 0.f;
          occaUnroll(p_Nq)
            for(int n=0;n<p_Nq;++n) {
              const dfloat Dr = s_D[n][i];
              ptmp += Dr*s_p[k][j][n];
            }

          r_rhsp[k] = ptmp;
        }
      }
    }

    // s term ----->
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          s_p[k][j][i] = r_G01[k]*r_pr[k] + r_G11[k]*r_ps[k] + r_G12[k]*r_pt[k];
        }
      }
    }
      
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          dfloat ptmp = 0.f;
          occaUnroll(p_Nq)
            for(int n=0;n<p_Nq;++n) {
              const dfloat Ds = s_D[n][j];
              ptmp += Ds*s_p[k][n][i];
            }

          r_rhsp[k] += ptmp;
        }
      }
    }

    // t term ---->
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          s_p[k][j][i] = r_G02[k]*r_pr[k] + r_G12[k]*r_ps[k] + r_G22[k]*r_pt[k];
        }
      }
    }
      
    barrier(localMemFence);

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          dfloat ptmp = 0.f;
          occaUnroll(p_Nq) 
            for(int n=0;n<p_Nq;++n) {
              const dfloat Dt = s_D[n][k];
              ptmp += Dt*s_p[n][j][i];
            }
          
          r_rhsp[k] += ptmp;

          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          rhsP[id] -= r_rhsp[k] + s_ndp[k][j][i];
        }
      }
    }
  }
}

kernel void insPoissonAddBCHex3D(const dlong Nelements,
                                  const int pressure_solve,
                                  const dfloat time,
                                  const dfloat dt,
                                  const dfloat * restrict x,
                                  const dfloat * restrict y,
                                  const dfloat * restrict z,
                                  const dlong  * restrict vmapM,
                                  const int    * restrict mapB,
                                        dfloat * restrict P){
  
  for(dlong e=0;e<Nelements;e++;outer0){
    for(int n=0;n<p_Nfp*p_Nfaces;++n;inner0){
      const dlong idM = vmapM[e*p_Nfp*p_Nfaces + n];
      const int bc = mapB[idM];

      if(bc>0) {
        const dfloat pM = P[idM];
        dfloat pP = 0.f;
        insPressureDirichletConditions3D(bc,time, x[idM], y[idM], z[idM], nx, ny, nz, pM, &pP);
        if(pressure_solve==0 && bc==3){ // if on an outflow BC and the pressure increment is in use
          dfloat pPm1 = 0.f;
          insPressureDirichletConditions3D(bc,time-dt, x[idM], y[idM], z[idM], nx, ny, nz, pM, &pPm1);
          pP = pP - pPm1;
        }
        P[idM] = pP;
      }    
    }
  }
}
