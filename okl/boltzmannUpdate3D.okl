//
#define QXID1 0  
#define QXID2 1  
#define QXID3 2
#define QXID4 3  
#define QXID5 4  
#define QXID6 5  
#define QXID8 6 
//
#define QYID1 7  
#define QYID2 8  
#define QYID3 9
#define QYID4 10  
#define QYID5 11  
#define QYID7 12  
#define QYID9 13 
//
#define QZID1 14  
#define QZID2 15  
#define QZID3 16
#define QZID4 17  
#define QZID6 18  
#define QZID7 19  
#define QZID10  20   
kernel void boltzmannLSERKUpdate3D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat dt,	
				    const dfloat rka,
				    const dfloat rkb,
				    const dfloat4 * restrict rhsq,
				          dfloat4 * restrict resq,
				          dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);

      dfloat4 resqa = resq[base+0], resqb = resq[base+1], resqc = resq[base+2];
      dfloat4 rhsqa = rhsq[base+0], rhsqb = rhsq[base+1], rhsqc = rhsq[base+2];
      dfloat4 qa    = q[base+0],    qb    = q[base+1],    qc    = q[base+2];

      resqa = rka*resqa + dt*rhsqa;
      resqb = rka*resqb + dt*rhsqb;
      resqc = rka*resqc + dt*rhsqc;

      qa += rkb*resqa;
      qb += rkb*resqb;
      qc += rkb*resqc;
      
      resq[base+0] = resqa;
      resq[base+1] = resqb;
      resq[base+2] = resqc;
      
      q[base+0] = qa;
      q[base+1] = qb;
      q[base+2] = qc;
    }
  }
}


kernel void boltzmannSARK3StageUpdate3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat expdt, 
            const dfloat rka,
            const dfloat erka,
            const dfloat rkb,
            const dfloat erkb,
            const dfloat4 * restrict rhsq1,
            const dfloat4 * restrict rhsq2,
            const dfloat4 * restrict qold,
                  dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);

      dfloat4 rhsq1a = rhsq1[base+0], rhsq1b = rhsq1[base+1], rhsq1c = rhsq1[base+2];
      dfloat4 rhsq2a = rhsq2[base+0], rhsq2b = rhsq2[base+1], rhsq2c = rhsq2[base+2];
      //
      dfloat4 qoa = qold[base+0], qob = qold[base+1], qoc = qold[base+2];
      
      //
      dfloat4 qa, qb, qc;
      qa.x   = qoa.x + dt*( rka*rhsq1a.x + rkb*rhsq2a.x ); 
      qa.y   = qoa.y + dt*( rka*rhsq1a.y + rkb*rhsq2a.y ); 
      qa.z   = qoa.z + dt*( rka*rhsq1a.z + rkb*rhsq2a.z ); 
      qa.w   = qoa.w + dt*( rka*rhsq1a.w + rkb*rhsq2a.w ); 
     
      qb.x   = expdt*qob.x + dt*( erka* rhsq1b.x + erkb* rhsq2b.x ); 
      qb.y   = expdt*qob.y + dt*( erka* rhsq1b.y + erkb* rhsq2b.y ); 
      qb.z   = expdt*qob.z + dt*( erka* rhsq1b.z + erkb* rhsq2b.z ); 
      qb.w   = expdt*qob.w + dt*( erka* rhsq1b.w + erkb* rhsq2b.w ); 

      qc.x   = expdt*qoc.x + dt*( erka* rhsq1c.x + erkb* rhsq2c.x ); 
      qc.y   = expdt*qoc.y + dt*( erka* rhsq1c.y + erkb* rhsq2c.y ); 
      

      q[base+0] = qa;
      q[base+1] = qb;
      q[base+2] = qc;

    }
  }
}



kernel void boltzmannSARK3Update3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat expdt, 
            const dfloat rka,
            const dfloat erka,
            const dfloat rkb,
            const dfloat erkb,
            const dfloat rkc,
            const dfloat erkc,
            const dfloat4 * restrict rhsq1,
            const dfloat4 * restrict rhsq2,
            const dfloat4 * restrict rhsq3,
                  dfloat4 * restrict qold,
                  dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);
      dfloat4 rhsq1a = rhsq1[base+0], rhsq1b = rhsq1[base+1], rhsq1c = rhsq1[base+2];
      dfloat4 rhsq2a = rhsq2[base+0], rhsq2b = rhsq2[base+1], rhsq2c = rhsq2[base+2];
      dfloat4 rhsq3a = rhsq3[base+0], rhsq3b = rhsq3[base+1], rhsq3c = rhsq3[base+2];
      dfloat4    qoa = qold[base+0],     qob = qold[base+1],     qoc = qold[base+2];
      
      //
      dfloat4 qa, qb, qc;
      qa.x   = qoa.x + dt*( rka*rhsq1a.x + rkb*rhsq2a.x + rkc*rhsq3a.x ); 
      qa.y   = qoa.y + dt*( rka*rhsq1a.y + rkb*rhsq2a.y + rkc*rhsq3a.y ); 
      qa.z   = qoa.z + dt*( rka*rhsq1a.z + rkb*rhsq2a.z + rkc*rhsq3a.z ); 
      qa.w   = qoa.w + dt*( rka*rhsq1a.w + rkb*rhsq2a.w + rkc*rhsq3a.w ); 
     
      qb.x   = expdt*qob.x + dt*( erka* rhsq1b.x + erkb* rhsq2b.x + erkc*rhsq3b.x ); 
      qb.y   = expdt*qob.y + dt*( erka* rhsq1b.y + erkb* rhsq2b.y + erkc*rhsq3b.y ); 
      qb.z   = expdt*qob.z + dt*( erka* rhsq1b.z + erkb* rhsq2b.z + erkc*rhsq3b.z ); 
      qb.w   = expdt*qob.w + dt*( erka* rhsq1b.w + erkb* rhsq2b.w + erkc*rhsq3b.w ); 

      qc.x   = expdt*qoc.x + dt*( erka* rhsq1c.x + erkb* rhsq2c.x + erkc*rhsq3c.x); 
      qc.y   = expdt*qoc.y + dt*( erka* rhsq1c.y + erkb* rhsq2c.y + erkc*rhsq3c.y); 
      

      q[base+0] = qa;
      q[base+1] = qb;
      q[base+2] = qc;

      //
      qold[base+0] = qa;
      qold[base+1] = qb;
      qold[base+2] = qc;


    }
  }
}



kernel void boltzmannSAAB3Update3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat expdt, 
            const dfloat ab1,
            const dfloat ab2,
            const dfloat ab3,
            const dfloat saab1,
            const dfloat saab2,
            const dfloat saab3,
                  dfloat4 * restrict rhsq3,
                  dfloat4 * restrict rhsq2,
                  dfloat4 * restrict rhsq1,
                  dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint base = 3*(n + element*p_Np);
      dfloat4 rhsq1a = rhsq1[base+0], rhsq1b = rhsq1[base+1], rhsq1c = rhsq1[base+2];
      dfloat4 rhsq2a = rhsq2[base+0], rhsq2b = rhsq2[base+1], rhsq2c = rhsq2[base+2];
      dfloat4 rhsq3a = rhsq3[base+0], rhsq3b = rhsq3[base+1], rhsq3c = rhsq3[base+2];
      //
      dfloat4 qa = q[base+0], qb = q[base+1], qc = q[base+2];
      //
      qa.x   += ab1*rhsq1a.x + ab2*rhsq2a.x + ab3*rhsq3a.x; 
      qa.y   += ab1*rhsq1a.y + ab2*rhsq2a.y + ab3*rhsq3a.y; 
      qa.z   += ab1*rhsq1a.z + ab2*rhsq2a.z + ab3*rhsq3a.z; 
      qa.w   += ab1*rhsq1a.w + ab2*rhsq2a.w + ab3*rhsq3a.w; 
     
      qb.x   = expdt*qb.x + saab1*rhsq1b.x + saab2*rhsq2b.x + saab3*rhsq3b.x; 
      qb.y   = expdt*qb.y + saab1*rhsq1b.y + saab2*rhsq2b.y + saab3*rhsq3b.y; 
      qb.z   = expdt*qb.z + saab1*rhsq1b.z + saab2*rhsq2b.z + saab3*rhsq3b.z; 
      qb.w   = expdt*qb.w + saab1*rhsq1b.w + saab2*rhsq2b.w + saab3*rhsq3b.w; 

      qc.x   = expdt*qc.x + saab1*rhsq1c.x + saab2*rhsq2c.x + saab3*rhsq3c.x; 
      qc.y   = expdt*qc.y + saab1*rhsq1c.y + saab2*rhsq2c.y + saab3*rhsq3c.y; 
      //           
      rhsq3[base+0] = rhsq2a;
      rhsq3[base+1] = rhsq2b;
      rhsq3[base+2] = rhsq2c;
      //
      rhsq2[base+0] = rhsq1a;
      rhsq2[base+1] = rhsq1b;
      rhsq2[base+2] = rhsq1c;
      //
      q[base+0] = qa;
      q[base+1] = qb;
      q[base+2] = qc;
    }
  }
}





// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXResidualUpdate3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat aki,
            const dfloat ake, 
            const dfloat4 * restrict q,
            const dfloat4 * restrict qZ,
                  dfloat4 * restrict qY){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);
      
      dfloat4 qima = qZ[base+0], qimb = qZ[base+1], qimc = qZ[base+2];
      dfloat4 qexa = qY[base+0], qexb = qY[base+1], qexc = qY[base+2];
      dfloat4 qa   = q[base+0],  qb   = q[base+1],  qc   = q[base+2];
      //
      qY[base+0] = qa + ake*dt*qexa + aki*dt*qima;
      qY[base+1] = qb + ake*dt*qexb + aki*dt*qimb;
      qY[base+2] = qc + ake*dt*qexc + aki*dt*qimc;
      

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXImplicitUpdate3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat4 * restrict qZ,
            const dfloat4 * restrict qY,
                  dfloat4 * restrict q,
                  dfloat4 * restrict qS){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      //
      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);

      dfloat4 qima = qZ[base+0], qimb = qZ[base+1], qimc = qZ[base+2];
      dfloat4 qexa = qY[base+0], qexb = qY[base+1], qexc = qY[base+2];
      dfloat4 qa   = q[base+0],  qb   = q[base+1],  qc   = q[base+2];
      //
      qS[base+0] = qa; 
      qS[base+1] = qb; 
      qS[base+2] = qc; 
      //
      q[base+0] = qexa + akk*dt*qima;
      q[base+1] = qexb + akk*dt*qimb; 
      q[base+2] = qexc + akk*dt*qimc;       

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXUpdate3D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat4 * restrict qZ,
            const dfloat4 * restrict qY,
            const dfloat4 * restrict qS,
                  dfloat4 * restrict q){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){

      const iint element = elementIds[e];
      const iint base = 3*(n + element*p_Np);

      dfloat4 qima = qZ[base+0], qimb = qZ[base+1], qimc = qZ[base+2];
      dfloat4 qexa = qY[base+0], qexb = qY[base+1], qexc = qY[base+2];
      dfloat4 qa   = qS[base+0],  qb  = qS[base+1], qc   = qS[base+2];
      //
      q[base+0] = qa + akk*dt*(qima + qexa);
      q[base+1] = qb + akk*dt*(qimb + qexb); 
      q[base+2] = qc + akk*dt*(qimc + qexc);   
    }
  }
}





kernel void boltzmannLSERKPmlUpdate3D(const iint Nelements,
              const iint * restrict elementIds, 
              const dfloat dt,  
              const dfloat rka,
              const dfloat rkb,
              const dfloat ramp, 
              const dfloat4 * restrict rhsq, 
              const dfloat * restrict rhspmlq,
                    dfloat4 * restrict resq,
                    dfloat * restrict respmlq,
                    dfloat * restrict pmlq,
                    dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){

      const iint element = elementIds[e];

      const iint base = element*p_Np*p_pmlNfields+n;
      
        // No-Need to Qx7 Qx9 Qx10
      dfloat resqx1 =  respmlq[base+QXID1*p_Np];
      dfloat resqx2 =  respmlq[base+QXID2*p_Np];
      dfloat resqx3 =  respmlq[base+QXID3*p_Np];
      dfloat resqx4 =  respmlq[base+QXID4*p_Np];
      dfloat resqx5 =  respmlq[base+QXID5*p_Np];
      dfloat resqx6 =  respmlq[base+QXID6*p_Np];
      dfloat resqx8 =  respmlq[base+QXID8*p_Np];  
      // No-Need to Qy6 Qy8 Qy10
      dfloat resqy1 =  respmlq[base+QYID1*p_Np];
      dfloat resqy2 =  respmlq[base+QYID2*p_Np];
      dfloat resqy3 =  respmlq[base+QYID3*p_Np];
      dfloat resqy4 =  respmlq[base+QYID4*p_Np];
      dfloat resqy5 =  respmlq[base+QYID5*p_Np];
      dfloat resqy7 =  respmlq[base+QYID7*p_Np];
      dfloat resqy9 =  respmlq[base+QYID9*p_Np];
      // No-Need to Qz5 Qz8 Qz9
      dfloat resqz1 = respmlq[base+QZID1 *p_Np];
      dfloat resqz2 = respmlq[base+QZID2 *p_Np];
      dfloat resqz3 = respmlq[base+QZID3 *p_Np];
      dfloat resqz4 = respmlq[base+QZID4 *p_Np];
      dfloat resqz6 = respmlq[base+QZID6 *p_Np];
      dfloat resqz7 = respmlq[base+QZID7 *p_Np];
      dfloat resqz10= respmlq[base+QZID10*p_Np];

        // No-Need to Qx7 Qx9 Qx10
      dfloat rhsqx1 = rhspmlq[base+QXID1*p_Np];
      dfloat rhsqx2 = rhspmlq[base+QXID2*p_Np];
      dfloat rhsqx3 = rhspmlq[base+QXID3*p_Np];
      dfloat rhsqx4 = rhspmlq[base+QXID4*p_Np];
      dfloat rhsqx5 = rhspmlq[base+QXID5*p_Np];
      dfloat rhsqx6 = rhspmlq[base+QXID6*p_Np];
      dfloat rhsqx8 = rhspmlq[base+QXID8*p_Np];  
      // No-Need to Qy6 Qy8 Qy10
      dfloat rhsqy1 = rhspmlq[base+QYID1*p_Np];
      dfloat rhsqy2 = rhspmlq[base+QYID2*p_Np];
      dfloat rhsqy3 = rhspmlq[base+QYID3*p_Np];
      dfloat rhsqy4 = rhspmlq[base+QYID4*p_Np];
      dfloat rhsqy5 = rhspmlq[base+QYID5*p_Np];
      dfloat rhsqy7 = rhspmlq[base+QYID7*p_Np];
      dfloat rhsqy9 = rhspmlq[base+QYID9*p_Np];
      // No-Need to Qz5 Qz8 Qz9
      dfloat rhsqz1  = rhspmlq[base+QZID1 *p_Np];
      dfloat rhsqz2  = rhspmlq[base+QZID2 *p_Np];
      dfloat rhsqz3  = rhspmlq[base+QZID3 *p_Np];
      dfloat rhsqz4  = rhspmlq[base+QZID4 *p_Np];
      dfloat rhsqz6  = rhspmlq[base+QZID6 *p_Np];
      dfloat rhsqz7  = rhspmlq[base+QZID7 *p_Np];
      dfloat rhsqz10 = rhspmlq[base+QZID10*p_Np];
      
      resqx1 = rka*resqx1 + dt*rhsqx1;
      resqx2 = rka*resqx2 + dt*rhsqx2;
      resqx3 = rka*resqx3 + dt*rhsqx3;
      resqx4 = rka*resqx4 + dt*rhsqx4;
      resqx5 = rka*resqx5 + dt*rhsqx5;
      resqx6 = rka*resqx6 + dt*rhsqx6;
      resqx8 = rka*resqx8 + dt*rhsqx8;

      resqy1 = rka*resqy1 + dt*rhsqy1;
      resqy2 = rka*resqy2 + dt*rhsqy2;
      resqy3 = rka*resqy3 + dt*rhsqy3;
      resqy4 = rka*resqy4 + dt*rhsqy4;
      resqy5 = rka*resqy5 + dt*rhsqy5;
      resqy7 = rka*resqy7 + dt*rhsqy7;
      resqy9 = rka*resqy9 + dt*rhsqy9;

      resqz1  = rka*resqz1  + dt*rhsqz1 ;
      resqz2  = rka*resqz2  + dt*rhsqz2 ;
      resqz3  = rka*resqz3  + dt*rhsqz3 ;
      resqz4  = rka*resqz4  + dt*rhsqz4 ;
      resqz6  = rka*resqz6  + dt*rhsqz6 ;
      resqz7  = rka*resqz7  + dt*rhsqz7 ;
      resqz10 = rka*resqz10 + dt*rhsqz10;

      pmlq[base+QXID1*p_Np] += rkb*resqx1;
      pmlq[base+QXID2*p_Np] += rkb*resqx2;
      pmlq[base+QXID3*p_Np] += rkb*resqx3;
      pmlq[base+QXID4*p_Np] += rkb*resqx4;
      pmlq[base+QXID5*p_Np] += rkb*resqx5;
      pmlq[base+QXID6*p_Np] += rkb*resqx6;
      pmlq[base+QXID8*p_Np] += rkb*resqx8;  
      // No-Need to Qy6 Qy8 Qy10
      pmlq[base+QYID1*p_Np] += rkb*resqy1;
      pmlq[base+QYID2*p_Np] += rkb*resqy2;
      pmlq[base+QYID3*p_Np] += rkb*resqy3;
      pmlq[base+QYID4*p_Np] += rkb*resqy4;
      pmlq[base+QYID5*p_Np] += rkb*resqy5;
      pmlq[base+QYID7*p_Np] += rkb*resqy7;
      pmlq[base+QYID9*p_Np] += rkb*resqy9;
      // No-Need to Qz5 Qz8 Qz9
      pmlq[base+QZID1 *p_Np] += rkb*resqz1 ;
      pmlq[base+QZID2 *p_Np] += rkb*resqz2 ;
      pmlq[base+QZID3 *p_Np] += rkb*resqz3 ;
      pmlq[base+QZID4 *p_Np] += rkb*resqz4 ;
      pmlq[base+QZID6 *p_Np] += rkb*resqz6 ;
      pmlq[base+QZID7 *p_Np] += rkb*resqz7 ;
      pmlq[base+QZID10*p_Np] += rkb*resqz10;
      //
      respmlq[base+QXID1*p_Np] = resqx1;
      respmlq[base+QXID2*p_Np] = resqx2;
      respmlq[base+QXID3*p_Np] = resqx3;
      respmlq[base+QXID4*p_Np] = resqx4;
      respmlq[base+QXID5*p_Np] = resqx5;
      respmlq[base+QXID6*p_Np] = resqx6;
      respmlq[base+QXID8*p_Np] = resqx8;  
      // No-Need to Qy6 Qy8 Qy10
      respmlq[base+QYID1*p_Np] = resqy1;
      respmlq[base+QYID2*p_Np] = resqy2;
      respmlq[base+QYID3*p_Np] = resqy3;
      respmlq[base+QYID4*p_Np] = resqy4;
      respmlq[base+QYID5*p_Np] = resqy5;
      respmlq[base+QYID7*p_Np] = resqy7;
      respmlq[base+QYID9*p_Np] = resqy9;
      // No-Need to Qz5 Qz8 Qz9
      respmlq[base+QZID1 *p_Np] = resqz1 ;
      respmlq[base+QZID2 *p_Np] = resqz2 ;
      respmlq[base+QZID3 *p_Np] = resqz3 ;
      respmlq[base+QZID4 *p_Np] = resqz4 ;
      respmlq[base+QZID6 *p_Np] = resqz6 ;
      respmlq[base+QZID7 *p_Np] = resqz7 ;
      respmlq[base+QZID10*p_Np] = resqz10;
      

      const iint id   = 3*(n + element*p_Np); 
      dfloat4 resqa = resq[id+0], resqb = resq[id+1], resqc = resq[id+2];
      dfloat4 rhsqa = rhsq[id+0], rhsqb = rhsq[id+1], rhsqc = rhsq[id+2];
      dfloat4 qa    = q[id+0],    qb    = q[id+1],    qc    = q[id+2];

      resqa = rka*resqa + dt*rhsqa;
      resqb = rka*resqb + dt*rhsqb;
      resqc = rka*resqc + dt*rhsqc;

      qa += rkb*resqa;
      qb += rkb*resqb;
      qc += rkb*resqc;
      
      resq[id+0] = resqa;
      resq[id+1] = resqb;
      resq[id+2] = resqc;
      
      q[id+0] = qa;
      q[id+1] = qb;
      q[id+2] = qc;

      
    }
  }
}