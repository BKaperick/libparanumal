kernel void boltzmannFilterVQuad3D(const iint Nelements,
				   const iint * restrict elementIds,
				   const dfloat * restrict F,
				   const iint * restrict cubeFaceNumber,
				   const iint * restrict EToE,
				   const dfloat * restrict qIn,
				   dfloat * restrict Fq) {
  
  for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
    shared dfloat s_F[3][p_Nq][p_Nq];
    shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
    exclusive iint eC, eL, eR, faceC, faceL, faceR;
    
    for (iint j=0;j<p_Nq; ++j; inner1) {
      for (iint i=0; i<p_Nq; ++i; inner0) {
	s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
	s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
	s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];
	
	eC = elementIds[eo];
	eL = EToE[eC*p_Nfaces+0];
	eR = EToE[eC*p_Nfaces+2];
	faceC = cubeFaceNumber[eC];
	faceL = cubeFaceNumber[eL];
	faceR = cubeFaceNumber[eR];
	
	occaUnroll(p_Nfields)
	  for(iint fld=0;fld<p_Nfields;++fld){
	    s_q[fld][1][j][i] = qIn[eC*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
	    
	    if(faceC==faceL)
	      s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
	    if(faceC==faceR)
	      s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
	  }
      }
    }

    barrier(localMemFence);

    for (iint j=0;j<p_Nq; ++j; inner1) {
      for (iint i=0; i<p_Nq; ++i; inner0) {
	dfloat Fqij[p_Nfields];
	if(faceC==faceL && faceC==faceR){
	  
	  occaUnroll(p_Nfields)
	    for(iint fld=0;fld<p_Nfields;++fld){
	      Fqij[fld] = 0;
	    }
	  
	  occaUnroll(p_Nq)
	    for(int n=0;n<p_Nq;++n){
	      // fetch once, use p_Nfields times
	      const dfloat FinL = s_F[0][j][n];
	      const dfloat FinC = s_F[1][j][n];
	      const dfloat FinR = s_F[2][j][n];
	      
	      // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
	      occaUnroll(p_Nfields)
		for(iint fld=0;fld<p_Nfields;++fld){
		  Fqij[fld] += FinL*s_q[fld][0][n][i];
		  Fqij[fld] += FinC*s_q[fld][1][n][i];
		  Fqij[fld] += FinR*s_q[fld][2][n][i];
		}
	    }
	}
	else{
	  
	  occaUnroll(p_Nfields)
	    for(iint fld=0;fld<p_Nfields;++fld){
	      Fqij[fld] = s_q[fld][1][j][i];
	    }
	}
	
	occaUnroll(p_Nfields)
	  for(iint fld=0;fld<p_Nfields;++fld){
	    Fq[eC*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
	  }
      }
    }
  }
}

kernel void boltzmannFilterVQuad3Dold(const iint Nelements,
				   const iint * restrict elementIds,
				   const dfloat * restrict dualMatrix,
				   const iint * restrict cubeFaceNumber,
				   const iint * restrict EToE,
				   const dfloat * restrict qIn,
				   dfloat * restrict qOut) {

  for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
      for (iint i=0; i<p_Nq; ++i; inner1) {
	for (iint j=0; j<p_Nq; ++j; inner0) {
	  
	  dfloat localMatrix[3*p_Nq];
	  iint eA[3];
	  dfloat qLocal[p_Nq*3];

	  eA[1] = elementIds[eo]; //center element

	  eA[0] = EToE[eA[1]*p_Nfaces]; //left element
	  eA[2] = EToE[eA[1]*p_Nfaces+2]; //right element
	  
	  //put filter matrix in L1 (one row only)
	  for (iint k = 0; k < 3*p_Nq; ++k) {
	    localMatrix[k] = dualMatrix[i*3*p_Nq + k];
	  }
	  
	  const iint faceC = cubeFaceNumber[eA[1]];
	  const iint faceL = cubeFaceNumber[eA[0]];
	  const iint faceR = cubeFaceNumber[eA[2]];
	  
	  if((faceC == faceL) && (faceC == faceR)) {

	    for (iint fld=0; fld<p_Nfields; ++fld) {
	    
	    for (iint k0 = 0; k0 < 3; ++k0) {
	      for (iint k1 = 0; k1 < p_Nq; ++k1) {
		qLocal[k0*p_Nq + k1]
		  = qIn[eA[k0]*p_Nfields*p_Np + fld*p_Np + k1*p_Nq + j];
	      }
	    }

	      dfloat q_new = 0;
	      for (iint k=0;k<3*p_Nq;++k) {
		q_new += qLocal[k]*localMatrix[k];
	      }
	      qOut[eA[1]*p_Nfields*p_Np + fld*p_Np + i*p_Nq + j] = q_new;
	    }
	  }
	}
      }
    }
  }
}
