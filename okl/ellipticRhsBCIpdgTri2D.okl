kernel void ellipticRhsBCIpdgTri2D(const int Nelements,
            const iint * restrict vmapM,
            const iint * restrict vmapP,
            const dfloat tau,
            const dfloat t,
            const dfloat * restrict x,
            const dfloat * restrict y,
            const dfloat * restrict vgeo,
            const dfloat * restrict sgeo,
            const iint   * restrict EToB,
            const dfloat * restrict DrT,
            const dfloat * restrict DsT,
            const dfloat * restrict LIFTT,
            const dfloat * restrict MM,
            dfloat * restrict rhs){
  
  for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dudx[p_Np];
    shared  dfloat s_dudy[p_Np];
    shared  dfloat s_lapu[p_Np];
    shared  dfloat s_nxdu[p_NfacesNfp];
    shared  dfloat s_nydu[p_NfacesNfp];
    shared  dfloat s_lapuflux[p_NfacesNfp];
    shared  dfloat s_Lnxdu[p_Np];
    shared  dfloat s_Lnydu[p_Np];

    exclusive iint idM;
    exclusive dfloat nx, ny, sJ, invJ, hinv;
    
    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_NfacesNfp){
        const iint id  = n + e*p_Nfaces*p_Nfp;
        idM = vmapM[id];          
     
        const iint face = n/p_Nfp;

        dfloat dudxP=0, dudyP=0, uP=0;
        
        // load surface geofactors for this face
        iint sid = p_Nsgeo*(e*p_Nfaces+face);
        nx = sgeo[sid+p_NXID];
        ny = sgeo[sid+p_NYID];
        sJ = sgeo[sid+p_SJID];
        invJ = sgeo[sid+p_IJID];
        hinv = sgeo[sid+p_IHID];

        const int bc = EToB[face+p_Nfaces*e];
        if(bc>0) {
          ellipticBoundaryConditions2D(bc, t, x[idM], y[idM], nx, ny, \
                                        0.f, 0.f, 0.f,                \
                                        uP, dudxP, dudyP);
        }  

        const dfloat du = uP;
        const dfloat hlf = 1.f;
        
        s_nxdu[n] = hlf*sJ*invJ*nx*du;
        s_nydu[n] = hlf*sJ*invJ*ny*du;

        s_lapuflux[n] = hlf*sJ*invJ*(-nx*(dudxP)-ny*(dudyP) -tau*hinv*du);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
        const int gid = e*p_Nvgeo;
        const dfloat drdx = vgeo[gid + p_RXID];
        const dfloat drdy = vgeo[gid + p_RYID];
        const dfloat dsdx = vgeo[gid + p_SXID];
        const dfloat dsdy = vgeo[gid + p_SYID];

        dfloat Lnxdu = 0;
        dfloat Lnydu = 0;
              
        occaUnroll(p_NfacesNfp)
          for(iint i=0;i<p_NfacesNfp;++i){
            Lnxdu += LIFTT[n+i*p_Np]*s_nxdu[i];
            Lnydu += LIFTT[n+i*p_Np]*s_nydu[i];
          }
    
        dfloat dudx = Lnxdu;
        dfloat dudy = Lnydu;

        s_dudx[n] = drdx*dudx + drdy*dudy; // abuse of notation
        s_dudy[n] = dsdx*dudx + dsdy*dudy;

        s_Lnxdu[n] = Lnxdu;
        s_Lnydu[n] = Lnydu;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_NfacesNfp){
        iint id = idM%p_Np;
        s_lapuflux[n] += sJ*invJ*(nx*s_Lnxdu[id]+ny*s_Lnydu[id]);
      }

      if(n<p_Np){
        dfloat laur = 0, laus = 0;

        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i) {
          laur += DrT[n+i*p_Np]*s_dudx[i];
          laus += DsT[n+i*p_Np]*s_dudy[i];
        }

        s_lapu[n] = -(laur+laus);
      }
      
    }
    
    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
        dfloat lau = 0;
              
        // lift remaining surface terms
        occaUnroll(p_NfacesNfp)
        for(int i=0;i<p_NfacesNfp;++i){
          lau += LIFTT[n+i*p_Np]*s_lapuflux[i];
        }
              
        s_lapu[n] += lau;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
        const dfloat J = vgeo[e*p_Nvgeo + p_JID];
              
        dfloat Mlapu = 0;

        // multiply by mass matrix
        occaUnroll(p_Np)
        for(int i=0;i<p_Np;++i){
          Mlapu += MM[n+i*p_Np]*s_lapu[i];
        }
            
        const iint id = e*p_Np+n;
        rhs[id] -=  J*Mlapu;
      }
    }
  }
}
