// increments gradients of pressure with pseudo-gradients at faces and 
// increments rhs with pseudo-gradient/penalty terms at faces (need to double check scaling with tau)

// sgeo stores dfloat4s with nx,ny,nz,(sJ/J)*(w1*w2*w3/(ws1*ws2))

// nx,ny,nz,sJ,invJ - need WsJ


kernel void ellipticAxIpdgTri2D(const int Nelements,
				const iint * restrict vmapM,
				const iint * restrict vmapP,
				const dfloat lambda,
				const dfloat tau,
				const dfloat * restrict vgeo,
				const dfloat * restrict sgeo,
				const dfloat * restrict MDr,
				const dfloat * restrict MDs,
				const dfloat * restrict LIFT,
				const dfloat * restrict MLIFT,
				const dfloat4 * restrict gradq,
				dfloat  * restrict Aq){
  
#if 0
  // assume the following are precomputed:
  // p, px, py at SEM nodes
  // +/- traces of p, px, py at SEM surface nodes

  0<=i,j,k,m<=N AND 0<=e<Nelements

    (phix, px)_e
    + (phiy, py)_e 
    + (phix, nx*(p+ - p-)/2)_de
    + (phiy, ny*(p+ - p-)/2)_de
    - (phi-, nx*(px+ + px-)/2)_de
    - (phi-, ny*(py+ + py-)/2)_de
    - (phi-, tau*(p+ - p-)/2)_de

#endif

  for(int e=0;e<Nelements;++e;outer0){
    
    shared dfloat s_dqdx[p_Np];
    shared dfloat s_dqdy[p_Np];
    shared dfloat s_nxflux[p_NfacesNfp];
    shared dfloat s_nyflux[p_NfacesNfp];
    shared dfloat s_qflux[p_NfacesNfp];
    
    // loop over slabs
    for(int n=0;n<p_Nmax;++n;inner0){

      if(n<p_Np){
	// assume that this stores (p, px, py, pz) as dfloat4
	const dfloat4 gradqn = gradq[e*p_Np+n];
	
	s_dqdx[n] = gradqn.x;
	s_dqdy[n] = gradqn.y;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_Nmax;++n;inner0){

      if(n<p_NfacesNfp){
	const int id = n + e*p_Nfaces*p_Nfp;
	const iint  idM = vmapM[id];					
	const iint  idP = vmapP[id];					

	const dfloat4 gradqM = gradq[idM];					
	const dfloat4 gradqP = gradq[idP];					
	
	// find face that owns this node
	iint face = n/p_Nfp;
	
	// load surface geofactors for this face
	iint sid = p_Nsgeo*(e*p_Nfaces+face);
	dfloat nx = sgeo[sid+p_NXID];
	dfloat ny = sgeo[sid+p_NYID];
	dfloat sJ = sgeo[sid+p_SJID];
	dfloat invJ = sgeo[sid+p_IJID];
	dfloat hinv = sgeo[sid+p_IHID];
	
	const dfloat sc = (idP==idM) ? -1.f:1.f;				
	
	dfloat dq = gradqP.w - gradqM.w;					
	
	s_nxflux[n] = 0.5f*sJ*invJ*nx*dq;
	s_nyflux[n] = 0.5f*sJ*invJ*ny*dq;
	s_qflux[n] = -0.5f*sJ*invJ*(nx*(sc*gradqP.x+gradqM.x) + ny*(sc*gradqP.y+gradqM.y)  + tau*hinv*dq);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_Nmax;++n;inner0){

      if(n<p_Np){
	const int gid = e*p_Nvgeo;
	const dfloat drdx = vgeo[gid + p_RXID];
	const dfloat drdy = vgeo[gid + p_RYID];
	const dfloat dsdx = vgeo[gid + p_SXID];
	const dfloat dsdy = vgeo[gid + p_SYID];
	
	dfloat dqdx = s_dqdx[n];
	dfloat dqdy = s_dqdy[n];
	for(iint i=0;i<p_NfacesNfp;++i){
	  dqdx += LIFT[n+i*p_Np]*s_nxflux[i];
	  dqdy += LIFT[n+i*p_Np]*s_nyflux[i];
	}
	s_dqdx[n] = drdx*dqdx + drdy*dqdy;
	s_dqdy[n] = dsdx*dqdx + dsdy*dqdy;
      }
    }

    barrier(localMemFence);

    // loop over slabs
    for(int n=0;n<p_Nmax;++n;inner0){

      if(n<p_Np){
	const dfloat J = vgeo[e*p_Nvgeo + p_JID];
	
	dfloat dr = 0, ds = 0, Aqn = 0;

	// weak derivative
	for(int i=0;i<p_Np;++i){
	  // multiply by  (MDr)^t, (MDs)^t
	  dr += MDr[n+i*p_Np]*s_dqdx[i];
	  ds += MDs[n+i*p_Np]*s_dqdy[i];
	}

	// lift surface terms
	for(int i=0;i<p_NfacesNfp;++i){
	  Aqn += MLIFT[n+i*p_Np]*s_qflux[i];
	}
	
	iint id = e*p_Np + n;
	Aq[id] = J*(Aqn + dr + ds);
      }
    }
  }
}
