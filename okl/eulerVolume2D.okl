#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// cDrT,cDsT into shared
kernel void eulerVolume2D(const iint Nelements,
			  const dfloat * restrict vgeo,
			  const dfloat * restrict cubInterpT,
			  const dfloat * restrict cubDrWT,
			  const dfloat * restrict cubDsWT,
			  const dfloat4 * restrict q4,
			  dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_U[p_NblockV][p_Np];
    shared dfloat s_V[p_NblockV][p_Np];
    shared dfloat s_R[p_NblockV][p_Np];

    shared dfloat s_cubRfluxr[p_NblockV][p_cubNp];
    shared dfloat s_cubRfluxs[p_NblockV][p_cubNp];
    shared dfloat s_cubUfluxr[p_NblockV][p_cubNp];
    shared dfloat s_cubUfluxs[p_NblockV][p_cubNp];
    shared dfloat s_cubVfluxr[p_NblockV][p_cubNp];
    shared dfloat s_cubVfluxs[p_NblockV][p_cubNp];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxVolumeNodes;++n;inner0){     // for all nodes in this element
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_Np){
	    const iint id = e*p_Np + n;
	    const dfloat4 q4n = q4[id];
	    s_R[es][n] = q4n.x;      	    
	    s_U[es][n] = q4n.y;
	    s_V[es][n] = q4n.z;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){ // for all elements in block
      for(iint n=0;n<p_maxVolumeNodes;++n;inner0){    
	iint e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_cubNp){

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	    dfloat cubR = 0.f, cubU = 0.f, cubV = 0.f;
	    
	    for(iint m=0;m<p_Np;++m){
	      cubR += cubInterpT[m*p_cubNp+n]*s_R[es][m];		      
	      cubU += cubInterpT[m*p_cubNp+n]*s_U[es][m];
	      cubV += cubInterpT[m*p_cubNp+n]*s_V[es][m];
	    }

	    
	    // (dphidx, U) + (dphidy, V)
	    s_cubRfluxr[es][n] = drdx*cubU + drdy*cubV;
	    s_cubRfluxs[es][n] = dsdx*cubU + dsdy*cubV;
	    
	    s_cubUfluxr[es][n] = drdx*(cubU*cubU/cubR + p_RT*cubR) + drdy*(cubU*cubV/cubR);
	    s_cubUfluxs[es][n] = dsdx*(cubU*cubU/cubR + p_RT*cubR) + dsdy*(cubU*cubV/cubR);

	    s_cubVfluxr[es][n] = drdx*(cubU*cubV/cubR) + drdy*(cubV*cubV/cubR + p_RT*cubR);
	    s_cubVfluxs[es][n] = dsdx*(cubU*cubV/cubR) + dsdy*(cubV*cubV/cubR + p_RT*cubR);

	  }
	}
      }
    }
    
    barrier(localMemfence);

    // weak derivatives
    for(iint es=0;es<p_NblockV;++es;inner1){ // for all elements in block
      for(iint n=0;n<p_maxVolumeNodes;++n;inner0){    
	iint e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Np){ // output at W&B nodes

	    // compute weak 'r' and 's' derivatives of volume fluxes at node n
	    dfloat rhsUr = 0, rhsVr = 0, rhsRr = 0;
	    dfloat rhsUs = 0, rhsVs = 0, rhsRs = 0;
	    
	    occaUnroll(p_cubNp)
	      for(iint i=0;i<p_cubNp;++i){
		// load data at node i of element e
#if 1
		const dfloat Drni = cubDrWT[i*p_Np+n];
		const dfloat Dsni = cubDsWT[i*p_Np+n];
#else
		const dfloat Drni = cubDrWT[i+n*p_cubNp];
		const dfloat Dsni = cubDsWT[i+n*p_cubNp];
#endif
		//		printf("Drni=%g Dsni=%g\n", Drni, Dsni);
		
		rhsRr += Drni*s_cubRfluxr[es][i];
		rhsUr += Drni*s_cubUfluxr[es][i];
		rhsVr += Drni*s_cubVfluxr[es][i];
			        
		rhsRs += Dsni*s_cubRfluxs[es][i];
		rhsUs += Dsni*s_cubUfluxs[es][i];
		rhsVs += Dsni*s_cubVfluxs[es][i];
	      }
	    
	    // store acoustics rhs contributions from weak differentiation
	    const iint id = e*p_Np + n;
	    dfloat4 rhsq4n;
	    rhsq4n.x = rhsRr+rhsRs;
	    rhsq4n.y = rhsUr+rhsUs;
	    rhsq4n.z = rhsVr+rhsVs;
	    rhsq4[id] = rhsq4n;
	  }
	}
      }
    }
  }
}
