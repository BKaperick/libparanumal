#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

// cDrT,cDsT into shared
kernel void eulerVolume2D(const iint Nelements,
			  const dfloat * restrict vgeo,
			  const dfloat * restrict cInterpT,
			  const dfloat * restrict cDrT,
			  const dfloat * restrict cDsT,
			  const dfloat4 * restrict q4,
			  dfloat4 * restrict rhsq4){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_U[p_NblockV][p_Np];
    shared dfloat s_V[p_NblockV][p_Np];
    shared dfloat s_R[p_NblockV][p_Np];

    shared dfloat s_cRfluxr[p_NblockV][p_Nc];
    shared dfloat s_cRfluxs[p_NblockV][p_Nc];
    shared dfloat s_cUfluxr[p_NblockV][p_Nc];
    shared dfloat s_cUfluxs[p_NblockV][p_Nc];
    shared dfloat s_cVfluxr[p_NblockV][p_Nc];
    shared dfloat s_cVfluxs[p_NblockV][p_Nc];

    shared dfloat s_cDrT[p_Nc][p_Np];
    shared dfloat s_cDsT[p_Nc][p_Np];
    shared dfloat s_cInterp[p_Np][p_Nc];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_maxNpNc;++n;inner0){     // for all nodes in this element
	// prefetch DrT, Ds into shared
	iint t = n + es*p_Np;
	while(t<p_Np*p_Nc){
	  s_cDrT[0][t] = cDrT[t]; // Nc x Np
	  s_cDsT[0][t] = cDsT[t]; // Nc x Np
	  s_cInterp[0][t] = cInterp[t]; // Np x Nc
	  t += p_maxNpNc*p_NblockV;
	}
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_np){
	    const iint id = e*p_Np + n;
	    const dfloat4 q4n = q4[id];
	    s_R[es][n] = q4n.x;      	    
	    s_U[es][n] = q4n.y;
	    s_V[es][n] = q4n.z;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){ // for all elements in block
      for(iint n=0;n<p_maxNpNc;++n;inner0){    
	iint e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Nc){

	    // prefetch geometric factors (constant on triangle)
	    const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	    const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	    const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	    const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	    
	    dfloat cR = 0.f, cU = 0.f, cV = 0.f;
	    
	    for(iint m=0;m<p_Np;++m){
	      cR += s_cInterp[m][n]*s_R[es][m];		      
	      cU += s_cInterp[m][n]*s_U[es][m];
	      cV += s_cInterp[m][n]*s_V[es][m];
	    }

	    s_cRfluxr[es][n] = -rx*cU - ry*cV;
	    s_cRfluxr[es][n] = -sx*cU - sy*cV;
	    
	    s_cUfluxr[es][n] = -rx*(cU*cU/cR + p_RT*cR) - ry*(cU*cV/cR);
	    s_cUfluxs[es][n] = -sx*(cU*cU/cR + p_RT*cR) - sy*(cU*cV/cR);

	    s_cVfluxr[es][n] = -rx*(cU*cV/cR) - ry*(cV*cV/cR + p_RT*cR);
	    s_cVfluxs[es][n] = -sx*(cU*cV/cR) - sy*(cV*cV/cR + p_RT*cR);
	  }
	}
      }
    }
    
    barrier(localMemfence);

    // weak derivatives
    for(iint es=0;es<p_NblockV;++es;inner1){ // for all elements in block
      for(iint n=0;n<p_maxNpNc;++n;inner0){    
	iint e = eo+es; // element in block
	if(e<Nelements){	 
	  if(n<p_Np){ // output at W&B nodes

	    // compute weak 'r' and 's' derivatives of volume fluxes at node n
	    dfloat rhsUr = 0, rhsVr = 0, rhsRr = 0;
	    dfloat rhsUs = 0, rhsVs = 0, rhsRs = 0;
	    
	    occaUnroll(p_Nc)
	      for(iint i=0;i<p_Nc;++i){
		// load data at node i of element e
		const dfloat Drni = s_cDrT[i][n];
		const dfloat Dsni = s_cDsT[i][n];

		rhsRr += Drni*s_cRfluxr[es][i];
		rhsUr += Drni*s_cUfluxr[es][i];
		rhsVr += Drni*s_cVfluxr[es][i];
		
		rhsRs += Dsni*s_cRfluxs[es][i];
		rhsUs += Dsni*s_cUfluxs[es][i];
		rhsVs += Dsni*s_cVfluxs[es][i];
	      }
	    
	    // store acoustics rhs contributions from weak differentiation
	    const iint id = e*p_Np + n;
	    dfloat4 rhsq4n;
	    rhsq4n.x = -rhsRr-rhsRs;
	    rhsq4n.y = -rhsUr-rhsUs;
	    rhsq4n.z = -rhsVr-rhsVs;
	    rhsq4[id] = rhsq4n;
	  }
	}
      }
    }
  }
}
