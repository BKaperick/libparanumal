
kernel void acousticsbbdgMRABVolume2D(const int Nelements,
          const int * restrict elementIds,
          const dfloat * restrict vgeo,
          const int * restrict D1ids,
          const int * restrict D2ids,
          const int * restrict D3ids,
          const dfloat * restrict Dvals,    
          const dfloat * restrict q,
          dfloat * restrict rhsq,
          const int rhsShift){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_u[p_NblockV][p_Np];
    shared dfloat s_v[p_NblockV][p_Np];
    shared dfloat s_p[p_NblockV][p_Np];

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

        int et = eo+es; // element in block

        if(et<Nelements){
          const int id = p_Nfields*(elementIds[et]*p_Np + n);
          s_u[es][n] = q[id+0];
          s_v[es][n] = q[id+1];
          s_p[es][n] = q[id+2];
        }
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
  
        int et = eo+es; // element in block
        if(et<Nelements){
          const int e = elementIds[et];

          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          // compute 'r' and 's' derivatives of (q_m) at node n
          const int D1i1 = D1ids[n];
          const int D2i1 = D2ids[n];
          const int D3i1 = D3ids[n];
          const dfloat Dval1 = Dvals[n];
          
          const int D1i2 = D1ids[n+p_Np];
          const int D2i2 = D2ids[n+p_Np];
          const int D3i2 = D3ids[n+p_Np];
          const dfloat Dval2 = Dvals[n+p_Np];

          const int D1i3 = D1ids[n+2*p_Np];
          const int D2i3 = D2ids[n+2*p_Np];
          const int D3i3 = D3ids[n+2*p_Np];    
          const dfloat Dval3 = Dvals[n+2*p_Np];

          const dfloat dudr = .5f*(Dval1*(s_u[es][D2i1] - s_u[es][D1i1]) +
                  Dval2*(s_u[es][D2i2] - s_u[es][D1i2]) +
                  Dval3*(s_u[es][D2i3] - s_u[es][D1i3]));
          const dfloat duds = .5f*(Dval1*(s_u[es][D3i1] - s_u[es][D1i1]) +
                  Dval2*(s_u[es][D3i2] - s_u[es][D1i2]) +
                  Dval3*(s_u[es][D3i3] - s_u[es][D1i3]));
          
          const dfloat dvdr = .5f*(Dval1*(s_v[es][D2i1] - s_v[es][D1i1]) +
                  Dval2*(s_v[es][D2i2] - s_v[es][D1i2]) +
                  Dval3*(s_v[es][D2i3] - s_v[es][D1i3]));
          const dfloat dvds = .5f*(Dval1*(s_v[es][D3i1] - s_v[es][D1i1]) +
                  Dval2*(s_v[es][D3i2] - s_v[es][D1i2]) +
                  Dval3*(s_v[es][D3i3] - s_v[es][D1i3]));
          
          const dfloat dpdr = .5f*(Dval1*(s_p[es][D2i1] - s_p[es][D1i1]) +
                  Dval2*(s_p[es][D2i2] - s_p[es][D1i2]) +
                  Dval3*(s_p[es][D2i3] - s_p[es][D1i3]));
          const dfloat dpds = .5f*(Dval1*(s_p[es][D3i1] - s_p[es][D1i1]) +
                  Dval2*(s_p[es][D3i2] - s_p[es][D1i2]) +
                  Dval3*(s_p[es][D3i3] - s_p[es][D1i3]));

          // chain rule
          dfloat dudx = drdx*dudr + dsdx*duds;
          dfloat dvdy = drdy*dvdr + dsdy*dvds;
          dfloat dpdx = drdx*dpdr + dsdx*dpds;
          dfloat dpdy = drdy*dpdr + dsdy*dpds;
          
          const int id = p_Nfields*(e*p_Np + n);
          const int rhsId = 3*id + p_Nfields*rhsShift;
          rhsq[rhsId+0] = -dpdx;
          rhsq[rhsId+1] = -dpdy;
          rhsq[rhsId+2] = -dudx-dvdy;
        }
      }
    }
  }
}
