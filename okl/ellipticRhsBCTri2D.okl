kernel void ellipticRhsBCTri2D(const int Nelements,
                              const dfloat * restrict ggeo,
                              const dfloat * restrict SrrT,
                              const dfloat * restrict SrsT,
                              const dfloat * restrict SsrT,
                              const dfloat * restrict SssT,
                              const dfloat * restrict MM,
                              const dfloat lambda,
                              const dfloat t,
                              const dfloat * restrict x,
                              const dfloat * restrict y,
                              const int    * restrict mapB,
                              dfloat  * restrict rhs){
  
  for(iint e=0;e<Nelements;e++;outer0){
    shared dfloat s_q[p_Np];

    for(int n=0;n<p_Np;++n;inner0){
      const iint id = n+e*p_Np;
      const int bc = mapB[n+e*p_Np];

      dfloat dudxP=0, dudyP=0, uP=0;

      if(bc>0) {
        ellipticBoundaryConditions2D(bc, t, x[id], y[id], nx, ny, \
                                      0.f, 0.f, 0.f,                \
                                      uP, dudxP, dudyP);
      }    

      s_q[n] = uP;
    }

    barrier(localMemFence);
    
    for(int n=0;n<p_Np;++n;inner0){
      const iint id = n + e*p_Np;
      const iint gid = e*p_Nggeo;
      const dfloat Grr = ggeo[gid + p_G00ID];
      const dfloat Grs = ggeo[gid + p_G01ID];
      const dfloat Gss = ggeo[gid + p_G11ID];
      const dfloat J   = ggeo[gid + p_GWJID];

      dfloat qrr = 0.;
      dfloat qrs = 0.;
      dfloat qsr = 0.;
      dfloat qss = 0.;
      dfloat qM = 0.;

      occaUnroll(p_Np)
        for (int k=0;k<p_Np;k++) {
          qrr += SrrT[n+k*p_Np]*s_q[k];
          qrs += SrsT[n+k*p_Np]*s_q[k];
          qsr += SsrT[n+k*p_Np]*s_q[k];
          qss += SssT[n+k*p_Np]*s_q[k];
          qM  += MM[n+k*p_Np]*s_q[k];
        }

      rhs[id] -= Grr*qrr+Grs*qrs+Grs*qsr+Gss*qss + J*lambda*qM;
    }
  }
}
