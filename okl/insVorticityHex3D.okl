kernel void insVorticityHex3D(const dlong Nelements,
                              const dfloat * restrict vgeo,
                              const dfloat * restrict const D,
                              const dlong offset,
                              const dfloat * restrict U,
                              const dfloat * restrict V,
                              const dfloat * restrict W,
                                    dfloat * restrict Vx,
                                    dfloat * restrict Vy,
                                    dfloat * restrict Vz){  
  
  // block partition of elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_U[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_V[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_W[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_Nq;++k;inner2){ 
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){     
            const dlong e = eo+es; // element in block
            if(e<Nelements){ 
              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq+i;

              s_U[es][k][j][i]  = U[id];
              s_V[es][k][j][i]  = V[id];
              s_W[es][k][j][i]  = W[id];

              if (es==0 && k==0)
                s_D[j][i] = D[j*p_Nq+i];
            }
          }
        }
      }
    }
          
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_Nq;++k;inner2){ 
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){  
            const dlong e = eo+es; 
            if(e<Nelements){ 
              const dlong gid = e*p_Np*p_Nvgeo +k*p_Nq*p_Nq +j*p_Nq +i;
              const dfloat drdx = vgeo[gid + p_RXID*p_Np];
              const dfloat drdy = vgeo[gid + p_RYID*p_Np];
              const dfloat drdz = vgeo[gid + p_RZID*p_Np];
              const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
              const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
              const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
              const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
              const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
              const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

              // compute 'r' and 's' derivatives of (q_m) at node n
              dfloat dudr  = 0.f, duds  = 0.f, dudt  = 0.f;
              dfloat dvdr  = 0.f, dvds  = 0.f, dvdt  = 0.f;
              dfloat dwdr  = 0.f, dwds  = 0.f, dwdt  = 0.f;

              occaUnroll(p_Nq)
                for(int n=0;n<p_Nq;++n){
                  const dfloat Dr = s_D[i][n];
                  const dfloat Ds = s_D[j][n];
                  const dfloat Dt = s_D[k][n];

                  dudr += Dr*s_U[es][k][j][n];
                  duds += Ds*s_U[es][k][n][i];
                  dudt += Dt*s_U[es][n][j][i];
                  dvdr += Dr*s_V[es][k][j][n];
                  dvds += Ds*s_V[es][k][n][i];
                  dvdt += Dt*s_V[es][n][j][i];
                  dwdr += Dr*s_W[es][k][j][n];
                  dwds += Ds*s_W[es][k][n][i];
                  dwdt += Dt*s_W[es][n][j][i];
                }

              const dfloat uy = drdy*ur + dsdy*us + dtdy*ut;
              const dfloat uz = drdz*ur + dsdz*us + dtdz*ut;

              const dfloat vx = drdx*vr + dsdx*vs + dtdx*vt;
              const dfloat vz = drdz*vr + dsdz*vs + dtdz*vt;

              const dfloat wx = drdx*wr + dsdx*ws + dtdx*wt;
              const dfloat wy = drdy*wr + dsdy*ws + dtdy*wt;

              const dlong id = e*p_Np+k*p_Nq*p_Nq+j*p_Nq +i; 
              Vx[id] = wy-vz;
              Vy[id] = uz-wx;
              Vx[id] = vx-uy;
            }
          }
        }
      }
    }
  }
}