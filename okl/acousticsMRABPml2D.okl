
// function to compute collocation differentiation
// contributions to nodal DG rhs for acoustics
kernel void acousticsMRABPml2D(const iint pmlNelements,
             const iint    * restrict pmlElementList,
             const iint    * restrict pmlIds,
             const dfloat  * restrict cubInterp,
             const dfloat  * restrict cubProject,
             const dfloat  * restrict pmlSigmaX,
             const dfloat  * restrict pmlSigmaY,
             const dfloat  * restrict q,
             const dfloat  * restrict pmlq,
             dfloat * restrict rhsq,
             dfloat * restrict pmlrhsq,
             const iint   rhsShift){

  // for all PML elements
  for(iint el=0;el<pmlNelements;++el;outer0){
    shared dfloat s_u[p_cubNp], s_v[p_cubNp], s_p[p_cubNp];
    shared dfloat s_utilde[p_cubNp], s_vtilde[p_cubNp], s_ptilde[p_cubNp];

    exclusive dfloat r_u, r_v, r_p; 
    exclusive dfloat r_utilde, r_vtilde, r_ptilde; 
    exclusive dfloat r_rhsu, r_rhsv, r_rhsp;
    exclusive dfloat r_rhsutilde, r_rhsvtilde, r_rhsptilde;
    exclusive iint pmlId;

    //fetch q and pmlq
    for(iint n=0; n<p_maxCubNodes;++n;inner0){  
      const iint e = pmlElementList[el];
      pmlId = pmlIds[el];
      
      if (n < p_Np){
        const iint base = p_Nfields*(e*p_Np + n);
        s_u[n] = q[base+0];
        s_v[n] = q[base+1];
        s_p[n] = q[base+2];

        const iint pmlBase = p_pmlNfields*(pmlId*p_Np+n);
        s_utilde[n] = pmlq[pmlBase+0];
        s_vtilde[n] = pmlq[pmlBase+1];
        s_ptilde[n] = pmlq[pmlBase+2];
      }

      // Initialize register variables
      r_u = 0.f;
      r_v = 0.f;
      r_p = 0.f;
      r_utilde = 0.f;
      r_vtilde = 0.f;
      r_ptilde = 0.f;
    }
    barrier(localMemFence);

    // Interpolate to cubature nodes
    for(iint n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        const iint pmlBase = pmlId*p_cubNp+n;
        const dfloat sigmax = pmlSigmaX[pmlBase];
        const dfloat sigmay = pmlSigmaY[pmlBase];

        occaUnroll(p_Np)
        for (int i=0;i<p_Np;++i){
          r_u += cubInterp[n + i*p_cubNp] * s_u[i];
          r_v += cubInterp[n + i*p_cubNp] * s_v[i];
          r_p += cubInterp[n + i*p_cubNp] * s_p[i];
          r_utilde += cubInterp[n + i*p_cubNp] * s_utilde[i];
          r_vtilde += cubInterp[n + i*p_cubNp] * s_vtilde[i];
          r_ptilde += cubInterp[n + i*p_cubNp] * s_ptilde[i];
        }

        r_rhsu = -(sigmax-sigmay)*r_u - sigmay*(sigmay-sigmax)*r_utilde; // uhat
        r_rhsv = -(sigmay-sigmax)*r_v - sigmax*(sigmax-sigmay)*r_vtilde; // vhat
        r_rhsp = -(sigmax+sigmay)*r_p - sigmax*sigmay*r_ptilde;          // p

        // update for u~,v~, p~
        r_rhsutilde = r_u-sigmay*r_utilde;  // du~/dt = -sigmay*u~  + uhat
        r_rhsvtilde = r_v-sigmax*r_vtilde;  // dv~/dt = -sigmax*v~  + vhat
        r_rhsptilde = r_p;                  // dp~/dt = p
      }
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(iint n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        s_u[n] = r_rhsu;
        s_v[n] = r_rhsv;
        s_p[n] = r_rhsp;
        s_utilde[n] = r_rhsutilde;
        s_vtilde[n] = r_rhsvtilde;
        s_ptilde[n] = r_rhsptilde;
      }
    }
    barrier(localMemFence);

    for(iint n=0;n<p_maxCubNodes;++n;inner0){
      if (n < p_Np){
        dfloat rhsp = 0.f;
        dfloat rhsu = 0.f;
        dfloat rhsv = 0.f;
        dfloat rhsptilde = 0.f;
        dfloat rhsutilde = 0.f;
        dfloat rhsvtilde = 0.f;

        // Project rhs down
        occaUnroll(p_cubNp)
        for (int i=0;i<p_cubNp;++i){
          rhsu += cubProject[n + i*p_Np] * s_u[i];
          rhsv += cubProject[n + i*p_Np] * s_v[i];
          rhsp += cubProject[n + i*p_Np] * s_p[i];
          rhsutilde += cubProject[n + i*p_Np] * s_utilde[i];
          rhsvtilde += cubProject[n + i*p_Np] * s_vtilde[i];
          rhsptilde += cubProject[n + i*p_Np] * s_ptilde[i];
        }

        // store acoustics rhs contributions from PML 
        const iint e = pmlElementList[el];
        const iint rhsBase = 3*p_Nfields*(e*p_Np + n) + p_Nfields*rhsShift;
        rhsq[rhsBase+0] += rhsu;
        rhsq[rhsBase+1] += rhsv;
        rhsq[rhsBase+2] += rhsp;

        // store PML rhs
        const iint pmlId = pmlIds[el];
        const iint pmlrhsBase = 3*p_pmlNfields*(pmlId*p_Np + n)  + p_pmlNfields*rhsShift;
        pmlrhsq[pmlrhsBase+0] = rhsutilde;
        pmlrhsq[pmlrhsBase+1] = rhsvtilde;
        pmlrhsq[pmlrhsBase+2] = rhsptilde;
      }
    }
  }
}
