#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3
//
#define UXID 0
#define UYID 1
#define PRID 2

#define UXN1ID 0
#define UYN1ID 1
#define UXN2ID 2
#define UYN2ID 3

/* offsets for nx, ny, sJ, 1/J */
#define NXID 0  
#define NYID 1  
#define SJID 2  
#define IJID 3  
#define WSJID 4
#define IHID 5


// BCs for -laplace(u) + g0*idt*inu*u
void boundaryConditionsIpdg2D(const iint bc,
			                           const dfloat  t,    const dfloat  x, const dfloat  y,
			                           const dfloat  nx,   const dfloat  ny,
			                           const dfloat  uxM,  const dfloat  uyM,
			                           const dfloat  uxnM, const dfloat  uynM,
			                                 dfloat * restrict uxB,  dfloat * restrict uyB,
			                                 dfloat * restrict uxnB, dfloat * restrict uynB){
	dfloat nu   = 1.0/40.0;
  dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

  if(bc==1){ // Wall 
    *uxB = 0.f; 
    *uyB = 0.f;
  }
  if(bc==2){ // Inflow 	
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
  if(bc==3){ // Outflow 
  // do nothing 
    *uxnB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uynB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
   
   if(bc==4){ // Slip
    *uxnB = uxM;
    *uynB = uyM;
  }
}

// BCs for div(u*u) - grad(p) for helmholtz rhs

void boundaryConditionsRhs2D(const iint bc,
			              const dfloat  t, const dfloat  x, const dfloat  y,
			              const dfloat  nx, const dfloat  ny,
			              const dfloat  uxM, const dfloat  uyM, const dfloat prM,
			                    dfloat * restrict uxB, dfloat * restrict uyB, dfloat * restrict prB){
	dfloat nu   = 1.0/40.0;
  dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

  if(bc==1){ // Wall 
    *uxB = 0.f; 
    *uyB = 0.f;
    // For pressure do nothing
    *prB = prM; // Neumann for Pressure // do nothing
  }
  if(bc==2){ // Inflow
  	
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
    //
    *prB = prM; // Neumann for Pressure   // do nothing
  }
  if(bc==3){ // Outflow 
    // do nothing 
    *uxB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uyB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
    //
    dfloat prbc = 0.5f*(1.0f - occaExp(2.0f*lamda*x));
    *prB = 2.0f* prbc - prM ; //Dirichlet for pressure in strong form
  }
}


// compute div(NU) + grad(Pr), volume terms
kernel void insHelmholtzRhsVolume2D(const iint Nelements,
																		const dfloat * restrict vgeo,
																		const dfloat * restrict DrT,
																		const dfloat * restrict DsT,
																		const dfloat * restrict Ux,
																		const dfloat * restrict Uy,
																		const dfloat * restrict Pr,
																		      dfloat * restrict NUx,
																		      dfloat * restrict NUy,
																		      dfloat * restrict rhsUx, 
																		      dfloat * restrict rhsUy){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
   // Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_F11[p_NblockV][p_Np];
   shared dfloat s_F12[p_NblockV][p_Np];
   shared dfloat s_F22[p_NblockV][p_Np];
   // Hold Pressure on Shared
   shared dfloat s_Pr[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id = e*p_Np+n;
					const dfloat ux = Ux[id];
					const dfloat uy = Uy[id];
					const dfloat pr = Pr[id];
					//
					s_F11[es][n] = ux*ux;
					s_F12[es][n] = ux*uy;
					s_F22[es][n] = uy*uy;
          s_Pr[es][n]  = pr;

				}
      }
    }

     // Make sure all node data is loaded into shared
    barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
			iint e = eo+es; // element in block
			if(e<Nelements){	  
			  // prefetch geometric factors (constant on triangle)
			  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
			  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
			  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
			  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
	      // compute 'r' and 's' derivatives of (q_m) at node n
				dfloat df11dr = 0.f, df11ds = 0.f; 
				dfloat df12dr = 0.f, df12ds = 0.f; 
				dfloat df22dr = 0.f, df22ds = 0.f; 
				dfloat dprdr  = 0.f, dprds  = 0.f;
        //
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat Drni = DrT[n+i*p_Np];
					const dfloat Dsni = DsT[n+i*p_Np];
					// 
					df11dr += Drni*s_F11[es][i];
					df11ds += Dsni*s_F11[es][i];
					df12dr += Drni*s_F12[es][i];
					df12ds += Dsni*s_F12[es][i];
					df22dr += Drni*s_F22[es][i];
					df22ds += Dsni*s_F22[es][i];
					//
					dprdr  += Drni*s_Pr[es][i];
					dprds  += Dsni*s_Pr[es][i];
				}
				// chain rule
        dfloat nux   = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
        dfloat nuy   = drdx*df12dr + dsdx*df12ds + drdy*df22dr + dsdy*df22ds;
        //
        dfloat dprdx = drdx*dprdr  + dsdx*dprds;
        dfloat dprdy = drdy*dprdr  + dsdy*dprds;
				
				// Update
				const iint id = e*p_Np+n;
				// Compute div(uxu)
				NUx[id]   = nux;
				NUy[id]   = nuy;
        // rhsU = - grad P
				rhsUx[id] = dprdx;
				rhsUy[id] = dprdy;
	 
	}
      }
    }
 }
}

//
kernel void insHelmholtzRhsSurface2D(const iint Nelements,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const iint   * restrict vmapM,
				     const iint   * restrict vmapP,
				     const iint   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat * restrict Ux,
				     const dfloat * restrict Uy,
				     const dfloat * restrict Pr,
				           dfloat * restrict NUx,
				           dfloat * restrict NUy,
				           dfloat * restrict rhsUx,
				           dfloat * restrict rhsUy){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxNUy[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];

     // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	    iint e = eo + es;
	     if(e<Nelements){
	      if(n<p_Nfp*p_Nfaces){
		    // find face that owns this node
		    iint face = n/p_Nfp;
		    // load surface geofactors for this face
		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
		    dfloat nx   = sgeo[sid+NXID];
		    dfloat ny   = sgeo[sid+NYID];
		    dfloat sJ   = sgeo[sid+SJID];
		    dfloat invJ = sgeo[sid+IJID];
		   
		    // indices of negative and positive traces of face node
		    iint id  = e*p_Nfp*p_Nfaces + n;
		    iint idM = vmapM[id];
		    iint idP = vmapP[id];

		   if(idP<0) idP = idM; // bc
		  // load negative and positive trace node values of Ux, Uy, Pr
		     dfloat  uxm = Ux[idM], uxp = Ux[idP];
			   dfloat  uym = Uy[idM], uyp = Uy[idP];
			   dfloat  prm = Pr[idM], prp = Pr[idP];

		    // apply boundary condition
		    iint bc = EToB[face+p_Nfaces*e];
		    if(bc>0)
		      boundaryConditionsRhs2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym, prm, &uxp, &uyp, &prp);

        // Find max normal velocity on the face
		    dfloat unm   = occaFabs(nx*uxm + ny*uym);
		    dfloat unp   = occaFabs(nx*uxp + ny*uyp);    
        dfloat unmax = (unm > unp) ? unm : unp;

        // evaluate "flux" terms: LLF
        const dfloat sc = invJ * sJ ; 
				s_fluxNUx[es][n] = sc*(.5f*( nx*(uxp*uxp - uxm*uxm) + ny*(uxp*uyp - uxm*uym) + unmax*(uxm-uxp) ));
				s_fluxNUy[es][n] = sc*(.5f*( nx*(uyp*uxp - uym*uxm) + ny*(uyp*uyp - uym*uym) + unmax*(uym-uyp) ));
        // Centered flux for pr p*-p = 0.5(prp-prm) // Central Flux
        s_fluxUx[es][n]  = sc*(.5f*nx*(prp-prm));
        s_fluxUy[es][n]  = sc*(.5f*ny*(prp-prm));
       	 }
    		}
			}
		}
    
   
    // wait for all flux functions are written to shared 
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
			for(iint n=0;n<p_maxNodes;++n;inner0){
				iint e = eo + es;
					if(e<Nelements){
						if(n<p_Np){
							iint id = e*p_Np + n;

							dfloat rhsnux = NUx[id];
							dfloat rhsnuy = NUy[id];
							dfloat rhsux  = rhsUx[id];
							dfloat rhsuy  = rhsUy[id];
							// Lift
							occaUnroll(p_NfacesNfp)
							for(int m=0;m<p_Nfaces*p_Nfp;++m){
								dfloat L = LIFTT[n+m*p_Np];
								//
								rhsnux  += L*s_fluxNUx[es][m];
								rhsnuy  += L*s_fluxNUy[es][m];
								rhsux   += L*s_fluxUx[es][m];
								rhsuy   += L*s_fluxUy[es][m];
					}
          // M^-1* (div(u*u)) + Lift*(F*-F))
					NUx[id] = rhsnux;
					NUy[id] = rhsnuy;
					//  rhsu = -grad(p)
					rhsUx[id] = -rhsux;
					rhsUy[id] = -rhsuy;
				  }
				}
      }
    }
  }


}



kernel void insHelmholtzRhsUpdate2D(const iint Nelements,
	                            const dfloat * restrict vgeo,
					                    const dfloat * restrict MM,
				                      const dfloat dt,	
				                      const dfloat a0,
				                      const dfloat a1,
				                      const dfloat a2,
				                      const dfloat b0,
				                      const dfloat b1,
				                      const dfloat b2,
				                      const dfloat * restrict Ux,
				                      const dfloat * restrict Uy,
				                            dfloat * restrict UO,
                              const dfloat * restrict NUx,
                              const dfloat * restrict NUy,
				                            dfloat * restrict NO,
				                            dfloat * restrict rhsUx,
				                            dfloat * restrict rhsUy){
  
  //Low storage Runge Kutta time step update
   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){ 
  // 	// Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_rhsUx[p_NblockV][p_Np];
   shared dfloat s_rhsUy[p_NblockV][p_Np];
   
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id  = e*p_Np+n;
					const iint idf = n+ 4*p_Np*e;

					const dfloat J = vgeo[e*p_Nvgeo + p_JID];
					//U at t^(n)
					const dfloat uxn0  = Ux[id];
					const dfloat uyn0  = Uy[id];
					// NU at t^(n)
					const dfloat nxn0  = NUx[id];
					const dfloat nyn0  = NUy[id];
					// U at t^(n-1) & (n-2)
					const dfloat uxn1 = UO[idf+UXN1ID];
					const dfloat uyn1 = UO[idf+UYN1ID];
					const dfloat uxn2 = UO[idf+UXN2ID];
					const dfloat uyn2 = UO[idf+UYN2ID];
					//NU at t^(n-1) &at t^(n-2)
					const dfloat nxn1 = NO[idf+UXN1ID];
					const dfloat nyn1 = NO[idf+UYN1ID];
					const dfloat nxn2 = NO[idf+UXN2ID];
					const dfloat nyn2 = NO[idf+UYN2ID];
          
          // Currently holds -grad(P)
					const dfloat rhsux = rhsUx[id];
					const dfloat rhsuy = rhsUy[id];
					
					//Update NU
					NO[idf+UXN1ID]  = nxn0;
					NO[idf+UYN1ID]  = nyn0;
					NO[idf+UXN2ID]  = nxn1;
					NO[idf+UYN2ID]  = nyn1;
					// Update U
          UO[idf+UXN1ID]  = uxn0;
					UO[idf+UYN1ID]  = uyn0;
					UO[idf+UXN2ID]  = uxn1;
					UO[idf+UYN2ID]  = uyn1;				
					// rhsU = -grad(P) + f^(n+1)
					// -> -lap(U) + g_o/(dt*nu) = 1/nu*[-grad(P) + sum(a_i*u_i)/dt - sum(b_i*NU_i)]
					// !!! hold inv dt later
          s_rhsUx[es][n]   = J*p_inu*(rhsux + (a0*uxn0 + a1*uxn1 + a2*uxn2)*p_idt - (b0*nxn0 + b1*nxn1 + b2*nxn2));
          s_rhsUy[es][n]   = J*p_inu*(rhsux + (a0*uyn0 + a1*uyn1 + a2*uyn2)*p_idt - (b0*nyn0 + b1*nyn1 + b2*nyn2)); 
				}
      }
    }

   //   // make sure all node data is loaded into shared
     barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
			 iint e = eo+es; // element in block
			  if(e<Nelements){	  
	      // Multiplay with Mass Matrix
				dfloat rhsux = 0.f, rhsuy = 0.f; 
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat M = MM[n+i*p_Np];
					rhsux  += M*s_rhsUx[es][i];
					rhsuy  += M*s_rhsUy[es][i];
				}
        // Update
				const iint id = e*p_Np+n;
				rhsUx[id] = rhsux;
				rhsUy[id] = rhsuy;
	 
	      }
      }
    }
    
  }
}



kernel void insHelmholtzRhsIpdgBC2D(const iint Nelements,
				                            const dfloat * restrict sgeo,
				                            const dfloat * restrict vgeo,
																    const dfloat * restrict DrT,
																    const dfloat * restrict DsT,
																    const dfloat * restrict FMMT,
				                            const iint   * restrict vmapM,
				                            const iint   * restrict vmapP,
				                            const iint   * restrict EToB,
				                            const dfloat time,
				                            const dfloat tau,
				     										    const dfloat * restrict x,
				    									      const dfloat * restrict y,
				     										    const dfloat * restrict Ux,
				     										    const dfloat * restrict Uy,
				                                  dfloat * restrict rhsUx,
				                                  dfloat * restrict rhsUy
				                                  ){
for(int e=0;e<Nelements;++e;outer0){
	// shared storage for flux terms
	  shared  dfloat s_uxB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uyB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uxnB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uynB[p_Nfp*p_Nfaces];
	  //
    shared dfloat s_nxuxB[p_Nfp*p_Nfaces];
    shared dfloat s_nxuyB[p_Nfp*p_Nfaces];
    shared dfloat s_nyuxB[p_Nfp*p_Nfaces];
    shared dfloat s_nyuyB[p_Nfp*p_Nfaces];
    //
    shared  dfloat s_Lux[p_Np];
	  shared  dfloat s_Luy[p_Np];
	  shared  dfloat s_Luxn[p_Np];
	  shared  dfloat s_Luyn[p_Np];
	  //
	  shared  dfloat s_Lnxux[p_Np];
	  shared  dfloat s_Lnxuy[p_Np];
	  shared  dfloat s_Lnyux[p_Np];
	  shared  dfloat s_Lnyuy[p_Np];
	 
	  //exclusive iint bc = 0, idM=0; 
	  exclusive dfloat tau_n;
	 
   for(iint n=0;n<p_maxNodes;++n;inner0){
	      if(n<p_Nfp*p_Nfaces){
	      	// Find face index and bc type
					 iint face     = n/p_Nfp;
					 iint bc       = EToB[face+p_Nfaces*e];
					 //
					  s_uxB[n]      = 0.f, s_uyB[n]      = 0.f ;
						s_uxnB[n]     = 0.f, s_uxnB[n]     = 0.f ;
						//
						s_nxuxB[n]    = 0.f, s_nxuyB[n]    = 0.f ;
						s_nyuxB[n]    = 0.f, s_nyuyB[n]    = 0.f ;
					//
	        if(bc>0){ 
						//
						const iint id  = n + e*p_Nfaces*p_Nfp;
						const iint idM = vmapM[id];					
						const iint idP = vmapP[id];					
            // load surface geofactors for this face
						iint sid       = p_Nsgeo*(e*p_Nfaces+face);
						dfloat nx      = sgeo[sid+p_NXID];
						dfloat ny      = sgeo[sid+p_NYID];
						dfloat sJ      = sgeo[sid+p_SJID];
						dfloat hinv    = sgeo[sid+p_IHID];

						tau_n = hinv* tau; // Scale stabilization parameter
						//
						// Read interior, may be needed like slip boundaries 
            dfloat  uxm = Ux[idM];
	         	dfloat  uym = Uy[idM];
	         	// Currently specific Neumann Boundaries is not implemented !!!
	         	dfloat  uxnm = 0.f, uynm =0.f; 
						            
            // Initialize external dirichlet for ux and uy
            dfloat  uxp = 0.f,  uyp = 0.f ; 
            // Initialize external Neumann for ux and uy
            dfloat  uxnp = 0.f, uynp =0.f ;

           boundaryConditionsIpdg2D(bc, time, x[idM], y[idM], nx, ny, 
            	                       uxm,  uym, uxnm, uynm,
            	                       &uxp, &uyp, &uxnp, &uynp);
            
					 // Hold RHS information and multiply with sJ
						s_uxB[n]      = sJ*uxp * hinv*tau ;
						s_uyB[n]      = sJ*uyp * hinv*tau ;
						s_uxnB[n]     = sJ*uxnp;
						s_uxnB[n]     = sJ*uynp;			
						//
						s_nxuxB[n]    = sJ*nx*uxp;
						s_nxuyB[n]    = sJ*nx*uyp;
						s_nyuxB[n]    = sJ*ny*uxp;
						s_nyuyB[n]    = sJ*ny*uyp;
    		}
  		}
		}

		barrier(localMemFence);

   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
	      dfloat uxb = 0.f, uyb =0.f, uxnb =0.f, uynb =0.f;
	      dfloat nxux = 0.f, nxuy = 0.f, nyux =0.f, nyuy =0.f;  
		    // lift remaining surface terms
		    occaUnroll(p_NfacesNfp)
		    for(int i=0;i<p_NfacesNfp;++i){
		    	 const dfloat FM = FMMT[n+i*p_Np];
		       uxb  += FM*s_uxB[i];
		       uyb  += FM*s_uyB[i];
		       uxnb += FM*s_uxnB[i];
		       uynb += FM*s_uynB[i];
		       //
           nxux += FM*s_nxuxB[i];
		       nxuy += FM*s_nxuyB[i];
		       nyux += FM*s_nyuxB[i];
		       nyuy += FM*s_nyuyB[i];

		     }	
				s_Lux[n]      = uxb;
				s_Luy[n]      = uyb;
				s_Luxn[n]     = uxnb;
				s_Luyn[n]     = uynb;
				//
				s_Lnxux[n]    = nxux;
		    s_Lnxuy[n]    = nxuy;
		    s_Lnyux[n]    = nyux;
		    s_Lnyuy[n]    = nyuy;
	      }
	    } 

	     barrier(localMemFence);

   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
				const int gid = e*p_Nvgeo;
				const dfloat drdx = vgeo[gid + p_RXID];
				const dfloat drdy = vgeo[gid + p_RYID];
				const dfloat dsdx = vgeo[gid + p_SXID];
				const dfloat dsdy = vgeo[gid + p_SYID];
				//
        dfloat drnxux= 0.f, drnxuy =0.f, drnyux= 0.f, drnyuy =0.f;
        dfloat dsnxux= 0.f, dsnxuy =0.f, dsnyux= 0.f, dsnyuy =0.f;
		    // lift remaining surface terms
		    occaUnroll(p_Np)
		    for(int i=0;i<p_Np;++i){
		    	const dfloat Drni = DrT[i+n*p_Np]; // !!!Take transpose was DrT[n+i*p_Np]
					const dfloat Dsni = DsT[i+n*p_Np]; // !!!Take transpose was DsT[i+n*p_Np]
					drnxux += Drni*s_Lnxux[n];
					dsnxux += Dsni*s_Lnxux[n];
					//
					drnyux += Drni*s_Lnyux[n];
					dsnyux += Dsni*s_Lnyux[n];
					//
					drnxuy += Drni*s_Lnxuy[n];
					dsnxuy += Dsni*s_Lnxuy[n];
					//
					drnyuy += Drni*s_Lnyuy[n];
					dsnyuy += Dsni*s_Lnyuy[n];
				}

				// (grad(phi),U_d) = DxT*

        dfloat dndux =  (drdx*drnxux + dsdx*dsnxux + drdy*drnyux + dsdy*dsnyux);
        dfloat dnduy =  (drdx*drnxuy + dsdx*dsnxuy + drdy*drnyuy + dsdy*dsnyuy);


        const iint id = e*p_Np+n;
				rhsUx[id] +=  s_Lux[n] + s_Luxn[n] - dndux;
				rhsUy[id] +=  s_Luy[n] + s_Luyn[n] - dnduy;

			}

   }

  }
}






