#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3
//
#define UXID 0
#define UYID 1
#define PRID 2

#define UXN1ID 0
#define UYN1ID 1
#define UXN2ID 2
#define UYN2ID 3

/* offsets for nx, ny, sJ, 1/J */
#define NXID 0  
#define NYID 1  
#define SJID 2  
#define IJID 3  
#define WSJID 4
#define IHID 5


void boundaryConditionsIpdg2D(const iint bc,
			                        const dfloat  t, const dfloat  x, const dfloat  y,
			                        const dfloat  nx,   const dfloat  ny,
			                        dfloat * restrict uB, dfloat * restrict uxB, dfloat * restrict uyB,
			                        dfloat * restrict vB, dfloat * restrict vxB, dfloat * restrict vyB){
	dfloat nu   = 1.0f/40.0f;
  dfloat lambda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

  if((bc==1)||(bc==4)){ // Wall/Slip 
    *uB = 0.f; 
    *vB = 0.f;

    *uxB = 0.f; 
    *uyB = 0.f; 
    *vxB = 0.f;
    *vyB = 0.f;
  }
  if(bc==2){ // Inflow 
    *uB = 1.0f - occaExp(lambda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *vB = 0.5f*lambda/(OCCA_PI)*occaExp(lambda*x)*occaSin(2.f*OCCA_PI*y);

   	*uxB = 0.f; 
    *uyB = 0.f; 
    *vxB = 0.f;
    *vyB = 0.f; 
  }
  if(bc==3){ // Outflow 
  	// do nothing 
    *uB = 0.f; 
    *vB = 0.f; 

    *uxB = -lambda*occaExp(lambda*x)*occaCos(2*OCCA_PI*y);
    *uyB = 2.f*OCCA_PI*occaExp(lambda*x)*occaSin(2.f*OCCA_PI*y);
    *vxB =  lambda*lambda*occaExp(lambda*x)*occaSin(2*OCCA_PI*y)/(2*OCCA_PI);
    *vyB =  lambda*occaExp(lambda*x)*occaCos(2*OCCA_PI*y);
   
  }
}



// Compute RHS Forcing i.e. 1/nu*(-grad(Pr) + sum(a_i x u_i)^(n-i) -sum(b_i x N(u)^(n-i))

kernel void insHelmholtzRhsForcing2D(const iint Nelements,
	                            const dfloat * restrict vgeo,
					                    const dfloat * restrict MM,
				                      const dfloat dt,	
				                      const dfloat a0,
				                      const dfloat a1,
				                      const dfloat a2,
				                      const dfloat b0,
				                      const dfloat b1,
				                      const dfloat b2,
				                      const dfloat * restrict Ux,
				                      const dfloat * restrict Uy,
				                            dfloat * restrict UO,
                              const dfloat * restrict NUx,
                              const dfloat * restrict NUy,
				                            dfloat * restrict NO,
				                            dfloat * restrict rhsUx, // grad(Pr)
				                            dfloat * restrict rhsUy){
  
  //Low storage Runge Kutta time step update
   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){ 
  // 	// Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_rhsUx[p_NblockV][p_Np];
   shared dfloat s_rhsUy[p_NblockV][p_Np];
   
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id  = e*p_Np+n;
					const iint idf = n+ 4*p_Np*e;

					const dfloat J = vgeo[e*p_Nvgeo + p_JID];
					//U at t^(n)
					const dfloat uxn0  = Ux[id];
					const dfloat uyn0  = Uy[id];
					// NU at t^(n)
					const dfloat nxn0  = NUx[id];
					const dfloat nyn0  = NUy[id];
					// U at t^(n-1) & (n-2)
					const dfloat uxn1 = UO[idf+UXN1ID];
					const dfloat uyn1 = UO[idf+UYN1ID];
					const dfloat uxn2 = UO[idf+UXN2ID];
					const dfloat uyn2 = UO[idf+UYN2ID];
					//NU at t^(n-1) &at t^(n-2)
					const dfloat nxn1 = NO[idf+UXN1ID];
					const dfloat nyn1 = NO[idf+UYN1ID];
					const dfloat nxn2 = NO[idf+UXN2ID];
					const dfloat nyn2 = NO[idf+UYN2ID];
          
          // Currently holds -grad(Pr)
					const dfloat dpdx = rhsUx[id];
					const dfloat dpdy = rhsUy[id];
					
					//Update NU
					NO[idf+UXN1ID]  = nxn0;
					NO[idf+UYN1ID]  = nyn0;
					NO[idf+UXN2ID]  = nxn1;
					NO[idf+UYN2ID]  = nyn1;
					// Update U
          UO[idf+UXN1ID]  = uxn0;
					UO[idf+UYN1ID]  = uyn0;
					UO[idf+UXN2ID]  = uxn1;
					UO[idf+UYN2ID]  = uyn1;				
					// -> -lap(U) + g_o/(dt*nu) = 1/nu*[-grad(P) + sum(a_i*u_i)/dt - sum(b_i*NU_i)]
          s_rhsUx[es][n]   = J*p_inu*(-dpdx + (a0*uxn0 + a1*uxn1 + a2*uxn2)*p_idt - (b0*nxn0 + b1*nxn1 + b2*nxn2));
          s_rhsUy[es][n]   = J*p_inu*(-dpdy + (a0*uyn0 + a1*uyn1 + a2*uyn2)*p_idt - (b0*nyn0 + b1*nyn1 + b2*nyn2)); 
				}
      }
    }

   //   // make sure all node data is loaded into shared
     barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
			 iint e = eo+es; // element in block
			  if(e<Nelements){	  
	      // Multiplay with Mass Matrix
				dfloat rhsux = 0.f, rhsuy = 0.f; 
				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat M = MM[n+i*p_Np];
					rhsux  += M*s_rhsUx[es][i];
					rhsuy  += M*s_rhsUy[es][i];
				}
        // Update
				const iint id = e*p_Np+n;
				rhsUx[id] = rhsux;
				rhsUy[id] = rhsuy;
	 
	      }
      }
    }
    
  }
}




kernel void insHelmholtzRhsIpdgBC2D(const int Nelements,
				const iint * restrict vmapM,
				const iint * restrict vmapP,
				const dfloat lambda,
				const dfloat tau,
				const dfloat t,
				const dfloat * restrict x,
				const dfloat * restrict y,
				const dfloat * restrict vgeo,
				const dfloat * restrict sgeo,
        const iint   * restrict EToB,
				const dfloat * restrict DrT,
				const dfloat * restrict DsT,
				const dfloat * restrict LIFTT,
				const dfloat * restrict MM,
				dfloat * restrict rhsUx,
				dfloat * restrict rhsUy){
  
 for(int e=0;e<Nelements;++e;outer0){
    shared  dfloat s_dudx[p_Np];
    shared  dfloat s_dudy[p_Np];
    shared  dfloat s_dvdx[p_Np];
    shared  dfloat s_dvdy[p_Np];
    //
    shared  dfloat s_lapu[p_Np];
    shared  dfloat s_lapv[p_Np];
    // //
    shared  dfloat s_nxdu[p_NfacesNfp];
    shared  dfloat s_nydu[p_NfacesNfp];
    shared  dfloat s_nxdv[p_NfacesNfp];
    shared  dfloat s_nydv[p_NfacesNfp];
    // //
    shared  dfloat s_lapuflux[p_NfacesNfp];
    shared  dfloat s_lapvflux[p_NfacesNfp];
    // //
    shared  dfloat s_Lnxdu[p_Np];
    shared  dfloat s_Lnydu[p_Np];
    shared  dfloat s_Lnxdv[p_Np];
    shared  dfloat s_Lnydv[p_Np];
    // //
     exclusive iint idM;
     exclusive dfloat nx, ny, sJ, invJ, hinv;
    
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
      	const iint id  = n + e*p_Nfaces*p_Nfp;
      	idM = vmapM[id];					
     
      	const iint face = n/p_Nfp;

      	dfloat4 graduP, gradvP;
      	graduP.x = 0.f; graduP.y = 0.f; graduP.w = 0.f;
      	gradvP.x = 0.f; gradvP.y = 0.f; gradvP.w = 0.f;
      	
      	// load surface geofactors for this face
      	iint sid = p_Nsgeo*(e*p_Nfaces+face);
      	nx = sgeo[sid+p_NXID];
      	ny = sgeo[sid+p_NYID];
      	sJ = sgeo[sid+p_SJID];
      	invJ = sgeo[sid+p_IJID];
      	hinv = sgeo[sid+p_IHID];

        iint bc = EToB[face+p_Nfaces*e];

        if(bc>0) boundaryConditionsIpdg2D(bc, t, x[idM], y[idM], nx, ny, 
        																	&graduP.w, &graduP.x, &graduP.y,
        																	&gradvP.w, &gradvP.x, &gradvP.y);

      	const dfloat du = graduP.w;
      	const dfloat dv = gradvP.w;
      	const dfloat half = 1.0f;
      	
      	s_nxdu[n] = half*sJ*invJ*nx*du;
      	s_nydu[n] = half*sJ*invJ*ny*du;
      	s_nxdv[n] = half*sJ*invJ*nx*dv;
				s_nydv[n] = half*sJ*invJ*ny*dv;

      	s_lapuflux[n] = half*sJ*invJ*(-nx*(graduP.x)
      				     -ny*(graduP.y)
      				     -tau*hinv*du);
      	s_lapvflux[n] = half*sJ*invJ*(-nx*(gradvP.x)
      				     -ny*(gradvP.y)
      				     -tau*hinv*dv);
      }
    }

    barrier(localMemFence);

    // dqdx += LIFT*(sJ/J)*nx*dq
    for(int n=0;n<p_maxNodes;++n;inner0){

      if(n<p_Np){
				const int gid = e*p_Nvgeo;
				const dfloat drdx = vgeo[gid + p_RXID];
				const dfloat drdy = vgeo[gid + p_RYID];
				const dfloat dsdx = vgeo[gid + p_SXID];
				const dfloat dsdy = vgeo[gid + p_SYID];
				
				dfloat Lnxdu = 0;
				dfloat Lnydu = 0;
				dfloat Lnxdv = 0;
				dfloat Lnydv = 0;//  dfloat  uxm = Ux[idM];
	         	// dfloat  uym = Uy[idM];
				
				occaUnroll(p_NfacesNfp)
				  for(iint i=0;i<p_NfacesNfp;++i){
				    Lnxdu += LIFTT[n+i*p_Np]*s_nxdu[i];
				    Lnydu += LIFTT[n+i*p_Np]*s_nydu[i];
				    Lnxdv += LIFTT[n+i*p_Np]*s_nxdv[i];
				    Lnydv += LIFTT[n+i*p_Np]*s_nydv[i];
				  }

				dfloat dudx = Lnxdu;
				dfloat dudy = Lnydu;
				dfloat dvdx = Lnxdv;
				dfloat dvdy = Lnydv;
				s_dudx[n] = drdx*dudx + drdy*dudy; // abuse of notation
				s_dudy[n] = dsdx*dudx + dsdy*dudy;
				s_dvdx[n] = drdx*dvdx + drdy*dvdy; // abuse of notation
				s_dvdy[n] = dsdx*dvdx + dsdy*dvdy;

				s_Lnxdu[n] = Lnxdu;
				s_Lnydu[n] = Lnydu;
				s_Lnxdv[n] = Lnxdv;
				s_Lnydv[n] = Lnydv;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_NfacesNfp){
				iint id = idM%p_Np;
				s_lapuflux[n] += sJ*invJ*(nx*s_Lnxdu[id]+ny*s_Lnydu[id]);
				s_lapvflux[n] += sJ*invJ*(nx*s_Lnxdv[id]+ny*s_Lnydv[id]);
      }

      if(n<p_Np){
				dfloat laur = 0, laus = 0;
				dfloat lavr = 0, lavs = 0;

				occaUnroll(p_Np)
				  for(int i=0;i<p_Np;++i)
				  {
				    laur += DrT[n+i*p_Np]*s_dudx[i];
				    laus += DsT[n+i*p_Np]*s_dudy[i];
				    lavr += DrT[n+i*p_Np]*s_dvdx[i];
				    lavs += DsT[n+i*p_Np]*s_dvdy[i];
				  }

				s_lapu[n] = -(laur+laus);
				s_lapv[n] = -(lavr+lavs);
      }
      
    }
    
    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){
				dfloat lau = 0;
				dfloat lav = 0;
				
				// lift remaining surface terms
				occaUnroll(p_NfacesNfp)
				  for(int i=0;i<p_NfacesNfp;++i){
				    lau += LIFTT[n+i*p_Np]*s_lapuflux[i];
				    lav += LIFTT[n+i*p_Np]*s_lapvflux[i];
				  }
				
				s_lapu[n] += lau;
				s_lapv[n] += lav;
      }
    }

    barrier(localMemFence);

    for(int n=0;n<p_maxNodes;++n;inner0){
      
      if(n<p_Np){
				const dfloat J = vgeo[e*p_Nvgeo + p_JID];
				
				dfloat Mlapu = 0;
				dfloat Mlapv = 0;

				// multiply by mass matrix
				occaUnroll(p_Np)
				  for(int i=0;i<p_Np;++i){
				    Mlapu += MM[n+i*p_Np]*s_lapu[i];
				    Mlapv += MM[n+i*p_Np]*s_lapv[i];
				  }
			
				const iint id = e*p_Np+n;
				rhsUx[id] -=  J*Mlapu;
				rhsUy[id] -=  J*Mlapv;
      }
    }
  
  }
}



























// // compute div(NU) + grad(Pr), volume terms
// kernel void insHelmholtzRhsVolume2D(const iint Nelements,
// 																		const dfloat * restrict vgeo,
// 																		const dfloat * restrict DrT,
// 																		const dfloat * restrict DsT,
// 																		const dfloat * restrict Ux,
// 																		const dfloat * restrict Uy,
// 																		const dfloat * restrict Pr,
// 																		      dfloat * restrict NUx,
// 																		      dfloat * restrict NUy,
// 																		      dfloat * restrict rhsUx, 
// 																		      dfloat * restrict rhsUy){
  
//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
//    // Hold Flux Vector on Shared, use symmetry f21 = f12
//    shared dfloat s_F11[p_NblockV][p_Np];
//    shared dfloat s_F12[p_NblockV][p_Np];
//    shared dfloat s_F22[p_NblockV][p_Np];
//    // Hold Pressure on Shared
//    shared dfloat s_Pr[p_NblockV][p_Np];

//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
// 				iint e = eo+es; // element in block
// 				if(e<Nelements){ 
// 					const iint id = e*p_Np+n;
// 					const dfloat ux = Ux[id];
// 					const dfloat uy = Uy[id];
// 					const dfloat pr = Pr[id];
// 					//
// 					s_F11[es][n] = ux*ux;
// 					s_F12[es][n] = ux*uy;
// 					s_F22[es][n] = uy*uy;
//           s_Pr[es][n]  = pr;

// 				}
//       }
//     }

//      // Make sure all node data is loaded into shared
//     barrier(localMemFence);


//     for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
//       for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
// 			iint e = eo+es; // element in block
// 			if(e<Nelements){	  
// 			  // prefetch geometric factors (constant on triangle)
// 			  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
// 			  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
// 			  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
// 			  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
// 	      // compute 'r' and 's' derivatives of (q_m) at node n
// 				dfloat df11dr = 0.f, df11ds = 0.f; 
// 				dfloat df12dr = 0.f, df12ds = 0.f; 
// 				dfloat df22dr = 0.f, df22ds = 0.f; 
// 				dfloat dprdr  = 0.f, dprds  = 0.f;
//         //
// 				occaUnroll(p_Np)
// 				for(iint i=0;i<p_Np;++i){
// 					const dfloat Drni = DrT[n+i*p_Np];
// 					const dfloat Dsni = DsT[n+i*p_Np];
// 					// 
// 					df11dr += Drni*s_F11[es][i];
// 					df11ds += Dsni*s_F11[es][i];
// 					df12dr += Drni*s_F12[es][i];
// 					df12ds += Dsni*s_F12[es][i];
// 					df22dr += Drni*s_F22[es][i];
// 					df22ds += Dsni*s_F22[es][i];
// 					//
// 					dprdr  += Drni*s_Pr[es][i];
// 					dprds  += Dsni*s_Pr[es][i];
// 				}
// 				// chain rule
//         dfloat nux   = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
//         dfloat nuy   = drdx*df12dr + dsdx*df12ds + drdy*df22dr + dsdy*df22ds;
//         //
//         dfloat dprdx = drdx*dprdr  + dsdx*dprds;
//         dfloat dprdy = drdy*dprdr  + dsdy*dprds;
				
// 				// Update
// 				const iint id = e*p_Np+n;
// 				// Compute div(uxu)
// 				NUx[id]   = nux;
// 				NUy[id]   = nuy;
//         // rhsU = - grad P
// 				rhsUx[id] = dprdx;
// 				rhsUy[id] = dprdy;
	 
// 	}
//       }
//     }
//  }
// }

// //
// kernel void insHelmholtzRhsSurface2D(const iint Nelements,
// 				     const dfloat * restrict sgeo,
// 				     const dfloat * restrict LIFTT,
// 				     const iint   * restrict vmapM,
// 				     const iint   * restrict vmapP,
// 				     const iint   * restrict EToB,
// 				     const dfloat time,
// 				     const dfloat * restrict x,
// 				     const dfloat * restrict y,
// 				     const dfloat * restrict Ux,
// 				     const dfloat * restrict Uy,
// 				     const dfloat * restrict Pr,
// 				           dfloat * restrict NUx,
// 				           dfloat * restrict NUy,
// 				           dfloat * restrict rhsUx,
// 				           dfloat * restrict rhsUy){
  
//   // for all elements
//   for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
//     // shared storage for flux terms
//     shared dfloat s_fluxNx[p_NblockS][p_Nfp*p_Nfaces];
//     shared dfloat s_fluxNy[p_NblockS][p_Nfp*p_Nfaces];
//     shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
//     shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];

//      // for all face nodes of all elements
//     for(iint es=0;es<p_NblockS;++es;inner1){
//       for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
// 	    iint e = eo + es;
// 	     if(e<Nelements){
// 	      if(n<p_Nfp*p_Nfaces){
// 		    // find face that owns this node
// 		    iint face = n/p_Nfp;
// 		    // load surface geofactors for this face
// 		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
// 		    dfloat nx   = sgeo[sid+NXID];
// 		    dfloat ny   = sgeo[sid+NYID];
// 		    dfloat sJ   = sgeo[sid+SJID];
// 		    dfloat invJ = sgeo[sid+IJID];
		   
// 		    // indices of negative and positive traces of face node
// 		    iint id  = e*p_Nfp*p_Nfaces + n;
// 		    iint idM = vmapM[id];
// 		    iint idP = vmapP[id];

// 		   if(idP<0) idP = idM; // 
// 		  // load negative and positive trace node values of Ux, Uy, Pr
// 		     dfloat  uxm = Ux[idM], uxp = Ux[idP];
// 			   dfloat  uym = Uy[idM], uyp = Uy[idP];
// 			   dfloat  prm = Pr[idM], prp = Pr[idP];

// 		    // apply boundary condition
// 		    iint bc = EToB[face+p_Nfaces*e];
// 		    if(bc>0)
// 		      boundaryConditionsRhs2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym, prm, &uxp, &uyp, &prp);

//         // Find max normal velocity on the face
// 		    dfloat unm   = occaFabs(nx*uxm + ny*uym);
// 		    dfloat unp   = occaFabs(nx*uxp + ny*uyp);    
//         dfloat unmax = (unm > unp) ? unm : unp;

//         // evaluate "flux" terms: LLF
//         const dfloat sc = invJ * sJ ; 
// 				s_fluxNx[es][n] = sc*(.5f*( nx*(uxp*uxp - uxm*uxm) + ny*(uxp*uyp - uxm*uym) + unmax*(uxm-uxp) ));
// 				s_fluxNy[es][n] = sc*(.5f*( nx*(uyp*uxp - uym*uxm) + ny*(uyp*uyp - uym*uym) + unmax*(uym-uyp) ));
//         // Centered flux for pr p*-p = 0.5(prp-prm) // Central Flux
//         s_fluxUx[es][n]  = sc*(.5f*nx*(prp-prm));
//         s_fluxUy[es][n]  = sc*(.5f*ny*(prp-prm));
//        	 }
//     		}
// 			}
// 		}
    
   
//     // wait for all flux functions are written to shared 
//     barrier(localMemFence);

//     // for each node in the element
//     for(iint es=0;es<p_NblockS;++es;inner1){
// 			for(iint n=0;n<p_maxNodes;++n;inner0){
// 				iint e = eo + es;
// 					if(e<Nelements){
// 						if(n<p_Np){
// 							iint id = e*p_Np + n;

// 							dfloat rhsnux = NUx[id];
// 							dfloat rhsnuy = NUy[id];
// 							dfloat rhsux  = rhsUx[id];
// 							dfloat rhsuy  = rhsUy[id];
// 							// Lift
// 							occaUnroll(p_NfacesNfp)
// 							for(int m=0;m<p_Nfaces*p_Nfp;++m){
// 								dfloat L = LIFTT[n+m*p_Np];
// 								//
// 								rhsnux  += L*s_fluxNx[es][m];
// 								rhsnuy  += L*s_fluxNy[es][m];
// 								rhsux   += L*s_fluxUx[es][m];
// 								rhsuy   += L*s_fluxUy[es][m];
// 					}
//           // M^-1* (div(u*u)) + Lift*(F*-F))
// 					NUx[id] = rhsnux;
// 					NUy[id] = rhsnuy;
// 					//  rhsu = -grad(p)
// 					rhsUx[id] = -rhsux;
// 					rhsUy[id] = -rhsuy;
// 				  }
// 				}
//       }
//     }
//   }


// }









// kernel void insHelmholtzRhsIpdgBC2Dv2(const iint Nelements,
// 				                            const dfloat * restrict sgeo,
// 				                            const dfloat * restrict vgeo,
// 																    const dfloat * restrict DrT,
// 																    const dfloat * restrict DsT,
// 																    const dfloat * restrict FMMT,
// 				                            const iint   * restrict vmapM,
// 				                            const iint   * restrict vmapP,
// 				                            const iint   * restrict EToB,
// 				                            const dfloat time,
// 				                            const dfloat tau,
// 				     										    const dfloat * restrict x,
// 				    									      const dfloat * restrict y,
// 				     										    const dfloat * restrict Ux,
// 				     										    const dfloat * restrict Uy,
// 				                                  dfloat * restrict rhsUx,
// 				                                  dfloat * restrict rhsUy
// 				                                  ){
// for(int e=0;e<Nelements;++e;outer0){
// 	// shared storage for flux terms
// 	  shared  dfloat s_uxB[p_Nfp*p_Nfaces];
// 	  shared  dfloat s_uyB[p_Nfp*p_Nfaces];
// 	  shared  dfloat s_uxnB[p_Nfp*p_Nfaces];
// 	  shared  dfloat s_uynB[p_Nfp*p_Nfaces];
// 	  //
//     shared dfloat s_nxuxB[p_Nfp*p_Nfaces];
//     shared dfloat s_nxuyB[p_Nfp*p_Nfaces];
//     shared dfloat s_nyuxB[p_Nfp*p_Nfaces];
//     shared dfloat s_nyuyB[p_Nfp*p_Nfaces];
//     //
//     shared  dfloat s_Lux[p_Np];
// 	  shared  dfloat s_Luy[p_Np];
// 	  shared  dfloat s_Luxn[p_Np];
// 	  shared  dfloat s_Luyn[p_Np];
// 	  //
// 	  shared  dfloat s_Lnxux[p_Np];
// 	  shared  dfloat s_Lnxuy[p_Np];
// 	  shared  dfloat s_Lnyux[p_Np];
// 	  shared  dfloat s_Lnyuy[p_Np];
	 
// 	  //exclusive iint bc = 0, idM=0; 
// 	 // exclusive dfloat tau_n;
	 
//    for(iint n=0;n<p_maxNodes;++n;inner0){
// 	      if(n<p_Nfp*p_Nfaces){
// 	      	// Find face index and bc type
// 					 iint face     = n/p_Nfp;
// 					 iint bc       = EToB[face+p_Nfaces*e];
// 					 //
// 					  s_uxB[n]      = 0.f, s_uyB[n]      = 0.f ;
// 						s_uxnB[n]     = 0.f, s_uxnB[n]     = 0.f ;
// 						//
// 						s_nxuxB[n]    = 0.f, s_nxuyB[n]    = 0.f ;
// 						s_nyuxB[n]    = 0.f, s_nyuyB[n]    = 0.f ;
// 					//
// 	        if(bc>0){ 
// 						//
// 						const iint id  = n + e*p_Nfaces*p_Nfp;
// 						const iint idM = vmapM[id];					
// 						const iint idP = vmapP[id];					
//             // load surface geofactors for this face
// 						iint sid       = p_Nsgeo*(e*p_Nfaces+face);
// 						dfloat nx      = sgeo[sid+p_NXID];
// 						dfloat ny      = sgeo[sid+p_NYID];
// 						dfloat sJ      = sgeo[sid+p_SJID];
// 						dfloat hinv    = sgeo[sid+p_IHID];

// 						//tau_n = hinv* tau; // Scale stabilization parameter
// 						//
// 						// Read interior, may be needed like slip boundaries 
//            //  dfloat  uxm = Ux[idM];
// 	         	// dfloat  uym = Uy[idM];
// 	         	// Currently specific Neumann Boundaries is not implemented !!!
// 	         	dfloat  uxnm = 0.f, uynm =0.f; 
						            
//             // Initialize external dirichlet for ux and uy
//             dfloat  uxp  = 0.f,  uyp = 0.f ; 
//             // Initialize external Neumann for ux and uy
//             dfloat  uxnp = 0.f, uynp = 0.f ;

//            boundaryConditionsIpdg2D(bc, time, x[idM], y[idM], nx, ny, 
//             	                       uxm,  uym, uxnm, uynm,
//             	                       &uxp, &uyp, &uxnp, &uynp);
            
// 					 // Hold RHS information and multiply with sJ
// 						s_uxB[n]      = sJ*uxp*hinv*tau ;
// 						s_uyB[n]      = sJ*uyp*hinv*tau ;
// 						s_uxnB[n]     = sJ*uxnp;
// 						s_uxnB[n]     = sJ*uynp;			
// 						//
// 						s_nxuxB[n]    = sJ*nx*uxp;
// 						s_nxuyB[n]    = sJ*nx*uyp;
// 						s_nyuxB[n]    = sJ*ny*uxp;
// 						s_nyuyB[n]    = sJ*ny*uyp;
//     		}
//   		}
// 		}

// 		barrier(localMemFence);

//    for(int n=0;n<p_Nmax;++n;inner0){
//       if(n<p_Np){
// 	      dfloat uxb = 0.f, uyb =0.f, uxnb =0.f, uynb =0.f;
// 	      dfloat nxux = 0.f, nxuy = 0.f, nyux =0.f, nyuy =0.f;  
// 		    // lift remaining surface terms
// 		    occaUnroll(p_NfacesNfp)
// 		    for(int m=0;m<p_Nfaces*p_Nfp;++m){
// 		    	 const dfloat FM = FMMT[n+m*p_Np];
// 		       uxb  += FM*s_uxB[m];
// 		       uyb  += FM*s_uyB[m];
// 		       uxnb += FM*s_uxnB[m];
// 		       uynb += FM*s_uynB[m];
// 		       //
//            nxux += FM*s_nxuxB[m];
// 		       nxuy += FM*s_nxuyB[m];
// 		       nyux += FM*s_nyuxB[m];
// 		       nyuy += FM*s_nyuyB[m];

// 		     }	
// 				s_Lux[n]      = uxb;
// 				s_Luy[n]      = uyb;
// 				s_Luxn[n]     = uxnb;
// 				s_Luyn[n]     = uynb;
// 				//
// 				s_Lnxux[n]    = nxux;
// 		    s_Lnxuy[n]    = nxuy;
// 		    s_Lnyux[n]    = nyux;
// 		    s_Lnyuy[n]    = nyuy;
// 	      }
// 	    } 

// 	     barrier(localMemFence);

//    for(int n=0;n<p_Nmax;++n;inner0){
//       if(n<p_Np){
// 				const int gid = e*p_Nvgeo;
// 				const dfloat drdx = vgeo[gid + p_RXID];
// 				const dfloat drdy = vgeo[gid + p_RYID];
// 				const dfloat dsdx = vgeo[gid + p_SXID];
// 				const dfloat dsdy = vgeo[gid + p_SYID];
// 				//
//         dfloat drnxux= 0.f, drnxuy =0.f, drnyux= 0.f, drnyuy =0.f;
//         dfloat dsnxux= 0.f, dsnxuy =0.f, dsnyux= 0.f, dsnyuy =0.f;
// 		    // lift remaining surface terms
// 		    occaUnroll(p_Np)
// 		    for(int i=0;i<p_Np;++i){
// 		    	const dfloat Drni = DrT[i+n*p_Np]; // !!!Take transpose was DrT[n+i*p_Np]
// 					const dfloat Dsni = DsT[i+n*p_Np]; // !!!Take transpose was DsT[i+n*p_Np]
// 					drnxux += Drni*s_Lnxux[n];
// 					dsnxux += Dsni*s_Lnxux[n];
// 					//
// 					drnyux += Drni*s_Lnyux[n];
// 					dsnyux += Dsni*s_Lnyux[n];
// 					//
// 					drnxuy += Drni*s_Lnxuy[n];
// 					dsnxuy += Dsni*s_Lnxuy[n];
// 					//
// 					drnyuy += Drni*s_Lnyuy[n];
// 					dsnyuy += Dsni*s_Lnyuy[n];
// 				}

// 				// (grad(phi),U_d) = DxT*

//         dfloat dndux =  (drdx*drnxux + dsdx*dsnxux + drdy*drnyux + dsdy*dsnyux);
//         dfloat dnduy =  (drdx*drnxuy + dsdx*dsnxuy + drdy*drnyuy + dsdy*dsnyuy);


//         const iint id = e*p_Np+n;
// 				rhsUx[id] +=  s_Lux[n] + s_Luxn[n] - dndux;
// 				rhsUy[id] +=  s_Luy[n] + s_Luyn[n] - dnduy;

// 				// rhsUx[id] +=  s_Lux[n] + s_Luxn[n];
// 				// rhsUy[id] +=  s_Luy[n] + s_Luyn[n];


// 			}

//    }

//   }
// }






