#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3
//
#define UXID 0
#define UYID 1

/* offsets for nx, ny, sJ, 1/J */
#define NXID 0  
#define NYID 1  
#define SJID 2  
#define IJID 3  
#define WSJID 4
#define IHID 5

void boundaryConditionsIpdg2D(const iint bc,
			                           const dfloat  t,    const dfloat  x, const dfloat  y,
			                           const dfloat  nx,   const dfloat  ny,
			                           const dfloat  uxM,  const dfloat  uyM,
			                           const dfloat  uxnM, const dfloat  uynM,
			                                 dfloat * restrict uxB,  dfloat * restrict uyB,
			                                 dfloat * restrict uxnB, dfloat * restrict uynB){

  if(bc==1){ // Wall 
    *uxB = 0.f; 
    *uyB = 0.f;
  }
  if(bc==2){ // Inflow
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
  if(bc==3){ // Outflow 
  // do nothing 
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI);
    *uxnB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uynB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
   
   if(bc==4){ // Slip
    *uxnB = uxM;
    *uynB = uyM;
  }




}

void boundaryConditionsRhs2D(const iint bc,
			              const dfloat  t, const dfloat  x, const dfloat  y,
			              const dfloat  nx, const dfloat  ny,
			              const dfloat  uxM, const dfloat  uyM, const dfloat prM,
			                    dfloat * restrict uxB, dfloat * restrict uyB, dfloat * restrict prB){

  if(bc==1){ // Wall 
    *uxB = 0.f; 
    *uyB = 0.f;
    // For pressure do nothing
  }
  if(bc==2){ // Inflow
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;
    *uxB = 1.0f - occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y) ; 
    *uyB = 0.5f*lamda/(OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);
  }
  if(bc==3){ // Outflow 
  // do nothing 
  	dfloat nu   = 1.0/40.0;
  	dfloat lamda = 1.f/(2.f * nu) - occaSqrt(1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

    *uxB = -lamda*occaExp(lamda*x)*occaCos(2.f*OCCA_PI*y);
    *uyB =  lamda*(0.5f*lamda/OCCA_PI)*occaExp(lamda*x)*occaSin(2.f*OCCA_PI*y);

    *prB = 0.5f*(1.0f - occaExp(2.0f*lamda*x)); //Dirichlet for pressure
  }
}



kernel void insHelmholtzRhsVolume2D(const iint Nelements,
																		const dfloat * restrict vgeo,
																		const dfloat * restrict DrT,
																		const dfloat * restrict DsT,
																		const dfloat * restrict U,
																		const dfloat * restrict Pr,
																		      dfloat * restrict NU,
																		      dfloat * restrict rhsU){
  
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements
   
   // Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_FxUx[p_NblockV][p_Np];
   shared dfloat s_FxUy[p_NblockV][p_Np];
   shared dfloat s_FyUy[p_NblockV][p_Np];
   // Hold Pressure on Shared
   shared dfloat s_Pr[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id = e*p_Np+n;
					const dfloat ux = U[id + UXID*p_NtotalDofs];
					const dfloat uy = U[id + UYID*p_NtotalDofs];
					const dfloat pr = Pr[id];
					//
					s_FxUx[es][n] = ux*ux;
					s_FxUy[es][n] = ux*uy;
					s_FyUy[es][n] = uy*uy;
          s_Pr[es][n]   = pr;

				}
      }
    }

     // Make sure all node data is loaded into shared
    barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
			iint e = eo+es; // element in block
			if(e<Nelements){	  
			  // prefetch geometric factors (constant on triangle)
			  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
			  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
			  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
			  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];
			 
	  // compute 'r' and 's' derivatives of (q_m) at node n
				dfloat df11dr = 0.f, df11ds = 0.f; 
				dfloat df12dr = 0.f, df12ds = 0.f; 
				dfloat df22dr = 0.f, df22ds = 0.f; 
				dfloat dprdr  = 0.f, dprds  = 0.f;

				occaUnroll(p_Np)
				for(iint i=0;i<p_Np;++i){
					const dfloat Drni = DrT[n+i*p_Np];
					const dfloat Dsni = DsT[n+i*p_Np];
					// 
					df11dr += Drni*s_FxUx[es][i];
					df11ds += Dsni*s_FxUx[es][i];
					//
					df12dr += Drni*s_FxUy[es][i];
					df12ds += Dsni*s_FxUy[es][i];
					// 
					df22dr += Drni*s_FyUy[es][i];
					df22ds += Dsni*s_FyUy[es][i];
					//
					dprdr  += Drni*s_Pr[es][i];
					dprds  += Dsni*s_Pr[es][i];
				}
				// chain rule
        dfloat nux   = drdx*df11dr + dsdx*df11ds + drdy*df12dr + dsdy*df12ds;
        dfloat nuy   = drdx*df12dr + dsdx*df12ds + drdy*df22dr + dsdy*df22ds;
        dfloat dprdx = drdx*dprdr  + dsdx*dprds;
        dfloat dprdy = drdy*dprdr  + dsdy*dprds;
				// Update RhsU
				const iint id = e*p_Np+n;
				// Compute div(uxu)
				NU[id + UXID*p_NDofs]   = nux;
				NU[id + UYID*p_NDofs]   = nuy;
        // rhsU = - grad P
				rhsU[id + UXID*p_NDofs] = dprdx;
				rhsU[id + UYID*p_NDofs] = dprdy;
	 
	}
      }
    }
 }
}






kernel void insHelmholtzRhsSurface2D(const iint Nelements,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const iint   * restrict vmapM,
				     const iint   * restrict vmapP,
				     const iint   * restrict EToB,
				     const dfloat time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat * restrict U,
				     const dfloat * restrict Pr,
				           dfloat * restrict NU,
				           dfloat * restrict rhsU){
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxNUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxNUy[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxUy[p_NblockS][p_Nfp*p_Nfaces];

     // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	   iint e = eo + es;
	    if(e<Nelements){
	      if(n<p_Nfp*p_Nfaces){
		    // find face that owns this node
		    iint face = n/p_Nfp;
		    // load surface geofactors for this face
		    iint sid    = p_Nsgeo*(e*p_Nfaces+face);
		    dfloat nx   = sgeo[sid+0];
		    dfloat ny   = sgeo[sid+1];
		    //
		    dfloat sJ   = sgeo[sid+2];
		    dfloat invJ = sgeo[sid+3];
		   
		    // indices of negative and positive traces of face node
		    iint id  = e*p_Nfp*p_Nfaces + n;
		    iint idM = vmapM[id];
		    iint idP = vmapP[id];

		   if(idP<0) idP = idM;
		  
	  // load negative and positive trace node values of q
	     dfloat  uxm = U[idM + UXID*p_NtotalDofs];
	     dfloat  uxp = U[idP + UXID*p_NtotalDofs];
	     //
		   dfloat  uym = U[idM + UYID*p_NtotalDofs];
		   dfloat  uyp = U[idP + UYID*p_NtotalDofs];
		   //
		   dfloat  prm = U[idM];
		   dfloat  prp = U[idP];

		    // apply boundary condition
		    iint bc = EToB[face+p_Nfaces*e];
		    if(bc>0)
		      boundaryConditionsRhs2D(bc, time, x[idM], y[idM], nx, ny, uxm, uym, prm, &uxp, &uyp, &prp);


        // Find max normal velocity
		    dfloat unm   = occaFabs(nx*uxm + ny*uym);
		    dfloat unp   = occaFabs(nx*uxp + ny*uyp);
            
        dfloat unmax = (unm > unp) ? unm : unp;

        // evaluate "flux" terms: LLF
        const dfloat sc = invJ * sJ ; 
				s_fluxNUx[es][n] = sc*(0.5f*( nx*(uxp*uxp - uxm*uxm) + ny*(uxp*uyp - uxm*uym) + unmax*(uxm-uxp) ));
				s_fluxNUy[es][n] = sc*(0.5f*( nx*(uyp*uxp - uym*uxm) + ny*(uyp*uyp - uym*uym) + unmax*(uym-uyp) ));
        // Centered flux for pr, p*-p = 0.5(prp-prm)
        s_fluxUx[es][n]  = sc*(0.5f*nx*(prp-prm));
        s_fluxUy[es][n]  = sc*(0.5f*ny*(prp-prm));
       	 }
    		}
			}
		}
    
   
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
			for(iint n=0;n<p_maxNodes;++n;inner0){
				iint e = eo + es;
					if(e<Nelements){
						if(n<p_Np){
							iint id = e*p_Np + n;

							dfloat rhsnux = NU[id + UXID*p_NDofs];
							dfloat rhsnuy = NU[id + UYID*p_NDofs];
							//
							dfloat rhsux = rhsU[id + UXID*p_NDofs];
							dfloat rhsuy = rhsU[id + UYID*p_NDofs];
							// Lift
							occaUnroll(p_NfacesNfp)
							for(int m=0;m<p_Nfaces*p_Nfp;++m){
								dfloat L = LIFTT[n+m*p_Np];
								//
								rhsnux  += L*s_fluxNUx[es][m];
								rhsnuy  += L*s_fluxNUy[es][m];
								//
								rhsux   += L*s_fluxUx[es][m];
								rhsuy   += L*s_fluxUy[es][m];
					}
          // M^-1* (div(u*u)) + Lift*(F*-F))
					NU[id + UXID*p_NDofs]   = rhsnux;
					NU[id + UYID*p_NDofs]   = rhsnuy;
					//  rhsu = -grad(p)
					rhsU[id + UXID*p_NtotalDofs] = -rhsux;
					rhsU[id + UYID*p_NtotalDofs] = -rhsuy;
				  }
				}
      }
    }
  }


}



kernel void insHelmholtzRhsUpdate2D(const iint Nelements,
	                            const dfloat * restrict vgeo,
					                    const dfloat * restrict MM,
				                      const dfloat dt,	
				                      const dfloat a0,
				                      const dfloat a1,
				                      const dfloat a2,
				                      const dfloat b0,
				                      const dfloat b1,
				                      const dfloat b2,
				                      const dfloat * restrict U,
				                      const dfloat * restrict UO,
				                      const dfloat * restrict UOO,
                              const dfloat * restrict NU,
				                            dfloat * restrict NUO,
				                            dfloat * restrict NUOO,
				                            dfloat * restrict rhsU
				                            ){
  
  //Low storage Runge Kutta time step update
   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){ 
  // 	// Hold Flux Vector on Shared, use symmetry f21 = f12
   shared dfloat s_rhsUx[p_NblockV][p_Np];
   shared dfloat s_rhsUy[p_NblockV][p_Np];
   
    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
				iint e = eo+es; // element in block
				if(e<Nelements){ 
					const iint id = e*p_Np+n;
					const dfloat J = vgeo[e*p_Nvgeo + p_JID];
					//
					const dfloat ux    = U[id + UXID*p_NtotalDofs];
					const dfloat uy    = U[id + UYID*p_NtotalDofs];
					//
					const dfloat uxo   = UO[id   + UXID*p_NDofs];
					const dfloat uyo   = UO[id   + UYID*p_NDofs];

					const dfloat uxoo  = UOO[id  + UXID*p_NDofs];
					const dfloat uyoo  = UOO[id  + UYID*p_NDofs];
					//
					const dfloat nux   = NU[id   + UXID*p_NDofs];
					const dfloat nuy   = NU[id   + UYID*p_NDofs];
					//
					const dfloat nuxo  = NUO[id  + UXID*p_NDofs];
					const dfloat nuyo  = NUO[id  + UYID*p_NDofs];
					//
					const dfloat nuxoo = NUOO[id + UXID*p_NDofs];
					const dfloat nuyoo = NUOO[id + UYID*p_NDofs];

					const dfloat rhsux = rhsU[id + UXID*p_NDofs];
					const dfloat rhsuy = rhsU[id + UYID*p_NDofs];
					//Update NU
					NUOO[id+ UXID*p_NDofs]    = nuxo;
					NUOO[id+ UYID*p_NDofs]    = nuyo;
					NUO[id + UXID*p_NDofs]    = nux;
					NUO[id + UYID*p_NDofs]    = nuy;
					//
          s_rhsUx[es][n]   = J*p_inu*(rhsux + (a0*ux + a1*uxo + a2*uxoo)/dt - (b0*nux + b1*nuxo + b2*nuxoo));
          s_rhsUy[es][n]   = J*p_inu*(rhsux + (a0*uy + a1*uyo + a2*uyoo)/dt - (b0*nuy + b1*nuyo + b2*nuyoo)); 
				}
      }
    }

   //   // make sure all node data is loaded into shared
     barrier(localMemFence);


    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
			iint e = eo+es; // element in block
			if(e<Nelements){	  
			 
	    // Multiplay with Mass Matrix
				dfloat rhsux = 0.f, rhsuy = 0.f; 

				occaUnroll(p_Np)

				for(iint i=0;i<p_Np;++i){
					const dfloat M = MM[n+i*p_Np];
					// 
					rhsux  += M*s_rhsUx[es][i];
					rhsuy  += M*s_rhsUy[es][i];
				}

				const iint id = e*p_Np+n;

				rhsU[id + UXID*p_NDofs] = rhsux;
				rhsU[id + UYID*p_NDofs] = rhsuy;
	 
	      }
      }
    }

  
    
  }
}



kernel void insHelmholtzRhsIpdgBC2D(const iint Nelements,
				                            const dfloat * restrict sgeo,
				                            const dfloat * restrict vgeo,
																    const dfloat * restrict DrT,
																    const dfloat * restrict DsT,
																    const dfloat * restrict FMMT,
				                            const iint   * restrict vmapM,
				                            const iint   * restrict vmapP,
				                            const iint   * restrict EToB,
				                            const dfloat time,
				                            const dfloat tau,
				     										    const dfloat * restrict x,
				    									      const dfloat * restrict y,
				     										    const dfloat * restrict U,
				                                  dfloat * restrict rhsU
				                                  ){
for(int e=0;e<Nelements;++e;outer0){
	// shared storage for flux terms
	  shared  dfloat s_uxB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uyB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uxnB[p_Nfp*p_Nfaces];
	  shared  dfloat s_uynB[p_Nfp*p_Nfaces];
	  //
    shared dfloat s_nxuxB[p_Nfp*p_Nfaces];
    shared dfloat s_nxuyB[p_Nfp*p_Nfaces];
    shared dfloat s_nyuxB[p_Nfp*p_Nfaces];
    shared dfloat s_nyuyB[p_Nfp*p_Nfaces];
    //
    shared  dfloat s_Lux[p_Np];
	  shared  dfloat s_Luy[p_Np];
	  shared  dfloat s_Luxn[p_Np];
	  shared  dfloat s_Luyn[p_Np];
	  //
	  shared  dfloat s_Lnxux[p_Np];
	  shared  dfloat s_Lnxuy[p_Np];
	  shared  dfloat s_Lnyux[p_Np];
	  shared  dfloat s_Lnyuy[p_Np];
	 
	  //exclusive iint bc = 0, idM=0; 
	  exclusive dfloat tau_n;
	 
   for(iint n=0;n<p_maxNodes;++n;inner0){
	      if(n<p_Nfp*p_Nfaces){
	      	// Find face index and bc type
					 iint face     = n/p_Nfp;
					 iint bc       = EToB[face+p_Nfaces*e];
					 //
					  s_uxB[n]      = 0.f, s_uyB[n]      = 0.f ;
						s_uxnB[n]     = 0.f, s_uxnB[n]     = 0.f ;
						//
						s_nxuxB[n]    = 0.f, s_nxuyB[n]    = 0.f ;
						s_nyuxB[n]    = 0.f, s_nyuyB[n]    = 0.f ;
					//
	        if(bc){ 
						//
						const iint id  = n + e*p_Nfaces*p_Nfp;
						const iint idM = vmapM[id];					
						const iint idP = vmapP[id];					
            // load surface geofactors for this face
						iint sid    = p_Nsgeo*(e*p_Nfaces+face);
						dfloat nx          = sgeo[sid+p_NXID];
						dfloat ny          = sgeo[sid+p_NYID];
						dfloat sJ          = sgeo[sid+p_SJID];
						//invJ        = sgeo[sid+p_IJID];
						dfloat hinv  = sgeo[sid+p_IHID];

						tau_n = hinv* tau; // Scale stabilization parameter
						//
						// Read interior, may be needed like slip boundaries 
            dfloat  uxm = U[idM + UXID*p_NtotalDofs];
	         	dfloat  uym = U[idM + UYID*p_NtotalDofs];
	         	// Currently specific Neumann Boundaries is not implemented !!!
	         	dfloat  uxnm = 0.f, uynm =0.f; 
						            
            // Initialize external dirichlet for ux and uy
            dfloat  uxp = 0.f,  uyp = 0.f ; 
            // Initialize external Neumann for ux and uy
            dfloat  uxnp = 0.f, uynp =0.f ;

           boundaryConditionsIpdg2D(bc, time, x[idM], y[idM], nx, ny, 
            	                       uxm,  uym, uxnm, uynm,
            	                       &uxp, &uyp, &uxnp, &uynp);
            
					 // Hold RHS information and multiply with sJ
						s_uxB[n]      = sJ*uxp;
						s_uyB[n]      = sJ*uyp;
						s_uxnB[n]     = sJ*uxnp;
						s_uxnB[n]     = sJ*uynp;
						//
						s_nxuxB[n]    = sJ*nx*uxp;
						s_nxuyB[n]    = sJ*nx*uyp;
						s_nyuxB[n]    = sJ*ny*uxp;
						s_nyuyB[n]    = sJ*ny*uyp;
    		}
  		}
		}

		barrier(localMemFence);

   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
	      dfloat uxb = 0.f, uyb =0.f, uxnb =0.f, uynb =0.f;
	      dfloat nxux = 0.f, nxuy = 0.f, nyux =0.f, nyuy =0.f;  
		    // lift remaining surface terms
		    occaUnroll(p_NfacesNfp)
		    for(int i=0;i<p_NfacesNfp;++i){
		    	 const dfloat L = FMMT[n+i*p_Np];
		       uxb  += L*s_uxB[i];
		       uyb  += L*s_uyB[i];
		       uxnb += L*s_uxnB[i];
		       uynb += L*s_uynB[i];
		       //
           nxux  += L*s_nxuxB[i];
		       nxuy  += L*s_nxuyB[i];
		       nyux  += L*s_nyuxB[i];
		       nyuy  += L*s_nyuyB[i];

		     }	
				s_Lux[n]      = uxb;
				s_Luy[n]      = uyb;
				s_Luxn[n]     = uxnb;
				s_Luxn[n]     = uynb;
				//
				s_Lnxux[n]     = nxux;
		    s_Lnxuy[n]     = nxuy;
		    s_Lnyux[n]     = nyux;
		    s_Lnyuy[n]     = nyuy;
	      }
	    } 

	     barrier(localMemFence);

   for(int n=0;n<p_Nmax;++n;inner0){
      if(n<p_Np){
				const int gid = e*p_Nvgeo;
				const dfloat drdx = vgeo[gid + p_RXID];
				const dfloat drdy = vgeo[gid + p_RYID];
				const dfloat dsdx = vgeo[gid + p_SXID];
				const dfloat dsdy = vgeo[gid + p_SYID];
				//
        dfloat drnxux= 0.f, drnxuy =0.f, drnyux= 0.f, drnyuy =0.f;
        dfloat dsnxux= 0.f, dsnxuy =0.f, dsnyux= 0.f, dsnyuy =0.f;
		    // lift remaining surface terms
		    occaUnroll(p_Np)
		    for(int i=0;i<p_Np;++i){
		    	const dfloat Drni = DrT[i+n*p_Np]; // Take transpose was DrT[n+i*p_Np]
					const dfloat Dsni = DsT[i+n*p_Np]; // Take transpose was DsT[i+n*p_Np]

					drnxux += Drni*s_Lnxux[n];
					dsnxux += Dsni*s_Lnxux[n];
					//
					drnyux += Drni*s_Lnyux[n];
					dsnyux += Dsni*s_Lnyux[n];
					//
					drnxuy += Drni*s_Lnxuy[n];
					dsnxuy += Dsni*s_Lnxuy[n];
					//
					drnyuy += Drni*s_Lnyuy[n];
					dsnyuy += Dsni*s_Lnyuy[n];
				}

        dfloat dndux = -(drdx*drnxux + dsdx*dsnxux + drdy*drnyux + dsdy*dsnyux);
        dfloat dnduy = -(drdx*drnxuy + dsdx*dsnxuy + drdy*drnyuy + dsdy*dsnyuy);


        const iint id = e*p_Np+n;
				rhsU[id + UXID*p_NDofs] += tau_n*s_Lux[n] + s_Luxn[n] +   dndux;
				rhsU[id + UYID*p_NDofs] += tau_n*s_Luy[n] + s_Luyn[n] +   dnduy;

			}

   }

  }
}






