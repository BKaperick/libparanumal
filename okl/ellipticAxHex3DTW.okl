
// cuboid of storage
kernel void ellipticAxHex3D_cuboid0(const iint Nelements,
				    const iint * restrict elementList,
				    const dfloat * restrict ggeo,
				    const dfloat * restrict D,
				    const dfloat lambda,
				    const dfloat * restrict q,
				    dfloat * restrict Aq,
				    dfloat * restrict grad){
  
  for(iint e=0; e<Nelements; ++e; outer0){

    shared dfloat s_q[p_Nz][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive int emap;
    exclusive dfloat r_tmpr, r_tmps, r_tmpt, r_Aq;

    for(iint k=0; k<p_Nz; ++k; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  
	  emap = elementList[e];
	  
	  if(k==0)
	    s_D[j][i] = D[j*p_Nq+i];
	}
      }
    }

    for(iint jo=0;jo<p_Nq;jo+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq)
	      s_q[js][k][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
	  }
	}
      }
      
      barrier(localMemFence);

      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      dfloat qt = 0;

	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  qt += s_D[k][n]*s_q[js][n][i];
		}
	      grad[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] = qt;
	    }
	  }
	}
      }
    }
    
    barrier(globalMemFence);

    for(iint ko=0;ko<p_Nq;ko+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint k = ks+ko;
	    if(k<p_Nq)
	      s_q[ks][j][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
	  }
	}
      }
      
      barrier(localMemFence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    const iint k = ko+ks;
	    
	    if(k<p_Nq){
	      // refetch qt
	      const dfloat qt = grad[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i];
	      
	      const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	      
	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
	      
	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0; n<p_Nq; ++n) {
		
		qr += s_D[i][n]*s_q[ks][j][n];
		qs += s_D[j][n]*s_q[ks][n][i];
	      }
	      
	      // assumes w*J built into G entries
	      r_tmpr = G00*qr + G01*qs + G02*qt;
	      r_tmps = G01*qr + G11*qs + G12*qt;
	      r_tmpt = G02*qr + G12*qs + G22*qt;

	      grad[emap*p_Np+ k*p_Nq*p_Nq + j*p_Nq + i] = r_tmpt;

	      r_Aq = GwJ*s_q[ks][j][i];
	    }
	  }
	}
      }

      barrier(localMemfence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){      
	    s_q[ks][j][i] = r_tmpr;
	  }
	}
      }

      barrier(localMemfence);

      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    const iint k = ko+ks;
	    
	    if(k<p_Nq){
	      dfloat tmpr = 0;

	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  tmpr += s_D[n][i]*s_q[ks][j][n];
		}
	      r_Aq += tmpr;
	    }
	  }
	}
      }

      barrier(localMemfence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){      
	    s_q[ks][j][i] = r_tmps;
	  }
	}
      }
      
      barrier(localMemfence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    const iint k = ko+ks;
	    
	    if(k<p_Nq){
	      dfloat tmps = 0;
	      
	      occaUnroll(p_Nq)
	      for(iint n=0;n<p_Nq;++n){
		tmps += s_D[n][j]*s_q[ks][n][i];
	      }
	      r_Aq += tmps;
	      Aq[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i] = r_Aq;

	    }
	  }
	}
      }
    }

    barrier(globalMemFence);

    for(iint jo=0;jo<p_Nq;jo+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      s_q[js][k][i] = grad[emap*p_Np +  k*p_Nq*p_Nq + j*p_Nq + i];
	    }
	  }
	}
      }
      
      barrier(localMemFence);

      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      dfloat tmpt = 0;
	      
	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  tmpt += s_D[n][k]*s_q[js][n][i];
		}
	      
	      Aq[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] += tmpt;
	      
	    }
	  }
	}
      }
    }
  }
}

#if 0
kernel void ellipticAxHex3D_cuboid1(const iint Nelements,
				    const iint * restrict elementList,
				    const dfloat * restrict ggeo,
				    const dfloat * restrict D,
				    const dfloat lambda,
				    const dfloat * restrict q,
				    dfloat * restrict Aq,
				    dfloat * restrict grad){
  
  for(iint e=0; e<Nelements; ++e; outer0){

    shared dfloat s_q[p_Nz][p_Nq][p_Nq];
    shared dfloat s_qr[p_Nz][p_Nq][p_Nq];
    shared dfloat s_qs[p_Nz][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    exclusive int emap;
    exclusive dfloat r_tmpr, r_tmps, r_tmpt, r_Aq;

    for(iint k=0; k<p_Nz; ++k; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  
	  emap = elementList[e];
	  
	  if(k==0)
	    s_D[j][i] = D[j*p_Nq+i];
	}
      }
    }

    for(iint jo=0;jo<p_Nq;jo+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq)
	      s_q[js][k][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
	  }
	}
      }
      
      barrier(localMemFence);

      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      dfloat qt = 0;

	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  qt += s_D[k][n]*s_q[js][n][i];
		}
	      grad[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] = qt;
	    }
	  }
	}
      }
    }
    
    barrier(globalMemFence);

    for(iint ko=0;ko<p_Nq;ko+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint k = ks+ko;
	    if(k<p_Nq)
	      s_q[ks][j][i] = q[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i];
	  }
	}
      }
      
      barrier(localMemFence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    const iint k = ko+ks;
	    
	    if(k<p_Nq){
	      // refetch qt
	      const dfloat qt = grad[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i];
	      
	      const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	      
	      const dfloat G00 = ggeo[base+p_G00ID*p_Np];
	      const dfloat G01 = ggeo[base+p_G01ID*p_Np];
	      const dfloat G02 = ggeo[base+p_G02ID*p_Np];
	      const dfloat G11 = ggeo[base+p_G11ID*p_Np];
	      const dfloat G12 = ggeo[base+p_G12ID*p_Np];
	      const dfloat G22 = ggeo[base+p_G22ID*p_Np];
	      const dfloat GwJ = ggeo[base+p_GWJID*p_Np];
	      
	      dfloat qr = 0.f, qs = 0.f;
	      for(iint n=0; n<p_Nq; ++n) {
		
		qr += s_D[i][n]*s_q[ks][j][n];
		qs += s_D[j][n]*s_q[ks][n][i];
	      }
	      
	      // assumes w*J built into G entries
	      s_qr[ks][j][i] = G00*qr + G01*qs + G02*qt;
	      s_qs[ks][j][i] = G01*qr + G11*qs + G12*qt;
	      r_tmpt = G02*qr + G12*qs + G22*qt;

	      grad[emap*p_Np+ k*p_Nq*p_Nq + j*p_Nq + i] = r_tmpt;

	      r_Aq = GwJ*s_q[ks][j][i];
	    }
	  }
	}
      }

      barrier(localMemfence);
      
      for(iint ks=0; ks<p_Nz; ++ks; inner2){
	for(iint j=0; j<p_Nq; ++j; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    const iint k = ko+ks;
	    
	    if(k<p_Nq){
	      dfloat tmpr = 0, tmps = 0;

	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  tmpr += s_D[n][i]*s_q[ks][j][n];
		  tmps += s_D[n][j]*s_q[ks][n][i];
		}
	      r_Aq += tmpr;
	      r_Aq += tmps;

	      Aq[emap*p_Np+k*p_Nq*p_Nq + j*p_Nq + i] = r_Aq;
	    }
	  }
	}
      }
    }
  }
  
  for(iint e=0; e<Nelements; ++e; outer0){

    shared dfloat s_q[p_Nz][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq+1];

    exclusive int emap;
    exclusive dfloat r_Aq;

    for(iint k=0; k<p_Nz; ++k; inner2){
      for(iint j=0; j<p_Nq; ++j; inner1){
	for(iint i=0; i<p_Nq; ++i; inner0){
	  
	  emap = elementList[e];
	  
	  if(k==0)
	    s_D[j][i] = D[j*p_Nq+i];
	}
      }
    }

    for(iint jo=0;jo<p_Nq;jo+=p_Nz){
      
      barrier(localMemFence);
      
      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      s_q[js][k][i] = grad[emap*p_Np +  k*p_Nq*p_Nq + j*p_Nq + i];
	    }
	  }
	}
      }
      
      barrier(localMemFence);

      for(iint js=0; js<p_Nz; ++js; inner2){
	for(iint k=0; k<p_Nq; ++k; inner1){
	  for(iint i=0; i<p_Nq; ++i; inner0){
	    iint j = js+jo;
	    if(j<p_Nq){
	      dfloat tmpt = 0;
	      
	      occaUnroll(p_Nq)
		for(iint n=0;n<p_Nq;++n){
		  tmpt += s_D[n][k]*s_q[js][n][i];
		}
	      
	      r_Aq += tmpt;
	      
	      Aq[emap*p_Np + k*p_Nq*p_Nq + j*p_Nq + i] += r_Aq;
	      
	    }
	  }
	}
      }
    }
  }
}
#endif

//#define LMF 1

kernel void ellipticAxHex3D_slab1(const iint Nelements,
				  const iint * restrict elementList,
				  const dfloat * restrict ggeo,
				  const dfloat * restrict D,
				  const dfloat lambda,
				  const dfloat * restrict q,
				  dfloat * restrict Aq, 
				  const dfloat * restrict grad){
  
  for(iint e=0; e<Nelements; ++e; outer0) {

    shared dfloat s_tmpr[p_Nq][p_Nq];
    shared dfloat s_tmps[p_Nq][p_Nq];
    shared dfloat s_q[p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_q[p_Nq], r_Aq[p_Nq], r_qt, r_tmpt;
    exclusive int emap;
    exclusive dfloat r_G00, r_G01, r_G02, r_G11, r_G12, r_G22, r_GwJ;

    // prefetch q(i,j,:,e) to register array
    for(iint j=0; j<p_Nq; ++j; inner1) {
      for(iint i=0; i<p_Nq; ++i; inner0) {
	
	emap = elementList[e];
	
	const iint base = i + j*p_Nq + emap*p_Np;
	
	occaUnroll(p_Nq)
	for(iint k=0; k<p_Nq; ++k) {
	  r_q[k] = q[base + k*p_Nq*p_Nq];
	  r_Aq[k] = 0.f;
	}

	s_D[j][i] = D[j*p_Nq+i];
      }
    }
    
#ifdef LMF
    barrier(localMemFence);
#else
    __threadfence_block();
#endif

    occaUnroll(p_Nq)    
    for(iint k=0; k<p_Nq; ++k) {
      
      for(iint j=0; j<p_Nq; ++j; inner1) {
	for(iint i=0; i<p_Nq; ++i; inner0) {

	  const iint gbase = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	  
	  r_G00 = ggeo[gbase+p_G00ID*p_Np];
	  r_G01 = ggeo[gbase+p_G01ID*p_Np];
	  r_G02 = ggeo[gbase+p_G02ID*p_Np];
	  r_G11 = ggeo[gbase+p_G11ID*p_Np];
	  r_G12 = ggeo[gbase+p_G12ID*p_Np];
	  r_G22 = ggeo[gbase+p_G22ID*p_Np];
	  r_GwJ = ggeo[gbase+p_GWJID*p_Np];
	    
	  // share k-slice of q
	  s_q[j][i] = r_q[k];
	    
	  // hide shared latency behind t-derivative
	  dfloat qtk = 0.f;
	  occaUnroll(p_Nq)
	  for(iint n=0; n<p_Nq; ++n) {
	    qtk += s_D[k][n]*r_q[n];
	  }
	  r_qt = qtk;
	    
	}
      }

#ifdef LMF
    barrier(localMemFence);
#else
    __threadfence_block();
#endif
	
      // process k-slice (first r- and s-derivatives)
      for(iint j=0; j<p_Nq; ++j; inner1) {
	for(iint i=0; i<p_Nq; ++i; inner0) {
#if 0
	  const iint base = emap*p_Nggeo*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	    
	  const dfloat r_G00 = ggeo[base+p_G00ID*p_Np];
	  const dfloat r_G01 = ggeo[base+p_G01ID*p_Np];
	  const dfloat r_G02 = ggeo[base+p_G02ID*p_Np];
	  const dfloat r_G11 = ggeo[base+p_G11ID*p_Np];
	  const dfloat r_G12 = ggeo[base+p_G12ID*p_Np];
	  const dfloat r_G22 = ggeo[base+p_G22ID*p_Np];
	  const dfloat r_GwJ = ggeo[base+p_GWJID*p_Np];
#endif
	    
	  dfloat qr = 0.f, qs = 0.f;
	  occaUnroll(p_Nq)
	  for(iint n=0; n<p_Nq; ++n) {
	    qr += s_D[i][n]*s_q[j][n];
	    qs += s_D[j][n]*s_q[n][i];
	  }
	    
	  // assumes w*J built into r_G entries
	  s_tmpr[j][i] = r_G00*qr + r_G01*qs + r_G02*r_qt;
	  s_tmps[j][i] = r_G01*qr + r_G11*qs + r_G12*r_qt;
	  r_tmpt           = r_G02*qr + r_G12*qs + r_G22*r_qt;
	    
	  r_Aq[k] += r_GwJ*lambda*r_q[k];
	    
	  occaUnroll(p_Nq)
	  for(iint n=0; n<p_Nq; ++n) {
	    r_Aq[n] += s_D[k][n]*r_tmpt;
	  }
	}
      }
	
#ifdef LMF
    barrier(localMemFence);
#else
    __threadfence_block();
#endif

      // second derivatives
      for(iint j=0; j<p_Nq; ++j; inner1) {
	for(iint i=0; i<p_Nq; ++i; inner0) {
	  dfloat Aq1 = 0.0f, Aq2 = 0.0f;
	    
	  occaUnroll(p_Nq)
	  for(iint n=0; n<p_Nq; ++n) {
	    Aq1 += s_D[n][i]*s_tmpr[j][n];
	    Aq2 += s_D[n][j]*s_tmps[n][i];
	  }
	    
	  r_Aq[k] +=  Aq1 + Aq2;
	}
      }
    }

    // write result out (local node storage)
    for(iint j=0; j<p_Nq; ++j; inner1) {
      for(iint i=0; i<p_Nq; ++i; inner0) {
	occaUnroll(p_Nq)
	  for(iint k=0; k<p_Nq; ++k) {
	    Aq[emap*p_Np+k*p_Nq*p_Nq+j*p_Nq+i] = r_Aq[k];
	  }
      }
    }
  }
} 

