// increments gradients of pressure with pseudo-gradients at faces and
// increments rhs with pseudo-gradient/penalty terms at faces (need to double check scaling with tau)

// sgeo stores dfloat4s with nx,ny,nz,(sJ/J)*(w1*w2*w3/(ws1*ws2))

// nx,ny,nz,sJ,invJ - need WsJ

#define surfaceTerms(sk,face,i, j, k)                                   \
  {                                                                     \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];                          \
  const dfloat hinv= sgeo[sk*p_Nsgeo+p_IHID];                           \
                                                                        \
  dfloat dqdxP, dqdyP, dqdzP, qP;                                       \
  dqdxP=0.f; dqdyP=0.f; dqdzP=0.f; qP=0.f;                              \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    const dlong  idM = vmapM[sk];                                       \
    ellipticBoundaryConditions3D(bc, t, x[idM], y[idM], z[idM], nx, ny, nz, 0.f, 0.f, 0.f, 0.f, qP, dqdxP, dqdyP, dqdzP);  \
  }                                                                     \
                                                                        \
  dfloat dq = qP;                                                       \
                                                                        \
  s_dqdx[k][j][i] += WsJ*nx*dq;                                         \
  s_dqdy[k][j][i] += WsJ*ny*dq;                                         \
  s_dqdz[k][j][i] += WsJ*nz*dq;                                         \
                                                                        \
  s_rhsq[k][j][i] -= WsJ*(nx*dqdxP + ny*dqdyP + nz*dqdzP+ tau*dq*hinv); \
  }

kernel void ellipticRhsBCIpdgHex3D(const dlong Nelements,
                                 const dlong * restrict vmapM,
                                 const dfloat tau,
                                 const dfloat t,
                                 const dfloat * restrict x,
                                 const dfloat * restrict y,
                                 const dfloat * restrict z,
                                 const dfloat * restrict vgeo,
                                 const dfloat * restrict sgeo,
                                 const int   * restrict EToB,
                                 const dfloat * restrict D,
                                 dfloat  * restrict rhs){

  for(dlong e=0;e<Nelements;++e;outer0){

    shared dfloat s_dqdx[p_Nq][p_Nq][p_Nq];
    shared dfloat s_dqdy[p_Nq][p_Nq][p_Nq];
    shared dfloat s_dqdz[p_Nq][p_Nq][p_Nq];
    shared dfloat s_rhsq[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];

    // loop over slabs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          s_dqdx[k][j][i] = 0.f;
          s_dqdy[k][j][i] = 0.f;
          s_dqdz[k][j][i] = 0.f;
          s_rhsq[k][j][i] = 0.f;

          if(k==0)
            s_D[j][i] = D[j*p_Nq+i];
        }
      }
    }

    barrier(localMemFence);

    // loop over faces to add pseudo-gradient

    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i ;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i ;             

        surfaceTerms(sk0,0,i,j,     0);
        surfaceTerms(sk5,5,i,j,p_Nq-1); 
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int k=0;k<p_Nq;++k;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i ;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i ;

        surfaceTerms(sk1,1,i,     0,k);
        surfaceTerms(sk3,3,i,p_Nq-1,k); 
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(int k=0;k<p_Nq;++k;inner1){
      for(int j=0;j<p_Nq;++j;inner0){

        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j ;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j ;
        
        surfaceTerms(sk2,2,p_Nq-1,j,k);
        surfaceTerms(sk4,4,     0,j,k); 
      }
    }

    barrier(localMemFence);

    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){

          const dlong gid = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np*p_Nvgeo;     

          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          const dfloat drdz = vgeo[gid + p_RZID*p_Np];
          
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID*p_Np];

          const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

          const dfloat JW   = vgeo[gid + p_JWID*p_Np];
          
          const dfloat dqdx = s_dqdx[k][j][i];
          const dfloat dqdy = s_dqdy[k][j][i];
          const dfloat dqdz = s_dqdz[k][j][i];
          
          s_dqdx[k][j][i] = (drdx*dqdx + drdy*dqdy + drdz*dqdz);
          s_dqdy[k][j][i] = (dsdx*dqdx + dsdy*dqdy + dsdz*dqdz);
          s_dqdz[k][j][i] = (dtdx*dqdx + dtdy*dqdy + dtdz*dqdz);
        }
      }
    }

    barrier(localMemFence);

    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          dfloat dr = 0, ds = 0, dt = 0;

          for(int n=0;n<p_Nq;++n){
            dr += s_D[n][i]*s_dqdx[k][j][n];
            ds += s_D[n][j]*s_dqdy[k][n][i];
            dt += s_D[n][k]*s_dqdz[n][j][i];
          }
          
          const dlong id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          rhs[id] -= s_rhsq[k][j][i]  + dr + ds + dt;
        }
      }
    }
  }
}
