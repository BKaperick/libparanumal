// compute local gradients

kernel void ellipticGradientQuad2D(const int Nelements,
				   const dfloat * restrict vgeo,
				   const dfloat * restrict const D,
				   const dfloat * restrict q,
				   dfloat4 * restrict gradq){  

  for(int e=0;e<Nelements;++e;outer0){

    shared dfloat s_D[p_Nq][p_Nq];
    shared dfloat s_q[p_Nq][p_Nq];
    
    for(int j=0;j<p_Nq;++j){
      // prefetch D
      for(int i=0;i<p_Nq;++i;inner0){
	s_D[j][i] = D[i + p_Nq*j];
      }
      // prefetch q
      for(int i=0;i<p_Nq;++i;inner0){
	const iint id = e*p_Np+j*p_Nq+i;
#if 0
	s_q[j][i] = q[id];
#else
	s_q[j][i] = 0;
#endif
      }
    }
    
    barrier(localMemFence);
    
    // loop over slabs
    for(int j=0;j<p_Nq;++j){
      for(int i=0;i<p_Nq;++i;inner0){
	
#if 0
	const int gid = i + j*p_Nq + e*p_Np*p_Nvgeo;
		
	const dfloat drdx = vgeo[gid + p_RXID*p_Np];
	const dfloat drdy = vgeo[gid + p_RYID*p_Np];
	
	const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
	const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
#else
	const dfloat drdx = 0, drdy = 0, dsdx = 0, dsdy = 0;
#endif
	// compute 1D derivatives
	dfloat qr = 0, qs = 0;
	for(int n=0;n<p_Nq;++n){
	  qr += s_D[i][n]*s_q[j][n];
	  qs += s_D[j][n]*s_q[n][i];
	}
	
	dfloat4 gradqn;
	gradqn.x = drdx*qr + dsdx*qs;
	gradqn.y = drdy*qr + dsdy*qs;
	gradqn.w = s_q[j][i];

	const iint id = e*p_Np+j*p_Nq+i; 
	gradq[id] = gradqn;

      }
    }
  }
}
