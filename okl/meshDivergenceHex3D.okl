#define RXID 0  
#define RYID 1  
#define RZID 2
#define SXID 3  
#define SYID 4  
#define SZID 5  
#define TXID 6  
#define TYID 7  
#define TZID 8

// baseline mesh Divergence - cube threads with no optimizations at all
@kernel void meshDivergenceHex3D_v0(int Nelements, 
				   dfloat * vgeo, 
				   dfloat * D, 
				   dfloat * q, 
				   dfloat * divq){
  
  for(int e=0;e<Nelements;++e;@outer(0)){
    
    // compute gradient at each node
    for(int k=0;k<p_Nq;++k;@inner(2)){
      for(int j=0;j<p_Nq;++j;@inner(1)){
	for(int i=0;i<p_Nq;++i;@inner(0)){

	  int n = i + p_Nq*j + p_Nq*p_Nq*k;
	  
	  // load geometric factors
	  int gid = p_Np*p_Nvgeo*e + n;
	  float drdx = vgeo[gid + p_Np*RXID];
	  float drdy = vgeo[gid + p_Np*RYID];
	  float drdz = vgeo[gid + p_Np*RZID];
	  float dsdx = vgeo[gid + p_Np*SXID];
	  float dsdy = vgeo[gid + p_Np*SYID];
	  float dsdz = vgeo[gid + p_Np*SZID];
	  float dtdx = vgeo[gid + p_Np*TXID];
	  float dtdy = vgeo[gid + p_Np*TYID];
	  float dtdz = vgeo[gid + p_Np*TZID];
	  
	  // matrix-vector multiplies
	  dfloat dudr = 0, dvdr = 0, dwdr = 0;
	  dfloat duds = 0, dvds = 0, dwds = 0;
	  dfloat dudt = 0, dvdt = 0, dwdt = 0;
	  for(int m=0;m<p_Nq;++m){
	    int idr = m + j*p_Nq + k*p_Nq*p_Nq + e*p_Np*3; // 3 fields
	    int ids = i + m*p_Nq + k*p_Nq*p_Nq + e*p_Np*3;
	    int idt = i + j*p_Nq + m*p_Nq*p_Nq + e*p_Np*3;
	    dqdr += D[i*p_Nq + m]*(drdx*q[idr] + drdy*q[idr+p_Np] + drdz*q[idr+2*p_Np]);
	    dqds += D[j*p_Nq + m]*(dsdx*q[ids] + dsdy*q[ids+p_Np] + dsdz*q[ids+2*p_Np]);
	    dqdt += D[k*p_Nq + m]*(dtdx*q[idt] + dtdy*q[idt+p_Np] + dtdz*q[idt+2*p_Np]); 
	  }
	  
	  // chain rule
	  divq[n+e*p_Np] = dqdr+dqds+dqdt;
	}
      }
    }
  }
}
