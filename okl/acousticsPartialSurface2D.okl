
void boundaryConditions2D(int bc, dfloat time, dfloat x, dfloat y,
			  dfloat uM, dfloat vM, dfloat pM,
			  dfloat *uP, dfloat *vP, dfloat *pP){
  
  if(bc==1){
    // assert Neumann for pressure and no penetration for velocity
    *uP = -uM;
    *vP = -vM;
    *pP = pM;
  }
  if(bc==2){
    dfloat dx = 1.f/occaSqrt(2.f);
    dfloat dy = 1.f/occaSqrt(2.f);
    dfloat omega = 10*M_PI;
    dfloat wave = occaCos(omega*(time-(x*dx+y*dy)));
    dfloat uI = dx*wave;
    dfloat vI = dy*wave;
    dfloat pI = wave;
    
    // scattered field wall
    *uP = -uM -2.f*uI;
    *vP = -vM -2.f*vI;
    *pP = pM;
  }
}

// function to compute surface contributions 
// for nodal DG acoustics right hand side
kernel void acousticsPartialSurface2D_s0(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,
					     const dfloat * restrict q,
					     dfloat       * restrict rhsq){
				   
  // for element in list
  for(int el=0;el<Nelements;++el;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)

      const int e = elementIds[el];
      
      if(n<p_Nfp*p_Nfaces){
	// find face that owns this node
	int face = n/p_Nfp;

	// load surface geofactors for this face
	int sid = p_Nsgeo*(e*p_Nfaces+face);
	dfloat nx = sgeo[sid+0];
	dfloat ny = sgeo[sid+1];
	dfloat sJ = sgeo[sid+2];
	dfloat invJ = sgeo[sid+3];

	// indices of negative and positive traces of face node
	int id  = e*p_Nfp*p_Nfaces + n;
	int idM = vmapM[id];
	int idP = vmapP[id];

	if(idP<0) idP = idM;
	int qidM = idM*p_Nfields, qidP = idP*p_Nfields;
	
	// load negative and positive trace node values of q
	dfloat uM = q[qidM+0], vM = q[qidM+1], pM = q[qidM+2];
	dfloat uP = q[qidP+0], vP = q[qidP+1], pP = q[qidP+2];
	
	// apply boundary condition
	int bc = EToB[face+p_Nfaces*e];
	if(bc>0)
	  boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);
	
	// compute (q^* - q^-)
	dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
	
	// evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	s_fluxu[n] = invJ*sJ*(-nx*dpS);
	s_fluxv[n] = invJ*sJ*(-ny*dpS);
	s_fluxp[n] = invJ*sJ*(-nx*duS-ny*dvS);
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element 
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){

	const int e = elementIds[el];
	
	int id = p_Nfields*(p_Np*e + n);

	// load rhs data from volume fluxes
	dfloat rhsu = rhsq[id];
	dfloat rhsv = rhsq[id+1];
	dfloat rhsp = rhsq[id+2];
      
	// rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  dfloat L = LIFTT[n+m*p_Np];
	  rhsu += L*s_fluxu[m];
	  rhsv += L*s_fluxv[m];
	  rhsp += L*s_fluxp[m];
	}

	// store incremented rhs
	rhsq[id]   = rhsu;
	rhsq[id+1] = rhsv;
	rhsq[id+2] = rhsp;
      }
    }
  }
}
    
// s1: float4 for q,rhsq
kernel void acousticsPartialSurface2D_s1(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,
					     const dfloat4 * restrict q4,
					     dfloat4       * restrict rhsq4){
				   
  // for elements in list
  for(int el=0;el<Nelements;++el;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)

      if(n<p_Nfp*p_Nfaces){

	// find element
	const int e = elementIds[el];      
	
	// find face that owns this node
	int face = n/p_Nfp;

	// load surface geofactors for this face
	int sid = p_Nsgeo*(e*p_Nfaces+face);
	dfloat nx = sgeo[sid+0];
	dfloat ny = sgeo[sid+1];
	dfloat sJ = sgeo[sid+2];
	dfloat invJ = sgeo[sid+3];

	// indices of negative and positive traces of face node
	int id  = e*p_Nfp*p_Nfaces + n;
	int idM = vmapM[id];
	int idP = vmapP[id];
	if(idP<0) idP = idM;
	
	// load negative and positive trace node values of q4
	dfloat4 qM = q4[idM], qP = q4[idP];
	
	dfloat uM = qM.x, vM = qM.y, pM = qM.z;
	dfloat uP = qP.x, vP = qP.y, pP = qP.z;

	// apply boundary condition
	int bc = EToB[face+p_Nfaces*e];
	if(bc>0)
	  boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);

	// compute (q^* - q^-)
	dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
      
	// evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	s_fluxu[n] = invJ*sJ*(-nx*dpS);
	s_fluxv[n] = invJ*sJ*(-ny*dpS);
	s_fluxp[n] = invJ*sJ*(-nx*duS-ny*dvS);
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element 
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){

	// find element
	const int e = elementIds[el];      
	
	int id = p_Np*e + n;

	// load rhs data from volume fluxes
	dfloat4 rhsq = rhsq4[id];
	dfloat rhsu = rhsq.x;
	dfloat rhsv = rhsq.y;
	dfloat rhsp = rhsq.z;

	// rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  dfloat L = LIFTT[n+m*p_Np];
	  rhsu += L*s_fluxu[m];
	  rhsv += L*s_fluxv[m];
	  rhsp += L*s_fluxp[m];
	}
	
	// store incremented rhs
	rhsq.x = rhsu;
	rhsq.y = rhsv;
	rhsq.z = rhsp;
	rhsq4[id]   = rhsq;
      }
    }
  }
}

// s2: float4 for sgeo
kernel void acousticsPartialSurface2D_s2(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat4 * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,
					     const dfloat4 * restrict q4,
					     dfloat4       * restrict rhsq4){
				   
  // for elements in list
  for(int el=0;el<Nelements;++el;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
      
      if(n<p_Nfp*p_Nfaces){

	// find element
	const int e = elementIds[el];      
	
	// find face that owns this node
	int face = n/p_Nfp;

	// load surface geofactors for this face
	int sid = e*p_Nfaces+face;
	dfloat4 sgeon = sgeo[sid];
	dfloat nx = sgeon.x;
	dfloat ny = sgeon.y;
	dfloat sJ = sgeon.z;
	dfloat invJ = sgeon.w;

	// indices of negative and positive traces of face node
	int id  = e*p_Nfp*p_Nfaces + n;
	int idM = vmapM[id];
	int idP = vmapP[id];

	// load negative and positive trace node values of q4
	dfloat4 qM = q4[idM], qP = q4[idP];
	
	dfloat uM = qM.x, vM = qM.y, pM = qM.z;
	dfloat uP = qP.x, vP = qP.y, pP = qP.z;

	if(idP<0) idP = idM;		
	
	// apply boundary condition
	int bc = EToB[face+p_Nfaces*e];
	if(bc>0)
	  boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);

	// compute (q^* - q^-)
	dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
      
	// evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	s_fluxu[n] = invJ*sJ*(-nx*dpS);
	s_fluxv[n] = invJ*sJ*(-ny*dpS);
	s_fluxp[n] = invJ*sJ*(-nx*duS-ny*dvS);
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element 
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){

	// find element
	const int e = elementIds[el];      
	
	int id = p_Np*e + n;

	// load rhs data from volume fluxes
	dfloat4 rhsq = rhsq4[id];
	dfloat rhsu = rhsq.x;
	dfloat rhsv = rhsq.y;
	dfloat rhsp = rhsq.z;

	// rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	for(int m=0;m<p_Nfp*p_Nfaces;++m){
	  dfloat L = LIFTT[n+m*p_Np];
	  rhsu += L*s_fluxu[m];
	  rhsv += L*s_fluxv[m];
	  rhsp += L*s_fluxp[m];
	}
	
	// store incremented rhs
	rhsq.x = rhsu;
	rhsq.y = rhsv;
	rhsq.z = rhsp;
	rhsq4[id]   = rhsq;
      }
    }
  }
}
    
// s3: unroll lift loop (use float for sgeo)
kernel void acousticsPartialSurface2D_s3(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,	     
					     const dfloat4 * restrict q4,
					     dfloat4       * restrict rhsq4){
				   
  // for all elements
  for(int el=0;el<Nelements;++el;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_Nfp*p_Nfaces];
    
    // for all face nodes of all elements
    for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
      
      if(n<p_Nfp*p_Nfaces){

	// find element
	const int e = elementIds[el];      
	
	// find face that owns this node
	int face = n/p_Nfp;

	// load surface geofactors for this face
	int sid = p_Nsgeo*(e*p_Nfaces+face);
	dfloat nx = sgeo[sid+0];
	dfloat ny = sgeo[sid+1];
	dfloat sJ = sgeo[sid+2];
	dfloat invJ = sgeo[sid+3];

	// indices of negative and positive traces of face node
	int id  = e*p_Nfp*p_Nfaces + n;
	int idM = vmapM[id];
	int idP = vmapP[id];

	if(idP<0) idP = idM;
	
	// load negative and positive trace node values of q4
	dfloat4 qM = q4[idM], qP = q4[idP];
	
	dfloat uM = qM.x, vM = qM.y, pM = qM.z;
	dfloat uP = qP.x, vP = qP.y, pP = qP.z;
	
	// apply boundary condition
	int bc = EToB[face+p_Nfaces*e];
	if(bc>0)
	  boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);

	// compute (q^* - q^-)
	dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
      
	// evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	s_fluxu[n] = invJ*sJ*(-nx*dpS);
	s_fluxv[n] = invJ*sJ*(-ny*dpS);
	s_fluxp[n] = invJ*sJ*(-nx*duS-ny*dvS);
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element 
    for(int n=0;n<p_maxNodes;++n;inner0){
      if(n<p_Np){

	// find element
	const int e = elementIds[el];      
	
	int id = p_Np*e + n;

	// load rhs data from volume fluxes
	dfloat4 rhsq = rhsq4[id];
	dfloat rhsu = rhsq.x;
	dfloat rhsv = rhsq.y;
	dfloat rhsp = rhsq.z;

	// rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	occaUnroll(p_Nfp)
	  for(int m=0;m<p_Nfp*p_Nfaces;++m){
	    dfloat L = LIFTT[n+m*p_Np];
	    rhsu += L*s_fluxu[m];
	    rhsv += L*s_fluxv[m];
	    rhsp += L*s_fluxp[m];
	  }
	
	// store incremented rhs
	rhsq.x = rhsu;
	rhsq.y = rhsv;
	rhsq.z = rhsp;
	rhsq4[id]   = rhsq;
      }
    }
  }
}

// s4: batch process elements
kernel void acousticsPartialSurface2D_s4(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,
					     const dfloat4 * restrict q4,
					     dfloat4       * restrict rhsq4){
				   
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS][p_Nfp*p_Nfaces];    

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int el = eo + es;
	if(el<Nelements){

	  if(n<p_Nfp*p_Nfaces){

	    // find element
	    const int e = elementIds[el];      
	    
	    // find face that owns this node
	    int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    int sid = p_Nsgeo*(e*p_Nfaces+face);
	    dfloat nx = sgeo[sid+0];
	    dfloat ny = sgeo[sid+1];
	    dfloat sJ = sgeo[sid+2];
	    dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
	  
	    // load negative and positive trace node values of q4
	    dfloat4 qM = q4[idM], qP = q4[idP];
	  
	    dfloat uM = qM.x, vM = qM.y, pM = qM.z;
	    dfloat uP = qP.x, vP = qP.y, pP = qP.z;

	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);
	    
	    // compute (q^* - q^-)
	    dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	    dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	    dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
	  
	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
	    s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
	    s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);
	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	int el = eo + es;
	if(el<Nelements){
	  if(n<p_Np){

	    // find element
	    const int e = elementIds[el];      

	    // find output node
	    int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat4 rhsq = rhsq4[id];
	    dfloat rhsu = rhsq.x;
	    dfloat rhsv = rhsq.y;
	    dfloat rhsp = rhsq.z;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_Nfp)
	      for(int m=0;m<p_Nfp*p_Nfaces;++m){
		dfloat L = LIFTT[n+m*p_Np];
		rhsu += L*s_fluxu[es][m];
		rhsv += L*s_fluxv[es][m];
		rhsp += L*s_fluxp[es][m];
	      }
	    
	    // store incremented rhs
	    rhsq.x = rhsu;
	    rhsq.y = rhsv;
	    rhsq.z = rhsp;
	    rhsq4[id] = rhsq;
	  }
	}
      }
    }
  }
}

// s5: lift in shared
kernel void acousticsPartialSurface2D_s5(const int Nelements,
					     const int   * restrict elementIds, 
					     const dfloat * restrict sgeo,
					     const dfloat * restrict LIFTT,
					     const int   * restrict vmapM,
					     const int   * restrict vmapP,
					     const int   * restrict EToB,
					     const dfloat time,
					     const dfloat * restrict x,
					     const dfloat * restrict y,
					     const dfloat4 * restrict q4,
					     dfloat4       * restrict rhsq4){
				   
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    // shared storage for flux terms
    shared dfloat s_fluxu[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxv[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxp[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_LIFTT[p_Nfp*p_Nfaces][p_Np];
    
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
	int el = eo + es;
	
	int t = n + p_maxNodes*es;
	while(t< (p_Np*p_Nfaces*p_Nfp)){
	  s_LIFTT[0][t] = LIFTT[t];
	  t+= p_maxNodes*p_NblockS;
	}
	
	if(el<Nelements){
	  if(n<p_Nfp*p_Nfaces){

	    // find element
	    const int e = elementIds[el];      
	    
	    // find face that owns this node
	    int face = n/p_Nfp;
	  
	    // load surface geofactors for this face
	    int sid = p_Nsgeo*(e*p_Nfaces+face);
	    dfloat nx = sgeo[sid+0];
	    dfloat ny = sgeo[sid+1];
	    dfloat sJ = sgeo[sid+2];
	    dfloat invJ = sgeo[sid+3];

	    // indices of negative and positive traces of face node
	    int id  = e*p_Nfp*p_Nfaces + n;
	    int idM = vmapM[id];
	    int idP = vmapP[id];

	    if(idP<0) idP = idM;
	  
	    // load negative and positive trace node values of q4
	    dfloat4 qM = q4[idM], qP = q4[idP];
	  
	    dfloat uM = qM.x, vM = qM.y, pM = qM.z;
	    dfloat uP = qP.x, vP = qP.y, pP = qP.z;

	    // apply boundary condition
	    int bc = EToB[face+p_Nfaces*e];
	    if(bc>0)
	      boundaryConditions2D(bc, time, x[idM], y[idM], uM, vM, pM, &uP, &vP, &pP);
	    
	    // compute (q^* - q^-)
	    dfloat duS = 0.5*(uP-uM) + p_Lambda2*(-nx)*(pP-pM);
	    dfloat dvS = 0.5*(vP-vM) + p_Lambda2*(-ny)*(pP-pM);
	    dfloat dpS = 0.5*(pP-pM) + p_Lambda2*(-nx*(uP-uM)-ny*(vP-vM));
	  
	    // evaluate "flux" terms: (sJ/J)*(A*nx+B*ny)*(q^* - q^-)
	    s_fluxu[es][n] = invJ*sJ*(-nx*dpS);
	    s_fluxv[es][n] = invJ*sJ*(-ny*dpS);
	    s_fluxp[es][n] = invJ*sJ*(-nx*duS-ny*dvS);
	  }
	}
      }
    }
    
    // wait for all shared memory writes of the previous inner loop to complete
    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner1){
      for(int n=0;n<p_maxNodes;++n;inner0){
	int el = eo + es;
	if(el<Nelements){
	  if(n<p_Np){

	    // find element
	    const int e = elementIds[el];      
	    
	    int id = p_Np*e + n;
	    
	    // load rhs data from volume fluxes
	    dfloat4 rhsq = rhsq4[id];
	    dfloat rhsu = rhsq.x;
	    dfloat rhsv = rhsq.y;
	    dfloat rhsp = rhsq.z;
	    
	    // rhs += LIFT*((sJ/J)*(A*nx+B*ny)*(q^* - q^-))
	    occaUnroll(p_NfacesNfp)
	      for(int m=0;m<p_Nfp*p_Nfaces;++m){
		dfloat L = s_LIFTT[m][n]; 
		rhsu += L*s_fluxu[es][m];
		rhsv += L*s_fluxv[es][m];
		rhsp += L*s_fluxp[es][m];
	      }
	    
	    // store incremented rhs
	    rhsq.x = rhsu;
	    rhsq.y = rhsv;
	    rhsq.z = rhsp;
	    rhsq4[id] = rhsq;
	  }
	}
      }
    }
  }
}
