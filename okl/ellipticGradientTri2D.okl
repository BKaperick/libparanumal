// compute local gradients

kernel void ellipticGradientTri2D_v0(const int Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict const DrT,
				     const dfloat * restrict const DsT,
				     const dfloat * restrict q,
				     dfloat4 * restrict gradq){  

  for(iint e=0;e<Nelements;++e;outer0){

    shared dfloat s_q[p_Np];

    for(iint n=0;n<p_Np;++n;inner0){
	
      // prefetch q
      const iint id = e*p_Np+n;
      s_q[n] = q[id];
    }
    
    barrier(localMemFence);

    for(iint n=0;n<p_Np;++n;inner0){
	
      const int gid = e*p_Nvgeo;
      
      const dfloat drdx = vgeo[gid + p_RXID];
      const dfloat drdy = vgeo[gid + p_RYID];
      const dfloat dsdx = vgeo[gid + p_SXID];
      const dfloat dsdy = vgeo[gid + p_SYID];

      // compute 1D derivatives
      dfloat qr = 0, qs = 0;
      for(iint i=0;i<p_Np;++i){
	qr += DrT[n+i*p_Np]*s_q[i];
	qs += DsT[n+i*p_Np]*s_q[i];
      }
      
      dfloat4 gradqn;
      gradqn.x = drdx*qr + dsdx*qs;
      gradqn.y = drdy*qr + dsdy*qs;
      gradqn.w = s_q[n];
      
      const iint id = e*p_Np+n; 
      gradq[id] = gradqn;
    }
  }
}

#define drdx s_vgeo[es][p_RXID]
#define drdy s_vgeo[es][p_RYID]
#define dsdx s_vgeo[es][p_SXID]
#define dsdy s_vgeo[es][p_SYID]

kernel void ellipticGradientTri2D_v1(const int Nelements,
				     const dfloat * restrict vgeo,
				     const dfloat * restrict const DrT,
				     const dfloat * restrict const DsT,
				     const dfloat * restrict q,
				     dfloat4 * restrict gradq){  
  
  // block partition of elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    
    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	if(e<Nelements){
	  // prefetch q
	  const iint id = e*p_Np+n;
	  s_q[e-eo][n] = q[id];
	}
	
	// coalesce volume geofac reads to shared
	iint t = n + p_Np*(e-eo);
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<Nelements*p_Nvgeo)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t+=p_NblockV*p_Np;
	}
      }
    }
    
    barrier(localMemFence);

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	if(e<Nelements){
	  const iint es = e-eo;
	  const int gid = e*p_Nvgeo;

	  // compute 1D derivatives
	  dfloat qr = 0, qs = 0;

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i){
	      qr += DrT[n+i*p_Np]*s_q[es][i];
	      qs += DsT[n+i*p_Np]*s_q[es][i];
	    }
	  
	  dfloat4 gradqn;
	  gradqn.x = drdx*qr + dsdx*qs;
	  gradqn.y = drdy*qr + dsdy*qs;
	  gradqn.w = s_q[es][n];
	  
	  const iint id = e*p_Np+n; 
	  gradq[id] = gradqn;
	}
      }
    }
  }
}


kernel void ellipticGradientTri2D(const int Nelements,
				  const dfloat * restrict vgeo,
				  const dfloat * restrict const DrT,
				  const dfloat * restrict const DsT,
				  const dfloat * restrict q,
				  dfloat4 * restrict gradq){  
  
  // block partition of elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    
    shared dfloat s_q[p_NblockV][p_Np];
    shared dfloat s_vgeo[p_NblockV][p_Nvgeo];
    shared dfloat s_DrT[p_Np][p_Np];
    shared dfloat s_DsT[p_Np][p_Np];

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	if(e<Nelements){
	  // prefetch q
	  const iint id = e*p_Np+n;
	  s_q[e-eo][n] = q[id];
	}
	
	// coalesce volume geofac reads to shared
	iint t = n + p_Np*(e-eo);
	while(t<p_Nvgeo*p_NblockV){
	  if(eo*p_Nvgeo+t<Nelements*p_Nvgeo)
	    s_vgeo[0][t] = vgeo[eo*p_Nvgeo+t];
	  t+=p_NblockV*p_Np;
	}
	
	t = n + p_Np*(e-eo);
	while(t<p_Np*p_Np){
	  s_DrT[0][t] = DrT[t];
	  s_DsT[0][t] = DsT[t];
	  t+=p_Np*p_NblockV;
	}
      }
    }
    
    barrier(localMemFence);

    for(iint e=eo;e<eo+p_NblockV;++e;inner1){
      for(iint n=0;n<p_Np;++n;inner0){
	if(e<Nelements){
	  const iint es = e-eo;
	  const int gid = e*p_Nvgeo;

	  // compute 1D derivatives
	  dfloat qr = 0, qs = 0;

	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i)
	      qr += s_DrT[i][n]*s_q[es][i];
	  occaUnroll(p_Np)
	    for(iint i=0;i<p_Np;++i)
	      qs += s_DsT[i][n]*s_q[es][i];
	  
	  dfloat4 gradqn;
	  gradqn.x = drdx*qr + dsdx*qs;
	  gradqn.y = drdy*qr + dsdy*qs;
	  gradqn.w = s_q[es][n];
	  
	  const iint id = e*p_Np+n; 
	  gradq[id] = gradqn;
	}
      }
    }
  }
}
