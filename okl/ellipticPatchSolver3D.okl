#define p_patchNelements (p_Nfaces+1)
#define p_patchNp (p_Np*(p_Nfaces+1))


// experimental overlapping patch solver
kernel void ellipticExactPatchSolver3D(const int Nelements,
				       const dfloat * restrict invAP,
				       const int   * restrict EToE,
				       const dfloat * restrict invDegree,
				       const dfloat * restrict q,
				       dfloat * restrict invAPq){
  
  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    shared dfloat s_q[p_NblockP][p_patchNp];
    
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          s_q[e-eo][es*p_Np+n] = 0.f;
        }
      }
    }

    barrier(localMemFence);

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int offset = e*p_patchNp*p_patchNp + es*p_Np + n; // patch matrices offset
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f, res5 = 0.f;

            //      occaUnroll(p_patchNp)
            occaUnroll(p_Np)
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp]*s_q[e-eo][m];
                res2 += invAP[offset + (m+  p_Np)*p_patchNp]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp]*s_q[e-eo][m+3*p_Np];
                res5 += invAP[offset + (m+4*p_Np)*p_patchNp]*s_q[e-eo][m+4*p_Np];
              }

            const dfloat invDeg = invDegree[e];

            invAPq[p_patchNp*e+es*p_Np+n] = invDeg*(res1+res2+res3+res4+res5);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxPatchSolver3D(const int Nelements,
					const int   * restrict patchesIndex,
					const dfloat * restrict invAP,
					const int   * restrict EToE,
					const dfloat * restrict invDegree,
					const dfloat * restrict q,
					dfloat * restrict invAPq){
  
  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockP;outer0){

    shared dfloat s_q[p_NblockP][p_patchNp];

    // loop over elements in sub-patch e and load q
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const int eP = (es==0) ? e: EToE[e*p_Nfaces+es-1]; // load element e first

            s_q[e-eo][es*p_Np+n] = 0.f;
            if(eP>=0){
              s_q[e-eo][es*p_Np+n] = q[eP*p_Np+n];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockP;++e;inner2){
      for(int es=0;es<p_patchNelements;++es;inner1){
        for(int n=0;n<p_Np;++n;inner0){
          if(e<Nelements){
            const dfloat invDeg = invDegree[e];

            // patch matrices offset
            const int offset = patchesIndex[e]*p_patchNp*p_patchNp + es*p_Np + n;
            dfloat res1 = 0.f, res2 = 0.f, res3 = 0.f, res4 = 0.f, res5 = 0.f;
            occaUnroll(p_Np)
              for(int m=0;m<p_Np;++m){
                res1 += invAP[offset + (m       )*p_patchNp ]*s_q[e-eo][m];
                res2 += invAP[offset + (m  +p_Np)*p_patchNp ]*s_q[e-eo][m+p_Np];
                res3 += invAP[offset + (m+2*p_Np)*p_patchNp ]*s_q[e-eo][m+2*p_Np];
                res4 += invAP[offset + (m+3*p_Np)*p_patchNp ]*s_q[e-eo][m+3*p_Np];
                res5 += invAP[offset + (m+4*p_Np)*p_patchNp ]*s_q[e-eo][m+4*p_Np];
              }

            invAPq[p_patchNp*e+es*p_Np+n] = invDeg*(res1+res2+res3+res4+res5);
          }
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticExactFacePatchSolver3D(const int NfacePairs,
					   const dfloat * restrict invAP,
					   const int   * restrict FPairsToE,
					   const dfloat * restrict invDegree,
					   const dfloat * restrict q,
					   dfloat * restrict invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;outer0){

    shared dfloat s_q[2*p_Np];

    // loop over elements in sub-patch e and load q
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int e = FPairsToE[2*f+es];

          s_q[es*p_Np+n] = 0.f;
          if(e>=0){
            s_q[es*p_Np+n] = q[e*p_Np+n];
          }
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(f<NfacePairs){
          const int offset = f*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset
          dfloat res1 = 0.f, res2 = 0.f;

          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
              res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
            }

          const int e = FPairsToE[2*f+es];
          dfloat invDeg;
          if(e>=0) {
            invDeg = invDegree[e];
          } else {
            invDeg = 0.f;
          }

          invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxFacePatchSolver3D(const int NfacePairs,
					    const int   * restrict patchesIndex,
					    const dfloat * restrict invAP,
					    const int   * restrict FPairsToE,
					    const dfloat * restrict invDegree,
					    const dfloat * restrict q,
					    dfloat * restrict invAPq){

  //tune later
  for(int f=0;f<NfacePairs;f++;outer0){

    shared dfloat s_q[2*p_Np];
    exclusive int e;

    // loop over elements in sub-patch f and load q
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){
	e = FPairsToE[2*f+es];
	
	s_q[es*p_Np+n] = 0.f;
	if(e>=0)
	  s_q[es*p_Np+n] = q[e*p_Np+n];
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int es=0;es<2;++es;inner1){
      for(int n=0;n<p_Np;++n;inner0){

	
	const int offset = patchesIndex[f]*2*p_Np*2*p_Np + es*p_Np + n; // patch matrices offset

	dfloat invDeg = (e>=0) ? invDegree[e]:0.f;

	dfloat res1 = 0.f, res2 = 0.f;
	
	occaUnroll(p_Np)
	  for(int m=0;m<p_Np;++m){
	    res1 += invAP[offset + (m     )*2*p_Np]*s_q[m     ];
	    res2 += invAP[offset + (m+p_Np)*2*p_Np]*s_q[m+p_Np];
	  }
	

	invAPq[2*p_Np*f+es*p_Np+n] = invDeg*(res1+res2);
      }
    }
  }
}


// experimental overlapping patch solver
kernel void ellipticExactBlockJacobiSolver3D(const int Nelements,
					     const dfloat * restrict invAP,
					     const dfloat * restrict invDegree,
					     const dfloat * restrict q,
					     dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_blockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];
          const int offset = e*p_Np*p_Np + n; // patch matrices offset
          dfloat res = 0.f;

          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}

// experimental overlapping patch solver
kernel void ellipticApproxBlockJacobiSolver3D(const int Nelements,
					      const int   * restrict patchesIndex,
					      const dfloat * restrict invAP,
					      const dfloat * restrict invDegree,
					      const dfloat * restrict q,
					      dfloat * restrict invAPq){

  // assume one patch per outer iteration (tune later)
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){

    shared dfloat s_q[p_NblockV][p_Np];

    // loop over elements and load q
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          s_q[e-eo][n] = q[e*p_Np+n];
        }
      }
    }

    barrier(localMemFence);

    // loop over elements/nodes in patch and do local smooth
    for(int e=eo;e<eo+p_NblockV;++e;inner1){
      for(int n=0;n<p_Np;++n;inner0){
        if(e<Nelements){
          const dfloat invDeg = invDegree[e];

          // patch matrices offset
          const int offset = patchesIndex[e]*p_Np*p_Np + n;
          dfloat res = 0.f;
          occaUnroll(p_Np)
            for(int m=0;m<p_Np;++m){
              res += invAP[offset + m*p_Np ]*s_q[e-eo][m];
            }

          invAPq[p_Np*e+n] = invDeg*res;
        }
      }
    }
  }
}


