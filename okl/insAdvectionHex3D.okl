
// compute div(NU)  = div(uxu) in collocation way (weak form)
kernel void insAdvectionVolumeHex3D(const dlong Nelements,
                                     const dfloat * restrict vgeo,
                                     const dfloat * restrict D,
                                     const dlong offset,
                                     const dfloat * restrict U,
                                     const dfloat * restrict V,
                                     const dfloat * restrict W,
                                           dfloat * restrict NU,
                                           dfloat * restrict NV,
                                           dfloat * restrict NW){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F12[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F13[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F21[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F22[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F23[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F31[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F32[p_NblockV][p_Nq][p_Nq][p_Nq];
    shared dfloat s_F33[p_NblockV][p_Nq][p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    for(int es=0;es<p_NblockV;++es;inner3){
      for(int k=0;k<p_Nq;++k;inner2){    
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){    
            const dlong e = eo+es; // element in block
            if(e<Nelements){ 
              const dlong gid = e*p_Np*p_Nvgeo+ j*p_Nq +i;
              const dfloat drdx = vgeo[gid + p_RXID*p_Np];
              const dfloat drdy = vgeo[gid + p_RYID*p_Np];
              const dfloat drdz = vgeo[gid + p_RZID*p_Np];
              const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
              const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
              const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
              const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
              const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
              const dfloat dtdz = vgeo[gid + p_TZID*p_Np];
              const dfloat JW = vgeo[gid + p_JWID*p_Np];

              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq+i;

              const dfloat Un = U[id];
              const dfloat Vn = V[id];
              const dfloat Wn = W[id];

              const dfloat cUn = JW*(drdx*Un+drdy*Vn+drdz*Wn);
              const dfloat cVn = JW*(dsdx*Un+dsdy*Vn+dsdz*Wn);
              const dfloat cWn = JW*(dtdx*Un+dtdy*Vn+dtdz*Wn);

              s_F11[es][k][j][i] = cUn*Un;
              s_F12[es][k][j][i] = cVn*Un;
              s_F13[es][k][j][i] = cWn*Un;
              s_F21[es][k][j][i] = cUn*Vn;
              s_F22[es][k][j][i] = cVn*Vn;
              s_F23[es][k][j][i] = cWn*Vn;
              s_F31[es][k][j][i] = cUn*Wn;
              s_F32[es][k][j][i] = cVn*Wn;
              s_F33[es][k][j][i] = cWn*Wn;

              if (es==0 && k==0)
                s_D[j][i] = D[j*p_Nq+i];
            }
          }
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner3){
      for(int k=0;k<p_Nq;++k;inner2){    
        for(int j=0;j<p_Nq;++j;inner1){ 
          for(int i=0;i<p_Nq;++i;inner0){   
            const dlong e = eo+es; 
            if(e<Nelements){ 
              const dlong gid = e*p_Np*p_Nvgeo +k*p_Nq*p_Nq +j*p_Nq +i;
              const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
              dfloat nu = 0.f, nv = 0.f, nw = 0.f;
              
              occaUnroll(p_Nq)
                for(int n=0;n<p_Nq;++n){
                  const dfloat Dr = s_D[n][i];
                  const dfloat Ds = s_D[n][j];
                  const dfloat Dt = s_D[n][k];

                  nu += Dr*s_F11[es][k][j][n]
                       +Ds*s_F12[es][k][n][i]
                       +Dt*s_F13[es][n][j][i];

                  nv += Dr*s_F21[es][k][j][n]
                       +Ds*s_F22[es][k][n][i]
                       +Dt*s_F23[es][n][j][i];

                  nw += Dr*s_F31[es][k][j][n]
                       +Ds*s_F32[es][k][n][i]
                       +Dt*s_F33[es][n][j][i];
                }

              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
              NU[id] = -invJW*nu;
              NV[id] = -invJW*nv;
              NW[id] = -invJW*nw;
            }
          }
        }
      }
    }
  }  
}


#define surfaceTerms(sk,face,i, j, k)                                   \
{                                                                       \
  const dlong  idM = vmapM[sk]+offset*p_Np;                             \
  const dlong  idP = vmapP[sk]+offset*p_Np;                             \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat  uM = U[idM], vM = V[idM], wM = W[idM];                  \
         dfloat uP = U[idP], vP = V[idP], wP = W[idP];                  \
                                                                        \
  int bc = EToB[face+p_Nfaces*e];                                       \
  if(bc>0) {                                                            \
    const dlong idm = vmapM[sk];                                        \
    insVelocityDirichletConditions3D(bc, time, x[idm], y[idm], z[idm], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP); \
  }                                                                     \
                                                                        \
  const dfloat unM   = occaFabs(nx*uM + ny*vM + nz*wM);                 \
  const dfloat unP   = occaFabs(nx*uP + ny*vP + nz*wP);                 \
  const dfloat unMax = (unM > unP) ? unM : unP;                         \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[es][k][j][i] += sc*(.5f*(nx*(uP*uP + uM*uM)                  \
                                  + ny*(uP*vP + uM*vM)                  \
                                  + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) ));\
  s_fluxNV[es][k][j][i] += sc*(.5f*(nx*(vP*uP + vM*uM)                  \
                                  + ny*(vP*vP + vM*vM)                  \
                                  + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) ));\
  s_fluxNW[es][k][j][i] += sc*(.5f*(nx*(wP*uP + wM*uM)                  \
                                  + ny*(wP*vP + wM*vM)                  \
                                  + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) ));\
}

kernel void insAdvectionSurfaceHex3D(const dlong Nelements,
                                      const dfloat * restrict sgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int   * restrict EToB,
                                      const dfloat time,
                                      const dfloat * restrict x,
                                      const dfloat * restrict y,
                                      const dfloat * restrict z,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      const dfloat * restrict W,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV,
                                      dfloat * restrict NW){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNU[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_fluxNV[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_fluxNW[p_NblockS][p_Nq][p_Nq][p_Nq];

    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){
            s_fluxNU[es][k][j][i] = 0.;
            s_fluxNV[es][k][j][i] = 0.;
            s_fluxNW[es][k][j][i] = 0.;
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i + j*p_Nq;
            const dlong sk2 = e*p_Nfp*p_Nfaces + 5*p_Nfp + i + j*p_Nq;

            surfaceTerms(sk0,0,i,j,0     );
            surfaceTerms(sk2,5,i,j,p_Nq-1);
          }
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + i + k*p_Nq;
            const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + i + k*p_Nq;

            surfaceTerms(sk1,1,i,0     ,k);
            surfaceTerms(sk3,3,i,p_Nq-1,k);
          }
        }
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int k=0;k<p_Nq;++k;inner1){
        for(int j=0;j<p_Nq;++j;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + j + k*p_Nq;
            const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + j + k*p_Nq;

            surfaceTerms(sk2,2,p_Nq-1,j,k);
            surfaceTerms(sk4,4,0     ,j,k);
          }
        }
      }
    }

    barrier(localMemFence);

    // for each node in the element
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_Nq;++j;inner1){
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            occaUnroll(p_Nq)
            for(int k=0;k<p_Nq;++k){
              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

              NU[id] += s_fluxNU[es][k][j][i];
              NV[id] += s_fluxNV[es][k][j][i];
              NW[id] += s_fluxNW[es][k][j][i];
            }
          }
        }
      }
    }
  }
}
#undef surfaceTerms


/* ------------------Quadrature kernels ----------------------------------*/

// compute div(NU)  = div(uxu) using quadrature (weak form)
kernel void insAdvectionCubatureVolumeHex3D(const dlong Nelements,
                                             const dfloat * restrict vgeo,
                                             const dfloat * restrict cubvgeo,
                                             const dfloat * restrict cubDWT,
                                             const dfloat * restrict cubInterpT,
                                             const dfloat * restrict cubProjectT,
                                             const dlong offset,
                                             const dfloat * restrict U,
                                             const dfloat * restrict V,
                                             const dfloat * restrict W,
                                             dfloat * restrict NU,
                                             dfloat * restrict NV,
                                             dfloat * restrict NW){

  for(dlong eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_F11[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F12[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F13[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F21[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F22[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F23[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F31[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F32[p_NblockV][p_cubNq][p_cubNq][p_cubNq];
    shared dfloat s_F33[p_NblockV][p_cubNq][p_cubNq][p_cubNq];

    shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];
    shared dfloat s_cubDWT[p_cubNq][p_Nq];

    exclusive dfloat r_Un, r_Vn, r_Wn;
    exclusive dfloat r_F11, r_F12, r_F13, r_F21, r_F22, r_F23, r_F31, r_F32, r_F33;

    //fetch the U and V values and store in flux arrays in shared
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){    
            const dlong e = eo+es; // element in block
            if((e<Nelements) && (i<p_Nq) && (j<p_Nq) && (k<p_Nq)){ 
              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq+i;

              const dfloat Un = U[id];
              const dfloat Vn = V[id];
              const dfloat Wn = W[id];

              s_F11[es][k][j][i] = Un;
              s_F12[es][k][j][i] = Vn;
              s_F13[es][k][j][i] = Wn;
            }

            const int id = i+j*p_cubNq;
            if ((es==0) && k==0 && (id<p_Nq*p_cubNq)) {
              s_cubDWT[0][id] = cubDWT[id];
              s_cubInterpT[0][id] = cubInterpT[id];
              s_cubProjectT[0][id] = cubProjectT[id];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate in i, store in register
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (j<p_Nq && k<p_Nq) {
              r_Un = 0.; r_Vn = 0.; r_Wn = 0.;

              occaUnroll(p_Nq)
              for (int n=0;n<p_Nq;n++) {
                const dfloat Ini = s_cubInterpT[n][i];
                r_Un  += Ini*s_F11[es][k][j][n];
                r_Vn  += Ini*s_F12[es][k][j][n];
                r_Wn  += Ini*s_F13[es][k][j][n];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (j<p_Nq && k<p_Nq) {
              s_F11[es][k][j][i] = r_Un;
              s_F12[es][k][j][i] = r_Vn;
              s_F13[es][k][j][i] = r_Wn;
            }
          }
        }
      }
    }

    //interpolate in j, store in register
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (k<p_Nq) {
              r_Un = 0.; r_Vn = 0.; r_Wn = 0.;

              occaUnroll(p_Nq)
              for (int n=0;n<p_Nq;n++) {
                const dfloat Ini = s_cubInterpT[n][j];
                r_Un  += Ini*s_F11[es][k][n][i];
                r_Vn  += Ini*s_F12[es][k][n][i];
                r_Wn  += Ini*s_F13[es][k][n][i];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (k<p_Nq) {
              s_F11[es][k][j][i] = r_Un;
              s_F12[es][k][j][i] = r_Vn;
              s_F13[es][k][j][i] = r_Wn;
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate in k and store flux in register
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            r_Un  = 0.; r_Vn  = 0.; r_Wn  = 0.;

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Inj = s_cubInterpT[n][k];
              r_Un  += Inj*s_F11[es][n][j][i];
              r_Vn  += Inj*s_F12[es][n][j][i];
              r_Wn  += Inj*s_F13[es][n][j][i];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //construct flux from registers
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            const dlong e = eo+es; // element in block
            if(e<Nelements){ 
              const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
              const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
              const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
              const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
              const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
              const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
              const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
              const dfloat dtdx = cubvgeo[gid + p_SXID*p_cubNp];
              const dfloat dtdy = cubvgeo[gid + p_SYID*p_cubNp];
              const dfloat dtdz = cubvgeo[gid + p_SZID*p_cubNp];
              const dfloat J = cubvgeo[gid + p_JID*p_cubNp];

              const dfloat cUn = J*(drdx*r_Un+drdy*r_Vn+drdz*r_Wn);
              const dfloat cVn = J*(dsdx*r_Un+dsdy*r_Vn+dsdz*r_Wn);
              const dfloat cWn = J*(dtdx*r_Un+dtdy*r_Vn+dtdz*r_Wn);

              s_F11[es][k][j][i] = cUn*r_Un;
              s_F12[es][k][j][i] = cVn*r_Un;
              s_F13[es][k][j][i] = cWn*r_Un;
              s_F21[es][k][j][i] = cUn*r_Vn;
              s_F22[es][k][j][i] = cVn*r_Vn;
              s_F23[es][k][j][i] = cWn*r_Vn;
              s_F31[es][k][j][i] = cUn*r_Wn;
              s_F32[es][k][j][i] = cVn*r_Wn;
              s_F33[es][k][j][i] = cWn*r_Wn;
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //project/differentiate in k
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            r_F11  = 0.; r_F12  = 0.; r_F13  = 0.;
            r_F21  = 0.; r_F22  = 0.; r_F23  = 0.;
            r_F31  = 0.; r_F32  = 0.; r_F33  = 0.;

            if (k<p_Nq) {
              occaUnroll(p_cubNq)
              for (int n=0;n<p_cubNq;n++) {
                const dfloat Pnj = s_cubProjectT[n][k];
                const dfloat Dnj = s_cubDWT[n][k];
                r_F11  += Pnj*s_F11[es][n][j][i];
                r_F21  += Pnj*s_F21[es][n][j][i];
                r_F31  += Pnj*s_F31[es][n][j][i];
                r_F12  += Pnj*s_F12[es][n][j][i];
                r_F22  += Pnj*s_F22[es][n][j][i];
                r_F32  += Pnj*s_F32[es][n][j][i];
                r_F13  += Dnj*s_F13[es][n][j][i];
                r_F23  += Dnj*s_F23[es][n][j][i];
                r_F33  += Dnj*s_F33[es][n][j][i];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (k<p_Nq) {
              s_F11[es][k][j][i] = r_F11;
              s_F12[es][k][j][i] = r_F12;
              s_F13[es][k][j][i] = r_F13;
              s_F21[es][k][j][i] = r_F21;
              s_F22[es][k][j][i] = r_F22;
              s_F23[es][k][j][i] = r_F23;
              s_F31[es][k][j][i] = r_F31;
              s_F32[es][k][j][i] = r_F32;
              s_F33[es][k][j][i] = r_F33;
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //project/differentiate in k
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            r_F11  = 0.; r_F12  = 0.; r_F13  = 0.;
            r_F21  = 0.; r_F22  = 0.; r_F23  = 0.;
            r_F31  = 0.; r_F32  = 0.; r_F33  = 0.;

            if (k<p_Nq && j<p_Nq) {
              occaUnroll(p_cubNq)
              for (int n=0;n<p_cubNq;n++) {
                const dfloat Pnj = s_cubProjectT[n][j];
                const dfloat Dnj = s_cubDWT[n][j];
                r_F11  += Pnj*s_F11[es][k][n][i];
                r_F21  += Pnj*s_F21[es][k][n][i];
                r_F31  += Pnj*s_F31[es][k][n][i];
                r_F12  += Dnj*s_F12[es][k][n][i];
                r_F22  += Dnj*s_F22[es][k][n][i];
                r_F32  += Dnj*s_F32[es][k][n][i];
                r_F13  += Pnj*s_F13[es][k][n][i];
                r_F23  += Pnj*s_F23[es][k][n][i];
                r_F33  += Pnj*s_F33[es][k][n][i];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write register back to shared
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            if (k<p_Nq && j<p_Nq) {
              s_F11[es][k][j][i] = r_F11;
              s_F12[es][k][j][i] = r_F12;
              s_F13[es][k][j][i] = r_F13;
              s_F21[es][k][j][i] = r_F21;
              s_F22[es][k][j][i] = r_F22;
              s_F23[es][k][j][i] = r_F23;
              s_F31[es][k][j][i] = r_F31;
              s_F32[es][k][j][i] = r_F32;
              s_F33[es][k][j][i] = r_F33;
            }
          }
        }
      }
    }

    barrier(localMemFence);    

    //project/differentiate in i and write back 
    for(int es=0;es<p_NblockV;++es;inner3){   
      for(int k=0;k<p_cubNq;++k;inner2){ 
        for(int j=0;j<p_cubNq;++j;inner1){ 
          for(int i=0;i<p_cubNq;++i;inner0){
            const dlong e = eo+es; // element in block
            if((e<Nelements) && (i<p_Nq) && (j<p_Nq) && (k<p_Nq)){ 
              const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq +j*p_Nq +i;
              const dfloat invJW = vgeo[gid + p_IJWID*p_Np];
              
              dfloat nu = 0.f, nv = 0.f, nw = 0.f;
              
              occaUnroll(p_cubNq)
                for(int n=0;n<p_cubNq;++n){
                  const dfloat Pni = s_cubProjectT[n][i];
                  const dfloat Dni = s_cubDWT[n][i];

                  nu += Dni*s_F11[es][k][j][n]
                       +Pni*s_F12[es][k][j][n]
                       +Pni*s_F13[es][k][j][n];

                  nv += Dni*s_F21[es][k][j][n]
                       +Pni*s_F22[es][k][j][n]
                       +Pni*s_F23[es][k][j][n];

                  nw += Dni*s_F31[es][k][j][n]
                       +Pni*s_F32[es][k][j][n]
                       +Pni*s_F33[es][k][j][n];
                }

              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
              NU[id] = -invJW*nu;
              NV[id] = -invJW*nv;
              NW[id] = -invJW*nw;
            }
          }
        }
      }
    }
  }  
} 

#define quadSurfaceTerms(face,mx,my, i, j, k)                           \
{                                                                       \
  dfloat nu = 0.f, nv = 0.f, nw = 0.f;                                  \
                                                                        \
  occaUnroll(p_cubNq)                                                   \
    for(int n=0;n<p_cubNq;++n){                                         \
      const dfloat Pni = s_cubProjectT[n][mx];                          \
      nu  += Pni*s_fluxNU[es][face][my][n];                             \
      nv  += Pni*s_fluxNV[es][face][my][n];                             \
      nw  += Pni*s_fluxNW[es][face][my][n];                             \
    }                                                                   \
                                                                        \
  s_NU[es][k][j][i] += nu;                                              \
  s_NV[es][k][j][i] += nv;                                              \
  s_NW[es][k][j][i] += nw;                                              \
}


kernel void insAdvectionCubatureSurfaceHex3D(const dlong Nelements,
                                      const dfloat * restrict vgeo,
                                      const dfloat * restrict cubsgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int    * restrict EToB,
                                      const dfloat * restrict cubInterpT,
                                      const dfloat * restrict cubProjectT,
                                      const dfloat time,
                                      const dfloat * restrict intx,
                                      const dfloat * restrict inty,
                                      const dfloat * restrict intz,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      const dfloat * restrict W,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV,
                                      dfloat * restrict NW){

  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    // shared storage for flux terms
    shared dfloat s_NU[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_NV[p_NblockS][p_Nq][p_Nq][p_Nq];
    shared dfloat s_NW[p_NblockS][p_Nq][p_Nq][p_Nq];

    shared dfloat s_UM[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];
    shared dfloat s_VM[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];
    shared dfloat s_WM[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];
    shared dfloat s_UP[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];
    shared dfloat s_VP[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];
    shared dfloat s_WP[p_NblockS][p_Nfaces][p_cubNq][p_cubNq];

    // reuse shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM
    #define s_fluxNW s_WM

    exclusive dfloat r_UMn[p_Nfaces], r_VMn[p_Nfaces], r_WMn[p_Nfaces];
    exclusive dfloat r_UPn[p_Nfaces], r_VPn[p_Nfaces], r_WPn[p_Nfaces];

    shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS;++es;inner2){
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements && i<p_Nq && j<p_Nq){
            occaUnroll(p_Nfaces)
            for (int face=0;face<p_Nfaces;face++) {
              const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;
              const dlong idM = vmapM[id]+offset*p_Np;
              const dlong idP = vmapP[id]+offset*p_Np;

              // load negative and positive trace node values of velocity
              s_UM[es][face][j][i] = U[idM];
              s_VM[es][face][j][i] = V[idM];
              s_WM[es][face][j][i] = W[idM];
              s_UP[es][face][j][i] = U[idP];
              s_VP[es][face][j][i] = V[idP];
              s_WP[es][face][j][i] = W[idP];
            }
          }

          //zero out resulting surface contributions
          if (i<p_Nq && j<p_Nq) {
            occaUnroll(p_Nq)
            for(int k=0;k<p_Nq;++k){
              s_NU[es][k][j][i] = 0.;
              s_NV[es][k][j][i] = 0.;
              s_NW[es][k][j][i] = 0.;
            }
          }

          //fetch reference operators
          if (es==0 && j<p_Nq) {
            const int id = i+j*p_cubNq;
            s_cubInterpT[0][id] = cubInterpT[id];
            s_cubProjectT[0][id] = cubProjectT[id];
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate traces in i, store in register
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            occaUnroll(p_Nfaces) 
            for (int face=0;face<p_Nfaces;face++) {
              r_UMn[face] = 0.; r_VMn[face] = 0.; r_WMn[face] = 0.;
              r_UPn[face] = 0.; r_VPn[face] = 0.; r_WPn[face] = 0.;
            }

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ini = s_cubInterpT[n][i];

              occaUnroll(p_Nfaces)
              for (int face=0;face<p_Nfaces;face++) {
                r_UMn[face]  += Ini*s_UM[es][face][j][n];
                r_VMn[face]  += Ini*s_VM[es][face][j][n];
                r_WMn[face]  += Ini*s_WM[es][face][j][n];
                r_UPn[face]  += Ini*s_UP[es][face][j][n];
                r_VPn[face]  += Ini*s_VP[es][face][j][n];
                r_WPn[face]  += Ini*s_WP[es][face][j][n];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write back to shared
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            occaUnroll(p_Nfaces)
            for (int face=0;face<p_Nfaces;face++) {
              s_UM[es][face][j][i] = r_UMn[face];
              s_VM[es][face][j][i] = r_VMn[face];
              s_WM[es][face][j][i] = r_WMn[face];
              s_UP[es][face][j][i] = r_UPn[face];
              s_VP[es][face][j][i] = r_VPn[face];
              s_WP[es][face][j][i] = r_WPn[face];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //interpolate traces in j, store in register
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          occaUnroll(p_Nfaces) 
          for (int face=0;face<p_Nfaces;face++) {
            r_UMn[face] = 0.; r_VMn[face] = 0.; r_WMn[face] = 0.;
            r_UPn[face] = 0.; r_VPn[face] = 0.; r_WPn[face] = 0.;
          }

          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ini = s_cubInterpT[n][j];

            occaUnroll(p_Nfaces)
            for (int face=0;face<p_Nfaces;face++) {
              r_UMn[face]  += Ini*s_UM[es][face][n][i];
              r_VMn[face]  += Ini*s_VM[es][face][n][i];
              r_WMn[face]  += Ini*s_WM[es][face][n][i];
              r_UPn[face]  += Ini*s_UP[es][face][n][i];
              r_VPn[face]  += Ini*s_VP[es][face][n][i];
              r_WPn[face]  += Ini*s_WP[es][face][n][i];
            }
          }
        }
      }
    }

    barrier(localMemFence); //need a barrier since s_fluxNU and s_fluxNV are aliased

    //write fluxes to shared
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements){
            occaUnroll(p_Nfaces)
            for (int face=0;face<p_Nfaces;face++) {
              const dlong sk = e*p_cubNfp*p_Nfaces + face*p_cubNfp + j*p_cubNq + i;
              const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];
              const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];
              const dfloat nz = cubsgeo[sk*p_Nsgeo+p_NZID];
              const dfloat sJ = cubsgeo[sk*p_Nsgeo+p_SJID];

              const dfloat uM = r_UMn[face], vM = r_VMn[face], wM = r_WMn[face];
                    dfloat uP = r_UPn[face], vP = r_VPn[face], wP = r_WPn[face];

              const int bc = EToB[face+p_Nfaces*e];
              if(bc>0) {
                const dlong idm = e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i;
                insVelocityDirichletConditions3D(bc, time, intx[idm], inty[idm], intz[idm], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP);
              }

              const dfloat unM   = occaFabs(nx*uM + ny*vM + nz*wM);
              const dfloat unP   = occaFabs(nx*uP + ny*vP + nz*wP);
              const dfloat unMax = (unM > unP) ? unM : unP;

              s_fluxNU[es][face][j][i] = sJ*(.5f*(nx*(uP*uP + uM*uM)
                                                + ny*(uP*vP + uM*vM)
                                                + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) ));
              s_fluxNV[es][face][j][i] = sJ*(.5f*(nx*(vP*uP + vM*uM)
                                                + ny*(vP*vP + vM*vM)
                                                + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) ));
              s_fluxNW[es][face][j][i] = sJ*(.5f*(nx*(wP*uP + wM*uM)
                                                + ny*(wP*vP + wM*vM)
                                                + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) ));
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //project fluxes in j, store in register
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            occaUnroll(p_Nfaces) 
            for (int face=0;face<p_Nfaces;face++) {
              r_UMn[face] = 0.; r_VMn[face] = 0.; r_WMn[face] = 0.;
            }

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ini = s_cubInterpT[n][j];

              occaUnroll(p_Nfaces)
              for (int face=0;face<p_Nfaces;face++) {
                r_UMn[face]  += Ini*s_fluxNU[es][face][n][i];
                r_VMn[face]  += Ini*s_fluxNV[es][face][n][i];
                r_WMn[face]  += Ini*s_fluxNW[es][face][n][i];
              }
            }
          }
        }
      }
    }

    barrier(localMemFence);

    //write back to shared
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if (j<p_Nq) {
            occaUnroll(p_Nfaces)
            for (int face=0;face<p_Nfaces;face++) {
              s_fluxNU[es][face][j][i] = r_UMn[face];
              s_fluxNV[es][face][j][i] = r_VMn[face];
              s_fluxNW[es][face][j][i] = r_WMn[face];
            }
          }
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if(i<p_Nq && j<p_Nq){
            quadSurfaceTerms(0,i,j,i,j,0     );
            quadSurfaceTerms(5,i,j,i,j,p_Nq-1);
          }
        }
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int k=0;k<p_cubNq;++k;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          if(i<p_Nq && k<p_Nq){
            quadSurfaceTerms(1,i,k,i,0     ,k);
            quadSurfaceTerms(3,i,k,i,p_Nq-1,k);
          }
        }
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int k=0;k<p_cubNq;++k;inner1){
        for(int j=0;j<p_cubNq;++j;inner0){
          if(j<p_Nq && k<p_Nq){
            quadSurfaceTerms(2,j,k,p_Nq-1,j,k);
            quadSurfaceTerms(4,j,k,0     ,j,k);
          }
        }
      }
    }

    barrier(localMemFence);

    for(int es=0;es<p_NblockS;++es;inner2){   
      for(int j=0;j<p_cubNq;++j;inner1){
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong e = eo + es;
          if(e<Nelements && i<p_Nq && j<p_Nq){
            occaUnroll(p_Nq)
            for(int k=0;k<p_Nq;++k){
              const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
              const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

              const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

              NU[id] += invJW*s_NU[es][k][j][i];
              NV[id] += invJW*s_NV[es][k][j][i];
              NW[id] += invJW*s_NW[es][k][j][i];
            }
          }
        }
      }
    }
  }
}
#undef quadSurfaceTerms
