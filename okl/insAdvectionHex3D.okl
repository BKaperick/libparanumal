

// compute div(NU)  = div(uxu) in collocation way (weak form)
kernel void insAdvectionVolumeHex3D(const dlong Nelements,
                                     const dfloat * restrict vgeo,
                                     const dfloat * restrict D,
                                     const dlong offset,
                                     const dfloat * restrict U,
                                     const dfloat * restrict V,
                                     const dfloat * restrict W,
                                           dfloat * restrict NU,
                                           dfloat * restrict NV,
                                           dfloat * restrict NW){

  for(dlong e=0; e<Nelements; ++e; outer0) {

    shared dfloat s_F11[p_Nq][p_Nq];
    shared dfloat s_F12[p_Nq][p_Nq];
    shared dfloat s_F13[p_Nq][p_Nq];
    shared dfloat s_F21[p_Nq][p_Nq];
    shared dfloat s_F22[p_Nq][p_Nq];
    shared dfloat s_F23[p_Nq][p_Nq];
    shared dfloat s_F31[p_Nq][p_Nq];
    shared dfloat s_F32[p_Nq][p_Nq];
    shared dfloat s_F33[p_Nq][p_Nq];

    shared dfloat s_D[p_Nq][p_Nq];

    exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_Nq;++j;inner1){ 
      for(int i=0;i<p_Nq;++i;inner0){
        const int id = i+j*p_Nq;
        s_D[0][id] = D[id];

        occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_Nq)
    for(int k=0;k<p_Nq;++k){ 

      //fetch slice
      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){
          const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
          const dfloat drdx = vgeo[gid + p_RXID*p_Np];
          const dfloat drdy = vgeo[gid + p_RYID*p_Np];
          const dfloat drdz = vgeo[gid + p_RZID*p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID*p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID*p_Np];
          const dfloat J    = vgeo[gid + p_JID*p_Np];

          const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
          const dfloat Un = U[id];
          const dfloat Vn = V[id];
          const dfloat Wn = W[id];

          const dfloat cUn = J*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = J*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = J*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Un;
          s_F12[j][i] = cVn*Un;
          s_F13[j][i] = cWn*Un;
          s_F21[j][i] = cUn*Vn;
          s_F22[j][i] = cVn*Vn;
          s_F23[j][i] = cWn*Vn;
          s_F31[j][i] = cUn*Wn;
          s_F32[j][i] = cVn*Wn;
          s_F33[j][i] = cWn*Wn;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_Nq;++j;inner1){ 
        for(int i=0;i<p_Nq;++i;inner0){
          occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Dr = s_D[n][i];
              const dfloat Ds = s_D[n][j];
              const dfloat Dk = s_D[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dk*s_F13[j][i];
              r_NV[n] += Dk*s_F23[j][i];
              r_NW[n] += Dk*s_F33[j][i];
            }
        }
      }

      barrier(localMemFence);
    } //k loop

    //write out
    for(int j=0;j<p_Nq;++j;inner1){ 
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){
            const dlong id =(e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id] = r_NU[k];
            NV[id] = r_NV[k];
            NW[id] = r_NW[k];
          }
      }
    }
  }
}


#define surfaceTerms(sk,face,m, i, j)                                   \
{                                                                       \
  const dlong  idM = vmapM[sk]+offset*p_Np;                             \
  const dlong  idP = vmapP[sk]+offset*p_Np;                             \
                                                                        \
  const dfloat nx = sgeo[sk*p_Nsgeo+p_NXID];                            \
  const dfloat ny = sgeo[sk*p_Nsgeo+p_NYID];                            \
  const dfloat nz = sgeo[sk*p_Nsgeo+p_NZID];                            \
  const dfloat sJ = sgeo[sk*p_Nsgeo+p_SJID];                            \
  const dfloat invWJ = sgeo[sk*p_Nsgeo+p_WIJID];                        \
                                                                        \
  const dfloat uM = U[idM], vM = V[idM], wM = W[idM];                   \
        dfloat uP = U[idP], vP = V[idP], wP = W[idP];                   \
                                                                        \
  const int bc = EToB[face+p_Nfaces*e];                                 \
  if(bc>0) {                                                            \
    const dlong idm = vmapM[sk];                                        \
    insVelocityDirichletConditions3D(bc, time, x[idm], y[idm], z[idm], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP); \
  }                                                                     \
                                                                        \
  const dfloat unM   = occaFabs(nx*uM + ny*vM + nz*wM);                 \
  const dfloat unP   = occaFabs(nx*uP + ny*vP + nz*wP);                 \
  const dfloat unMax = (unM > unP) ? unM : unP;                         \
                                                                        \
  const dfloat sc = invWJ * sJ;                                         \
  s_fluxNU[m][j][i] = sc*(.5f*(nx*(uP*uP + uM*uM)                      \
                             + ny*(uP*vP + uM*vM)                      \
                             + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) )); \
  s_fluxNV[m][j][i] = sc*(.5f*(nx*(vP*uP + vM*uM)                      \
                             + ny*(vP*vP + vM*vM)                      \
                             + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) )); \
  s_fluxNW[m][j][i] = sc*(.5f*(nx*(wP*uP + wM*uM)                      \
                             + ny*(wP*vP + wM*vM)                      \
                             + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) )); \
}

kernel void insAdvectionSurfaceHex3D(const dlong Nelements,
                                      const dfloat * restrict sgeo,
                                      const dlong  * restrict vmapM,
                                      const dlong  * restrict vmapP,
                                      const int    * restrict EToB,
                                      const dfloat time,
                                      const dfloat * restrict x,
                                      const dfloat * restrict y,
                                      const dfloat * restrict z,
                                      const dlong offset,
                                      const dfloat * restrict U,
                                      const dfloat * restrict V,
                                      const dfloat * restrict W,
                                      dfloat * restrict NU,
                                      dfloat * restrict NV,
                                      dfloat * restrict NW){

  // for all elements
  for(dlong e=0;e<Nelements;e++;outer0){
    // shared storage for flux terms
    shared dfloat s_fluxNU[2][p_Nq][p_Nq];
    shared dfloat s_fluxNV[2][p_Nq][p_Nq];
    shared dfloat s_fluxNW[2][p_Nq][p_Nq];

    exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }
      }
    }

    barrier(localMemFence);

    // for all face nodes of all elements
    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + i + j*p_Nq;
        const dlong sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + i + j*p_Nq;

        surfaceTerms(sk0,0,0,i,j);
        surfaceTerms(sk5,5,1,i,j);
      }
    }

    barrier(localMemFence);

    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        //face 0
        r_NU[0] += s_fluxNU[0][i][j];
        r_NV[0] += s_fluxNV[0][i][j];
        r_NW[0] += s_fluxNW[0][i][j];

        //face 5
        r_NU[p_Nq-1] += s_fluxNU[1][i][j];
        r_NV[p_Nq-1] += s_fluxNV[1][i][j];
        r_NW[p_Nq-1] += s_fluxNW[1][i][j];
      }
    }

    barrier(localMemFence);    

    // face 1 & 3
    for(int k=0;k<p_Nq;++k;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        const dlong sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + i + k*p_Nq;
        const dlong sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + i + k*p_Nq;

        surfaceTerms(sk1,1,0,i,k);
        surfaceTerms(sk3,3,1,i,k);
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        if (j==0) {//face 1
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][i][n];
            r_NV[n] += s_fluxNV[0][i][n];
            r_NW[n] += s_fluxNW[0][i][n];
          }
        }
        if (j==p_Nq-1) {//face 3
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][i][n];
            r_NV[n] += s_fluxNV[1][i][n];
            r_NW[n] += s_fluxNW[1][i][n];
          }
        }
      }
    }

    barrier(localMemFence);    

    // face 2 & 4
    for(int k=0;k<p_Nq;++k;inner1){
      for(int j=0;j<p_Nq;++j;inner0){
        const dlong sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + j + k*p_Nq;
        const dlong sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + j + k*p_Nq;

        surfaceTerms(sk2,2,0,j,k);
        surfaceTerms(sk4,4,1,j,k);
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        if (i==p_Nq-1) {//face 2
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[0][j][n];
            r_NV[n] += s_fluxNV[0][j][n];
            r_NW[n] += s_fluxNW[0][j][n];
          }
        }
        if (i==0) {//face 4
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[1][j][n];
            r_NV[n] += s_fluxNV[1][j][n];
            r_NW[n] += s_fluxNW[1][j][n];
          }
        }
      }
    }

    barrier(localMemFence);   

    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

          NU[id] += r_NU[k];
          NV[id] += r_NV[k];
          NW[id] += r_NW[k];
        }
      }
    }
  }
}
#undef surfaceTerms


/* ------------------Quadrature kernels ----------------------------------*/
kernel void insAdvectionCubatureVolumeHex3D(const dlong Nelements,
                                             const dfloat * restrict vgeo,
                                             const dfloat * restrict cubvgeo,
                                             const dfloat * restrict cubDWT,
                                             const dfloat * restrict cubInterpT,
                                             const dfloat * restrict cubProjectT,
                                             const dlong offset,
                                             const dfloat * restrict U,
                                             const dfloat * restrict V,
                                             const dfloat * restrict W,
                                                   dfloat * restrict cU, //storage for interpolated fields
                                                   dfloat * restrict cV, //storage for interpolated fields
                                                   dfloat * restrict cW, //storage for interpolated fields
                                                   dfloat * restrict NU,
                                                   dfloat * restrict NV,
                                                   dfloat * restrict NW){

  //----------------------------kernel 1 interpolate velocity fields to quadrature points
  for(dlong e=0; e<Nelements; ++e; outer0) {

    shared dfloat s_U[p_Nq][p_cubNq];
    shared dfloat s_V[p_Nq][p_cubNq];
    shared dfloat s_W[p_Nq][p_cubNq];
    shared dfloat s_cubInterpT[p_Nq][p_cubNq];

    exclusive dfloat r_U[p_cubNq], r_V[p_cubNq], r_W[p_cubNq];

    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
        }

        occaUnroll(p_cubNq)
          for(int k=0;k<p_cubNq;++k){         
            r_U[k] = 0.;
            r_V[k] = 0.;
            r_W[k] = 0.;
          }
      }
    }

    barrier(localMemFence);

    //read in and interpolate in k
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (i<p_Nq && j<p_Nq) {
          occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){
            const dlong id =(e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            const dfloat uc = U[id];
            const dfloat vc = V[id];
            const dfloat wc = W[id];

            occaUnroll(p_cubNq)
            for(int n=0;n<p_cubNq;++n){
              const dfloat Ik = s_cubInterpT[k][n];
              r_U[n] += Ik*uc;
              r_V[n] += Ik*vc;
              r_W[n] += Ik*wc;
            }
          }
        }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_cubNq)
    for(int k=0;k<p_cubNq;++k){ 
      //load slice to shared
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if (i<p_Nq && j<p_Nq) {
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if(j<p_Nq){
            r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

            occaUnroll(p_Nq)
            for (int n=0;n<p_Nq;n++) {
              const dfloat Ii = s_cubInterpT[n][i];
              r_U[k] += Ii*s_U[j][n];
              r_V[k] += Ii*s_V[j][n];
              r_W[k] += Ii*s_W[j][n];
            }
          }
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if(j<p_Nq){
            s_U[j][i] = r_U[k];
            s_V[j][i] = r_V[k];
            s_W[j][i] = r_W[k];
          }
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          r_U[k] = 0; r_V[k] = 0; r_W[k] = 0;

          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            const dfloat Ij = s_cubInterpT[n][j];
            r_U[k] += Ij*s_U[n][i];
            r_V[k] += Ij*s_V[n][i];
            r_W[k] += Ij*s_W[n][i];
          }

          const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          cU[id] = r_U[k];
          cV[id] = r_V[k];
          cW[id] = r_W[k];
        }
      }
    }
  }


  //-----------------------------kernel 2 do the reference divergence
  for(dlong e=0; e<Nelements; ++e; outer0) {

    shared dfloat s_F11[p_cubNq][p_cubNq];
    shared dfloat s_F12[p_cubNq][p_cubNq];
    shared dfloat s_F13[p_cubNq][p_cubNq];
    shared dfloat s_F21[p_cubNq][p_cubNq];
    shared dfloat s_F22[p_cubNq][p_cubNq];
    shared dfloat s_F23[p_cubNq][p_cubNq];
    shared dfloat s_F31[p_cubNq][p_cubNq];
    shared dfloat s_F32[p_cubNq][p_cubNq];
    shared dfloat s_F33[p_cubNq][p_cubNq];

    shared dfloat s_cubDWT[p_cubNq][p_Nq];

    exclusive dfloat r_NU[p_cubNq], r_NV[p_cubNq], r_NW[p_cubNq];

    for(int j=0;j<p_cubNq;++j;inner1){ 
      for(int i=0;i<p_cubNq;++i;inner0){
        const int id = i+j*p_cubNq;
        s_cubDWT[0][id] = cubDWT[id];

        occaUnroll(p_cubNq)
          for(int k=0;k<p_cubNq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_cubNq)
    for(int k=0;k<p_cubNq;++k){ 

      //fetch slice
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          const dlong gid = e*p_cubNp*p_Nvgeo+ k*p_cubNq*p_cubNq + j*p_cubNq +i;
          const dfloat drdx = cubvgeo[gid + p_RXID*p_cubNp];
          const dfloat drdy = cubvgeo[gid + p_RYID*p_cubNp];
          const dfloat drdz = cubvgeo[gid + p_RZID*p_cubNp];
          const dfloat dsdx = cubvgeo[gid + p_SXID*p_cubNp];
          const dfloat dsdy = cubvgeo[gid + p_SYID*p_cubNp];
          const dfloat dsdz = cubvgeo[gid + p_SZID*p_cubNp];
          const dfloat dtdx = cubvgeo[gid + p_TXID*p_cubNp];
          const dfloat dtdy = cubvgeo[gid + p_TYID*p_cubNp];
          const dfloat dtdz = cubvgeo[gid + p_TZID*p_cubNp];
          const dfloat J = cubvgeo[gid + p_JID*p_cubNp];

          const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat Un = cU[id];
          const dfloat Vn = cV[id];
          const dfloat Wn = cW[id];

          const dfloat cUn = J*(drdx*Un+drdy*Vn+drdz*Wn);
          const dfloat cVn = J*(dsdx*Un+dsdy*Vn+dsdz*Wn);
          const dfloat cWn = J*(dtdx*Un+dtdy*Vn+dtdz*Wn);

          s_F11[j][i] = cUn*Un;
          s_F12[j][i] = cVn*Un;
          s_F13[j][i] = cWn*Un;
          s_F21[j][i] = cUn*Vn;
          s_F22[j][i] = cVn*Vn;
          s_F23[j][i] = cWn*Vn;
          s_F31[j][i] = cUn*Wn;
          s_F32[j][i] = cVn*Wn;
          s_F33[j][i] = cWn*Wn;
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          occaUnroll(p_cubNq)
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Dr = s_cubDWT[n][i];
              const dfloat Ds = s_cubDWT[n][j];
              const dfloat Dk = s_cubDWT[k][n];
              r_NU[k] += Dr*s_F11[j][n];
              r_NV[k] += Dr*s_F21[j][n];
              r_NW[k] += Dr*s_F31[j][n];

              r_NU[k] += Ds*s_F12[n][i];
              r_NV[k] += Ds*s_F22[n][i];
              r_NW[k] += Ds*s_F32[n][i];

              r_NU[n] += Dk*s_F13[j][i];
              r_NV[n] += Dk*s_F23[j][i];
              r_NW[n] += Dk*s_F33[j][i];
            }
        }
      }

      barrier(localMemFence);
    } //k loop

    //write out
    for(int j=0;j<p_cubNq;++j;inner1){ 
      for(int i=0;i<p_cubNq;++i;inner0){
        occaUnroll(p_cubNq)
          for(int k=0;k<p_cubNq;++k){
            const dlong id =e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
            cU[id] = r_NU[k];
            cV[id] = r_NV[k];
            cW[id] = r_NW[k];
          }
      }
    }
  }

  //---------------------------kernel 3 project fluxes back to GLL grid
  for(dlong e=0; e<Nelements; ++e; outer0) {
    shared dfloat s_NU[p_Nq][p_cubNq];
    shared dfloat s_NV[p_Nq][p_cubNq];
    shared dfloat s_NW[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubProjectT[0][id] = cubProjectT[id];
        }
        
        occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){         
            r_NU[k] = 0.;
            r_NV[k] = 0.;
            r_NW[k] = 0.;
          }
      }
    }

    barrier(localMemFence);

    //read in and project in k
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        occaUnroll(p_cubNq)
        for(int k=0;k<p_cubNq;++k){
          const dlong id = e*p_cubNp + k*p_cubNq*p_cubNq + j*p_cubNq + i;
          const dfloat NUn = cU[id];
          const dfloat NVn = cV[id];
          const dfloat NWn = cW[id];

          occaUnroll(p_Nq)
          for(int n=0;n<p_Nq;++n){
            const dfloat Pk = s_cubProjectT[k][n];
            r_NU[n] += Pk*NUn;
            r_NV[n] += Pk*NVn;
            r_NW[n] += Pk*NWn;
          }
        }
      }
    }

    barrier(localMemFence);

    occaUnroll(p_Nq)
    for(int k=0;k<p_Nq;++k){ 
      //load slice to shared
      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          s_NU[j][i] = r_NU[k];
          s_NV[j][i] = r_NV[k];
          s_NW[j][i] = r_NW[k];
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if(i<p_Nq){
            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            occaUnroll(p_cubNq)
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pi = s_cubProjectT[n][i];
              r_NU[k] += Pi*s_NU[j][n];
              r_NV[k] += Pi*s_NV[j][n];
              r_NW[k] += Pi*s_NW[j][n];
            }
          }
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if(i<p_Nq){
            s_NU[j][i] = r_NU[k];
            s_NV[j][i] = r_NV[k];
            s_NW[j][i] = r_NW[k];
          }
        }
      }

      barrier(localMemFence);

      for(int j=0;j<p_cubNq;++j;inner1){ 
        for(int i=0;i<p_cubNq;++i;inner0){
          if (i<p_Nq && j<p_Nq) {
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            r_NU[k] = 0; r_NV[k] = 0; r_NW[k] = 0;

            occaUnroll(p_cubNq)
            for (int n=0;n<p_cubNq;n++) {
              const dfloat Pj = s_cubProjectT[n][j];
              r_NU[k] += Pj*s_NU[n][i];
              r_NV[k] += Pj*s_NV[n][i];
              r_NW[k] += Pj*s_NW[n][i];
            }

            const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            NU[id] = -invJW*r_NU[k];
            NV[id] = -invJW*r_NV[k];
            NW[id] = -invJW*r_NW[k];
          }
        }
      }
    }
  }
}


#define quadSurfaceTerms(face)                           \
{                                                                       \
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if(i<p_Nq && j<p_Nq){\
        const dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + j*p_Nq +i;\
        const dlong idM = vmapM[id]+offset*p_Np;\
        const dlong idP = vmapP[id]+offset*p_Np;\
        s_UM[j][i] = U[idM];\
        s_VM[j][i] = V[idM];\
        s_WM[j][i] = W[idM];\
        s_UP[j][i] = U[idP];\
        s_VP[j][i] = V[idP];\
        s_WP[j][i] = W[idP];\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq) {\
        r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;\
        r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;\
        occaUnroll(p_Nq)\
        for (int n=0;n<p_Nq;n++) {\
          const dfloat Ini = s_cubInterpT[n][i];\
          r_UMn  += Ini*s_UM[j][n];\
          r_VMn  += Ini*s_VM[j][n];\
          r_WMn  += Ini*s_WM[j][n];\
          r_UPn  += Ini*s_UP[j][n];\
          r_VPn  += Ini*s_VP[j][n];\
          r_WPn  += Ini*s_WP[j][n];\
        }\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq) {\
        s_UM[j][i] = r_UMn;\
        s_VM[j][i] = r_VMn;\
        s_WM[j][i] = r_WMn;\
        s_UP[j][i] = r_UPn;\
        s_VP[j][i] = r_VPn;\
        s_WP[j][i] = r_WPn;\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      r_UMn = 0.; r_VMn = 0.; r_WMn = 0.;\
      r_UPn = 0.; r_VPn = 0.; r_WPn = 0.;\
      occaUnroll(p_Nq)\
      for (int n=0;n<p_Nq;n++) {\
        const dfloat Inj = s_cubInterpT[n][j];\
        r_UMn += Inj*s_UM[n][i];\
        r_VMn += Inj*s_VM[n][i];\
        r_WMn += Inj*s_WM[n][i];\
        r_UPn += Inj*s_UP[n][i];\
        r_VPn += Inj*s_VP[n][i];\
        r_WPn += Inj*s_WP[n][i];\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      const dlong sk = e*p_cubNfp*p_Nfaces + face*p_cubNfp + j*p_cubNq + i;\
      const dfloat nx = cubsgeo[sk*p_Nsgeo+p_NXID];\
      const dfloat ny = cubsgeo[sk*p_Nsgeo+p_NYID];\
      const dfloat nz = cubsgeo[sk*p_Nsgeo+p_NZID];\
      const dfloat sJ = cubsgeo[sk*p_Nsgeo+p_SJID];\
      const dfloat uM = r_UMn, vM = r_VMn, wM = r_WMn;\
            dfloat uP = r_UPn, vP = r_VPn, wP = r_WPn;\
\
      const int bc = EToB[face+p_Nfaces*e];\
      if(bc>0) {\
        const dlong idm = e*p_Nfaces*p_cubNfp + face*p_cubNfp + j*p_cubNq + i;\
        insVelocityDirichletConditions3D(bc, time, intx[idm], inty[idm], intz[idm], nx, ny, nz, uM, vM, wM, &uP, &vP, &wP);\
      }\
\
      const dfloat unM   = occaFabs(nx*uM + ny*vM + nz*wM);\
      const dfloat unP   = occaFabs(nx*uP + ny*vP + nz*wP);\
      const dfloat unMax = (unM > unP) ? unM : unP;\
\
      s_fluxNU[j][i] = sJ*(.5f*(nx*(uP*uP + uM*uM)\
                              + ny*(uP*vP + uM*vM)\
                              + nz*(uP*wP + uM*wM)  + unMax*(uM-uP) ));\
      s_fluxNV[j][i] = sJ*(.5f*(nx*(vP*uP + vM*uM)\
                              + ny*(vP*vP + vM*vM)\
                              + nz*(vP*wP + vM*wM)  + unMax*(vM-vP) ));\
      s_fluxNW[j][i] = sJ*(.5f*(nx*(wP*uP + wM*uM)\
                              + ny*(wP*vP + wM*vM)\
                              + nz*(wP*wP + wM*wM)  + unMax*(wM-wP) ));\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq) {\
        r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;\
        occaUnroll(p_cubNq)\
        for (int n=0;n<p_cubNq;n++) {\
          const dfloat Pnj = s_cubProjectT[n][j];\
          r_NUn  += Pnj*s_fluxNU[n][i];\
          r_NVn  += Pnj*s_fluxNV[n][i];\
          r_NWn  += Pnj*s_fluxNW[n][i];\
        }\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq) {\
        s_fluxNU[j][i] = r_NUn;\
        s_fluxNV[j][i] = r_NVn;\
        s_fluxNW[j][i] = r_NWn;\
      }\
    }\
  }\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq && i<p_Nq) {\
        r_NUn = 0.; r_NVn = 0.; r_NWn = 0.;\
        occaUnroll(p_cubNq)\
        for(int n=0;n<p_cubNq;++n){\
          const dfloat Pni = s_cubProjectT[n][i];\
          r_NUn += Pni*s_fluxNU[j][n];\
          r_NVn += Pni*s_fluxNV[j][n];\
          r_NWn += Pni*s_fluxNW[j][n];\
        }\
      }\
    }\
  }\
\
  barrier(localMemFence);\
\
  for(int j=0;j<p_cubNq;++j;inner1){\
    for(int i=0;i<p_cubNq;++i;inner0){\
      if (j<p_Nq && i<p_Nq) {\
        s_fluxNU[j][i] = r_NUn;\
        s_fluxNV[j][i] = r_NVn;\
        s_fluxNW[j][i] = r_NWn;\
      }\
    }\
  }\
}
#endif

kernel void insAdvectionCubatureSurfaceHex3D(const dlong Nelements,
                                            const dfloat * restrict vgeo,
                                            const dfloat * restrict cubsgeo,
                                            const dlong  * restrict vmapM,
                                            const dlong  * restrict vmapP,
                                            const int    * restrict EToB,
                                            const dfloat * restrict cubInterpT,
                                            const dfloat * restrict cubProjectT,
                                            const dfloat time,
                                            const dfloat * restrict intx,
                                            const dfloat * restrict inty,
                                            const dfloat * restrict intz,
                                            const dlong offset,
                                            const dfloat * restrict U,
                                            const dfloat * restrict V,
                                            const dfloat * restrict W,
                                                  dfloat * restrict NU,
                                                  dfloat * restrict NV,
                                                  dfloat * restrict NW){

  // for all elements
  for(dlong e=0;e<Nelements;e++;outer0){
    // shared storage for flux terms
    exclusive dfloat r_NU[p_Nq], r_NV[p_Nq], r_NW[p_Nq];

    shared dfloat s_UM[p_cubNq][p_cubNq];
    shared dfloat s_VM[p_cubNq][p_cubNq];
    shared dfloat s_WM[p_cubNq][p_cubNq];
    shared dfloat s_UP[p_cubNq][p_cubNq];
    shared dfloat s_VP[p_cubNq][p_cubNq];
    shared dfloat s_WP[p_cubNq][p_cubNq];

    // reuse shared memory buffers
    #define s_fluxNU s_UM
    #define s_fluxNV s_VM
    #define s_fluxNW s_WM

    exclusive dfloat r_UMn, r_VMn, r_WMn;
    exclusive dfloat r_UPn, r_VPn, r_WPn;

    #define r_NUn r_UMn
    #define r_NVn r_VMn
    #define r_NWn r_WMn

    shared dfloat s_cubInterpT[p_Nq][p_cubNq];
    shared dfloat s_cubProjectT[p_cubNq][p_Nq];

    // for all face nodes of all elements
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        //zero out resulting surface contributions
        occaUnroll(p_Nq)
        for(int k=0;k<p_Nq;++k){
          r_NU[k] = 0.;
          r_NV[k] = 0.;
          r_NW[k] = 0.;
        }

        //fetch reference operators
        const int id = i+j*p_cubNq;
        if (id<p_Nq*p_cubNq) {
          s_cubInterpT[0][id] = cubInterpT[id];
          s_cubProjectT[0][id] = cubProjectT[id];
        }
      }
    }
#if 1
    barrier(localMemFence);

    quadSurfaceTerms(0) //face 0

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j<p_Nq && i<p_Nq) {
          r_NU[0] += s_fluxNU[i][j];
          r_NV[0] += s_fluxNV[i][j];
          r_NW[0] += s_fluxNW[i][j];
        }
      }
    }

    barrier(localMemFence);

    quadSurfaceTerms(5) //face 5

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j<p_Nq && i<p_Nq) {
          r_NU[p_Nq-1] += s_fluxNU[i][j];
          r_NV[p_Nq-1] += s_fluxNV[i][j];
          r_NW[p_Nq-1] += s_fluxNW[i][j];
        }
      }
    }

    barrier(localMemFence);

    quadSurfaceTerms(1) //face 1

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j==0 && i<p_Nq) {//face 1
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[i][n];
            r_NV[n] += s_fluxNV[i][n];
            r_NW[n] += s_fluxNW[i][n];
          }
        }
      }
    }

    barrier(localMemFence);

    quadSurfaceTerms(3) //face 3

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j==p_Nq-1 && i<p_Nq) {//face 3
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[i][n];
            r_NV[n] += s_fluxNV[i][n];
            r_NW[n] += s_fluxNW[i][n];
          }
        }
      }
    }

    barrier(localMemFence);

    quadSurfaceTerms(2) //face 2

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j<p_Nq && i==p_Nq-1) {//face 2
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[j][n];
            r_NV[n] += s_fluxNV[j][n];
            r_NW[n] += s_fluxNW[j][n];
          }
        }
      }
    }

    barrier(localMemFence);

    quadSurfaceTerms(4) //face 4

    barrier(localMemFence);    

    //accumulate in register pencil
    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if (j<p_Nq && i==0) {//face 4
          occaUnroll(p_Nq)
          for (int n=0;n<p_Nq;n++) {
            r_NU[n] += s_fluxNU[j][n];
            r_NV[n] += s_fluxNV[j][n];
            r_NW[n] += s_fluxNW[j][n];
          }
        }
      }
    }

    barrier(localMemFence);

    for(int j=0;j<p_cubNq;++j;inner1){
      for(int i=0;i<p_cubNq;++i;inner0){
        if(i<p_Nq && j<p_Nq){
          occaUnroll(p_Nq)
          for(int k=0;k<p_Nq;++k){
            const dlong gid = e*p_Np*p_Nvgeo+ k*p_Nq*p_Nq + j*p_Nq +i;
            const dfloat invJW = vgeo[gid + p_IJWID*p_Np];

            const dlong id = (e+offset)*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;

            NU[id] += invJW*r_NU[k];
            NV[id] += invJW*r_NV[k];
            NW[id] += invJW*r_NW[k];
          }
        }
      }
    }
    #endif
  }
}
#undef quadSurfaceTerms
