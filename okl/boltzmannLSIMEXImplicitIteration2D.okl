dfloat GET_MAX3(const dfloat x1, const dfloat x2, const dfloat x3){

dfloat xmax = 0.; 
         xmax = x1>x2 ? x1:x2; 
         xmax = xmax > x3 ? xmax:x3;

         return(xmax); 
}

dfloat GET_MAX2(const dfloat x1, const dfloat x2){

         dfloat xmax = x1>x2 ? x1:x2; 
        
         return(xmax); 
}



kernel void boltzmannLSIMEXImplicitIteration2D(const iint Nelements,
			              const iint * restrict elementIds,
			              const dfloat dt,	
		                const dfloat akk,
	                  const dfloat  * restrict cubInterpT,
	                  const dfloat  * restrict cubProjectT,
	                  const dfloat4 * restrict qex,
	                        dfloat4 * restrict qim){
  for(iint e=0;e<Nelements;++e;outer0)
  {
    for(iint n=0;n<p_Np;++n;inner0)
    {
      const iint element = elementIds[e];
      const iint id0     = 2*(element*p_Np + n);
      const iint id1     = id0 + 1;
            
      dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

      // Read explicit part 
      dfloat4 qexa = qex[id0];
      dfloat4 qexb = qex[id1];
      
      // Read implicit part
      dfloat4 qima = qim[id0];
      dfloat4 qimb = qim[id1];      
      
      //
      dfloat qex1 = qexa.x;
      dfloat qex2 = qexa.y;
      dfloat qex3 = qexa.z;
      dfloat qex4 = qexa.w;
      dfloat qex5 = qexb.x;
      dfloat qex6 = qexb.y;       
      
      // First iteration, Qim = Qex ; 
      dfloat qim1 = qex1;
      dfloat qim2 = qex2;
      dfloat qim3 = qex3;
      dfloat qim4 = qex4;
      dfloat qim5 = qex5;
      dfloat qim6 = qex6; 
      //         
     if(akk>0) // No need to itearte if akk=0
     {
     dfloat err = 0.0;  
     dfloat cc  = akk * dt * p_tauInv;
     dfloat icc    = 1.0/cc; 

      for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
      {
         //
         N4 = -cc*( qim4 -            ( qim2*qim3/qim1 ) );
         N5 = -cc*( qim5 - p_invsqrt2*( qim2*qim2/qim1 ) );
         N6 = -cc*( qim6 - p_invsqrt2*( qim3*qim3/qim1 ) );

         //
        dfloat z1 =  qex1 - qim1 ;
        dfloat z2 =  qex2 - qim2 ;
        dfloat z3 =  qex3 - qim3 ;
        dfloat z4 =  qex4 - qim4 +  N4 ;
        dfloat z5 =  qex5 - qim5 +  N5 ;
        dfloat z6 =  qex6 - qim6 +  N6 ;
        
        //hold old values
        dfloat qim4o = qim4;
        dfloat qim5o = qim5;
        dfloat qim6o = qim6;
        

        //
         //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
        qim4 = qim4o  + z4/(cc+1.0)  
                      + z2*qim3/(qim1*(1.0+icc)) 
                      + z3*qim2/(qim1*(1.0+icc))
                      - z1*qim2*qim3/(qim1*qim1*(1.0+icc)); 

        qim5 = qim5o  +  z5/(cc+1)
                      +  p_sqrt2 * ( z2*qim2/(qim1*(1.0 + icc)))
                      -  p_sqrt2 * ( z1*(qim2*qim2)/(2.0 *(qim1*qim1)*(1.0+icc)));

        qim6 = qim6o +  z6/(cc+1.0)
                     +  p_sqrt2* ( z3*qim3/(qim1*(1.0+icc)))
                     -  p_sqrt2* ( z1*(qim3*qim3)/(2.0*(qim1*qim1)*(1.0+icc)));

        // Compute errors for q4 q5 a6
         dfloat err4 = fabs(qim4-qim4o);
         dfloat err5 = fabs(qim5-qim5o);
         dfloat err6 = fabs(qim6-qim6o);

         err = GET_MAX3(err4,err5,err6);     
         
        
         if(err<p_LSIMEX_TOL) break;

      }

     

    }
    
     // do not update q1 ,q2 ,q3 
    qim[id0].x =  qim1 ;
    qim[id0].y =  qim2 ;
    qim[id0].z =  qim3 ;  
    qim[id0].w =  qim4 ;
    //
    qim[id1].x =  qim5 ;
    qim[id1].y =  qim6 ;  

    }
  }
}






kernel void boltzmannLSIMEXSplitPmlImplicitIteration2D(const iint Nelements,
                    const iint * restrict elementIds,
                    const dfloat dt,  
                    const dfloat ramp,
                    const dfloat akk,
                    const dfloat * restrict cubInterpT,
                    const dfloat * restrict cubProjectT,
                    const dfloat * restrict qYx,
                    const dfloat * restrict qYy,
                   // const dfloat * restrict qYnt,
                          dfloat * restrict qZx,
                          dfloat * restrict qZy,
                    //      dfloat * restrict qZnt,
                          dfloat4 *restrict qZ ){
  for(iint e=0;e<Nelements;++e;outer0)
  {
    for(iint n=0;n<p_Np;++n;inner0)
    {
      const iint element = elementIds[e];
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;
      
      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      
      #if 0
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 
      #endif
   
      // Initialize
      dfloat qxi1 = qxe1;
      dfloat qxi2 = qxe2;
      dfloat qxi3 = qxe3;
      dfloat qxi4 = qxe4;
      dfloat qxi5 = qxe5;
      dfloat qxi6 = qxe6; 
      //
      dfloat qyi1 = qye1;
      dfloat qyi2 = qye2;
      dfloat qyi3 = qye3;
      dfloat qyi4 = qye4;
      dfloat qyi5 = qye5;
      dfloat qyi6 = qye6; 
      //
      #if 0
      dfloat nti1 = nte1;
      dfloat nti2 = nte2;
      dfloat nti3 = nte3;
      dfloat nti4 = nte4;
      dfloat nti5 = nte5;
      dfloat nti6 = nte6; 
      #endif
      //
      dfloat q1 =  p_q1bar                 + qxi1 + qyi1;
      dfloat q2 =  ramp*p_q2bar            + qxi2 + qyi2;
      dfloat q3 =  ramp*p_q3bar            + qxi3 + qyi3;
      dfloat q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
      dfloat q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
      dfloat q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;

    //
     if(akk>0)
     {
        dfloat err = 0.0;  
        dfloat coeff  = akk * dt * p_tauInv;
        dfloat icc    = 1.0/coeff; 

        dfloat cch    = 0.5*coeff; 
        dfloat icch   = 1.0/cch; 


        dfloat N4=0.,N5=0.,N6=0.;  

      for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
      {

          //
          N4 = -coeff*( q4 -            ( q2*q3/q1 ) );
          N5 = -coeff*( q5 - p_invsqrt2*( q2*q2/q1 ) );
          N6 = -coeff*( q6 - p_invsqrt2*( q3*q3/q1 ) );

          //
          dfloat zx1 =  qxe1 - qxi1 ;
          dfloat zx2 =  qxe2 - qxi2 ;
          dfloat zx3 =  qxe3 - qxi3 ;
          dfloat zx4 =  qxe4 - qxi4 +  0.5*N4 ;
          dfloat zx5 =  qxe5 - qxi5 +  0.5*N5 ;
          dfloat zx6 =  qxe6 - qxi6 +  0.5*N6 ;
          //
          dfloat zy1 =  qye1 - qyi1 ;
          dfloat zy2 =  qye2 - qyi2 ;
          dfloat zy3 =  qye3 - qyi3 ;
          dfloat zy4 =  qye4 - qyi4 +  0.5*N4 ;
          dfloat zy5 =  qye5 - qyi5 +  0.5*N5 ;
          dfloat zy6 =  qye6 - qyi6 +  0.5*N6 ;
          #if 0
          //
          dfloat znt1 =  nte1 - nti1 ;
          dfloat znt2 =  nte2 - nti2 ;
          dfloat znt3 =  nte3 - nti3 ;
          dfloat znt4 =  nte4 - nti4 +  N4 ;
          dfloat znt5 =  nte5 - nti5 +  N5 ;
          dfloat znt6 =  nte6 - nti6 +  N6 ;
           #endif

          //
          dfloat qxi4o = qxi4;
          dfloat qxi5o = qxi5;
          dfloat qxi6o = qxi6;
          //
          dfloat qyi4o = qyi4;
          dfloat qyi5o = qyi5;
          dfloat qyi6o = qyi6;
          
          #if 0
          dfloat nti4o = nti4;
          dfloat nti5o = nti5;
          dfloat nti6o = nti6;
          #endif


        
         //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )

        qxi4  +=        zx4/(cch+1.0)  
                      + zx2*q3/(q1*(1.0+icch)) 
                      + zx3*q2/(q1*(1.0+icch))
                      - zx1*q2*q3/(q1*q1*(1.0+icch)); 

        qxi5  +=         zx5/(cch+1.)
                      +  p_sqrt2 * ( zx2*q2/(q1*(1.0 + icch)))
                      -  p_sqrt2 * ( zx1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

        qxi6 +=         zx6/(cch+1.0)
                     +  p_sqrt2* ( zx3*q3/(q1*(1.0+icch)))
                     -  p_sqrt2* ( zx1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));

        //  
        qyi4  +=        zy4/(cch+1.0)  
                      + zy2*q3/(q1*(1.0+icch)) 
                      + zy3*q2/(q1*(1.0+icch))
                      - zy1*q2*q3/(q1*q1*(1.0+icch)); 

        qyi5  +=         zy5/(cch+1.)
                      +  p_sqrt2 * ( zy2*q2/(q1*(1.0 + icch)))
                      -  p_sqrt2 * ( zy1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

        qyi6 +=         zy6/(cch+1.0)
                     +  p_sqrt2* ( zy3*q3/(q1*(1.0+icch)))
                     -  p_sqrt2* ( zy1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));   
        

         #if 0
         //  
        nti4  +=        znt4/(coeff+1.0)  
                      + znt2*q3/(q1*(1.0+icc)) 
                      + znt3*q2/(q1*(1.0+icc))
                      - znt1*q2*q3/(q1*q1*(1.0+icc)); 

        nti5  +=         znt5/(coeff+1.)
                      +  p_sqrt2 * ( znt2*q2/(q1*(1.0 + icc)))
                      -  p_sqrt2 * ( znt1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icc)));

        nti6 +=         znt6/(coeff+1.0)
                     +  p_sqrt2* ( znt3*q3/(q1*(1.0+icc)))
                     -  p_sqrt2* ( znt1*(q3*q3)/(2.0*(q1*q1)*(1.0+icc)));  
         #endif


         q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
         q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
         q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;                                     

        // Compute errors for q4 q5 a6
         dfloat ex4 = fabs(qxi4-qxi4o);
         dfloat ex5 = fabs(qxi5-qxi5o);
         dfloat ex6 = fabs(qxi6-qxi6o);
         //
         dfloat ey4 = fabs(qyi4-qyi4o);
         dfloat ey5 = fabs(qyi5-qyi5o);
         dfloat ey6 = fabs(qyi6-qyi6o);

         #if 0

         dfloat ent4 = fabs(nti4-nti4o);
         dfloat ent5 = fabs(nti5-nti5o);
         dfloat ent6 = fabs(nti6-nti6o);
         dfloat ex  = GET_MAX3(ex4,ex5,ex6);  
         dfloat ey  = GET_MAX3(ey4,ey5,ey6);   
         dfloat ent = GET_MAX3(ent4,ent5,ent6);   

         err =  GET_MAX3(ex,ey,ent);   

         #endif
         
         dfloat ex  = GET_MAX3(ex4,ex5,ex6);  
         dfloat ey  = GET_MAX3(ey4,ey5,ey6);   
          

         err =  GET_MAX2(ex,ey);   
         

         if(err<p_LSIMEX_TOL) break;

      }
    }
    
   // PML UPDATES
      qZx[id1] = qxi1;
      qZx[id2] = qxi2;
      qZx[id3] = qxi3;
      qZx[id4] = qxi4;
      qZx[id5] = qxi5;
      qZx[id6] = qxi6; 
      //
       // PML UPDATES
      qZy[id1] = qyi1;
      qZy[id2] = qyi2;
      qZy[id3] = qyi3;
      qZy[id4] = qyi4;
      qZy[id5] = qyi5;
      qZy[id6] = qyi6; 
      
      #if 0
       // PML UPDATES
      qZnt[id1] = nti1;
      qZnt[id2] = nti2;
      qZnt[id3] = nti3;
      qZnt[id4] = nti4;
      qZnt[id5] = nti5;
      qZnt[id6] = nti6; 

      #endif
      // 
      dfloat4 temp;

      temp.x =  q1;
      temp.y =  q2;
      temp.z =  q3;
      temp.w =  q4;

      qZ[2*(n + element*p_Np)] = temp;

      temp.x =  q5;
      temp.y =  q6;
      temp.z =  0.0;
      temp.w =  0.0;

      qZ[2*(n + element*p_Np) +1] = temp;

    }
  }
}







kernel void boltzmannLSIMEXImplicitIterationCub2D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat dt,	
				         const dfloat akk,
					     const dfloat * restrict cubInterpT,
					     const dfloat * restrict cubProjectT,
					     const dfloat4 * restrict qe,
					           dfloat4 * restrict q){ 
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
             shared dfloat s_q[p_NblockV][6][p_Np];
             shared dfloat s_E[p_NblockV*p_Np];
    volatile shared dfloat s_err[p_G][p_S];
    volatile shared dfloat s_b[p_G];


    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];

    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qe1 =0.0, qe2 = 0.0, qe3=0.0 ;
    exclusive dfloat qe4 =0.0, qe5 = 0.0, qe6=0.0 ;  
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;  


    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
      	iint e = eo+es; // element in block
      	if(e<Nelements)
        {
      	  element = elementIds[e];
      	  if(n<p_Np)
          {
      	    const iint id = element*p_Np+n;
      	    dfloat4 qea  = qe[2*id];
      	    dfloat4 qeb  = qe[2*id+1];
      	    //
      	    dfloat4  qa  = q[2*id]  ;
      	    dfloat4  qb  = q[2*id+1];

            // hold explicit part at register, constant in iterations    
      	    qe1  = qea.x;
      	    qe2  = qea.y;
      	    qe3  = qea.z;
      	    qe4  = qea.w;   
      	    qe5  = qeb.x;
      	    qe6  = qeb.y;	 
            // Initialize solution
            q1  = qe1;
      	    q2  = qe2;
      	    q3  = qe3;
      	    q4  = qe4; 
      	    q5  = qe5;
      	    q6  = qe6;	       	    
	         }
	       }
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);


if(akk>0)
 {
  for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
  { 
       

       // prefetch solution to shared memory
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {        
          iint e = eo+es; // element in block
          if(e<Nelements)
          {
            if(n<p_Np)
            {           
              s_q[es][0][n] = q1;
              s_q[es][1][n] = q2;
              s_q[es][2][n] = q3;
              s_q[es][3][n] = q4;   
              s_q[es][4][n] = q5;
              s_q[es][5][n] = q6;
            }
          }
        }
      }

 // make sure all node data is loaded into shared
    barrier(localMemFence);

  // interpolate q to cubature
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {     
            iint e = eo+es; // element in block
            if(e<Nelements)
            {
              if(n<p_cubNp)
              {
                dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
                dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
                
                occaUnroll(p_Np)
                for(iint m=0;m<p_Np;++m)
                {
                  const dfloat Icn  = cubInterpT[m*p_cubNp+n];
                  cubq1 += Icn*s_q[es][0][m];
                  cubq2 += Icn*s_q[es][1][m];
                  cubq3 += Icn*s_q[es][2][m];
                  cubq4 += Icn*s_q[es][3][m];
                  cubq5 += Icn*s_q[es][4][m];
                  cubq6 += Icn*s_q[es][5][m];
                }
                
                dfloat coeff  = akk * dt * p_tauInv;
                dfloat icubq1 = 1.0 / cubq1;
                // BGK relaxation approximation to the Boltzmann collision operator
                s_cubN4[es][n] = -coeff * (cubq4-(           cubq2*cubq3*icubq1));
                s_cubN5[es][n] = -coeff * (cubq5-(p_invsqrt2*cubq2*cubq2*icubq1));
                s_cubN6[es][n] = -coeff * (cubq6-(p_invsqrt2*cubq3*cubq3*icubq1));
              }
          }
        }
      }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {     
          iint e = eo+es; // element in block
          if(e<Nelements)
          {
            if(n<p_Np)
            {                 
              // use temporaries for part sums for N4,N5,N6 because of exclusives
              dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

              occaUnroll(p_cubNp)
              for(iint i=0;i<p_cubNp;++i)
              {
                const dfloat Pnc  = cubProjectT[i*p_Np+n];
                N4 += Pnc*s_cubN4[es][i];
                N5 += Pnc*s_cubN5[es][i];
                N6 += Pnc*s_cubN6[es][i];
              }
               //
              dfloat z1 =  qe1 - q1 ;
              dfloat z2 =  qe2 - q2 ;
              dfloat z3 =  qe3 - q3 ;
              dfloat z4 =  qe4 - q4 +  N4 ;
              dfloat z5 =  qe5 - q5 +  N5 ;
              dfloat z6 =  qe6 - q6 +  N6 ;
              
              // Store solution for error check
              dfloat q4o = q4;
              dfloat q5o = q5;
              dfloat q6o = q6;
              //
              dfloat cc     = akk * dt * p_tauInv;
              dfloat icc    = 1.0/cc; 

                   //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
              q4 +=           z4/(cc+1.0)  
                            + z2*q3/(q1*(1.0+icc)) 
                            + z3*q2/(q1*(1.0+icc))
                            - z1*q2*q3/(q1*q1*(1.0+icc)); 

              q5 +=            z5/(cc+1)
                            +  p_sqrt2 * ( z2*q2/(q1*(1.0 + icc)))
                            -  p_sqrt2 * ( z1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icc)));

              q6 +=           z6/(cc+1.0)
                           +  p_sqrt2* ( z3*q3/(q1*(1.0+icc)))
                           -  p_sqrt2* ( z1*(q3*q3)/(2.0*(q1*q1)*(1.0+icc)));


              // Compute errors 
               dfloat err4 = fabs(q4-q4o);
               dfloat err5 = fabs(q5-q5o);
               dfloat err6 = fabs(q6-q6o);
              // Compute maximum of error
               err = GET_MAX3(err4,err5,err6);
              // Hold error in shared for local reduction
               s_E[es*p_Np + n] = err; 
            }
          }
        }
      }


    // make sure error vector is loaded into shared
    barrier(localMemFence);
     
     // Reduction->Step 1 // All parallel
      for(int g=0;g<p_G;++g;inner1)
      {
        for(int s=0;s<p_S;++s;inner0)
        {
            const iint n = g*p_S + s;
            s_err[g][s] = n>p_NblockV*p_Np  ? 0.0 : s_E[n];

            if(s<16) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 16]);
            if(s< 8) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 8]);
            if(s< 4) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 4]);
            if(s< 2) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 2]);
            if(s==0) s_b[g]      = GET_MAX2(s_err[g][s],s_err[g][s + 1]);
        }
      }
    
    barrier(localMemFence);
   // Reduction->step 2 // Squential now
     for(int g=0;g<p_G;++g;inner1)
     {
        for(int s=0;s<p_S;++s;inner0)
        {
          if(g==0) // Squential
          {
            if(p_G>8){
            if(s<8)  s_b[s] = GET_MAX2(s_b[s],s_b[s + 8]);}
            if(p_G>4){
            if(s< 4) s_b[s] = GET_MAX2(s_b[s],s_b[s + 4]);}
            if(p_G>2){
            if(s< 2) s_b[s] = GET_MAX2(s_b[s],s_b[s + 2]);}
            if(s==0) s_b[s] = GET_MAX2(s_b[s],s_b[s + 1]);
          }
        }
      }
     

   // 
    barrier(localMemFence);
    
    // This is for making all threads in the same group exit  at the same time
    for(iint es=0;es<p_NblockV;++es;inner1)
    {
      for(iint n=0;n<p_maxNodesVolume;++n;inner0)
      {     
             err = s_b[0];
         }
       }

   // This is for making all threads in the same group exit  at the same time
   if (err<p_LSIMEX_TOL) break;


  }
}

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);



    // If converged update solution
    for(iint es=0;es<p_NblockV;++es;inner1)
    {
      for(iint n=0;n<p_maxNodesVolume;++n;inner0)
      {    
        iint e = eo+es; // element in block
        if(e<Nelements)
        {
          element = elementIds[e];
          if(n<p_Np)
          {
            const iint id0     = 2*(element*p_Np + n);
            const iint id1     = id0 + 1;

             // do not update q1 ,q2 ,q3 
            q[id0].x =  q1 ;
            q[id0].y =  q2 ;
            q[id0].z =  q3 ;  
            q[id0].w =  q4 ;
            //
            q[id1].x =  q5 ;
            q[id1].y =  q6 ; 
            q[id1].z =  0.0 ;
            q[id1].w =  0.0 ; 


           }
         }
      }
    }



  }
}





kernel void boltzmannLSIMEXSplitPmlImplicitIterationCub2D(const iint Nelements,
                    const iint * restrict elementIds,
                    const dfloat dt,  
                    const dfloat ramp,
                    const dfloat akk,
                    const dfloat * restrict cubInterpT,
                    const dfloat * restrict cubProjectT,
                    const dfloat * restrict qYx,
                    const dfloat * restrict qYy,
                    const dfloat * restrict qYnt,
                          dfloat * restrict qZx,
                          dfloat * restrict qZy,
                          dfloat * restrict qZnt,
                          dfloat4 *restrict qZ ){
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
             shared dfloat s_q[p_NblockV][6][p_Np];
             shared dfloat s_E[p_NblockV*p_Np];
    volatile shared dfloat s_err[p_G][p_S];
    volatile shared dfloat s_b[p_G];


    // sub-group of p_Np cubature node interpolants of N4,N5,N6
    shared dfloat s_cubN4[p_NblockV][p_cubNp];
    shared dfloat s_cubN5[p_NblockV][p_cubNp];
    shared dfloat s_cubN6[p_NblockV][p_cubNp];

    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qxe1 =0.0, qxe2 = 0.0, qxe3=0.0 ;
    exclusive dfloat qxe4 =0.0, qxe5 = 0.0, qxe6=0.0 ; 
    //
    exclusive dfloat qye1 =0.0, qye2 = 0.0, qye3=0.0 ;
    exclusive dfloat qye4 =0.0, qye5 = 0.0, qye6=0.0 ;  
    //
    exclusive dfloat nte1 =0.0, nte2 = 0.0, nte3=0.0 ;
    exclusive dfloat nte4 =0.0, nte5 = 0.0, nte6=0.0 ;   
    //
    exclusive dfloat qx1 =0.0, qx2 = 0.0, qx3=0.0 ;
    exclusive dfloat qx4 =0.0, qx5 = 0.0, qx6=0.0 ;  

    exclusive dfloat qy1 =0.0, qy2 = 0.0, qy3=0.0 ;
    exclusive dfloat qy4 =0.0, qy5 = 0.0, qy6=0.0 ;  
    //
    exclusive dfloat nt1 =0.0, nt2 = 0.0, nt3=0.0 ;
    exclusive dfloat nt4 =0.0, nt5 = 0.0, nt6=0.0 ; 
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;   


    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
  
        iint e = eo+es; // element in block
        if(e<Nelements)
        {
          element = elementIds[e];
          if(n<p_Np)
          {
             //
            const iint base = n + element*p_Nfields*p_Np;
            const iint id1 = base + 0*p_Np;
            const iint id2 = base + 1*p_Np;
            const iint id3 = base + 2*p_Np;
            const iint id4 = base + 3*p_Np;
            const iint id5 = base + 4*p_Np;
            const iint id6 = base + 5*p_Np;
            
                  // PML UPDATES
            qxe1 = qYx[id1];
            qxe2 = qYx[id2];
            qxe3 = qYx[id3];
            qxe4 = qYx[id4];
            qxe5 = qYx[id5];
            qxe6 = qYx[id6]; 
            //
            qye1 = qYy[id1];
            qye2 = qYy[id2];
            qye3 = qYy[id3];
            qye4 = qYy[id4];
            qye5 = qYy[id5];
            qye6 = qYy[id6]; 
            //
            nte1 = qYnt[id1];
            nte2 = qYnt[id2];
            nte3 = qYnt[id3];
            nte4 = qYnt[id4];
            nte5 = qYnt[id5];
            nte6 = qYnt[id6]; 
         
            // Initialize
            qx1 = qxe1;
            qx2 = qxe2;
            qx3 = qxe3;
            qx4 = qxe4;
            qx5 = qxe5;
            qx6 = qxe6; 
            //
            qy1 = qye1;
            qy2 = qye2;
            qy3 = qye3;
            qy4 = qye4;
            qy5 = qye5;
            qy6 = qye6; 
            //
            nt1 = nte1;
            nt2 = nte2;
            nt3 = nte3;
            nt4 = nte4;
            nt5 = nte5;
            nt6 = nte6; 
            //
           q1 =  p_q1bar                 + qx1 + qy1;
           q2 =  ramp*p_q2bar            + qx2 + qy2;
           q3 =  ramp*p_q3bar            + qx3 + qy3;
           q4 =  ramp*ramp*p_q4bar       + qx4 + qy4;
           q5 =  ramp*ramp*p_q5bar       + qx5 + qy5;
           q6 =  ramp*ramp*p_q6bar       + qx6 + qy6;

           }
         }
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);


if(akk>0)
 {
  for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
  { 
       // prefetch q to shared
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {        
          iint e = eo+es; // element in block
          if(e<Nelements)
          {
            if(n<p_Np)
            {           
              s_q[es][0][n] = q1;
              s_q[es][1][n] = q2;
              s_q[es][2][n] = q3;
              s_q[es][3][n] = q4;   
              s_q[es][4][n] = q5;
              s_q[es][5][n] = q6;
            }
          }
        }
      }

 // make sure all node data is loaded into shared
    barrier(localMemFence);

  // interpolate q to cubature
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {     
            iint e = eo+es; // element in block
            if(e<Nelements)
            {
              if(n<p_cubNp)
              {
                dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
                dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
                
                occaUnroll(p_Np)
                for(iint m=0;m<p_Np;++m)
                {
                  const dfloat Icn  = cubInterpT[m*p_cubNp+n];
                  cubq1 += Icn*s_q[es][0][m];
                  cubq2 += Icn*s_q[es][1][m];
                  cubq3 += Icn*s_q[es][2][m];
                  cubq4 += Icn*s_q[es][3][m];
                  cubq5 += Icn*s_q[es][4][m];
                  cubq6 += Icn*s_q[es][5][m];
                }
                
                dfloat coeff  = akk * dt * p_tauInv;
                dfloat icubq1 = 1.0 / cubq1;
                // BGK relaxation approximation to the Boltzmann collision operator
                s_cubN4[es][n] = -coeff * (cubq4-(           cubq2*cubq3*icubq1));
                s_cubN5[es][n] = -coeff * (cubq5-(p_invsqrt2*cubq2*cubq2*icubq1));
                s_cubN6[es][n] = -coeff * (cubq6-(p_invsqrt2*cubq3*cubq3*icubq1));
              }
          }
        }
      }

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1)
      {
        for(iint n=0;n<p_maxNodesVolume;++n;inner0)
        {     
          iint e = eo+es; // element in block
          if(e<Nelements)
          {
            if(n<p_Np)
            {                 
              // use temporaries for part sums for N4,N5,N6 because of exclusives
              dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

              occaUnroll(p_cubNp)
              for(iint i=0;i<p_cubNp;++i)
              {
                const dfloat Pnc  = cubProjectT[i*p_Np+n];
                N4 += Pnc*s_cubN4[es][i];
                N5 += Pnc*s_cubN5[es][i];
                N6 += Pnc*s_cubN6[es][i];
              }
                 //
              dfloat zx1 =  qxe1 - qx1 ;
              dfloat zx2 =  qxe2 - qx2 ;
              dfloat zx3 =  qxe3 - qx3 ;
              dfloat zx4 =  qxe4 - qx4 +  0.5*N4 ;
              dfloat zx5 =  qxe5 - qx5 +  0.5*N5 ;
              dfloat zx6 =  qxe6 - qx6 +  0.5*N6 ;
              //
              dfloat zy1 =  qye1 - qy1 ;
              dfloat zy2 =  qye2 - qy2 ;
              dfloat zy3 =  qye3 - qy3 ;
              dfloat zy4 =  qye4 - qy4 +  0.5*N4 ;
              dfloat zy5 =  qye5 - qy5 +  0.5*N5 ;
              dfloat zy6 =  qye6 - qy6 +  0.5*N6 ;
              //
              dfloat znt1 =  nte1 - nt1 ;
              dfloat znt2 =  nte2 - nt2 ;
              dfloat znt3 =  nte3 - nt3 ;
              dfloat znt4 =  nte4 - nt4 +  N4 ;
              dfloat znt5 =  nte5 - nt5 +  N5 ;
              dfloat znt6 =  nte6 - nt6 +  N6 ;


              //
              dfloat qx4o = qx4;
              dfloat qx5o = qx5;
              dfloat qx6o = qx6;
              //
              dfloat qy4o = qy4;
              dfloat qy5o = qy5;
              dfloat qy6o = qy6;
              //
              dfloat nt4o = nt4;
              dfloat nt5o = nt5;
              dfloat nt6o = nt6;
              //
              dfloat cc     = akk * dt * p_tauInv;
              dfloat icc    = 1.0/cc; 
              dfloat cch    = 0.5*cc; 
              dfloat icch   = 1./cch;  

                     //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
              qx4  +=        zx4/(cch+1.0)  
                            + zx2*q3/(q1*(1.0+icch)) 
                            + zx3*q2/(q1*(1.0+icch))
                            - zx1*q2*q3/(q1*q1*(1.0+icch)); 

              qx5  +=         zx5/(cch+1.)
                            +  p_sqrt2 * ( zx2*q2/(q1*(1.0 + icch)))
                            -  p_sqrt2 * ( zx1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

              qx6 +=         zx6/(cch+1.0)
                           +  p_sqrt2* ( zx3*q3/(q1*(1.0+icch)))
                           -  p_sqrt2* ( zx1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));

              //  
              qy4  +=        zy4/(cch+1.0)  
                            + zy2*q3/(q1*(1.0+icch)) 
                            + zy3*q2/(q1*(1.0+icch))
                            - zy1*q2*q3/(q1*q1*(1.0+icch)); 

              qy5  +=         zy5/(cch+1.)
                            +  p_sqrt2 * ( zy2*q2/(q1*(1.0 + icch)))
                            -  p_sqrt2 * ( zy1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

              qy6 +=         zy6/(cch+1.0)
                           +  p_sqrt2* ( zy3*q3/(q1*(1.0+icch)))
                           -  p_sqrt2* ( zy1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));   

               //  
              nt4  +=        znt4/(cc+1.0)  
                            + znt2*q3/(q1*(1.0+icc)) 
                            + znt3*q2/(q1*(1.0+icc))
                            - znt1*q2*q3/(q1*q1*(1.0+icc)); 

              nt5  +=         znt5/(cc+1.)
                            +  p_sqrt2 * ( znt2*q2/(q1*(1.0 + icc)))
                            -  p_sqrt2 * ( znt1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icc)));

              nt6 +=         znt6/(cc+1.0)
                           +  p_sqrt2* ( znt3*q3/(q1*(1.0+icc)))
                           -  p_sqrt2* ( znt1*(q3*q3)/(2.0*(q1*q1)*(1.0+icc)));  


               q4 =  ramp*ramp*p_q4bar       + qx4 + qy4;
               q5 =  ramp*ramp*p_q5bar       + qx5 + qy5;
               q6 =  ramp*ramp*p_q6bar       + qx6 + qy6;                                     

              // Compute errors for q4 q5 a6
               dfloat ex4 = fabs(qx4-qx4o);
               dfloat ex5 = fabs(qx5-qx5o);
               dfloat ex6 = fabs(qx6-qx6o);
               //
               dfloat ey4 = fabs(qy4-qy4o);
               dfloat ey5 = fabs(qy5-qy5o);
               dfloat ey6 = fabs(qy6-qy6o);

               dfloat ent4 = fabs(nt4-nt4o);
               dfloat ent5 = fabs(nt5-nt5o);
               dfloat ent6 = fabs(nt6-nt6o);


               dfloat ex  = GET_MAX3(ex4,ex5,ex6);  
               dfloat ey  = GET_MAX3(ey4,ey5,ey6);   
               dfloat ent = GET_MAX3(ent4,ent5,ent6);   

               err =  GET_MAX3(ex,ey,ent);   

               s_E[es*p_Np + n] = err; 
            }
          }
        }
      }


    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);

      for(int g=0;g<p_G;++g;inner1)
      {
        for(int s=0;s<p_S;++s;inner0)
        {
            const iint n = g*p_S + s;
            s_err[g][s] = n>p_NblockV*p_Np  ? 0.0 : s_E[n];

            if(s<16) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 16]);
            if(s< 8) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 8]);
            if(s< 4) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 4]);
            if(s< 2) s_err[g][s] = GET_MAX2(s_err[g][s],s_err[g][s + 2]);
            if(s==0) s_b[g]      = GET_MAX2(s_err[g][s],s_err[g][s + 1]);
        }
      }
    
    barrier(localMemFence);

     for(int g=0;g<p_G;++g;inner1)
     {
        for(int s=0;s<p_S;++s;inner0)
        {
          if(g==0)
          {
            if(p_G>8){
            if(s<8)  s_b[s] = GET_MAX2(s_b[s],s_b[s + 8]);}
            if(p_G>4){
            if(s< 4) s_b[s] = GET_MAX2(s_b[s],s_b[s + 4]);}
            if(p_G>2){
            if(s< 2) s_b[s] = GET_MAX2(s_b[s],s_b[s + 2]);}
            if(s==0) s_b[s] = GET_MAX2(s_b[s],s_b[s + 1]);
          }
        }
      }
     

   // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
    
    // partial projection to nodes from cubature-sub-group
    for(iint es=0;es<p_NblockV;++es;inner1)
    {
      for(iint n=0;n<p_maxNodesVolume;++n;inner0)
      {     
             err = s_b[0];
         }
       }


   if (err<p_LSIMEX_TOL) break;


  }
}

    // make sure all cubature node data is loaded into shared
    barrier(localMemFence);



    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1)
    {
      for(iint n=0;n<p_maxNodesVolume;++n;inner0)
      {    
        iint e = eo+es; // element in block
        if(e<Nelements)
        {
          element = elementIds[e];
          if(n<p_Np)
          {
            //
            const iint base = n + element*p_Nfields*p_Np;
            const iint id1 = base + 0*p_Np;
            const iint id2 = base + 1*p_Np;
            const iint id3 = base + 2*p_Np;
            const iint id4 = base + 3*p_Np;
            const iint id5 = base + 4*p_Np;
            const iint id6 = base + 5*p_Np;

                  // PML UPDATES
            qZx[id1] = qx1;
            qZx[id2] = qx2;
            qZx[id3] = qx3;
            qZx[id4] = qx4;
            qZx[id5] = qx5;
            qZx[id6] = qx6; 
            //
             // PML UPDATES
            qZy[id1] = qy1;
            qZy[id2] = qy2;
            qZy[id3] = qy3;
            qZy[id4] = qy4;
            qZy[id5] = qy5;
            qZy[id6] = qy6; 
            //
             // PML UPDATES
            qZnt[id1] = nt1;
            qZnt[id2] = nt2;
            qZnt[id3] = nt3;
            qZnt[id4] = nt4;
            qZnt[id5] = nt5;
            qZnt[id6] = nt6; 
            // 
            dfloat4 temp;

            temp.x =  q1;
            temp.y =  q2;
            temp.z =  q3;
            temp.w =  q4;

            qZ[2*(n + element*p_Np)] = temp;

            temp.x =  q5;
            temp.y =  q6;
            temp.z =  0.0;
            temp.w =  0.0;

            qZ[2*(n + element*p_Np) +1] = temp; 
           }
         }
      }
    }



  }
}



