
kernel void boltzmannLSIMEXImplicitIteration2D(const iint Nelements,
					       const iint * restrict elementIds,
					       const dfloat dt,	
					       const dfloat akk,
					       const dfloat  * restrict cubInterpT,
					       const dfloat  * restrict cubProjectT,
					       const dfloat4 * restrict qex,
					       dfloat4 * restrict qim){

for(iint e=0;e<Nelements;++e;outer0){
	for(iint n=0;n<p_Np;++n;inner0){

      const iint element = elementIds[e];
      const iint id0     = 2*(element*p_Np + n);
      const iint id1     = id0 + 1;
            
      dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

      // Read explicit part 
      dfloat4 qexa = qex[id0];
      dfloat4 qexb = qex[id1];
      
      // Read implicit part
      dfloat4 qima = qim[id0];
      dfloat4 qimb = qim[id1];      
      
      //
      dfloat qex1 = qexa.x;
      dfloat qex2 = qexa.y;
      dfloat qex3 = qexa.z;
      dfloat qex4 = qexa.w;
      dfloat qex5 = qexb.x;
      dfloat qex6 = qexb.y;       
      
      // First iteration, Qim = Qex ; 
      dfloat qim1 = qex1;
      dfloat qim2 = qex2;
      dfloat qim3 = qex3;
      dfloat qim4 = qex4;
      dfloat qim5 = qex5;
      dfloat qim6 = qex6; 
      //         
      if(akk>0){ // No need to solve, just update

		dfloat cc  = akk * dt * p_tauInv;
		dfloat icc    = 1.0f/cc; 

		//
		N4 = -cc*( qim4 -            ( qim2*qim3/qim1 ) );
		N5 = -cc*( qim5 - p_invsqrt2*( qim2*qim2/qim1 ) );
		N6 = -cc*( qim6 - p_invsqrt2*( qim3*qim3/qim1 ) );

		//
		dfloat z1 =  qex1 - qim1 ;
		dfloat z2 =  qex2 - qim2 ;
		dfloat z3 =  qex3 - qim3 ;
		dfloat z4 =  qex4 - qim4 +  N4 ;
		dfloat z5 =  qex5 - qim5 +  N5 ;
		dfloat z6 =  qex6 - qim6 +  N6 ;

		//hold old values
		dfloat qim4o = qim4;
		dfloat qim5o = qim5;
		dfloat qim6o = qim6;

		//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
		qim4 = qim4o  + z4/(cc+1.0f)  
		+ z2*qim3/(qim1*(1.0f+icc)) 
		+ z3*qim2/(qim1*(1.0f+icc))
		- z1*qim2*qim3/(qim1*qim1*(1.0f+icc)); 

		qim5 = qim5o  +  z5/(cc+1)
		+  p_sqrt2 * ( z2*qim2/(qim1*(1.0f + icc)))
		-  p_sqrt2 * ( z1*(qim2*qim2)/(2.0f *(qim1*qim1)*(1.0f+icc)));

		qim6 = qim6o +  z6/(cc+1.0f)
		+  p_sqrt2* ( z3*qim3/(qim1*(1.0f+icc)))
		-  p_sqrt2* ( z1*(qim3*qim3)/(2.0f*(qim1*qim1)*(1.0f+icc)));
	}
	
	// do not update q1 ,q2 ,q3 
	qim[id0].x =  qim1 ;
	qim[id0].y =  qim2 ;
	qim[id0].z =  qim3 ;  
	qim[id0].w =  qim4 ;
	//
	qim[id1].x =  qim5 ;
	qim[id1].y =  qim6 ;  
	
	}
}
  

}

kernel void boltzmannLSIMEXSplitPmlImplicitIteration2D(const iint Nelements,
						       const iint * restrict elementIds,
						       const dfloat dt,  
						       const dfloat ramp,
						       const dfloat akk,
						       const dfloat * restrict cubInterpT,
						       const dfloat * restrict cubProjectT,
						       const dfloat * restrict qYx,
						       const dfloat * restrict qYy,
						       dfloat * restrict qZx,
						       dfloat * restrict qZy,
						       dfloat4 *restrict qZ ){

for(iint e=0;e<Nelements;++e;outer0){
	for(iint n=0;n<p_Np;++n;inner0){
      
		const iint element = elementIds[e];
		//
		const iint base = n + element*p_Nfields*p_Np;
		const iint id1 = base + 0*p_Np;
		const iint id2 = base + 1*p_Np;
		const iint id3 = base + 2*p_Np;
		const iint id4 = base + 3*p_Np;
		const iint id5 = base + 4*p_Np;
		const iint id6 = base + 5*p_Np;

		// PML UPDATES
		dfloat qxe1 = qYx[id1];
		dfloat qxe2 = qYx[id2];
		dfloat qxe3 = qYx[id3];
		dfloat qxe4 = qYx[id4];
		dfloat qxe5 = qYx[id5];
		dfloat qxe6 = qYx[id6]; 
		//
		dfloat qye1 = qYy[id1];
		dfloat qye2 = qYy[id2];
		dfloat qye3 = qYy[id3];
		dfloat qye4 = qYy[id4];
		dfloat qye5 = qYy[id5];
		dfloat qye6 = qYy[id6]; 
		// Initialize
		dfloat qxi1 = qxe1;
		dfloat qxi2 = qxe2;
		dfloat qxi3 = qxe3;
		dfloat qxi4 = qxe4;
		dfloat qxi5 = qxe5;
		dfloat qxi6 = qxe6; 
		//
		dfloat qyi1 = qye1;
		dfloat qyi2 = qye2;
		dfloat qyi3 = qye3;
		dfloat qyi4 = qye4;
		dfloat qyi5 = qye5;
		dfloat qyi6 = qye6; 
		//
		dfloat q1 =  p_q1bar                 + qxi1 + qyi1;
		dfloat q2 =  ramp*p_q2bar            + qxi2 + qyi2;
		dfloat q3 =  ramp*p_q3bar            + qxi3 + qyi3;
		dfloat q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
		dfloat q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
		dfloat q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;

		//
		if(akk>0){
			dfloat err = 0.0;  
			dfloat coeff  = akk * dt * p_tauInv;
			dfloat icc    = 1.0f/coeff; 
			    
			dfloat cch    = 0.5f*coeff; 
			dfloat icch   = 1.0f/cch; 
			
			
			dfloat N4=0.,N5=0.,N6=0.;  
			
			//
			N4 = -coeff*( q4 -            ( q2*q3/q1 ) );
			N5 = -coeff*( q5 - p_invsqrt2*( q2*q2/q1 ) );
			N6 = -coeff*( q6 - p_invsqrt2*( q3*q3/q1 ) );
			    
			//
			dfloat zx1 =  qxe1 - qxi1 ;
			dfloat zx2 =  qxe2 - qxi2 ;
			dfloat zx3 =  qxe3 - qxi3 ;
			dfloat zx4 =  qxe4 - qxi4 +  0.5f*N4 ;
			dfloat zx5 =  qxe5 - qxi5 +  0.5f*N5 ;
			dfloat zx6 =  qxe6 - qxi6 +  0.5f*N6 ;
			//
			dfloat zy1 =  qye1 - qyi1 ;
			dfloat zy2 =  qye2 - qyi2 ;
			dfloat zy3 =  qye3 - qyi3 ;
			dfloat zy4 =  qye4 - qyi4 +  0.5f*N4 ;
			dfloat zy5 =  qye5 - qyi5 +  0.5f*N5 ;
			dfloat zy6 =  qye6 - qyi6 +  0.5f*N6 ;
			    
			//
			dfloat qxi4o = qxi4;
			dfloat qxi5o = qxi5;
			dfloat qxi6o = qxi6;
			//
			dfloat qyi4o = qyi4;
			dfloat qyi5o = qyi5;
			dfloat qyi6o = qyi6;
			    
			//Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
			    
			qxi4  +=
			  zx4/(cch+1.0f)  
			  + zx2*q3/(q1*(1.0f+icch)) 
			  + zx3*q2/(q1*(1.0f+icch))
			  - zx1*q2*q3/(q1*q1*(1.0f+icch)); 
			    
			qxi5  +=
			  zx5/(cch+1.)
			  +  p_sqrt2 * ( zx2*q2/(q1*(1.0f + icch)))
			  -  p_sqrt2 * ( zx1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icch)));
			    
			qxi6 +=
			  zx6/(cch+1.0f)
			  +  p_sqrt2* ( zx3*q3/(q1*(1.0f+icch)))
			  -  p_sqrt2* ( zx1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icch)));
			    
			//  
			qyi4  +=
			  zy4/(cch+1.0f)  
			  + zy2*q3/(q1*(1.0f+icch)) 
			  + zy3*q2/(q1*(1.0f+icch))
			  - zy1*q2*q3/(q1*q1*(1.0f+icch)); 
			    
			qyi5  +=
			  zy5/(cch+1.)
			  +  p_sqrt2 * ( zy2*q2/(q1*(1.0f + icch)))
			  -  p_sqrt2 * ( zy1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icch)));
			    
			qyi6 +=
			  zy6/(cch+1.0f)
			  +  p_sqrt2* ( zy3*q3/(q1*(1.0f+icch)))
			  -  p_sqrt2* ( zy1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icch)));   
			    
			    
			q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
			q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
			q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;                                     
	    
		}  
		// PML UPDATES
		qZx[id1] = qxi1;
		qZx[id2] = qxi2;
		qZx[id3] = qxi3;
		qZx[id4] = qxi4;
		qZx[id5] = qxi5;
		qZx[id6] = qxi6; 
		//
		// PML UPDATES
		qZy[id1] = qyi1;
		qZy[id2] = qyi2;
		qZy[id3] = qyi3;
		qZy[id4] = qyi4;
		qZy[id5] = qyi5;
		qZy[id6] = qyi6; 
		//
		dfloat4 temp;

		temp.x =  q1;
		temp.y =  q2;
		temp.z =  q3;
		temp.w =  q4;

		qZ[2*(n + element*p_Np)] = temp;

		temp.x =  q5;
		temp.y =  q6;
		temp.z =  0.0;
		temp.w =  0.0;

		qZ[2*(n + element*p_Np) +1] = temp;
      
    }
  }
}


kernel void boltzmannLSIMEXImplicitIterationCub2D(const iint Nelements,
						  const iint * restrict elementIds,
						  const dfloat dt, 
						  const dfloat akk,
						  const dfloat * restrict cubInterpT,
						  const dfloat * restrict cubProjectT,
						  const dfloat4 * restrict qe,
						  dfloat4 * restrict q){ 

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_q[p_NblockV][6][p_Np];
    shared dfloat s_qE[p_NblockV][6][p_Np];
    shared dfloat s_cubq[p_NblockV][6][p_cubNp];
   
    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qe1 =0.0, qe2 = 0.0, qe3=0.0 ;
    exclusive dfloat qe4 =0.0, qe5 = 0.0, qe6=0.0 ;  
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;  

    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
        iint e = eo+es; // element in block
        if(e<Nelements){
	  
	  element = elementIds[e];
	  if(n<p_Np){
	    
	    const iint id = element*p_Np+n;
	    dfloat4 qea  = qe[2*id];
	    dfloat4 qeb  = qe[2*id+1];
	    //load 
	    
	    s_qE[es][0][n] = qea.x;
	    s_qE[es][1][n] = qea.y;
	    s_qE[es][2][n] = qea.z;
	    s_qE[es][3][n] = qea.w;   
	    s_qE[es][4][n] = qeb.x;
	    s_qE[es][5][n] = qeb.y;
	    //
	    s_q[es][0][n] = qea.x;
	    s_q[es][1][n] = qea.y;
	    s_q[es][2][n] = qea.z;
	    s_q[es][3][n] = qea.w;   
	    s_q[es][4][n] = qeb.x;
	    s_q[es][5][n] = qeb.y;  
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){

	iint e = eo+es; // element in block
	if(e<Nelements){
	  
	  if(n<p_cubNp){
	    
	    occaUnroll(p_Np)
	      for(iint m=0;m<p_Np;++m){
		
		const dfloat Icn  = cubInterpT[m*p_cubNp+n];
		q1 += Icn*s_q[es][0][m];
		q2 += Icn*s_q[es][1][m];
		q3 += Icn*s_q[es][2][m];
		q4 += Icn*s_q[es][3][m];
		q5 += Icn*s_q[es][4][m];
		q6 += Icn*s_q[es][5][m];
		//
		qe1 += Icn*s_qE[es][0][m];
		qe2 += Icn*s_qE[es][1][m];
		qe3 += Icn*s_qE[es][2][m];
		qe4 += Icn*s_qE[es][3][m];
		qe5 += Icn*s_qE[es][4][m];
		qe6 += Icn*s_qE[es][5][m];
	      }
	  }
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_cubNp){
	      if(akk>0){ 	
	      dfloat cc  = akk * dt * p_tauInv;
	      dfloat icc    = 1.0f/cc; 
	      dfloat iq1    = 1.0f/ q1;
	      // BGK relaxation approximation to the Boltzmann collision operator
	      dfloat N4 = -cc * (q4-(           q2*q3*iq1));
	      dfloat N5 = -cc * (q5-(p_invsqrt2*q2*q2*iq1));
	      dfloat N6 = -cc * (q6-(p_invsqrt2*q3*q3*iq1));
	      
	      //
	      dfloat z1 =  qe1 - q1 ;
	      dfloat z2 =  qe2 - q2 ;
	      dfloat z3 =  qe3 - q3 ;
	      dfloat z4 =  qe4 - q4 +  N4 ;
	      dfloat z5 =  qe5 - q5 +  N5 ;
	      dfloat z6 =  qe6 - q6 +  N6 ;

	      // Store solution for error check
	      dfloat q4o = q4;
	      dfloat q5o = q5;
	      dfloat q6o = q6;
	      //
	      //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
	      q4 +=
		z4/(cc+1.0f)  
		+ z2*q3/(q1*(1.0f+icc)) 
		+ z3*q2/(q1*(1.0f+icc))
		- z1*q2*q3/(q1*q1*(1.0f+icc)); 

	      q5 +=
		z5/(cc+1)
		+  p_sqrt2 * ( z2*q2/(q1*(1.0f + icc)))
		-  p_sqrt2 * ( z1*(q2*q2)/(2.0f *(q1*q1)*(1.0f+icc)));

	      q6 +=
		z6/(cc+1.0f)
		+  p_sqrt2* ( z3*q3/(q1*(1.0f+icc)))
		-  p_sqrt2* ( z1*(q3*q3)/(2.0f*(q1*q1)*(1.0f+icc)));
			}

	      s_cubq[es][0][n] = q1;
	      s_cubq[es][1][n] = q2;
	      s_cubq[es][2][n] = q3;
	      s_cubq[es][3][n] = q4;
	      s_cubq[es][4][n] = q5;
	      s_cubq[es][5][n] = q6;
	    }
	  }
	}
      }
      
      // make sure all cubature node data is loaded into shared
    barrier(localMemFence);
      
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_Np){

	      // use temporaries for part sums for N4,N5,N6 because of exclusives
	      q1 = 0.; q2 = 0.; q3 = 0.; q4 = 0.; q5 = 0.; q6 = 0.;
	      
	      occaUnroll(p_cubNp)
		for(iint i=0;i<p_cubNp;++i){
		  const dfloat Pnc  = cubProjectT[i*p_Np+n];
		  q1 += Pnc*s_cubq[es][0][i];
		  q2 += Pnc*s_cubq[es][1][i];
		  q3 += Pnc*s_cubq[es][2][i];
		  q4 += Pnc*s_cubq[es][3][i];
		  q5 += Pnc*s_cubq[es][4][i];
		  q6 += Pnc*s_cubq[es][5][i];
		}
	      
	      //
	      const iint id0     = 2*(element*p_Np + n);
	      const iint id1     = id0 + 1;
	      
	      // do not update q1 ,q2 ,q3 
	      q[id0].x =  q1 ;
	      q[id0].y =  q2 ;
	      q[id0].z =  q3 ;  
	      q[id0].w =  q4 ;
	      //
	      q[id1].x =  q5 ;
	      q[id1].y =  q6 ; 
	      q[id1].z =  0.0 ;
	      q[id1].w =  0.0 ; 
	      
	    }
	  }
	}
      }
    //}
  }
}

kernel void boltzmannLSIMEXSplitPmlImplicitIterationCub2D(const iint Nelements,
							  const iint * restrict elementIds,
							  const dfloat dt,  
							  const dfloat ramp,
							  const dfloat akk,
							  const dfloat * restrict cubInterpT,
							  const dfloat * restrict cubProjectT,
							  const dfloat * restrict qYx,
							  const dfloat * restrict qYy,
							  dfloat * restrict qZx,
							  dfloat * restrict qZy,
							  dfloat4 *restrict qZ ){
  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    // shared memory for q at nodes
    shared dfloat s_qxE[p_NblockV][6][p_Np];            
    shared dfloat s_qyE[p_NblockV][6][p_Np];
    shared dfloat s_q[p_NblockV][6][p_Np];
    
    //
    shared dfloat s_cubqx[p_NblockV][6][p_cubNp];
    shared dfloat s_cubqy[p_NblockV][6][p_cubNp];
    shared dfloat s_cubq[p_NblockV][6][p_cubNp];
    
    //
    shared dfloat s_E[p_NblockV*p_cubNp];
    //
    volatile shared dfloat s_err[p_G][p_S];
    volatile shared dfloat s_b[p_G];
    
    exclusive iint   element;
    exclusive dfloat err =0.; 
    //
    exclusive dfloat qxe1 =0.0, qxe2 = 0.0, qxe3=0.0 ;
    exclusive dfloat qxe4 =0.0, qxe5 = 0.0, qxe6=0.0 ; 
    //
    exclusive dfloat qye1 =0.0, qye2 = 0.0, qye3=0.0 ;
    exclusive dfloat qye4 =0.0, qye5 = 0.0, qye6=0.0 ;  
    //
    exclusive dfloat qx1 =0.0, qx2 = 0.0, qx3=0.0 ;
    exclusive dfloat qx4 =0.0, qx5 = 0.0, qx6=0.0 ;  
    
    exclusive dfloat qy1 =0.0, qy2 = 0.0, qy3=0.0 ;
    exclusive dfloat qy4 =0.0, qy5 = 0.0, qy6=0.0 ;  
    //
    exclusive dfloat q1 =0.0, q2 = 0.0, q3=0.0 ;
    exclusive dfloat q4 =0.0, q5 = 0.0, q6=0.0 ;   
    
    
    // prefetch q to shared
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  element = elementIds[e];
	  if(n<p_Np){
	    //
	    const iint base = n + element*p_Nfields*p_Np;
	    const iint id1 = base + 0*p_Np;
	    const iint id2 = base + 1*p_Np;
	    const iint id3 = base + 2*p_Np;
	    const iint id4 = base + 3*p_Np;
	    const iint id5 = base + 4*p_Np;
	    const iint id6 = base + 5*p_Np;
	    
	    // PML UPDATES
	    s_qxE[es][0][n] = qYx[id1];
	    s_qxE[es][1][n] = qYx[id2];
	    s_qxE[es][2][n] = qYx[id3];
	    s_qxE[es][3][n] = qYx[id4];
	    s_qxE[es][4][n] = qYx[id5];
	    s_qxE[es][5][n] = qYx[id6]; 
	    //
	    s_qyE[es][0][n] = qYy[id1];
	    s_qyE[es][1][n] = qYy[id2];
	    s_qyE[es][2][n] = qYy[id3];
	    s_qyE[es][3][n] = qYy[id4];
	    s_qyE[es][4][n] = qYy[id5];
	    s_qyE[es][5][n] = qYy[id6]; 
	    //
	    s_q[es][0][n] =  p_q1bar            + s_qxE[es][0][n] + s_qyE[es][0][n];
	    s_q[es][1][n] =  ramp*p_q2bar       + s_qxE[es][1][n] + s_qyE[es][1][n];
	    s_q[es][2][n] =  ramp*p_q3bar       + s_qxE[es][2][n] + s_qyE[es][2][n];
	    s_q[es][3][n] =  ramp*ramp*p_q4bar  + s_qxE[es][3][n] + s_qyE[es][3][n];
	    s_q[es][4][n] =  ramp*ramp*p_q5bar  + s_qxE[es][4][n] + s_qyE[es][4][n];
	    s_q[es][5][n] =  ramp*ramp*p_q6bar  + s_qxE[es][5][n] + s_qyE[es][5][n];
	    
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);
    

    // interpolate q to cubature
    for(iint es=0;es<p_NblockV;++es;inner1){
      for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	
	iint e = eo+es; // element in block
	if(e<Nelements){
	  if(n<p_cubNp){

	    occaUnroll(p_Np)
	      for(iint m=0;m<p_Np;++m){
		const dfloat Icn  = cubInterpT[m*p_cubNp+n];
		qxe1 += Icn*s_qxE[es][0][m];
		qxe2 += Icn*s_qxE[es][1][m];
		qxe3 += Icn*s_qxE[es][2][m];
		qxe4 += Icn*s_qxE[es][3][m];
		qxe5 += Icn*s_qxE[es][4][m];
		qxe6 += Icn*s_qxE[es][5][m];
		//
		qye1 += Icn*s_qyE[es][0][m];
		qye2 += Icn*s_qyE[es][1][m];
		qye3 += Icn*s_qyE[es][2][m];
		qye4 += Icn*s_qyE[es][3][m];
		qye5 += Icn*s_qyE[es][4][m];
		qye6 += Icn*s_qyE[es][5][m];
		//
		q1   += Icn*s_q[es][0][m];
		q2   += Icn*s_q[es][1][m];
		q3   += Icn*s_q[es][2][m];
		q4   += Icn*s_q[es][3][m];
		q5   += Icn*s_q[es][4][m];
		q6   += Icn*s_q[es][5][m];
	      }
	    
	    qx1 = qxe1;
	    qx2 = qxe2;
	    qx3 = qxe3;
	    qx4 = qxe4;
	    qx5 = qxe5;
	    qx6 = qxe6;
	    //
	    qy1 = qye1;
	    qy2 = qye2;
	    qy3 = qye3;
	    qy4 = qye4;
	    qy5 = qye5;
	    qy6 = qye6;
	  }
	}
      }
    }
    
    // make sure all node data is loaded into shared
    barrier(localMemFence);

    
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_cubNp){
	    	if(akk>0){
	      
	      dfloat cc     = akk * dt * p_tauInv;
	      dfloat icc    = 1.0f/cc; 
	      dfloat cch    = 0.5f*cc; 
	      dfloat icch   = 1.0f/cch;  
	      dfloat iq1    = 1.0f / q1;
              
	      // BGK relaxation approximation to the Boltzmann collision operator
	      dfloat N4 = -cc*(q4-(           q2*q3*iq1));
	      dfloat N5 = -cc*(q5-(p_invsqrt2*q2*q2*iq1));
	      dfloat N6 = -cc*(q6-(p_invsqrt2*q3*q3*iq1));
	      //
	      dfloat alpha = 0.5f;
	      dfloat beta  = 0.5f;
	      //
	      dfloat zx1 =  qxe1 - qx1 ;
	      dfloat zx2 =  qxe2 - qx2 ;
	      dfloat zx3 =  qxe3 - qx3 ;
	      dfloat zx4 =  qxe4 - qx4 +  alpha*N4 ;
	      dfloat zx5 =  qxe5 - qx5 +  alpha*N5 ;
	      dfloat zx6 =  qxe6 - qx6 +  alpha*N6 ;
	      //
	      dfloat zy1 =  qye1 - qy1 ;
	      dfloat zy2 =  qye2 - qy2 ;
	      dfloat zy3 =  qye3 - qy3 ;
	      dfloat zy4 =  qye4 - qy4 +  beta*N4 ;
	      dfloat zy5 =  qye5 - qy5 +  beta*N5 ;
	      dfloat zy6 =  qye6 - qy6 +  beta*N6 ;
	      //
	      dfloat qx4o = qx4;
	      dfloat qx5o = qx5;
	      dfloat qx6o = qx6;
	      //
	      dfloat qy4o = qy4;
	      dfloat qy5o = qy5;
	      dfloat qy6o = qy6;
	      //
	      
	      //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
	      qx4  +=        zx4/(cch+1.0f)  
		+ zx2*q3/(q1*(1.0f+icch)) 
		+ zx3*q2/(q1*(1.0f+icch))
		- zx1*q2*q3/(q1*q1*(1.0f+icch)); 
	      
	      qx5  +=         zx5/(cch+1.)
		+  p_sqrt2 * ( zx2*q2/(q1*(1.0f + icch)))
		-  p_sqrt2 * ( zx1*(q2*q2)/(2.0 *(q1*q1)*(1.0f+icch)));
	      
	      qx6 +=         zx6/(cch+1.0f)
		+  p_sqrt2* ( zx3*q3/(q1*(1.0f+icch)))
		-  p_sqrt2* ( zx1*(q3*q3)/(2.0*(q1*q1)*(1.0f+icch)));
	      
	      //  
	      qy4  +=        zy4/(cch+1.0f)  
		+ zy2*q3/(q1*(1.0f+icch)) 
		+ zy3*q2/(q1*(1.0f+icch))
		- zy1*q2*q3/(q1*q1*(1.0f+icch)); 
	      
	      qy5  +=         zy5/(cch+1.)
		+  p_sqrt2 * ( zy2*q2/(q1*(1.0f + icch)))
		-  p_sqrt2 * ( zy1*(q2*q2)/(2.0 *(q1*q1)*(1.0f+icch)));
	      
	      qy6 +=         zy6/(cch+1.0f)
		+  p_sqrt2* ( zy3*q3/(q1*(1.0f+icch)))
		-  p_sqrt2* ( zy1*(q3*q3)/(2.0*(q1*q1)*(1.0f+icch)));   
	      
	      
	      q4 =  ramp*ramp*p_q4bar       + qx4 + qy4;
	      q5 =  ramp*ramp*p_q5bar       + qx5 + qy5;
	      q6 =  ramp*ramp*p_q6bar       + qx6 + qy6;  
	      }                                   
	      
	      s_cubqx[es][0][n] = qx1;
	      s_cubqx[es][1][n] = qx2;
	      s_cubqx[es][2][n] = qx3;
	      s_cubqx[es][3][n] = qx4;
	      s_cubqx[es][4][n] = qx5;
	      s_cubqx[es][5][n] = qx6;
	      //
	      s_cubqy[es][0][n] = qy1;
	      s_cubqy[es][1][n] = qy2;
	      s_cubqy[es][2][n] = qy3;
	      s_cubqy[es][3][n] = qy4;
	      s_cubqy[es][4][n] = qy5;
	      s_cubqy[es][5][n] = qy6;
	      // 
	      s_cubq[es][0][n] = q1;
	      s_cubq[es][1][n] = q2;
	      s_cubq[es][2][n] = q3;
	      s_cubq[es][3][n] = q4;
	      s_cubq[es][4][n] = q5;
	      s_cubq[es][5][n] = q6;
	    }
	  }
	}
      }
      
      // make sure all cubature node data is loaded into shared
      barrier(localMemFence);
      
      // partial projection to nodes from cubature-sub-group
      for(iint es=0;es<p_NblockV;++es;inner1){
	for(iint n=0;n<p_maxNodesVolume;++n;inner0){
	  iint e = eo+es; // element in block
	  if(e<Nelements){
	    if(n<p_Np){

	      // use temporaries for part sums for N4,N5,N6 because of exclusives
	      q1  = 0.; q2  = 0.; q3  = 0.; q4  = 0.;  q5  = 0.; q6  = 0.; 
	      qx1 = 0.; qx2 = 0.; qx3 = 0.; qx4 = 0.; qx5 = 0.; qx6 = 0.; 
	      qy1 = 0.; qy2 = 0.; qy3 = 0.; qy4 = 0.; qy5 = 0.; qy6 = 0.; 
	      
	      occaUnroll(p_cubNp)
		for(iint i=0;i<p_cubNp;++i)
		  {
		    const dfloat Pnc  = cubProjectT[i*p_Np+n];
		    q1 += Pnc*s_cubq[es][0][i];
		    q2 += Pnc*s_cubq[es][1][i];
		    q3 += Pnc*s_cubq[es][2][i];
		    q4 += Pnc*s_cubq[es][3][i];
		    q5 += Pnc*s_cubq[es][4][i];
		    q6 += Pnc*s_cubq[es][5][i];
		    //
		    qx1 += Pnc*s_cubqx[es][0][i];
		    qx2 += Pnc*s_cubqx[es][1][i];
		    qx3 += Pnc*s_cubqx[es][2][i];
		    qx4 += Pnc*s_cubqx[es][3][i];
		    qx5 += Pnc*s_cubqx[es][4][i];
		    qx6 += Pnc*s_cubqx[es][5][i];
		    //
		    qy1 += Pnc*s_cubqy[es][0][i];
		    qy2 += Pnc*s_cubqy[es][1][i];
		    qy3 += Pnc*s_cubqy[es][2][i];
		    qy4 += Pnc*s_cubqy[es][3][i];
		    qy5 += Pnc*s_cubqy[es][4][i];
		    qy6 += Pnc*s_cubqy[es][5][i];
		    
		  }
	      //
	      const iint base = n + element*p_Nfields*p_Np;
	      const iint id1 = base + 0*p_Np;
	      const iint id2 = base + 1*p_Np;
	      const iint id3 = base + 2*p_Np;
	      const iint id4 = base + 3*p_Np;
	      const iint id5 = base + 4*p_Np;
	      const iint id6 = base + 5*p_Np;
	      
	      // PML UPDATES
	      qZx[id1] = qx1;
	      qZx[id2] = qx2;
	      qZx[id3] = qx3;
	      qZx[id4] = qx4;
	      qZx[id5] = qx5;
	      qZx[id6] = qx6; 
	      //
	      // PML UPDATES
	      qZy[id1] = qy1;
	      qZy[id2] = qy2;
	      qZy[id3] = qy3;
	      qZy[id4] = qy4;
	      qZy[id5] = qy5;
	      qZy[id6] = qy6; 
	      //
	      dfloat4 temp;
	      
	      temp.x =  q1;
	      temp.y =  q2;
	      temp.z =  q3;
	      temp.w =  q4;
	      
	      qZ[2*(n + element*p_Np)] = temp;
	      
	      temp.x =  q5;
	      temp.y =  q6;
	      temp.z =  0.0;
	      temp.w =  0.0;
	      
	      qZ[2*(n + element*p_Np) +1] = temp; 
	      
	    }
	  }
	}
      }
  //  }
  }
}

