dfloat GET_MAX3(const dfloat x1, const dfloat x2, const dfloat x3){

dfloat xmax = 0.; 
         xmax = x1>x2 ? x1:x2; 
         xmax = xmax > x3 ? xmax:x3;

         return(xmax); 
}




kernel void boltzmannLsimexImplicitIteration2D(const iint Nelements,
			              const iint * restrict elementIds,
			              const dfloat dt,	
		                const dfloat akk,
	                  const dfloat  * restrict cubInterpT,
	                  const dfloat  * restrict cubProjectT,
	                  const dfloat4 * restrict qex,
	                        dfloat4 * restrict qim){
  for(iint e=0;e<Nelements;++e;outer0)
  {
    for(iint n=0;n<p_Np;++n;inner0)
    {
      const iint element = elementIds[e];
      const iint id0     = 2*(element*p_Np + n);
      const iint id1     = id0 + 1;
            
      dfloat N4=0.0,  N5 = 0.0,  N6=0.0;

      // Read explicit part 
      dfloat4 qexa = qex[id0];
      dfloat4 qexb = qex[id1];
      
      // Read implicit part
      dfloat4 qima = qim[id0];
      dfloat4 qimb = qim[id1];      
      
      //
      dfloat qex1 = qexa.x;
      dfloat qex2 = qexa.y;
      dfloat qex3 = qexa.z;
      dfloat qex4 = qexa.w;
      dfloat qex5 = qexb.x;
      dfloat qex6 = qexb.y;       
      
      // First iteration, Qim = Qex ; 
      dfloat qim1 = qex1;
      dfloat qim2 = qex2;
      dfloat qim3 = qex3;
      dfloat qim4 = qex4;
      dfloat qim5 = qex5;
      dfloat qim6 = qex6; 
      //         
     if(akk>0)
     {
     dfloat err = 0.0;  
     dfloat coeff  = akk * dt * p_tauInv;

      for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
      {
         //
         N4 = -coeff*( qim4 -            ( qim2*qim3/qim1 ) );
         N5 = -coeff*( qim5 - p_invsqrt2*( qim2*qim2/qim1 ) );
         N6 = -coeff*( qim6 - p_invsqrt2*( qim3*qim3/qim1 ) );

         //
        dfloat z1 =  qex1 - qim1 ;
        dfloat z2 =  qex2 - qim2 ;
        dfloat z3 =  qex3 - qim3 ;
        dfloat z4 =  qex4 - qim4 +  N4 ;
        dfloat z5 =  qex5 - qim5 +  N5 ;
        dfloat z6 =  qex6 - qim6 +  N6 ;
        
        //
        dfloat qim4o = qim4;
        dfloat qim5o = qim5;
        dfloat qim6o = qim6;
        //
        dfloat cc     = coeff;
        dfloat icc    = 1.0/cc; 

        //
         //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
        qim4 = qim4o  + z4/(cc+1.0)  
                      + z2*qim3/(qim1*(1.0+icc)) 
                      + z3*qim2/(qim1*(1.0+icc))
                      - z1*qim2*qim3/(qim1*qim1*(1.0+icc)); 

        qim5 = qim5o  +  z5/(cc+1)
                      +  p_sqrt2 * ( z2*qim2/(qim1*(1.0 + icc)))
                      -  p_sqrt2 * ( z1*(qim2*qim2)/(2.0 *(qim1*qim1)*(1.0+icc)));

        qim6 = qim6o +  z6/(cc+1.0)
                     +  p_sqrt2* ( z3*qim3/(qim1*(1.0+icc)))
                     -  p_sqrt2* ( z1*(qim3*qim3)/(2.0*(qim1*qim1)*(1.0+icc)));

        // Compute errors for q4 q5 a6
         dfloat err4 = fabs(qim4-qim4o);
         dfloat err5 = fabs(qim5-qim5o);
         dfloat err6 = fabs(qim6-qim6o);

         err = GET_MAX3(err4,err5,err6);     
         
        
         if(err<p_LSIMEX_TOL) break;

      }
    }
    
     // do not update q1 ,q2 ,q3 
    qim[id0].x =  qim1 ;
    qim[id0].y =  qim2 ;
    qim[id0].z =  qim3 ;  
    qim[id0].w =  qim4 ;
    //
    qim[id1].x =  qim5 ;
    qim[id1].y =  qim6 ;  

    }
  }
}






kernel void boltzmannLsimexSplitPmlImplicitIteration2D(const iint Nelements,
                    const iint * restrict elementIds,
                    const dfloat dt,  
                    const dfloat akk,
                    const dfloat ramp,
                    const dfloat * restrict cubInterpT,
                    const dfloat * restrict cubProjectT,
                    const dfloat * restrict qYx,
                    const dfloat * restrict qYy,
                    const dfloat * restrict qYnt,
                          dfloat * restrict qZx,
                          dfloat * restrict qZy,
                          dfloat * restrict qZnt){
  for(iint e=0;e<Nelements;++e;outer0)
  {
    for(iint n=0;n<p_Np;++n;inner0)
    {
      const iint element = elementIds[e];
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;
      
      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      //
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 
   
      //
      // Initialize
      dfloat qxi1 = qxe1;
      dfloat qxi2 = qxe2;
      dfloat qxi3 = qxe3;
      dfloat qxi4 = qxe4;
      dfloat qxi5 = qxe5;
      dfloat qxi6 = qxe6; 
      //
      dfloat qyi1 = qye1;
      dfloat qyi2 = qye2;
      dfloat qyi3 = qye3;
      dfloat qyi4 = qye4;
      dfloat qyi5 = qye5;
      dfloat qyi6 = qye6; 
      //
      dfloat nti1 = nte1;
      dfloat nti2 = nte2;
      dfloat nti3 = nte3;
      dfloat nti4 = nte4;
      dfloat nti5 = nte5;
      dfloat nti6 = nte6; 
      //
     if(akk>0)
     {
     dfloat err = 0.0;  
     dfloat cc  = akk * dt * p_tauInv;
     dfloat N4=0.,N5=0.,N6=0.;  

      for(iint iter=0; iter<p_LSIMEX_MAXITER; iter++)
      {

        dfloat q1 =  p_q1bar                 + qxi1 + qyi1;
        dfloat q2 =  ramp*p_q2bar            + qxi2 + qyi2;
        dfloat q3 =  ramp*p_q3bar            + qxi3 + qyi3;
        dfloat q4 =  ramp*ramp*p_q4bar       + qxi4 + qyi4;
        dfloat q5 =  ramp*ramp*p_q5bar       + qxi5 + qyi5;
        dfloat q6 =  ramp*ramp*p_q6bar       + qxi6 + qyi6;
         
         //
        N4 = -cc*( q4 -            ( q2*q3/q1 ) );
        N5 = -cc*( q5 - p_invsqrt2*( q2*q2/q1 ) );
        N6 = -cc*( q6 - p_invsqrt2*( q3*q3/q1 ) );

         //
        dfloat zx1 =  qxe1 - qxi1 ;
        dfloat zx2 =  qxe2 - qxi2 ;
        dfloat zx3 =  qxe3 - qxi3 ;
        dfloat zx4 =  qxe4 - qxi4 +  0.5*N4 ;
        dfloat zx5 =  qxe5 - qxi5 +  0.5*N5 ;
        dfloat zx6 =  qxe6 - qxi6 +  0.5*N6 ;
        //
        dfloat zy1 =  qye1 - qyi1 ;
        dfloat zy2 =  qye2 - qyi2 ;
        dfloat zy3 =  qye3 - qyi3 ;
        dfloat zy4 =  qye4 - qyi4 +  0.5*N4 ;
        dfloat zy5 =  qye5 - qyi5 +  0.5*N5 ;
        dfloat zy6 =  qye6 - qyi6 +  0.5*N6 ;
        //
        dfloat znt1 =  nte1 - nti1 ;
        dfloat znt2 =  nte2 - nti2 ;
        dfloat znt3 =  nte3 - nti3 ;
        dfloat znt4 =  nte4 - nti4 +  N4 ;
        dfloat znt5 =  nte5 - nti5 +  N5 ;
        dfloat znt6 =  nte6 - nti6 +  N6 ;


        //
        dfloat qxi4o = qxi4;
        dfloat qxi5o = qxi5;
        dfloat qxi6o = qxi6;
        //
        dfloat qyi4o = qyi4;
        dfloat qyi5o = qyi5;
        dfloat qyi6o = qyi6;
        //
        dfloat nti4o = nti4;
        dfloat nti5o = nti5;
        dfloat nti6o = nti6;


        //
        
        dfloat icc    = 1.0/cc; 
        dfloat cch    = 0.5*cc; 
        dfloat icch   = 1./cch; 

        //
         //Update Qim = Qim + (I-akk*dt*del(N)/del(Qim) )^-1 * ( Qex-Qim + N(Qim) )
        qxi4  +=        zx4/(cch+1.0)  
                      + zx2*q3/(q1*(1.0+icch)) 
                      + zx3*q2/(q1*(1.0+icch))
                      - zx1*q2*q3/(q1*q1*(1.0+icch)); 

        qxi5  +=         zx5/(cch+1.)
                      +  p_sqrt2 * ( zx2*q2/(q1*(1.0 + icch)))
                      -  p_sqrt2 * ( zx1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

        qxi6 +=         zx6/(cch+1.0)
                     +  p_sqrt2* ( zx3*q3/(q1*(1.0+icch)))
                     -  p_sqrt2* ( zx1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));

        //  
        qyi4  +=        zy4/(cch+1.0)  
                      + zy2*q3/(q1*(1.0+icch)) 
                      + zy3*q2/(q1*(1.0+icch))
                      - zy1*q2*q3/(q1*q1*(1.0+icch)); 

        qyi5  +=         zy5/(cch+1.)
                      +  p_sqrt2 * ( zy2*q2/(q1*(1.0 + icch)))
                      -  p_sqrt2 * ( zy1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icch)));

        qyi6 +=         zy6/(cch+1.0)
                     +  p_sqrt2* ( zy3*q3/(q1*(1.0+icch)))
                     -  p_sqrt2* ( zy1*(q3*q3)/(2.0*(q1*q1)*(1.0+icch)));   

         //  
        nti4  +=        znt4/(cc+1.0)  
                      + znt2*q3/(q1*(1.0+icc)) 
                      + znt3*q2/(q1*(1.0+icc))
                      - znt1*q2*q3/(q1*q1*(1.0+icc)); 

        nti5  +=         znt5/(cc+1.)
                      +  p_sqrt2 * ( znt2*q2/(q1*(1.0 + icc)))
                      -  p_sqrt2 * ( znt1*(q2*q2)/(2.0 *(q1*q1)*(1.0+icc)));

        nti6 +=         znt6/(cc+1.0)
                     +  p_sqrt2* ( znt3*q3/(q1*(1.0+icc)))
                     -  p_sqrt2* ( znt1*(q3*q3)/(2.0*(q1*q1)*(1.0+icc)));                           

        // Compute errors for q4 q5 a6
         dfloat ex4 = fabs(qxi4-qxi4o);
         dfloat ex5 = fabs(qxi5-qxi5o);
         dfloat ex6 = fabs(qxi6-qxi6o);
         //
         dfloat ey4 = fabs(qyi4-qyi4o);
         dfloat ey5 = fabs(qyi5-qyi5o);
         dfloat ey6 = fabs(qyi6-qyi6o);

         dfloat ent4 = fabs(nti4-nti4o);
         dfloat ent5 = fabs(nti5-nti5o);
         dfloat ent6 = fabs(nti6-nti6o);


         dfloat ex  = GET_MAX3(ex4,ex5,ex6);  
         dfloat ey  = GET_MAX3(ey4,ey5,ey6);   
         dfloat ent = GET_MAX3(ent4,ent5,ent6);   

         err =  GET_MAX3(ex,ey,ent);   
         
        
         if(err<p_LSIMEX_TOL) break;

      }
    }
    
   // PML UPDATES
      qZx[id1] = qxi1;
      qZx[id2] = qxi2;
      qZx[id3] = qxi3;
      qZx[id4] = qxi4;
      qZx[id5] = qxi5;
      qZx[id6] = qxi6; 
      //
       // PML UPDATES
      qZy[id1] = qyi1;
      qZy[id2] = qyi2;
      qZy[id3] = qyi3;
      qZy[id4] = qyi4;
      qZy[id5] = qyi5;
      qZy[id6] = qyi6; 
      //
       // PML UPDATES
      qZnt[id1] = nti1;
      qZnt[id2] = nti2;
      qZnt[id3] = nti3;
      qZnt[id4] = nti4;
      qZnt[id5] = nti5;
      qZnt[id6] = nti6; 

    }
  }
}







// kernel void boltzmannNonPmlImexImplicitIterationCub2D(const iint Nelements,
// 					     const iint * restrict elementIds,
// 					     const dfloat dt,	
// 				         const dfloat akk,
// 					     const dfloat * restrict cubInterpT,
// 					     const dfloat * restrict cubProjectT,
// 					     const dfloat4 * restrict qex,
// 					           dfloat4 * restrict qim){
  
//   for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

//     // shared memory for q at nodes
//     // shared dfloat s_q[p_NblockV][6][p_Np];
//     shared dfloat s_im[p_NblockV][6][p_Np];
//     shared dfloat s_err[p_NblockV][p_Np]

//     // sub-group of p_Np cubature node interpolants of N4,N5,N6
//     shared dfloat s_cubN4[p_NblockV][p_cubNp];
//     shared dfloat s_cubN5[p_NblockV][p_cubNp];
//     shared dfloat s_cubN6[p_NblockV][p_cubNp];

//     exclusive iint   element;
//     exclusive dfloat error; 
//     //
//     exclusive dfloat qex1 =0.0, qex2 = 0.0, qex3=0.0 ;
//     exclusive dfloat qex4 =0.0, qex5 = 0.0, qex6=0.0 ;  
//     //
//     exclusive dfloat qim1 =0.0, qim2 = 0.0, qim3=0.0 ;
//     exclusive dfloat qim4 =0.0, qim5 = 0.0, qim6=0.0 ;  


//     // prefetch q to shared
//     for(iint es=0;es<p_NblockV;++es;inner1){
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){    
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  element = elementIds[e];
// 	  if(n<p_Np){
// 	    const iint id = element*p_Np+n;
// 	    dfloat4 qexa  = qex[2*id];
// 	    dfloat4 qexb  = qex[2*id+1];
// 	    //
// 	    dfloat4  qima  = qim[2*id]  ;
// 	    dfloat4  qimb  = qim[2*id+1];

//          // hold explicit part at register, constant in iterations    
// 	    qex1  = qexa.x;
// 	    qex2  = qexa.y;
// 	    qex3  = qexa.z;
// 	    qex4  = qexa.w;   
// 	    qex5  = qexb.x;
// 	    qex6  = qexb.y;	 
//         //
//         qim1  = qima.x;
// 	    qim2  = qima.y;
// 	    qim3  = qima.z;
// 	    qim4  = qima.w;   
// 	    qim5  = qimb.x;
// 	    qim6  = qimb.y;	 
// 	    //
//         s_qim[es][0][n] = qim1;
// 	    s_qim[es][1][n] = qim2;
// 	    s_qim[es][2][n] = qim3;
// 	    s_qim[es][3][n] = qim4;   
// 	    s_qim[es][4][n] = qim5;
// 	    s_qim[es][5][n] = qim6;
       
// 	  }
// 	}

//       }
//     }
    
//     // make sure all node data is loaded into shared
//     barrier(localMemFence);

// for (iint iter=0;iter<MAX_ITER;iter++)
// {
//     // interpolate q to cubature
//     for(iint es=0;es<p_NblockV;++es;inner1){
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_cubNp){
// 	    dfloat cubq1 = 0.0f, cubq2 = 0.0f, cubq3 = 0.0f;
// 	    dfloat cubq4 = 0.0f, cubq5 = 0.0f, cubq6 = 0.0f;
	    
// 	    occaUnroll(p_Np)
// 	    for(iint m=0;m<p_Np;++m){
// 	      const dfloat Icn  = cubInterpT[m*p_cubNp+n];
// 	      cubq1 += Icn*s_qim[es][0][m];
// 	      cubq2 += Icn*s_qim[es][1][m];
// 	      cubq3 += Icn*s_qim[es][2][m];
// 	      cubq4 += Icn*s_qim[es][3][m];
// 	      cubq5 += Icn*s_qim[es][4][m];
// 	      cubq6 += Icn*s_qim[es][5][m];
// 	    }
	    
// 	    dfloat coeff  = -akk * dt * p_tauInv;
// 	    dfloat icubq1 = 1.0 / cubq1;
// 	    // BGK relaxation approximation to the Boltzmann collision operator
// 	    s_cubN4[es][n] = coeff * (cubq4-(           cubq2*cubq3*icubq1));
// 	    s_cubN5[es][n] = coeff * (cubq5-(p_invsqrt2*cubq2*cubq2*icubq1));
// 	    s_cubN6[es][n] = coeff * (cubq6-(p_invsqrt2*cubq3*cubq3*icubq1));
// 	  }
// 	}
//       }
//     }

//     // make sure all cubature node data is loaded into shared
//     barrier(localMemFence);
    
//     // partial projection to nodes from cubature-sub-group
//     for(iint es=0;es<p_NblockV;++es;inner1){
//       for(iint n=0;n<p_maxNodesVolume;++n;inner0){     
	
// 	iint e = eo+es; // element in block
// 	if(e<Nelements){
// 	  if(n<p_Np){
	    	    
// 	    // use temporaries for part sums for N4,N5,N6 because of exclusives
// 	    dfloat N4 = 0.f, N5 = 0.f, N6 = 0.f;

// 	    occaUnroll(p_cubNp)
// 	    for(iint i=0;i<p_cubNp;++i){
// 	      const dfloat Pnc  = cubProjectT[i*p_Np+n];
// 	      N4 += Pnc*s_cubN4[es][i];
// 	      N5 += Pnc*s_cubN5[es][i];
// 	      N6 += Pnc*s_cubN6[es][i];
// 	    }

// 	    iint id0      = 2*(element*p_Np + n);
// 	    iint id1      = id0 + 1; 
	    
// 	    //
//         dfloat cc     = akk * dt * p_tauInv;
//         dfloat icc    = 1.0/cc;  
//         //
//         dfloat z1 =  qex1 - qim1 ;
//         dfloat z2 =  qex2 - qim2 ;
//         dfloat z3 =  qex3 - qim3 ;
//         dfloat z4 =  qex4 - qim4 +  N4 ;
//         dfloat z5 =  qex5 - qim5 +  N5 ;
//         dfloat z6 =  qex6 - qim6 +  N6 ;
        
//         //Store old values
//         dfloat qim1o = qim1;
//         dfloat qim2o = qim2;
//         dfloat qim1o = qim3;
//         dfloat qim1o = qim4;
//         dfloat qim1o = qim5;
//         dfloat qim1o = qim6;
   
//         //Update
//         qim1 = z1     + qim1o;
//         qim2 = z2     + qim2o;
//         qim3 = z3     + qim3o;
//         qim4 = qim4o  + z4/(cc+1.0)  
//                       + z2*qim3o/(qim1o*(1.0+icc)) 
//                       + z3*qim2o/(qim1o*(1.0+icc))
//                       - z1*qim2o*q3/(qim1o*qim1o*(1.0+icc)); 

//         qim5 = qim5o  +  z5/(cc+1)
//                       +  p_sqrt2 * ( z2*qim2o/(qim1o*(1.0 + icc)))
//                       -  p_sqrt2 * ( z1*(qim2o*qim2o)/(2.0 *(qim1o*qim1o)*(1.0+icc)));

//         qim6 = qim6o +  z6/(cc+1.0)... 
//                     +  p_sqrt2* ( z3*qim3o/(qim1o*(1.0+icc)))...
//                     -  p_sqrt2* ( z1*(qim3o*qim3o)/(2.0*(qim1o*qim1o)*(1.0+icc)));

//         //
//         s_qim[es][0][n] = qim1;
// 	    s_qim[es][1][n] = qim2;
// 	    s_qim[es][2][n] = qim3;
// 	    s_qim[es][3][n] = qim4;   
// 	    s_qim[es][4][n] = qim5;
// 	    s_qim[es][5][n] = qim6;

         
//                      }
//                  }
//              }
//          }



//         if (err<TOL) break;
// }
  
// }


//  //  for
//  //  	for
//  //        // Update
//  //        qim[id0].x = q1n;
//  //        qim[id0].y = q2n;
//  //        qim[id0].z = q3n;
//  //        qim[id0].w = q4n;
//  //        qim[id1].x = q5n;
//  //        qim[id1].y = q6n;

// 	//   }
// 	// }
      
