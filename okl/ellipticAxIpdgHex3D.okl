// increments gradients of pressure with pseudo-gradients at faces and 
// increments rhs with pseudo-gradient/penalty terms at faces (need to double check scaling with tau)

// sgeo stores dfloat4s with nx,ny,nz,(sJ/J)*(w1*w2*w3/(ws1*ws2))

// nx,ny,nz,sJ,invJ - need WsJ

/* assumes zero Neumann - nasty hack for h */
#define surfaceTerms(sk, i, j, k)					\
  {									\
    const iint  idM = vmapM[sk];					\
    const iint  idP = vmapP[sk];					\
    									\
    const dfloat nx  = sgeo[sk*p_Nsgeo+p_NXID];				\
    const dfloat ny  = sgeo[sk*p_Nsgeo+p_NYID];				\
    const dfloat nz  = sgeo[sk*p_Nsgeo+p_NZID];				\
    const dfloat WsJ = sgeo[sk*p_Nsgeo+p_WSJID];			\
    const dfloat hinv= sgeo[sk*p_Nsgeo+p_IHID];				\
    									\
    const dfloat4 gradqM = gradq[idM];					\
    const dfloat4 gradqP = gradq[idP];					\
									\
    const dfloat sc = (idP==idM) ? -1.f:1.f;				\
									\
    const dfloat dq = gradqP.w - gradqM.w;				\
    									\
    s_dqdx[k][j][i] += 0.5f*WsJ*nx*dq;					\
    s_dqdy[k][j][i] += 0.5f*WsJ*ny*dq;					\
    s_dqdz[k][j][i] += 0.5f*WsJ*nz*dq;					\
									\
    s_rhsq[k][j][i] -= 0.5f*WsJ*(nx*(sc*gradqP.x+gradqM.x) +		\
				 ny*(sc*gradqP.y+gradqM.y) +		\
				 nz*(sc*gradqP.z+gradqM.z) +		\
				 tau*hinv*dq);				\
  }

// (grad phi, grad q) + ([phi], n.{grad q}) + ({grad phi}, n[u]) + (tau[phi],[u])

kernel void ellipticAxIpdgHex3D(const int Nelements,
				const iint * restrict vmapM,
				const iint * restrict vmapP,
				const dfloat lambda,
				const dfloat tau,
				const dfloat * restrict vgeo,
				const dfloat * restrict sgeo,
				const dfloat * restrict const D,
				const dfloat4 * restrict gradq,
				dfloat  * restrict Aq){
  
#if 0
  // assume the following are precomputed:
  // p, px, py at SEM nodes
  // +/- traces of p, px, py at SEM surface nodes

  0<=i,j,k,m<=N AND 0<=e<Nelements

    (phix, px)_e
    + (phiy, py)_e 
    + (phix, nx*(p+ - p-)/2)_de
    + (phiy, ny*(p+ - p-)/2)_de
    - (phi-, nx*(px+ + px-)/2)_de
    - (phi-, ny*(py+ + py-)/2)_de
    - (phi-, tau*(p+ - p-)/2)_de
    
    // here w is one component of the product TP quadrature weights
    (phir, rx*(px + Fsc*nx*dp) + ry*(py + Fsc*ny*dp) + rz*(pz + Fsc*nz*dp)) )_e
+   (phir, sx*(px + Fsc*nx*dp) + sy*(py + Fsc*ny*dp) + sz*(pz + Fsc*nz*dp)) )_e
+   (phir, tx*(px + Fsc*nx*dp) + ty*(py + Fsc*ny*dp) + tz*(pz + Fsc*nz*dp)) )_e
    (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

    px => px + Fsc*nx*dp (i.e. add pseudo-gradient at end points 
    py => py + Fsc*ny*dp
    pz => pz + Fsc*nz*dp
    Fsc = delta*(Js/J)*(1/w)
    dp = (p+ - p-)/2;

    // simplify
    (phir, rx*px+ ry*py + rz*pz) )_e
+   (phir, sx*px+ sy*py + sz*pz) )_e
+   (phir, tx*px+ ty*py + tz*pz) )_e
+   (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

#endif

  for(iint e=0;e<Nelements;++e;outer0){
    
    volatile shared dfloat s_dqdx[p_Nq][p_Nq][p_Nq];
    volatile shared dfloat s_dqdy[p_Nq][p_Nq][p_Nq];
    volatile shared dfloat s_dqdz[p_Nq][p_Nq][p_Nq];
    volatile shared dfloat s_rhsq[p_Nq][p_Nq][p_Nq];
    shared dfloat s_D[p_Nq][p_Nq];
    
    // loop over slabs
    for(iint k=0;k<p_Nq;++k){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){

	  // assume that this stores (p, px, py, pz) as dfloat4
	  const dfloat4 gradqn = gradq[e*p_Np+k*p_Nq*p_Nq+j*p_Nq+i];
	  
	  const iint gid = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np*p_Nvgeo;	 

	  const dfloat JW = vgeo[gid + p_JWID*p_Np];

	  s_dqdx[k][j][i] = JW*gradqn.x;
	  s_dqdy[k][j][i] = JW*gradqn.y;
	  s_dqdz[k][j][i] = JW*gradqn.z;
	  s_rhsq[k][j][i] = JW*lambda*gradqn.w;
	  
	  if(k==0)
	    s_D[j][i] = D[j*p_Nq+i];
	}
      }
    }
    
    barrier(localMemFence);

    // face 0 & 5
    for(iint j=0;j<p_Nq;++j;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	iint sk0 = e*p_Nfp*p_Nfaces + 0*p_Nfp + j*p_Nq + i ;
	iint sk5 = e*p_Nfp*p_Nfaces + 5*p_Nfp + j*p_Nq + i ;		

	surfaceTerms(sk0,i,j,     0);
	surfaceTerms(sk5,i,j,p_Nq-1); 
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(iint k=0;k<p_Nq;++k;inner1){
      for(iint i=0;i<p_Nq;++i;inner0){
	iint sk1 = e*p_Nfp*p_Nfaces + 1*p_Nfp + k*p_Nq + i ;
	iint sk3 = e*p_Nfp*p_Nfaces + 3*p_Nfp + k*p_Nq + i ;

	surfaceTerms(sk1,i,     0,k);
	surfaceTerms(sk3,i,p_Nq-1,k); 
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(iint k=0;k<p_Nq;++k;inner1){
      for(iint j=0;j<p_Nq;++j;inner0){

	iint sk2 = e*p_Nfp*p_Nfaces + 2*p_Nfp + k*p_Nq + j ;
	iint sk4 = e*p_Nfp*p_Nfaces + 4*p_Nfp + k*p_Nq + j ;
	
	surfaceTerms(sk2,p_Nq-1,j,k);
	surfaceTerms(sk4,     0,j,k); 
      }
    }

    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){

	  const iint gid = i + j*p_Nq + k*p_Nq*p_Nq + e*p_Np*p_Nvgeo;	 

	  const dfloat drdx = vgeo[gid + p_RXID*p_Np];
	  const dfloat drdy = vgeo[gid + p_RYID*p_Np];
	  const dfloat drdz = vgeo[gid + p_RZID*p_Np];
	  
	  const dfloat dsdx = vgeo[gid + p_SXID*p_Np];
	  const dfloat dsdy = vgeo[gid + p_SYID*p_Np];
	  const dfloat dsdz = vgeo[gid + p_SZID*p_Np];

	  const dfloat dtdx = vgeo[gid + p_TXID*p_Np];
	  const dfloat dtdy = vgeo[gid + p_TYID*p_Np];
	  const dfloat dtdz = vgeo[gid + p_TZID*p_Np];

	  const dfloat JW   = vgeo[gid + p_JWID*p_Np];
	  
	  const dfloat dqdx = s_dqdx[k][j][i];
	  const dfloat dqdy = s_dqdy[k][j][i];
	  const dfloat dqdz = s_dqdz[k][j][i];
	  
	  s_dqdx[k][j][i] = (drdx*dqdx + drdy*dqdy + drdz*dqdz);
	  s_dqdy[k][j][i] = (dsdx*dqdx + dsdy*dqdy + dsdz*dqdz);
	  s_dqdz[k][j][i] = (dtdx*dqdx + dtdy*dqdy + dtdz*dqdz);
	}
      }
    }

    barrier(localMemFence);

    for(iint k=0;k<p_Nq;++k){
      for(iint j=0;j<p_Nq;++j;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){
	  dfloat dr = 0, ds = 0, dt = 0;

	  for(iint n=0;n<p_Nq;++n){
	    dr += s_D[n][i]*s_dqdx[k][j][n];
	    ds += s_D[n][j]*s_dqdy[k][n][i];
	    dt += s_D[n][k]*s_dqdz[n][j][i];
	  }
	  
	  iint id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	  Aq[id] = s_rhsq[k][j][i]  + dr + ds + dt;
	}
      }
    }
  }
}
