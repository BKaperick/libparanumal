// increments gradients of pressure with pseudo-gradients at faces and 
// increments rhs with pseudo-gradient/penalty terms at faces (need to double check scaling with tau)

// sgeo stores datafloat4s with nx,ny,nz,(sJ/J)*(w1*w2*w3/(ws1*ws2))

// nx,ny,nz,sJ,invJ - need sWJ

#define surfaceTerms(sk,i, j, k)					\
									\
  const iint  idM = vmapM[sk];						\
  constiint   idP = vmapP[sk];						\
									\
  const dfloat nx = sgeo[sk*p_Nsgeo+0];					\
  const dfloat ny = sgeo[sk*p_Nsgeo+1];					\
  const dfloat nz = sgeo[sk*p_Nsgeo+2];					\
  const dfloat sJ = sgeo[sk*p_Nsgeo++3];				\
  const dfloat invJ = sgeo[sk*p_Nsgeo+4];				\
  const dfloat sWJJ = sgeo[sk*p_Nsgeo+5];				\
									\
  const datafloat4 gradqM = gradq[idM];					\
  const datafloat4 graqqP = gradq[idP];					\
  									\
  datafloat dq = gradqP.w - gradqM.w;					\
  									\
  s_dqdx[k][j][i] += 0.5f*sWJ*nx*dq;					\
  s_dqdy[k][j][i] += 0.5f*sWJ*ny*dq;					\
  s_dqdz[k][j][i] += 0.5f*sWJ*nz*dq;					\
									\
  s_rhs[k][j][i] += 0.5f*sWJ*( nx*(gradqP.x+gradqM.x) +			\
			       ny*(gradqP.y+gradqM.y) +			\
			       nz*(gradqP.z+gradqM.z) -			\
			       tau*dq);				       



kernel void ellipticAxIpdgHex3D(const int Nelements,
				const iint * restrict vmapM,
				const iint * restrict vmapP,
				const datafloat tau,
				const datafloat * restrict vgeo,
				const datafloat * restrict sgeo,
				const datafloat * restrict const D,
				const datafloat4 * restrict gradq,
				datafloat  * restrict Aq){
  
#if 0
  // assume the following are precomputed:
  // p, px, py at SEM nodes
  // +/- traces of p, px, py at SEM surface nodes

  0<=i,j,k,m<=N AND 0<=e<Nelements

    (phix, px)_e
    + (phiy, py)_e 
    + (phix, nx*(p+ - p-)/2)_de
    + (phiy, ny*(p+ - p-)/2)_de
    - (phi-, nx*(px+ + px-)/2)_de
    - (phi-, ny*(py+ + py-)/2)_de
    - (phi-, tau*(p+ - p-)/2)_de
    
    // here w is one component of the product TP quadrature weights
    (phir, rx*(px + Fsc*nx*dp) + ry*(py + Fsc*ny*dp) + rz*(pz + Fsc*nz*dp)) )_e
+   (phir, sx*(px + Fsc*nx*dp) + sy*(py + Fsc*ny*dp) + sz*(pz + Fsc*nz*dp)) )_e
+   (phir, tx*(px + Fsc*nx*dp) + ty*(py + Fsc*ny*dp) + tz*(pz + Fsc*nz*dp)) )_e
    (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

    px => px + Fsc*nx*dp (i.e. add pseudo-gradient at end points 
    py => py + Fsc*ny*dp
    pz => pz + Fsc*nz*dp
    Fsc = delta*(Js/J)*(1/w)
    dp = (p+ - p-)/2;

    // simplify
    (phir, rx*px+ ry*py + rz*pz) )_e
+   (phir, sx*px+ sy*py + sz*pz) )_e
+   (phir, tx*px+ ty*py + tz*pz) )_e
+   (phi-, Fsc*(nx*(px+ + px-) + ny*(py+ + py-) + nz*(pz+ + pz-) - tau*(p+ - p-))/2)_e

#endif

  for(int e=0;e<Nelements;++e;outer0){
    
    shared datafloat s_dqdx[p_Nq][p_Nq][p_Nq];
    shared datafloat s_dqdy[p_Nq][p_Nq][p_Nq];
    shared datafloat s_dqdz[p_Nq][p_Nq][p_Nq];
    shared datafloat s_rhs[p_Nq][p_Nq][p_Nq];
    
    // loop over slabs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  // assume that this stores (p, px, py, pz) as datafloat4
	  const datafloat4 qijk = q[e*p_Np+k*p_Nq*p_Nq+j*p_Nq+i];
	  s_dqdx[k][j][i] = qijk.x;
	  s_dqdy[k][j][i] = qijk.y;
	  s_dqdz[k][j][i] = qijk.z;
	  s_rhs[k][j][i] = 0.f;
	}
      }
    }

    barrier(localMemFence);
	  
    // loop over faces to add pseudo-gradient

    // face 0 & 5
    for(int j=0;j<p_Nq;++j;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
	int sk = e*p_Nfp*Nfaces + 0*p_Nfp + j*p_Nq + i ;
	surfaceTerms(sk,i,j,0);

		    
	sk = e*p_Nfp*Nfaces + 5*p_Nfp + j*p_Nq + i ;	
	surfaceTerms(sk,i,j,p_Nq-1); // need to be careful about layout of faces
      }
    }

    barrier(localMemFence);

    // face 1 & 3
    for(int k=0;k<p_Nq;++k;inner1){
      for(int i=0;i<p_Nq;++i;inner0){
	int sk = e*p_Nfp*Nfaces + 1*p_Nfp + k*p_Nq + i ;
	surfaceTerms(sk,i,0,k);

	sk = e*p_Nfp*Nfaces + 3*p_Nfp + k*p_Nq + i ;
	surfaceTerms(sk,i,p_Nq-1,k); 
      }
    }

    barrier(localMemFence);

    // face 2 & 4
    for(int k=0;k<p_Nq;++k;inner1){
      for(int j=0;j<p_Nq;++j;inner0){

	int sk = e*p_Nfp*Nfaces + 2*p_Nfp + k*p_Nq + j ;
	surfaceTerms(sk,0,j,k);

	sk = e*p_Nfp*Nfaces + 4*p_Nfp + k*p_Nq + j ;
	surfaceTerms(sk,p_Nq-1,j,k); 
      }
    }

    barrier(localMemFence);

    // prescale by geofacs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  // does need the nasty geofacs
	  const int gid = i + j*p_Nq + k*p_Nfp + e*p_Np*p_Nvgeo;
	  
	  const dfloat drdx = vgeo[gid + RXID*p_Np];
	  const dfloat drdy = vgeo[gid + RYID*p_Np];
	  const dfloat drdz = vgeo[gid + RZID*p_Np];
	  
	  const dfloat dsdx = vgeo[gid + SXID*p_Np];
	  const dfloat dsdy = vgeo[gid + SYID*p_Np];
	  const dfloat dsdz = vgeo[gid + SZID*p_Np];

	  const dfloat dtdx = vgeo[gid + TXID*p_Np];
	  const dfloat dtdy = vgeo[gid + TYID*p_Np];
	  const dfloat dtdz = vgeo[gid + TZID*p_Np];

	  // chain rule
	  const datafloat tmpx = s_dqdx[k][j][i];
	  const datafloat tmpy = s_dqdy[k][j][i];
	  const datafloat tmpz = s_dqdz[k][j][i];
	  s_dqdx[k][j][i] = drdx*tmpx + drdy*tmpy + drdz*tmpz;
	  s_dqdy[k][j][i] = dsdx*tmpx + dsdy*tmpy + dsdz*tmpz;
	  s_dqdz[k][j][i] = dtdy*tmpx + dtdy*tmpy + dtdz*tmpz;
	}
      }
    }

    barrier(localMemFence);

    // loop over slabs
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  datafloat dr = 0, ds = 0, dt = 0;
	  for(int n=0;n<p_Nq;++n){
	    dr += s_D[i][n]*s_dqdx[k][j][n];
	    ds += s_D[j][n]*s_dqdy[k][n][i];
	    dt += s_D[k][n]*s_dqdz[n][j][i];
	  }
	  s_rhs[k][j][i] += dr + ds + dt;
	}
      }
    }
    
    // output result
    for(int k=0;k<p_Nq;++k){
      for(int j=0;j<p_Nq;++j;inner1){
	for(int i=0;i<p_Nq;++i;inner0){
	  int id = e*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
	  Aq[id] = s_rhs[k][j][i];
	}
      }
    }
  }
}
