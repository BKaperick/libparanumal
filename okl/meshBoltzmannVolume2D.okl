#define RXID 0  
#define RYID 1  
#define SXID 2  
#define SYID 3

kernel void meshBoltzmannVolume2D(const int Nelements,
				  const dfloat * restrict vgeo,
				  const dfloat * restrict DrT,
				  const dfloat * restrict DsT,
				  const dfloat4 * restrict q,
				  dfloat4 * restrict rhsq){
  
  for(int eo=0;eo<Nelements;eo+=p_NblockV;outer0){  // for all elements

    shared dfloat s_q[p_NblockV][p_Nfields][p_Np];

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element

	int e = eo+es; // element in block
	if(e<Nelements){
	  const int id = 2*e*p_Np+n;
	  dfloat4 qn = q[id];

	  int off = 4*(n%2);
	  int node = n/2;
	  
	  s_q[es][0+off][node] = qn.x;
	  s_q[es][1+off][node] = qn.y;
	  s_q[es][2+off][node] = qn.z;
	  s_q[es][3+off][node] = qn.w;

	  off = 4*((n+p_Np)%2);
	  node = (n+p_Np)/2;
	  
	  qn = q[id+p_Np];
	  s_q[es][0+off][node] = qn.x;
	  s_q[es][1+off][node] = qn.y;
	  s_q[es][2+off][node] = qn.z;
	  s_q[es][3+off][node] = qn.w;
	}
      }
    }

    // make sure all node data is loaded into shared
    barrier(localMemFence);

    for(int es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(int n=0;n<p_Np;++n;inner0){     // for all nodes in this element
	
	int e = eo+es; // element in block
	if(e<Nelements){
	  
	  // prefetch geometric factors (constant on triangle)
	  const dfloat drdx = vgeo[e*p_Nvgeo + RXID];
	  const dfloat drdy = vgeo[e*p_Nvgeo + RYID];
	  const dfloat dsdx = vgeo[e*p_Nvgeo + SXID];
	  const dfloat dsdy = vgeo[e*p_Nvgeo + SYID];

	  // compute 'r' and 's' derivatives of (q_m) at node n
	  dfloat dq1dr = 0, dq2dr = 0, dq3dr = 0, dq4dr = 0, dq5dr = 0, dq6dr = 0;
	  dfloat dq1ds = 0, dq2ds = 0, dq3ds = 0, dq4ds = 0, dq5ds = 0, dq6ds = 0;

	  occaUnroll(p_Np)
	  for(int i=0;i<p_Np;++i){
	    const dfloat Drni = DrT[n+i*p_Np];
	    const dfloat Dsni = DsT[n+i*p_Np];
	    
	    // differentiate q components with respect to 'r' and 's'
	    dq1dr += Drni*s_q[es][0][i];
	    dq1ds += Dsni*s_q[es][0][i];
	    dq2dr += Drni*s_q[es][1][i];
	    dq2ds += Dsni*s_q[es][1][i];
	    dq3dr += Drni*s_q[es][2][i];
	    dq3ds += Dsni*s_q[es][2][i];
	    dq4dr += Drni*s_q[es][3][i];
	    dq4ds += Dsni*s_q[es][3][i];
	    dq5dr += Drni*s_q[es][4][i];
	    dq5ds += Dsni*s_q[es][4][i];
	    dq6dr += Drni*s_q[es][5][i];
	    dq6ds += Dsni*s_q[es][5][i];
	  }

	  
	  // chain rule
	  dfloat dq1dx = drdx*dq1dr + dsdx*dq1ds;
	  dfloat dq2dx = drdx*dq2dr + dsdx*dq2ds;
	  dfloat dq3dx = drdx*dq3dr + dsdx*dq3ds;
	  dfloat dq4dx = drdx*dq4dr + dsdx*dq4ds;
	  dfloat dq5dx = drdx*dq5dr + dsdx*dq5ds;
	  dfloat dq6dx = drdx*dq6dr + dsdx*dq6ds;
	  
	  dfloat dq1dy = drdy*dq1dr + dsdy*dq1ds;
	  dfloat dq2dy = drdy*dq2dr + dsdy*dq2ds;
	  dfloat dq3dy = drdy*dq3dr + dsdy*dq3ds;
	  dfloat dq4dy = drdy*dq4dr + dsdy*dq4ds;
	  dfloat dq5dy = drdy*dq5dr + dsdy*dq5ds;
	  dfloat dq6dy = drdy*dq6dr + dsdy*dq6ds;
	  
	  // indices for writing the RHS terms
	  int id = p_Nfields*(e*p_Np + n);
	  
	  // constant
	  dfloat sqrtRT = p_sqrtRT;
	  dfloat sqrt2 = occaSqrt(2.f);
	  dfloat invsqrt2 = 1.f/occaSqrt(2.f);
	  
	  // transport operator
	  dfloat rhsq1 = -sqrtRT*(dq2dx + dq3dy);
	  dfloat rhsq2 = -sqrtRT*(dq1dx + sqrt2*dq5dx + dq4dy);	
	  dfloat rhsq3 = -sqrtRT*(dq4dx + dq1dy + sqrt2*dq6dy);	
	  dfloat rhsq4 = -sqrtRT*(dq3dx + dq2dy);		
	  dfloat rhsq5 = -sqrtRT*sqrt2*dq2dx;			
	  dfloat rhsq6 = -sqrtRT*sqrt2*dq3dy;                   

	  // BGK relaxation approximation to the Boltzmann collision operator
	  rhsq4 -= p_tauInv*(s_q[es][3][n]- (s_q[es][1][n]*s_q[es][2][n]/s_q[es][0][n]));
	  rhsq5 -= p_tauInv*(s_q[es][4][n] - p_invsqrt2*(s_q[es][1][n]*s_q[es][1][n]/s_q[es][0][n]));
	  rhsq6 -= p_tauInv*(s_q[es][5][n] - p_invsqrt2*(s_q[es][2][n]*s_q[es][2][n]/s_q[es][0][n]));
	  
	  dfloat4 tmp;
	  tmp.x = rhsq1;
	  tmp.y = rhsq2;
	  tmp.z = rhsq3;
	  tmp.w = rhsq4;

	  rhsq[2*e*p_Np + 2*n] = tmp;

	  tmp.x = rhsq5;
	  tmp.y = rhsq6;
	  tmp.z = 0.f;
	  tmp.w = 0.f;

	  rhsq[2*e*p_Np + 2*n+1] = tmp;
	}
      }
    }
  }
}

