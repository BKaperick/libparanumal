
kernel void boltzmannLSERKUpdate2D(const iint Nelements,
				    const iint * restrict elementIds,
				    const dfloat dt,	
				    const dfloat rka,
				    const dfloat rkb,
				    const dfloat4 * restrict rhsq,
				          dfloat4 * restrict resq,
				          dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint base = 2*(n + element*p_Np);

      dfloat4 resqa = resq[base+0];
      dfloat4 resqb = resq[base+1];

      dfloat4 rhsqa = rhsq[base+0];
      dfloat4 rhsqb = rhsq[base+1];

      dfloat4 qa = q[base+0];
      dfloat4 qb = q[base+1];

      resqa = rka*resqa + dt*rhsqa;
      resqb = rka*resqb + dt*rhsqb;

      qa += rkb*resqa;
      qb += rkb*resqb;
      
      resq[base+0] = resqa;
      resq[base+1] = resqb;
      
      q[base+0] = qa;
      q[base+1] = qb;
    }
  }
}

// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABUpdateFirst2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt,  
            const dfloat4 * restrict rhsq,
                  dfloat4 * restrict rhsq2,
                  dfloat4 * restrict rhsq3,
                  dfloat4 * restrict q){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 rhsqa = rhsq[id0];
      dfloat4 rhsqb = rhsq[id1];

      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];

      dfloat c1 = -(p_expdt - 1.)/p_tauInv;
      
      //
      qa.x += dt*rhsqa.x;
      qa.y += dt*rhsqa.y;
      qa.z += dt*rhsqa.z;
      qa.w  = p_expdt*qa.w + c1*rhsqa.w; 

      qb.x  = p_expdt*qb.x + c1*rhsqb.x;
      qb.y  = p_expdt*qb.y + c1*rhsqb.y;

            
      q[id0] = qa;
      q[id1] = qb;
      //
      rhsq2[id0] = rhsqa;
      rhsq2[id1] = rhsqb;
      //
      rhsq3[id0] = rhsqa;
      rhsq3[id1] = rhsqb;

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABUpdateSecond2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt,  
            const dfloat4 * restrict rhsq,
                  dfloat4 * restrict rhsq2,
                  dfloat4 * restrict rhsq3,
                  dfloat4 * restrict q){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 rhsq1a = rhsq[id0];
      dfloat4 rhsq1b = rhsq[id1];
      //
      dfloat4 rhsq2a = rhsq2[id0];
      dfloat4 rhsq2b = rhsq2[id1];
      //
      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];
      
      //Computes only once
      dfloat c1 = (p_expdt + 2.*dt*p_tauInv - dt*p_tauInv*p_expdt - 1.)/(dt*p_tauInv*p_tauInv);
      dfloat c2 = -(p_expdt + dt*p_tauInv - 1.)/(dt*p_tauInv*p_tauInv);

//
      qa.x += 1.5*dt*rhsq1a.x - 0.5*dt*rhsq2a.x;
      qa.y += 1.5*dt*rhsq1a.y - 0.5*dt*rhsq2a.y;
      qa.z += 1.5*dt*rhsq1a.z - 0.5*dt*rhsq2a.z;
      qa.w = p_expdt*qa.w + c1*rhsq1a.w - c2*rhsq2a.w; 

      qb.x = p_expdt*qb.x + c1*rhsq1b.x - c2*rhsq2b.x; 
      qb.y = p_expdt*qb.y + c1*rhsq1b.y - c2*rhsq2b.y;

            
      q[id0] = qa;
      q[id1] = qb;
      //
      rhsq2[id0] = rhsq1a;
      rhsq2[id1] = rhsq1b;
      //
      rhsq3[id0] = rhsq2a;
      rhsq3[id1] = rhsq2b;

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt,  
            const dfloat4 * restrict rhsq,
                  dfloat4 * restrict rhsq2,
                  dfloat4 * restrict rhsq3,
                  dfloat4 * restrict q){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 rhsq1a = rhsq[id0];
      dfloat4 rhsq1b = rhsq[id1];
      //
      dfloat4 rhsq2a = rhsq2[id0];
      dfloat4 rhsq2b = rhsq2[id1];
      //
      dfloat4 rhsq3a = rhsq3[id0];
      dfloat4 rhsq3b = rhsq3[id1];
      //
      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];
      
//
      qa.x += p_ab1*rhsq1a.x + p_ab2*rhsq2a.x + p_ab3*rhsq3a.x;
      qa.y += p_ab1*rhsq1a.y + p_ab2*rhsq2a.y + p_ab3*rhsq3a.y;
      qa.z += p_ab1*rhsq1a.z + p_ab2*rhsq2a.z + p_ab3*rhsq3a.z;
      qa.w  = p_expdt*qa.w + p_saab1*rhsq1a.w + p_saab2*rhsq2a.w + p_saab3*rhsq3a.w;

      qb.x = p_expdt*qb.x + p_saab1*rhsq1b.x + p_saab2*rhsq2b.x + p_saab3*rhsq3b.x; 
      qb.y = p_expdt*qb.y + p_saab1*rhsq1b.y + p_saab2*rhsq2b.y + p_saab3*rhsq3b.y; 

            
      q[id0] = qa;
      q[id1] = qb;
      //
      rhsq2[id0] = rhsq1a;
      rhsq2[id1] = rhsq1b;
      //
      rhsq3[id0] = rhsq2a;
      rhsq3[id1] = rhsq2b;

    }
  }
}





kernel void boltzmannLSERKSplitPmlUpdate2D(const iint Nelements,
              const iint * restrict elementIds, 
              const dfloat dt,  
              const dfloat rka,
              const dfloat rkb,
              const dfloat ramp,  
              const dfloat * restrict rhsqx,
              const dfloat * restrict rhsqy,
              const dfloat * restrict rhsNT,  
              dfloat * restrict resqx,
              dfloat * restrict resqy,
              dfloat * restrict resNT,
              dfloat * restrict qx,
              dfloat * restrict qy,
              dfloat * restrict NT,
              dfloat4 * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){

      const iint element = elementIds[e];

      const iint base = n + element*p_Nfields*p_Np;

      dfloat resqx1 = resqx[base+0*p_Np];
      dfloat resqx2 = resqx[base+1*p_Np];
      dfloat resqx3 = resqx[base+2*p_Np];
      dfloat resqx4 = resqx[base+3*p_Np];
      dfloat resqx5 = resqx[base+4*p_Np];
      dfloat resqx6 = resqx[base+5*p_Np];

      dfloat resqy1 = resqy[base+0*p_Np];
      dfloat resqy2 = resqy[base+1*p_Np];
      dfloat resqy3 = resqy[base+2*p_Np];
      dfloat resqy4 = resqy[base+3*p_Np];
      dfloat resqy5 = resqy[base+4*p_Np];
      dfloat resqy6 = resqy[base+5*p_Np];

      dfloat resNT1 = resNT[base+0*p_Np];
      dfloat resNT2 = resNT[base+1*p_Np];
      dfloat resNT3 = resNT[base+2*p_Np];
      dfloat resNT4 = resNT[base+3*p_Np];
      dfloat resNT5 = resNT[base+4*p_Np];
      dfloat resNT6 = resNT[base+5*p_Np];
      
      dfloat rhsqx1 = rhsqx[base+0*p_Np];
      dfloat rhsqx2 = rhsqx[base+1*p_Np];
      dfloat rhsqx3 = rhsqx[base+2*p_Np];
      dfloat rhsqx4 = rhsqx[base+3*p_Np];
      dfloat rhsqx5 = rhsqx[base+4*p_Np];
      dfloat rhsqx6 = rhsqx[base+5*p_Np];

      dfloat rhsqy1 = rhsqy[base+0*p_Np];
      dfloat rhsqy2 = rhsqy[base+1*p_Np];
      dfloat rhsqy3 = rhsqy[base+2*p_Np];
      dfloat rhsqy4 = rhsqy[base+3*p_Np];
      dfloat rhsqy5 = rhsqy[base+4*p_Np];
      dfloat rhsqy6 = rhsqy[base+5*p_Np];

      dfloat rhsNT1 = rhsNT[base+0*p_Np];
      dfloat rhsNT2 = rhsNT[base+1*p_Np];
      dfloat rhsNT3 = rhsNT[base+2*p_Np];
      dfloat rhsNT4 = rhsNT[base+3*p_Np];
      dfloat rhsNT5 = rhsNT[base+4*p_Np];
      dfloat rhsNT6 = rhsNT[base+5*p_Np];

      dfloat qx1 = qx[base+0*p_Np];
      dfloat qx2 = qx[base+1*p_Np];
      dfloat qx3 = qx[base+2*p_Np];
      dfloat qx4 = qx[base+3*p_Np];
      dfloat qx5 = qx[base+4*p_Np];
      dfloat qx6 = qx[base+5*p_Np];

      dfloat qy1 = qy[base+0*p_Np];
      dfloat qy2 = qy[base+1*p_Np];
      dfloat qy3 = qy[base+2*p_Np];
      dfloat qy4 = qy[base+3*p_Np];
      dfloat qy5 = qy[base+4*p_Np];
      dfloat qy6 = qy[base+5*p_Np];

      dfloat NT1 = NT[base+0*p_Np];
      dfloat NT2 = NT[base+1*p_Np];
      dfloat NT3 = NT[base+2*p_Np];
      dfloat NT4 = NT[base+3*p_Np];
      dfloat NT5 = NT[base+4*p_Np];
      dfloat NT6 = NT[base+5*p_Np];

      
      resqx1 = rka*resqx1 + dt*rhsqx1;
      resqx2 = rka*resqx2 + dt*rhsqx2;
      resqx3 = rka*resqx3 + dt*rhsqx3;
      resqx4 = rka*resqx4 + dt*rhsqx4;
      resqx5 = rka*resqx5 + dt*rhsqx5;
      resqx6 = rka*resqx6 + dt*rhsqx6;

      resqy1 = rka*resqy1 + dt*rhsqy1;
      resqy2 = rka*resqy2 + dt*rhsqy2;
      resqy3 = rka*resqy3 + dt*rhsqy3;
      resqy4 = rka*resqy4 + dt*rhsqy4;
      resqy5 = rka*resqy5 + dt*rhsqy5;
      resqy6 = rka*resqy6 + dt*rhsqy6;

      resNT1 = rka*resNT1 + dt*rhsNT1;
      resNT2 = rka*resNT2 + dt*rhsNT2;
      resNT3 = rka*resNT3 + dt*rhsNT3;
      resNT4 = rka*resNT4 + dt*rhsNT4;
      resNT5 = rka*resNT5 + dt*rhsNT5;
      resNT6 = rka*resNT6 + dt*rhsNT6;

      qx1 += rkb*resqx1;
      qx2 += rkb*resqx2;
      qx3 += rkb*resqx3;
      qx4 += rkb*resqx4;
      qx5 += rkb*resqx5;
      qx6 += rkb*resqx6;

      qy1 += rkb*resqy1;
      qy2 += rkb*resqy2;
      qy3 += rkb*resqy3;
      qy4 += rkb*resqy4;
      qy5 += rkb*resqy5;
      qy6 += rkb*resqy6;

      NT1 += rkb*resNT1;
      NT2 += rkb*resNT2;
      NT3 += rkb*resNT3;
      NT4 += rkb*resNT4;
      NT5 += rkb*resNT5;
      NT6 += rkb*resNT6;


      dfloat4 qa, qb;
      qa.x = p_q1bar + qx1 + qy1;
      qa.y = ramp*p_q2bar + qx2 + qy2;
      qa.z = ramp*p_q3bar + qx3 + qy3;
      qa.w = ramp*ramp*p_q4bar + qx4 + qy4;
      
      qb.x = ramp*ramp*p_q5bar + qx5 + qy5;
      qb.y = ramp*ramp*p_q6bar + qx6 + qy6;

      q[2*(n+element*p_Np)] = qa;
      q[2*(n+element*p_Np)+1] = qb;

      resqx[base+0*p_Np] = resqx1;
      resqx[base+1*p_Np] = resqx2;
      resqx[base+2*p_Np] = resqx3;
      resqx[base+3*p_Np] = resqx4;
      resqx[base+4*p_Np] = resqx5;
      resqx[base+5*p_Np] = resqx6;

      resqy[base+0*p_Np] = resqy1;
      resqy[base+1*p_Np] = resqy2;
      resqy[base+2*p_Np] = resqy3;
      resqy[base+3*p_Np] = resqy4;
      resqy[base+4*p_Np] = resqy5;
      resqy[base+5*p_Np] = resqy6;

      resNT[base+0*p_Np] = resNT1;
      resNT[base+1*p_Np] = resNT2;
      resNT[base+2*p_Np] = resNT3;
      resNT[base+3*p_Np] = resNT4;
      resNT[base+4*p_Np] = resNT5;
      resNT[base+5*p_Np] = resNT6;

      qx[base+0*p_Np] = qx1;
      qx[base+1*p_Np] = qx2;
      qx[base+2*p_Np] = qx3;
      qx[base+3*p_Np] = qx4;
      qx[base+4*p_Np] = qx5;
      qx[base+5*p_Np] = qx6;

      qy[base+0*p_Np] = qy1;
      qy[base+1*p_Np] = qy2;
      qy[base+2*p_Np] = qy3;
      qy[base+3*p_Np] = qy4;
      qy[base+4*p_Np] = qy5;
      qy[base+5*p_Np] = qy6;

      NT[base+0*p_Np] = NT1;
      NT[base+1*p_Np] = NT2;
      NT[base+2*p_Np] = NT3;
      NT[base+3*p_Np] = NT4;
      NT[base+4*p_Np] = NT5;
      NT[base+5*p_Np] = NT6;
    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXResidualUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat aki,
            const dfloat ake, 
            const dfloat4 * restrict q,
            const dfloat4 * restrict qZ,
                  dfloat4 * restrict qY){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 qima = qZ[id0];
      dfloat4 qimb = qZ[id1];

      dfloat4 qexa = qY[id0];
      dfloat4 qexb = qY[id1];
      //
      dfloat4 qa   = q[id0];
      dfloat4 qb   = q[id1];

      qY[id0] = qa + ake*dt*qexa + aki*dt*qima;
      qY[id1] = qb + ake*dt*qexb + aki*dt*qimb;
      

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXImplicitUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat4 * restrict qZ,
            const dfloat4 * restrict qY,
                  dfloat4 * restrict q,
                  dfloat4 * restrict qS){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      //
      const iint element = elementIds[e];
      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 qima = qZ[id0];
      dfloat4 qimb = qZ[id1];

      dfloat4 qexa = qY[id0];
      dfloat4 qexb = qY[id1];
      //
      dfloat4 qa  = q[id0];
      dfloat4 qb  = q[id1];

      qS[id0] = qa; 
      qS[id1] = qb; 

      q[id0] = qexa + akk*dt*qima;
      q[id1] = qexb + akk*dt*qimb;      

    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat4 * restrict qZ,
            const dfloat4 * restrict qY,
            const dfloat4 * restrict qS,
                  dfloat4 * restrict q){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      const iint id0 = 2*(n + element*p_Np);
      const iint id1 = id0 + 1; 

      dfloat4 qia = qZ[id0];
      dfloat4 qib = qZ[id1];

      dfloat4 qea = qY[id0];
      dfloat4 qeb = qY[id1];
      //
      dfloat4 qa  = qS[id0];
      dfloat4 qb  = qS[id1];
      //
      q[id0] = qa+ akk*dt*(qia + qea);
      q[id1] = qb+ akk*dt*(qib + qeb);     

    }
  }
}




// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXSplitPmlResidualUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt,
            const dfloat ramp, 
            const dfloat c_im,
            const dfloat c_ex, 
            const dfloat  * restrict pmlqx,
            const dfloat  * restrict pmlqy,
            const dfloat  * restrict pmlnt,
            const dfloat  * restrict pmlZx,
            const dfloat  * restrict pmlZy,
            const dfloat  * restrict pmlZnt,
                  dfloat  * restrict pmlYx,
                  dfloat  * restrict pmlYy,
                  dfloat  * restrict pmlYnt,
                  dfloat4 * restrict qY){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;


      // PML UPDATES
      dfloat qx1 = pmlqx[id1];
      dfloat qx2 = pmlqx[id2];
      dfloat qx3 = pmlqx[id3];
      dfloat qx4 = pmlqx[id4];
      dfloat qx5 = pmlqx[id5];
      dfloat qx6 = pmlqx[id6]; 
      //
      dfloat qy1 = pmlqy[id1];
      dfloat qy2 = pmlqy[id2];
      dfloat qy3 = pmlqy[id3];
      dfloat qy4 = pmlqy[id4];
      dfloat qy5 = pmlqy[id5];
      dfloat qy6 = pmlqy[id6]; 
      //
      dfloat nt1 = pmlnt[id1];
      dfloat nt2 = pmlnt[id2];
      dfloat nt3 = pmlnt[id3];
      dfloat nt4 = pmlnt[id4];
      dfloat nt5 = pmlnt[id5];
      dfloat nt6 = pmlnt[id6]; 

      // PML UPDATES
      dfloat qxi1 = pmlZx[id1];
      dfloat qxi2 = pmlZx[id2];
      dfloat qxi3 = pmlZx[id3];
      dfloat qxi4 = pmlZx[id4];
      dfloat qxi5 = pmlZx[id5];
      dfloat qxi6 = pmlZx[id6]; 
      //
      dfloat qyi1 = pmlZy[id1];
      dfloat qyi2 = pmlZy[id2];
      dfloat qyi3 = pmlZy[id3];
      dfloat qyi4 = pmlZy[id4];
      dfloat qyi5 = pmlZy[id5];
      dfloat qyi6 = pmlZy[id6]; 
      //
      dfloat nti1 = pmlZnt[id1];
      dfloat nti2 = pmlZnt[id2];
      dfloat nti3 = pmlZnt[id3];
      dfloat nti4 = pmlZnt[id4];
      dfloat nti5 = pmlZnt[id5];
      dfloat nti6 = pmlZnt[id6]; 

      // PML UPDATES
      dfloat qxe1 = pmlYx[id1];
      dfloat qxe2 = pmlYx[id2];
      dfloat qxe3 = pmlYx[id3];
      dfloat qxe4 = pmlYx[id4];
      dfloat qxe5 = pmlYx[id5];
      dfloat qxe6 = pmlYx[id6]; 
      //
      dfloat qye1 = pmlYy[id1];
      dfloat qye2 = pmlYy[id2];
      dfloat qye3 = pmlYy[id3];
      dfloat qye4 = pmlYy[id4];
      dfloat qye5 = pmlYy[id5];
      dfloat qye6 = pmlYy[id6]; 
      //
      dfloat nte1 = pmlYnt[id1];
      dfloat nte2 = pmlYnt[id2];
      dfloat nte3 = pmlYnt[id3];
      dfloat nte4 = pmlYnt[id4];
      dfloat nte5 = pmlYnt[id5];
      dfloat nte6 = pmlYnt[id6]; 
      //
      // PML UPDATES
      dfloat qxy1 = qx1 + c_ex*dt*qxe1 + c_im*dt*qxi1;
      dfloat qxy2 = qx2 + c_ex*dt*qxe2 + c_im*dt*qxi2;
      dfloat qxy3 = qx3 + c_ex*dt*qxe3 + c_im*dt*qxi3;
      dfloat qxy4 = qx4 + c_ex*dt*qxe4 + c_im*dt*qxi4;
      dfloat qxy5 = qx5 + c_ex*dt*qxe5 + c_im*dt*qxi5;
      dfloat qxy6 = qx6 + c_ex*dt*qxe6 + c_im*dt*qxi6; 
      //
      dfloat qyy1 = qy1 + c_ex*dt*qye1 + c_im*dt*qyi1;
      dfloat qyy2 = qy2 + c_ex*dt*qye2 + c_im*dt*qyi2;
      dfloat qyy3 = qy3 + c_ex*dt*qye3 + c_im*dt*qyi3;
      dfloat qyy4 = qy4 + c_ex*dt*qye4 + c_im*dt*qyi4;
      dfloat qyy5 = qy5 + c_ex*dt*qye5 + c_im*dt*qyi5;
      dfloat qyy6 = qy6 + c_ex*dt*qye6 + c_im*dt*qyi6; 

      
      // PML UPDATES
      pmlYx[id1] = qxy1;
      pmlYx[id2] = qxy2;
      pmlYx[id3] = qxy3;
      pmlYx[id4] = qxy4;
      pmlYx[id5] = qxy5;
      pmlYx[id6] = qxy6; 
      //
      pmlYy[id1] = qyy1;
      pmlYy[id2] = qyy2;
      pmlYy[id3] = qyy3;
      pmlYy[id4] = qyy4;
      pmlYy[id5] = qyy5;
      pmlYy[id6] = qyy6; 

      pmlYnt[id1] = nt1 + c_ex*dt*nte1 + c_im*dt*nti1;
      pmlYnt[id2] = nt2 + c_ex*dt*nte2 + c_im*dt*nti2;
      pmlYnt[id3] = nt3 + c_ex*dt*nte3 + c_im*dt*nti3;
      pmlYnt[id4] = nt4 + c_ex*dt*nte4 + c_im*dt*nti4;
      pmlYnt[id5] = nt5 + c_ex*dt*nte5 + c_im*dt*nti5;
      pmlYnt[id6] = nt6 + c_ex*dt*nte6 + c_im*dt*nti6; 
      //
    
      dfloat4 temp; 

      temp.x =  p_q1bar                 + qxy1 + qyy1;
      temp.y =  ramp*p_q2bar            + qxy2 + qyy2;
      temp.z =  ramp*p_q3bar            + qxy3 + qyy3;
      temp.w =  ramp*ramp*p_q4bar       + qxy4 + qyy4;

      qY[2*(n + element*p_Np)] = temp;

      temp.x =  ramp*ramp*p_q5bar       + qxy5 + qyy5;
      temp.y =  ramp*ramp*p_q6bar       + qxy6 + qyy6;
      temp.z =  0.0;
      temp.w =  0.0;
      
      qY[2*(n + element*p_Np)+1] = temp;


    }
  }
}



// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXSplitPmlImplicitUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat ramp,
            const dfloat akk,
            const dfloat  * restrict qZx,
            const dfloat  * restrict qZy,
            const dfloat  * restrict qZnt,     
            const dfloat  * restrict qYx,
            const dfloat  * restrict qYy,
            const dfloat  * restrict qYnt,
                  dfloat  * restrict pmlqx,
                  dfloat  * restrict pmlqy,
                  dfloat  * restrict pmlNT,     
                  dfloat  * restrict qSx,
                  dfloat  * restrict qSy,
                  dfloat  * restrict qSnt,
                  dfloat4 * restrict q ){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;


      // PML UPDATES
      dfloat qx1 = pmlqx[id1];
      dfloat qx2 = pmlqx[id2];
      dfloat qx3 = pmlqx[id3];
      dfloat qx4 = pmlqx[id4];
      dfloat qx5 = pmlqx[id5];
      dfloat qx6 = pmlqx[id6]; 
      //
      dfloat qy1 = pmlqy[id1];
      dfloat qy2 = pmlqy[id2];
      dfloat qy3 = pmlqy[id3];
      dfloat qy4 = pmlqy[id4];
      dfloat qy5 = pmlqy[id5];
      dfloat qy6 = pmlqy[id6]; 
      //
      dfloat nt1 = pmlNT[id1];
      dfloat nt2 = pmlNT[id2];
      dfloat nt3 = pmlNT[id3];
      dfloat nt4 = pmlNT[id4];
      dfloat nt5 = pmlNT[id5];
      dfloat nt6 = pmlNT[id6]; 

      // PML UPDATES
      dfloat qxi1 = qZx[id1];
      dfloat qxi2 = qZx[id2];
      dfloat qxi3 = qZx[id3];
      dfloat qxi4 = qZx[id4];
      dfloat qxi5 = qZx[id5];
      dfloat qxi6 = qZx[id6]; 
      //
      dfloat qyi1 = qZy[id1];
      dfloat qyi2 = qZy[id2];
      dfloat qyi3 = qZy[id3];
      dfloat qyi4 = qZy[id4];
      dfloat qyi5 = qZy[id5];
      dfloat qyi6 = qZy[id6]; 
      //
      dfloat nti1 = qZnt[id1];
      dfloat nti2 = qZnt[id2];
      dfloat nti3 = qZnt[id3];
      dfloat nti4 = qZnt[id4];
      dfloat nti5 = qZnt[id5];
      dfloat nti6 = qZnt[id6]; 

      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      //
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 

      // PML UPDATES
      qSx[id1] = qx1;
      qSx[id2] = qx2;
      qSx[id3] = qx3;
      qSx[id4] = qx4;
      qSx[id5] = qx5;
      qSx[id6] = qx6; 
      //
      qSy[id1] = qy1;
      qSy[id2] = qy2;
      qSy[id3] = qy3;
      qSy[id4] = qy4;
      qSy[id5] = qy5;
      qSy[id6] = qy6; 

      qSnt[id1] = nt1;
      qSnt[id2] = nt2;
      qSnt[id3] = nt3;
      qSnt[id4] = nt4;
      qSnt[id5] = nt5;
      qSnt[id6] = nt6; 
      //

      // PML UPDATES
      qx1 = qxe1 + akk*dt*qxi1;
      qx2 = qxe2 + akk*dt*qxi2;
      qx3 = qxe3 + akk*dt*qxi3;
      qx4 = qxe4 + akk*dt*qxi4;
      qx5 = qxe5 + akk*dt*qxi5;
      qx6 = qxe6 + akk*dt*qxi6; 
       // PML UPDATES
      qy1 = qye1 + akk*dt*qyi1;
      qy2 = qye2 + akk*dt*qyi2;
      qy3 = qye3 + akk*dt*qyi3;
      qy4 = qye4 + akk*dt*qyi4;
      qy5 = qye5 + akk*dt*qyi5;
      qy6 = qye6 + akk*dt*qyi6;

        // PML UPDATES
      nt1 = nte1 + akk*dt*nti1;
      nt2 = nte2 + akk*dt*nti2;
      nt3 = nte3 + akk*dt*nti3;
      nt4 = nte4 + akk*dt*nti4;
      nt5 = nte5 + akk*dt*nti5;
      nt6 = nte6 + akk*dt*nti6;  

      
      // PML UPDATES
      pmlqx[id1] = qx1;
      pmlqx[id2] = qx2;
      pmlqx[id3] = qx3;
      pmlqx[id4] = qx4;
      pmlqx[id5] = qx5;
      pmlqx[id6] = qx6; 
       // PML UPDATES
      pmlqy[id1] = qy1;
      pmlqy[id2] = qy2;
      pmlqy[id3] = qy3;
      pmlqy[id4] = qy4;
      pmlqy[id5] = qy5;
      pmlqy[id6] = qy6; 

      // PML UPDATES
      pmlNT[id1] = nt1;
      pmlNT[id2] = nt2;
      pmlNT[id3] = nt3;
      pmlNT[id4] = nt4;
      pmlNT[id5] = nt5;
      pmlNT[id6] = nt6; 

      dfloat4 temp;

      temp.x =  p_q1bar                 + qx1 + qy1;
      temp.y =  ramp*p_q2bar            + qx2 + qy2;
      temp.z =  ramp*p_q3bar            + qx3 + qy3;
      temp.w =  ramp*ramp*p_q4bar       + qx4 + qy4;

      q[2*(n + element*p_Np)] = temp;

      temp.x =  ramp*ramp*p_q5bar       + qx5 + qy5;
      temp.y =  ramp*ramp*p_q6bar       + qx6 + qy6;
      temp.z =  0.0;
      temp.w =  0.0;

       q[2*(n + element*p_Np) +1] = temp;

    }
  }
}




// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannLSIMEXSplitPmlUpdate2D(const iint Nelements,
            const iint * restrict elementIds,
            const dfloat dt, 
            const dfloat akk,
            const dfloat ramp,
            const dfloat  * restrict qZx,
            const dfloat  * restrict qZy,
            const dfloat  * restrict qZnt,     
            const dfloat  * restrict qYx,
            const dfloat  * restrict qYy,
            const dfloat  * restrict qYnt,
            const dfloat  * restrict qSx,
                  dfloat  * restrict qSy,
                  dfloat  * restrict qSnt,     
                  dfloat  * restrict pmlqx,
                  dfloat  * restrict pmlqy,
                  dfloat  * restrict pmlNT,
                  dfloat4 * restrict q ){
  // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];

      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;


     
      // PML UPDATES
      dfloat qxi1 = qZx[id1];
      dfloat qxi2 = qZx[id2];
      dfloat qxi3 = qZx[id3];
      dfloat qxi4 = qZx[id4];
      dfloat qxi5 = qZx[id5];
      dfloat qxi6 = qZx[id6]; 
      //
      dfloat qyi1 = qZy[id1];
      dfloat qyi2 = qZy[id2];
      dfloat qyi3 = qZy[id3];
      dfloat qyi4 = qZy[id4];
      dfloat qyi5 = qZy[id5];
      dfloat qyi6 = qZy[id6]; 
      //
      dfloat nti1 = qZnt[id1];
      dfloat nti2 = qZnt[id2];
      dfloat nti3 = qZnt[id3];
      dfloat nti4 = qZnt[id4];
      dfloat nti5 = qZnt[id5];
      dfloat nti6 = qZnt[id6]; 

      // PML UPDATES
      dfloat qxe1 = qYx[id1];
      dfloat qxe2 = qYx[id2];
      dfloat qxe3 = qYx[id3];
      dfloat qxe4 = qYx[id4];
      dfloat qxe5 = qYx[id5];
      dfloat qxe6 = qYx[id6]; 
      //
      dfloat qye1 = qYy[id1];
      dfloat qye2 = qYy[id2];
      dfloat qye3 = qYy[id3];
      dfloat qye4 = qYy[id4];
      dfloat qye5 = qYy[id5];
      dfloat qye6 = qYy[id6]; 
      //
      dfloat nte1 = qYnt[id1];
      dfloat nte2 = qYnt[id2];
      dfloat nte3 = qYnt[id3];
      dfloat nte4 = qYnt[id4];
      dfloat nte5 = qYnt[id5];
      dfloat nte6 = qYnt[id6]; 

      // PML UPDATES
      dfloat qsx1 = qSx[id1];
      dfloat qsx2 = qSx[id2];
      dfloat qsx3 = qSx[id3];
      dfloat qsx4 = qSx[id4];
      dfloat qsx5 = qSx[id5];
      dfloat qsx6 = qSx[id6]; 
      // PML UPDATES
      dfloat qsy1 = qSy[id1];
      dfloat qsy2 = qSy[id2];
      dfloat qsy3 = qSy[id3];
      dfloat qsy4 = qSy[id4];
      dfloat qsy5 = qSy[id5];
      dfloat qsy6 = qSy[id6];  

      // PML UPDATES
      dfloat nts1 = qSnt[id1];
      dfloat nts2 = qSnt[id2];
      dfloat nts3 = qSnt[id3];
      dfloat nts4 = qSnt[id4];
      dfloat nts5 = qSnt[id5];
      dfloat nts6 = qSnt[id6]; 
      //

      // PML UPDATES
      dfloat qx1 =qsx1 + akk*dt*( qxe1 + qxi1);
      dfloat qx2 =qsx2 + akk*dt*( qxe2 + qxi2);
      dfloat qx3 =qsx3 + akk*dt*( qxe3 + qxi3);
      dfloat qx4 =qsx4 + akk*dt*( qxe4 + qxi4);
      dfloat qx5 =qsx5 + akk*dt*( qxe5 + qxi5);
      dfloat qx6 =qsx6 + akk*dt*( qxe6 + qxi6); 
       // PML UPDATES
      dfloat qy1 =qsy1 + akk*dt*( qye1 + qyi1);
      dfloat qy2 =qsy2 + akk*dt*( qye2 + qyi2);
      dfloat qy3 =qsy3 + akk*dt*( qye3 + qyi3);
      dfloat qy4 =qsy4 + akk*dt*( qye4 + qyi4);
      dfloat qy5 =qsy5 + akk*dt*( qye5 + qyi5);
      dfloat qy6 =qsy6 + akk*dt*( qye6 + qyi6); 

       // PML UPDATES
      pmlqx[id1] =qx1;
      pmlqx[id2] =qx2;
      pmlqx[id3] =qx3;
      pmlqx[id4] =qx4;
      pmlqx[id5] =qx5;
      pmlqx[id6] =qx6; 
       // PML UPDATES
      pmlqy[id1] =qy1;
      pmlqy[id2] =qy2;
      pmlqy[id3] =qy3;
      pmlqy[id4] =qy4;
      pmlqy[id5] =qy5;
      pmlqy[id6] =qy6; 
     //
       // PML UPDATES
      pmlNT[id1] =nts1 + akk*dt*( nte1 + nti1);
      pmlNT[id2] =nts2 + akk*dt*( nte2 + nti2);
      pmlNT[id3] =nts3 + akk*dt*( nte3 + nti3);
      pmlNT[id4] =nts4 + akk*dt*( nte4 + nti4);
      pmlNT[id5] =nts5 + akk*dt*( nte5 + nti5);
      pmlNT[id6] =nts6 + akk*dt*( nte6 + nti6); 
      
      //
      dfloat4 temp;

      temp.x =  p_q1bar                 + qx1 + qy1;
      temp.y =  ramp*p_q2bar            + qx2 + qy2;
      temp.z =  ramp*p_q3bar            + qx3 + qy3;
      temp.w =  ramp*ramp*p_q4bar       + qx4 + qy4;

      q[2*(n + element*p_Np)] = temp;

      temp.x =  ramp*ramp*p_q5bar       + qx5 + qy5;
      temp.y =  ramp*ramp*p_q6bar       + qx6 + qy6;
      temp.z =  0.0;
      temp.w =  0.0;

       q[2*(n + element*p_Np) +1] = temp;

    }
  }
}





// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABSplitPmlUpdateFirst2D(
            const iint                Nelements,
            const iint     * restrict elementIds,
            const dfloat              dt, 
            const dfloat             ramp,
                  dfloat  * restrict rhsQX,
                  dfloat  * restrict rhsQY,
                  dfloat  * restrict rhsNT,
                  dfloat  * restrict rhsQX2,
                  dfloat  * restrict rhsQY2,
                  dfloat  * restrict rhsNT2,
                  dfloat  * restrict rhsQX3,
                  dfloat  * restrict rhsQY3,
                  dfloat  * restrict rhsNT3,
                  dfloat  * restrict pmlQX,
                  dfloat  * restrict pmlQY,
                  dfloat  * restrict pmlNT,
                  dfloat4 * restrict q)
{  
 // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;
      //
      const iint id0 = n+ element*p_Np;

      // PML UPDATES
      dfloat rhsqx11 = rhsQX[id1];
      dfloat rhsqx12 = rhsQX[id2];
      dfloat rhsqx13 = rhsQX[id3];
      dfloat rhsqx14 = rhsQX[id4];
      dfloat rhsqx15 = rhsQX[id5];
      dfloat rhsqx16 = rhsQX[id6]; 
      //
      dfloat rhsqy11 = rhsQY[id1];
      dfloat rhsqy12 = rhsQY[id2];
      dfloat rhsqy13 = rhsQY[id3];
      dfloat rhsqy14 = rhsQY[id4];
      dfloat rhsqy15 = rhsQY[id5];
      dfloat rhsqy16 = rhsQY[id6]; 

      // PML UPDATES
      dfloat rhsnt11 = rhsNT[id1];
      dfloat rhsnt12 = rhsNT[id2];
      dfloat rhsnt13 = rhsNT[id3];
      dfloat rhsnt14 = rhsNT[id4];
      dfloat rhsnt15 = rhsNT[id5];
      dfloat rhsnt16 = rhsNT[id6];
     
      
      //
      dfloat qx1 = pmlQX[id1];
      dfloat qx2 = pmlQX[id2];
      dfloat qx3 = pmlQX[id3];
      dfloat qx4 = pmlQX[id4];
      dfloat qx5 = pmlQX[id5];
      dfloat qx6 = pmlQX[id6]; 
      //
      dfloat qy1 = pmlQY[id1];
      dfloat qy2 = pmlQY[id2];
      dfloat qy3 = pmlQY[id3];
      dfloat qy4 = pmlQY[id4];
      dfloat qy5 = pmlQY[id5];
      dfloat qy6 = pmlQY[id6]; 
      //
      dfloat nt1 = pmlNT[id1];
      dfloat nt2 = pmlNT[id2];
      dfloat nt3 = pmlNT[id3];
      dfloat nt4 = pmlNT[id4];
      dfloat nt5 = pmlNT[id5];
      dfloat nt6 = pmlNT[id6]; 
      

      // First Order SAAB Coefficients
      dfloat c1 = -(p_pmlexpdt - 1.)/(0.5*p_tauInv);
      
      qx1 = qx1 + dt*rhsqx11;
      qx2 = qx2 + dt*rhsqx12;
      qx3 = qx3 + dt*rhsqx13;
      qx4 = p_pmlexpdt*qx4 + c1*rhsqx14;
      qx5 = p_pmlexpdt*qx5 + c1*rhsqx15;
      qx6 = p_pmlexpdt*qx6 + c1*rhsqx16;
      //
      qy1 = qy1 + dt*rhsqy11;
      qy2 = qy2 + dt*rhsqy12;
      qy3 = qy3 + dt*rhsqy13;
      qy4 = p_pmlexpdt*qy4 + c1*rhsqy14;
      qy5 = p_pmlexpdt*qy5 + c1*rhsqy15;
      qy6 = p_pmlexpdt*qy6 + c1*rhsqy16;
      //
      nt1 += dt * rhsnt11;
      nt2 += dt * rhsnt12;
      nt3 += dt * rhsnt13;
      nt4 += dt * rhsnt14;
      nt5 += dt * rhsnt15;
      nt6 += dt * rhsnt16;
     //

    // Update Fields
      pmlQX[id1] = qx1 ;
      pmlQX[id2] = qx2 ;
      pmlQX[id3] = qx3 ;
      pmlQX[id4] = qx4 ;
      pmlQX[id5] = qx5 ;
      pmlQX[id6] = qx6 ; 

      pmlQY[id1] = qy1 ;
      pmlQY[id2] = qy2 ;
      pmlQY[id3] = qy3 ;
      pmlQY[id4] = qy4 ;
      pmlQY[id5] = qy5 ;
      pmlQY[id6] = qy6 ; 

      pmlNT[id1] = nt1 ;
      pmlNT[id2] = nt2 ;
      pmlNT[id3] = nt3 ;
      pmlNT[id4] = nt4 ;
      pmlNT[id5] = nt5 ;
      pmlNT[id6] = nt6 ; 

      //
      rhsQX2[id1] = rhsqx11 ;
      rhsQX2[id2] = rhsqx12 ;
      rhsQX2[id3] = rhsqx13 ;
      rhsQX2[id4] = rhsqx14 ;
      rhsQX2[id5] = rhsqx15 ;
      rhsQX2[id6] = rhsqx16 ;
      //
      rhsQX3[id1] = rhsqx11 ;
      rhsQX3[id2] = rhsqx12 ;
      rhsQX3[id3] = rhsqx13 ;
      rhsQX3[id4] = rhsqx14 ;
      rhsQX3[id5] = rhsqx15 ;
      rhsQX3[id6] = rhsqx16 ;


      //
      rhsQY2[id1] = rhsqy11 ;
      rhsQY2[id2] = rhsqy12 ;
      rhsQY2[id3] = rhsqy13 ;
      rhsQY2[id4] = rhsqy14 ;
      rhsQY2[id5] = rhsqy15 ;
      rhsQY2[id6] = rhsqy16 ;
      //
      rhsQY3[id1] = rhsqy11 ;
      rhsQY3[id2] = rhsqy12 ;
      rhsQY3[id3] = rhsqy13 ;
      rhsQY3[id4] = rhsqy14 ;
      rhsQY3[id5] = rhsqy15 ;
      rhsQY3[id6] = rhsqy16 ;

       //
      rhsNT2[id1] = rhsnt11 ;
      rhsNT2[id2] = rhsnt12 ;
      rhsNT2[id3] = rhsnt13 ;
      rhsNT2[id4] = rhsnt14 ;
      rhsNT2[id5] = rhsnt15 ;
      rhsNT2[id6] = rhsnt16 ;
      //
      rhsNT3[id1] = rhsnt11 ;
      rhsNT3[id2] = rhsnt12 ;
      rhsNT3[id3] = rhsnt13 ;
      rhsNT3[id4] = rhsnt14 ;
      rhsNT3[id5] = rhsnt15 ;
      rhsNT3[id6] = rhsnt16 ;   
      //
      dfloat4 qa, qb;
      qa.x = p_q1bar + qx1 + qy1;
      qa.y = ramp*p_q2bar + qx2 + qy2;
      qa.z = ramp*p_q3bar + qx3 + qy3;
      qa.w = ramp*ramp*p_q4bar + qx4 + qy4;
      
      qb.x = ramp*ramp*p_q5bar + qx5 + qy5;
      qb.y = ramp*ramp*p_q6bar + qx6 + qy6;
      qb.z = 0.0; 
      qb.w = 0.0; 

      q[2*(n+element*p_Np)]   = qa;
      q[2*(n+element*p_Np)+1] = qb;
      
    }
  }
}


// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABSplitPmlUpdateSecond2D(
            const iint                Nelements,
            const iint     * restrict elementIds,
            const dfloat              dt, 
            const dfloat             ramp,
                  dfloat  * restrict rhsQX,
                  dfloat  * restrict rhsQY,
                  dfloat  * restrict rhsNT,
                  dfloat  * restrict rhsQX2,
                  dfloat  * restrict rhsQY2,
                  dfloat  * restrict rhsNT2,
                  dfloat  * restrict rhsQX3,
                  dfloat  * restrict rhsQY3,
                  dfloat  * restrict rhsNT3,
                  dfloat  * restrict pmlQX,
                  dfloat  * restrict pmlQY,
                  dfloat  * restrict pmlNT,
                  dfloat4 * restrict q)
{  
 // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;
      //
      const iint id0 = n+ element*p_Np;

      // PML UPDATES
      dfloat rhsqx11 = rhsQX[id1];
      dfloat rhsqx12 = rhsQX[id2];
      dfloat rhsqx13 = rhsQX[id3];
      dfloat rhsqx14 = rhsQX[id4];
      dfloat rhsqx15 = rhsQX[id5];
      dfloat rhsqx16 = rhsQX[id6]; 
      //
      // PML UPDATES
      dfloat rhsqx21 = rhsQX2[id1];
      dfloat rhsqx22 = rhsQX2[id2];
      dfloat rhsqx23 = rhsQX2[id3];
      dfloat rhsqx24 = rhsQX2[id4];
      dfloat rhsqx25 = rhsQX2[id5];
      dfloat rhsqx26 = rhsQX2[id6]; 
      //
      dfloat rhsqy11 = rhsQY[id1];
      dfloat rhsqy12 = rhsQY[id2];
      dfloat rhsqy13 = rhsQY[id3];
      dfloat rhsqy14 = rhsQY[id4];
      dfloat rhsqy15 = rhsQY[id5];
      dfloat rhsqy16 = rhsQY[id6]; 
      ////
      dfloat rhsqy21 = rhsQY2[id1];
      dfloat rhsqy22 = rhsQY2[id2];
      dfloat rhsqy23 = rhsQY2[id3];
      dfloat rhsqy24 = rhsQY2[id4];
      dfloat rhsqy25 = rhsQY2[id5];
      dfloat rhsqy26 = rhsQY2[id6]; 


      // PML UPDATES
      dfloat rhsnt11 = rhsNT[id1];
      dfloat rhsnt12 = rhsNT[id2];
      dfloat rhsnt13 = rhsNT[id3];
      dfloat rhsnt14 = rhsNT[id4];
      dfloat rhsnt15 = rhsNT[id5];
      dfloat rhsnt16 = rhsNT[id6];

      // PML UPDATES
      dfloat rhsnt21 = rhsNT2[id1];
      dfloat rhsnt22 = rhsNT2[id2];
      dfloat rhsnt23 = rhsNT2[id3];
      dfloat rhsnt24 = rhsNT2[id4];
      dfloat rhsnt25 = rhsNT2[id5];
      dfloat rhsnt26 = rhsNT2[id6];
      
      //
      dfloat qx1 = pmlQX[id1];
      dfloat qx2 = pmlQX[id2];
      dfloat qx3 = pmlQX[id3];
      dfloat qx4 = pmlQX[id4];
      dfloat qx5 = pmlQX[id5];
      dfloat qx6 = pmlQX[id6]; 
      //
      dfloat qy1 = pmlQY[id1];
      dfloat qy2 = pmlQY[id2];
      dfloat qy3 = pmlQY[id3];
      dfloat qy4 = pmlQY[id4];
      dfloat qy5 = pmlQY[id5];
      dfloat qy6 = pmlQY[id6]; 
      //
      dfloat nt1 = pmlNT[id1];
      dfloat nt2 = pmlNT[id2];
      dfloat nt3 = pmlNT[id3];
      dfloat nt4 = pmlNT[id4];
      dfloat nt5 = pmlNT[id5];
      dfloat nt6 = pmlNT[id6]; 
      //
      //Computes only once
      dfloat c1 =  (p_pmlexpdt + 2*dt*0.5*p_tauInv - dt*0.5*p_tauInv*p_pmlexpdt - 1.)/(dt*0.5*p_tauInv*0.5*p_tauInv);
      dfloat c2 = -(p_pmlexpdt +    dt*0.5*p_tauInv - 1.)/(dt*0.5*p_tauInv*0.5*p_tauInv);
     
      // dfloat c1 = 1.5*dt;
      // dfloat c2 = -0.5*dt; 
      
      qx1 = qx1 + 1.5*dt*rhsqx11 - 0.5*dt*rhsqx21;
      qx2 = qx2 + 1.5*dt*rhsqx12 - 0.5*dt*rhsqx22;
      qx3 = qx3 + 1.5*dt*rhsqx13 - 0.5*dt*rhsqx23;
      qx4 = p_pmlexpdt*qx4 + c1*rhsqx14 + c2*rhsqx24;
      qx5 = p_pmlexpdt*qx5 + c1*rhsqx15 + c2*rhsqx25;
      qx6 = p_pmlexpdt*qx6 + c1*rhsqx16 + c2*rhsqx26;
      //
      qy1 = qy1 + 1.5*dt*rhsqy11 -0.5*dt*rhsqy21;
      qy2 = qy2 + 1.5*dt*rhsqy12 -0.5*dt*rhsqy22;
      qy3 = qy3 + 1.5*dt*rhsqy13 -0.5*dt*rhsqy23;
      qy4 = p_pmlexpdt*qy4 + c1*rhsqy14 + c2*rhsqy24;
      qy5 = p_pmlexpdt*qy5 + c1*rhsqy15 + c2*rhsqy25;
      qy6 = p_pmlexpdt*qy6 + c1*rhsqy16 + c2*rhsqy26;
      //
     //
      nt1 += 1.5*dt*rhsnt11 -0.5*dt*rhsnt21;
      nt2 += 1.5*dt*rhsnt12 -0.5*dt*rhsnt22;
      nt3 += 1.5*dt*rhsnt13 -0.5*dt*rhsnt23;
      nt4 += 1.5*dt*rhsnt14 -0.5*dt*rhsnt24;
      nt5 += 1.5*dt*rhsnt15 -0.5*dt*rhsnt25;
      nt6 += 1.5*dt*rhsnt16 -0.5*dt*rhsnt26;
      
     //

    // Update Fields
      pmlQX[id1] = qx1 ;
      pmlQX[id2] = qx2 ;
      pmlQX[id3] = qx3 ;
      pmlQX[id4] = qx4 ;
      pmlQX[id5] = qx5 ;
      pmlQX[id6] = qx6 ; 

      pmlQY[id1] = qy1 ;
      pmlQY[id2] = qy2 ;
      pmlQY[id3] = qy3 ;
      pmlQY[id4] = qy4 ;
      pmlQY[id5] = qy5 ;
      pmlQY[id6] = qy6 ; 

      pmlNT[id1] = nt1 ;
      pmlNT[id2] = nt2 ;
      pmlNT[id3] = nt3 ;
      pmlNT[id4] = nt4 ;
      pmlNT[id5] = nt5 ;
      pmlNT[id6] = nt6 ; 

      //
      rhsQX2[id1] = rhsqx11 ;
      rhsQX2[id2] = rhsqx12 ;
      rhsQX2[id3] = rhsqx13 ;
      rhsQX2[id4] = rhsqx14 ;
      rhsQX2[id5] = rhsqx15 ;
      rhsQX2[id6] = rhsqx16 ;
     

      //
      rhsQY2[id1] = rhsqy11 ;
      rhsQY2[id2] = rhsqy12 ;
      rhsQY2[id3] = rhsqy13 ;
      rhsQY2[id4] = rhsqy14 ;
      rhsQY2[id5] = rhsqy15 ;
      rhsQY2[id6] = rhsqy16 ;
      
       //
      rhsNT2[id1] = rhsnt11 ;
      rhsNT2[id2] = rhsnt12 ;
      rhsNT2[id3] = rhsnt13 ;
      rhsNT2[id4] = rhsnt14 ;
      rhsNT2[id5] = rhsnt15 ;
      rhsNT2[id6] = rhsnt16 ;
      
      //
      dfloat4 qa, qb;
      qa.x = p_q1bar + qx1 + qy1;
      qa.y = ramp*p_q2bar + qx2 + qy2;
      qa.z = ramp*p_q3bar + qx3 + qy3;
      qa.w = ramp*ramp*p_q4bar + qx4 + qy4;
      
      qb.x = ramp*ramp*p_q5bar + qx5 + qy5;
      qb.y = ramp*ramp*p_q6bar + qx6 + qy6;
      qb.z = 0.0; 
      qb.w = 0.0; 

      q[2*(n+element*p_Np)]   = qa;
      q[2*(n+element*p_Np)+1] = qb;
      
    }
  }
}



// Perform an update like Y = Q + c_im*Res_IM + c_ex*Res_EX;
kernel void boltzmannSAABSplitPmlUpdate2D(
            const iint                Nelements,
            const iint     * restrict elementIds,
            const dfloat              dt, 
            const dfloat             ramp,
                  dfloat  * restrict rhsQX,
                  dfloat  * restrict rhsQY,
                  dfloat  * restrict rhsNT,
                  dfloat  * restrict rhsQX2,
                  dfloat  * restrict rhsQY2,
                  dfloat  * restrict rhsNT2,
                  dfloat  * restrict rhsQX3,
                  dfloat  * restrict rhsQY3,
                  dfloat  * restrict rhsNT3,
                  dfloat  * restrict pmlQX,
                  dfloat  * restrict pmlQY,
                  dfloat  * restrict pmlNT,
                  dfloat4 * restrict q){  
 // Low storage Runge Kutta time step update
  for(iint e=0;e<Nelements;++e;outer0){
    for(iint n=0;n<p_Np;++n;inner0){
      const iint element = elementIds[e];
      
      //
      const iint base = n + element*p_Nfields*p_Np;
      const iint id1 = base + 0*p_Np;
      const iint id2 = base + 1*p_Np;
      const iint id3 = base + 2*p_Np;
      const iint id4 = base + 3*p_Np;
      const iint id5 = base + 4*p_Np;
      const iint id6 = base + 5*p_Np;
      //
      const int id0 = n+ element*p_Np;

      // PML UPDATES
      dfloat rhsqx11 = rhsQX[id1];
      dfloat rhsqx12 = rhsQX[id2];
      dfloat rhsqx13 = rhsQX[id3];
      dfloat rhsqx14 = rhsQX[id4];
      dfloat rhsqx15 = rhsQX[id5];
      dfloat rhsqx16 = rhsQX[id6]; 
      //
      dfloat rhsqy11 = rhsQY[id1];
      dfloat rhsqy12 = rhsQY[id2];
      dfloat rhsqy13 = rhsQY[id3];
      dfloat rhsqy14 = rhsQY[id4];
      dfloat rhsqy15 = rhsQY[id5];
      dfloat rhsqy16 = rhsQY[id6]; 

      dfloat rhsnt11 = rhsNT[id1];
      dfloat rhsnt12 = rhsNT[id2];
      dfloat rhsnt13 = rhsNT[id3];
      dfloat rhsnt14 = rhsNT[id4];
      dfloat rhsnt15 = rhsNT[id5];
      dfloat rhsnt16 = rhsNT[id6];

      // PML OLD VALUES
      dfloat rhsqx21 = rhsQX2[id1];
      dfloat rhsqx22 = rhsQX2[id2];
      dfloat rhsqx23 = rhsQX2[id3];
      dfloat rhsqx24 = rhsQX2[id4];
      dfloat rhsqx25 = rhsQX2[id5];
      dfloat rhsqx26 = rhsQX2[id6]; 
      //
      dfloat rhsqy21 = rhsQY2[id1];
      dfloat rhsqy22 = rhsQY2[id2];
      dfloat rhsqy23 = rhsQY2[id3];
      dfloat rhsqy24 = rhsQY2[id4];
      dfloat rhsqy25 = rhsQY2[id5];
      dfloat rhsqy26 = rhsQY2[id6]; 

      dfloat rhsnt21 = rhsNT2[id1];
      dfloat rhsnt22 = rhsNT2[id2];
      dfloat rhsnt23 = rhsNT2[id3];
      dfloat rhsnt24 = rhsNT2[id4];
      dfloat rhsnt25 = rhsNT2[id5];
      dfloat rhsnt26 = rhsNT2[id6];

      // PML OLD VALUES
      dfloat rhsqx31 = rhsQX3[id1];
      dfloat rhsqx32 = rhsQX3[id2];
      dfloat rhsqx33 = rhsQX3[id3];
      dfloat rhsqx34 = rhsQX3[id4];
      dfloat rhsqx35 = rhsQX3[id5];
      dfloat rhsqx36 = rhsQX3[id6]; 
      //
      dfloat rhsqy31 = rhsQY3[id1];
      dfloat rhsqy32 = rhsQY3[id2];
      dfloat rhsqy33 = rhsQY3[id3];
      dfloat rhsqy34 = rhsQY3[id4];
      dfloat rhsqy35 = rhsQY3[id5];
      dfloat rhsqy36 = rhsQY3[id6]; 

      dfloat rhsnt31 = rhsNT3[id1];
      dfloat rhsnt32 = rhsNT3[id2];
      dfloat rhsnt33 = rhsNT3[id3];
      dfloat rhsnt34 = rhsNT3[id4];
      dfloat rhsnt35 = rhsNT3[id5];
      dfloat rhsnt36 = rhsNT3[id6];

      //
      dfloat qx1 = pmlQX[id1];
      dfloat qx2 = pmlQX[id2];
      dfloat qx3 = pmlQX[id3];
      dfloat qx4 = pmlQX[id4];
      dfloat qx5 = pmlQX[id5];
      dfloat qx6 = pmlQX[id6]; 
      //
      dfloat qy1 = pmlQY[id1];
      dfloat qy2 = pmlQY[id2];
      dfloat qy3 = pmlQY[id3];
      dfloat qy4 = pmlQY[id4];
      dfloat qy5 = pmlQY[id5];
      dfloat qy6 = pmlQY[id6]; 
      //
      dfloat nt1 = pmlNT[id1];
      dfloat nt2 = pmlNT[id2];
      dfloat nt3 = pmlNT[id3];
      dfloat nt4 = pmlNT[id4];
      dfloat nt5 = pmlNT[id5];
      dfloat nt6 = pmlNT[id6]; 
      //

         
    //
      
      qx1  = qx1 +            p_ab1*rhsqx11 +       p_ab2*rhsqx21 + p_ab3*rhsqx31;
      qx2  = qx2 +            p_ab1*rhsqx12 +       p_ab2*rhsqx22 + p_ab3*rhsqx32;
      qx3  = qx3 +              p_ab1*rhsqx13 +      p_ab2*rhsqx23 + p_ab3*rhsqx33;
      qx4  = p_pmlexpdt*qx4 +  p_pmlsaab1*rhsqx14 + p_pmlsaab2*rhsqx24 + p_pmlsaab3*rhsqx34;
      qx5  = p_pmlexpdt*qx5 +  p_pmlsaab1*rhsqx15 + p_pmlsaab2*rhsqx25 + p_pmlsaab3*rhsqx35;
      qx6  = p_pmlexpdt*qx6 +  p_pmlsaab1*rhsqx16 + p_pmlsaab2*rhsqx26 + p_pmlsaab3*rhsqx36;
      //
      qy1  = qy1 +  p_ab1*rhsqy11 + p_ab2*rhsqy21 + p_ab3*rhsqy31;
      qy2  = qy2 +  p_ab1*rhsqy12 + p_ab2*rhsqy22 + p_ab3*rhsqy32;
      qy3  = qy3 +  p_ab1*rhsqy13 + p_ab2*rhsqy23 + p_ab3*rhsqy33;
      qy4  = p_pmlexpdt*qy4 +  p_pmlsaab1*rhsqy14 + p_pmlsaab2*rhsqy24 + p_pmlsaab3*rhsqy34;
      qy5  = p_pmlexpdt*qy5 +  p_pmlsaab1*rhsqy15 + p_pmlsaab2*rhsqy25 + p_pmlsaab3*rhsqy35;
      qy6  = p_pmlexpdt*qy6 +  p_pmlsaab1*rhsqy16 + p_pmlsaab2*rhsqy26 + p_pmlsaab3*rhsqy36;
      //
      nt1 += dt*(p_ab1*rhsnt11 + p_ab2*rhsnt21 + p_ab3*rhsnt31);
      nt2 += dt*(p_ab1*rhsnt12 + p_ab2*rhsnt22 + p_ab3*rhsnt32);
      nt3 += dt*(p_ab1*rhsnt13 + p_ab2*rhsnt23 + p_ab3*rhsnt33);
      nt4 += dt*(p_ab1*rhsnt14 + p_ab2*rhsnt24 + p_ab3*rhsnt34);
      nt5 += dt*(p_ab1*rhsnt15 + p_ab2*rhsnt25 + p_ab3*rhsnt35);
      nt6 += dt*(p_ab1*rhsnt16 + p_ab2*rhsnt26 + p_ab3*rhsnt36);

    // Update Fields
      pmlQX[id1] = qx1 ;
      pmlQX[id2] = qx2 ;
      pmlQX[id3] = qx3 ;
      pmlQX[id4] = qx4 ;
      pmlQX[id5] = qx5 ;
      pmlQX[id6] = qx6 ; 

      pmlQY[id1] = qy1 ;
      pmlQY[id2] = qy2 ;
      pmlQY[id3] = qy3 ;
      pmlQY[id4] = qy4 ;
      pmlQY[id5] = qy5 ;
      pmlQY[id6] = qy6 ; 

      pmlNT[id1] = nt1 ;
      pmlNT[id2] = nt2 ;
      pmlNT[id3] = nt3 ;
      pmlNT[id4] = nt4 ;
      pmlNT[id5] = nt5 ;
      pmlNT[id6] = nt6 ; 

      //
      rhsQX2[id1] = rhsqx11 ;
      rhsQX2[id2] = rhsqx12 ;
      rhsQX2[id3] = rhsqx13 ;
      rhsQX2[id4] = rhsqx14 ;
      rhsQX2[id5] = rhsqx15 ;
      rhsQX2[id6] = rhsqx16 ;
      //
      rhsQX3[id1] = rhsqx21 ;
      rhsQX3[id2] = rhsqx22 ;
      rhsQX3[id3] = rhsqx23 ;
      rhsQX3[id4] = rhsqx24 ;
      rhsQX3[id5] = rhsqx25 ;
      rhsQX3[id6] = rhsqx26 ;


      //
      rhsQY2[id1] = rhsqy11 ;
      rhsQY2[id2] = rhsqy12 ;
      rhsQY2[id3] = rhsqy13 ;
      rhsQY2[id4] = rhsqy14 ;
      rhsQY2[id5] = rhsqy15 ;
      rhsQY2[id6] = rhsqy16 ;
      //
      rhsQY3[id1] = rhsqy21 ;
      rhsQY3[id2] = rhsqy22 ;
      rhsQY3[id3] = rhsqy23 ;
      rhsQY3[id4] = rhsqy24 ;
      rhsQY3[id5] = rhsqy25 ;
      rhsQY3[id6] = rhsqy26 ;

       //
      rhsNT2[id1] = rhsnt11 ;
      rhsNT2[id2] = rhsnt12 ;
      rhsNT2[id3] = rhsnt13 ;
      rhsNT2[id4] = rhsnt14 ;
      rhsNT2[id5] = rhsnt15 ;
      rhsNT2[id6] = rhsnt16 ;
      //
      rhsNT3[id1] = rhsnt21 ;
      rhsNT3[id2] = rhsnt22 ;
      rhsNT3[id3] = rhsnt23 ;
      rhsNT3[id4] = rhsnt24 ;
      rhsNT3[id5] = rhsnt25 ;
      rhsNT3[id6] = rhsnt26 ;   
      //
      dfloat4 qa, qb;

      qa.x = p_q1bar           + qx1 + qy1;
      qa.y = ramp*p_q2bar      + qx2 + qy2;
      qa.z = ramp*p_q3bar      + qx3 + qy3;
      qa.w = ramp*ramp*p_q4bar + qx4 + qy4;
      
      qb.x = ramp*ramp*p_q5bar + qx5 + qy5;
      qb.y = ramp*ramp*p_q6bar + qx6 + qy6;
      qb.z = 0.0; 
      qb.w = 0.0; 

      q[2*(n+element*p_Np)]   = qa;
      q[2*(n+element*p_Np)+1] = qb;
      
    }
  }
}

