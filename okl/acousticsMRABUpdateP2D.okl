kernel void acousticsMRABUpdateP2D(const int Nelements,
           const int   * restrict elementIds,
           const int   * restrict N,
           const dfloat dt, 
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           const dfloat t,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict invVB1D,
           const int   * restrict EToB,
           const int   * restrict EToE,
           const dfloat * restrict BBLower,
           const int   * restrict BBRaiseids,
           const dfloat * restrict BBRaiseVals,  
           const int   * restrict vmapM,
           dfloat * restrict rhsq,
           dfloat * restrict q,
           dfloat * restrict fQM,
           dfloat * restrict fQP,
           const int   rhsShift){
  
  for(int et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_q[p_Np*p_Nfields];

    shared dfloat s_un[p_Nfaces*p_Nfp];
    shared dfloat s_vn[p_Nfaces*p_Nfp];
    shared dfloat s_pn[p_Nfaces*p_Nfp];

    shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    shared dfloat s_sourceu[p_Nfp*p_Nfaces];
    shared dfloat s_sourcev[p_Nfp*p_Nfaces];
    shared dfloat s_sourcep[p_Nfp*p_Nfaces];

    for(int n=0; n < p_maxNodes; ++n; inner0){  //maxNodes = max(Np,Nfaces*Nfp)
      if (n < p_Np){
        const int e = elementIds[et];
        const int id = p_Nfields*(e*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;

        for (int fld = 0; fld < p_Nfields; ++fld) 
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
      }
    }
    barrier(localMemFence);

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      const int e = elementIds[et];

      //write update      
      if (n < p_Np){
        const int id = p_Nfields*(e*p_NpMax + n);

        for (int fld = 0; fld < p_Nfields; ++fld) 
          q[id+fld] = s_q[p_Nfields*n+fld];
      }

      if (n<p_Nfaces*p_Nfp) {
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //compute source injection if present
        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          const int idM = vmapM[id];

          //get the nodal values of the incident field along the trace
          const dfloat X = x[idM];
          const dfloat Y = y[idM];

          const dfloat c = sqrt(p_sourceC2);

          dfloat u,v,p;

          acousticsPointSource2D((X-p_sourceX0), (Y-p_sourceY0), (t+p_sourceT0), p_sourceFreq, c, u, v, p);

          s_sourceu[n] = u;
          s_sourcev[n] = v;
          s_sourcep[n] = p;
        }

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_pn[n] = s_q[qidM+2];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_pn[n];
      }
    }

    barrier(localMemFence); 

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      if (n < p_Nfp*p_Nfaces){
        const int e = elementIds[et];
        const int f  = n/p_Nfp; //face number
        const int id  = n%p_Nfp; //local node number

        dfloat sourceu = 0.f;
        dfloat sourcev = 0.f;
        dfloat sourcep = 0.f;

        dfloat s = 0.f;

        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          if (bc==-10) s= 1.f;
          if (bc==-11) s=-1.f;

          occaUnroll(p_Nfp)
          for (int m=0;m<p_Nfp;m++) {
            sourceu += invVB1D[id + p_Nfp*m]*s_sourceu[f*p_Nfp+m];
            sourcev += invVB1D[id + p_Nfp*m]*s_sourcev[f*p_Nfp+m];
            sourcep += invVB1D[id + p_Nfp*m]*s_sourcep[f*p_Nfp+m];
          }
        }
        s_un[n] += sourceu;
        s_vn[n] += sourcev;
        s_pn[n] += sourcep;
      }
    }

    barrier(localMemFence);

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      const int e = elementIds[et];      
      
      if (n < p_Nfp*p_Nfaces){
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(2)
            for (int m=0;m<2;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[2*id+m];
              const int BBRaiseid = BBRaiseids[2*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(p_Nfp)
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_pn[n];
        }        
      }
    }
  }
}

kernel void acousticsMRABTraceUpdateP2D(const int Nelements,
           const int   * restrict elementIds,
           const int   * restrict N,
           const dfloat dt, 
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           const dfloat t,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict invVB1D,
           const int   * restrict EToB,
           const int   * restrict EToE,
           const dfloat * restrict BBLower,
           const int   * restrict BBRaiseids,
           const dfloat * restrict BBRaiseVals,  
           const int   * restrict vmapM,
           const dfloat * restrict rhsq,
           const dfloat * restrict q,
           dfloat * restrict fQM,
           dfloat * restrict fQP,
           const int   rhsShift){
  
  for(int et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_q[p_Np*p_Nfields];

    shared dfloat s_un[p_Nfaces*p_Nfp];
    shared dfloat s_vn[p_Nfaces*p_Nfp];
    shared dfloat s_pn[p_Nfaces*p_Nfp];

    shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    shared dfloat s_sourceu[p_Nfp*p_Nfaces];
    shared dfloat s_sourcev[p_Nfp*p_Nfaces];
    shared dfloat s_sourcep[p_Nfp*p_Nfaces];

    for(int n=0; n < p_maxNodes; ++n; inner0){  //maxNodes = max(Np,Nfaces*Nfp)
      if (n < p_Np){
        const int e = elementIds[et];
        const int id = p_Nfields*(e*p_NpMax + n);

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;

        for (int fld = 0; fld < p_Nfields; ++fld) 
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsq[rhsId1+fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
      }
    }
    barrier(localMemFence);

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      const int e = elementIds[et];

      if (n<p_Nfaces*p_Nfp) {
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //compute source injection if present
        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          const int idM = vmapM[id];

          //get the nodal values of the incident field along the trace
          const dfloat X = x[idM];
          const dfloat Y = y[idM];

          const dfloat c = sqrt(p_sourceC2);

          dfloat u,v,p;

          acousticsPointSource2D((X-p_sourceX0), (Y-p_sourceY0), (t+p_sourceT0), p_sourceFreq, c, u, v, p);

          s_sourceu[n] = u;
          s_sourcev[n] = v;
          s_sourcep[n] = p;
        }

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_pn[n] = s_q[qidM+2];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_pn[n];
      }
    }

    barrier(localMemFence); 

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      if (n < p_Nfp*p_Nfaces){
        const int e = elementIds[et];
        const int f  = n/p_Nfp; //face number
        const int id  = n%p_Nfp; //local node number

        dfloat sourceu = 0.f;
        dfloat sourcev = 0.f;
        dfloat sourcep = 0.f;

        dfloat s = 0.f;

        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          if (bc==-10) s= 1.f;
          if (bc==-11) s=-1.f;

          occaUnroll(p_Nfp)
          for (int m=0;m<p_Nfp;m++) {
            sourceu += invVB1D[id + p_Nfp*m]*s_sourceu[f*p_Nfp+m];
            sourcev += invVB1D[id + p_Nfp*m]*s_sourcev[f*p_Nfp+m];
            sourcep += invVB1D[id + p_Nfp*m]*s_sourcep[f*p_Nfp+m];
          }
        }
        s_un[n] += sourceu;
        s_vn[n] += sourcev;
        s_pn[n] += sourcep;
      }
    }

    barrier(localMemFence);    

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      const int e = elementIds[et];      
      
      if (n < p_Nfp*p_Nfaces){
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(2)
            for (int m=0;m<2;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[2*id+m];
              const int BBRaiseid = BBRaiseids[2*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(p_Nfp)
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_pn[n];
        }        
      }
    }
  }
}



kernel void acousticsMRABUpdateP2D_wadg(const int Nelements,
           const int   * restrict elementIds,
           const int   * restrict N,
           const dfloat dt, 
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat t,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict invVB1D,
           const int   * restrict EToB,
           const int   * restrict EToE,
           const dfloat * restrict BBLower,
           const int   * restrict BBRaiseids,
           const dfloat * restrict BBRaiseVals,  
           const int   * restrict vmapM,
           dfloat * restrict rhsq,
           dfloat * restrict q,
           dfloat * restrict fQM,
           dfloat * restrict fQP,
           const int   rhsShift){
  
  for(int et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_q[p_Np*p_Nfields];

    shared dfloat s_un[p_Nfaces*p_Nfp];
    shared dfloat s_vn[p_Nfaces*p_Nfp];
    shared dfloat s_pn[p_Nfaces*p_Nfp];

    shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    shared dfloat s_sourceu[p_Nfp*p_Nfaces];
    shared dfloat s_sourcev[p_Nfp*p_Nfaces];
    shared dfloat s_sourcep[p_Nfp*p_Nfaces];

    shared dfloat s_p[p_cubNp];
    exclusive dfloat r_p;

    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      if (n < p_Np){
        const int e = elementIds[et];
        const int id = p_Nfields*(e*p_NpMax + n);
        const int rhsId = 3*id + rhsShift*p_Nfields;
        s_p[n] = rhsq[rhsId + 2]; // extract pressure rhs
      }

      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        const int e = elementIds[et];
        // Prefetch value of c2
        const dfloat c2n = c2[n + e*p_cubNpMax];
        
        dfloat val = 0.f;
        occaUnroll(p_Np)
        for (int i=0;i<p_Np;++i){
          val += cubInterp[n + i*p_cubNp] * s_p[i];
        }

        // Multiply result by wavespeed c2 at cubature node
        r_p = val * c2n;
      }
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        s_p[n] = r_p;
      }
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n < p_Np){
        const int e = elementIds[et];
        // Extract velocity rhs
        const int id = p_Nfields*(e*p_NpMax + n);
        const int rhsId = 3*id + rhsShift*p_Nfields;
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[rhsId + 0];
        rhsqn[1] = rhsq[rhsId + 1];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        occaUnroll(p_cubNp)
        for (int i=0;i<p_cubNp;++i){
          rhsp += cubProject[n + i*p_Np] * s_p[i];
        }
        rhsqn[2] = rhsp;

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;

        // Increment solutions (saving rhs)
        for (int fld = 0; fld < p_Nfields; ++fld) {
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsqn[fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
          rhsq[rhsId+fld] = rhsqn[fld];
        }
      }      
    }
    barrier(localMemFence);

    //write update and negative traces
    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      const int e = elementIds[et];

      //write update      
      if (n < p_Np){
        const int id = p_Nfields*(e*p_NpMax + n);

        for (int fld = 0; fld < p_Nfields; ++fld) 
          q[id+fld] = s_q[p_Nfields*n+fld];
      }

      if (n<p_Nfaces*p_Nfp) {
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //compute source injection if present
        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          const int idM = vmapM[id];

          //get the nodal values of the incident field along the trace
          const dfloat X = x[idM];
          const dfloat Y = y[idM];

          const dfloat c = sqrt(p_sourceC2);

          dfloat u,v,p;

          acousticsPointSource2D((X-p_sourceX0), (Y-p_sourceY0), (t+p_sourceT0), p_sourceFreq, c, u, v, p);

          s_sourceu[n] = u;
          s_sourcev[n] = v;
          s_sourcep[n] = p;
        }

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_pn[n] = s_q[qidM+2];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_pn[n];
      }
    }

    barrier(localMemFence); 

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      if (n < p_Nfp*p_Nfaces){
        const int e = elementIds[et];
        const int f  = n/p_Nfp; //face number
        const int id  = n%p_Nfp; //local node number

        dfloat sourceu = 0.f;
        dfloat sourcev = 0.f;
        dfloat sourcep = 0.f;

        dfloat s = 0.f;

        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          if (bc==-10) s= 1.f;
          if (bc==-11) s=-1.f;

          occaUnroll(p_Nfp)
          for (int m=0;m<p_Nfp;m++) {
            sourceu += invVB1D[id + p_Nfp*m]*s_sourceu[f*p_Nfp+m];
            sourcev += invVB1D[id + p_Nfp*m]*s_sourcev[f*p_Nfp+m];
            sourcep += invVB1D[id + p_Nfp*m]*s_sourcep[f*p_Nfp+m];
          }
        }
        s_un[n] += sourceu;
        s_vn[n] += sourcev;
        s_pn[n] += sourcep;
      }
    }

    barrier(localMemFence);    

    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      const int e = elementIds[et];      
      
      if (n < p_Nfp*p_Nfaces){
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(2)
            for (int m=0;m<2;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[2*id+m];
              const int BBRaiseid = BBRaiseids[2*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(p_Nfp)
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_pn[n];
        }        
      }
    }
  }
}

kernel void acousticsMRABTraceUpdateP2D_wadg(const int Nelements,
           const int   * restrict elementIds,
           const int   * restrict N,
           const dfloat dt, 
           const dfloat a1,
           const dfloat a2,
           const dfloat a3,
           const dfloat * restrict cubInterp,
           const dfloat * restrict cubProject,
           const dfloat * restrict c2,
           const dfloat t,
           const dfloat * restrict x,
           const dfloat * restrict y,
           const dfloat * restrict invVB1D,
           const int   * restrict EToB,
           const int   * restrict EToE,
           const dfloat * restrict BBLower,
           const int   * restrict BBRaiseids,
           const dfloat * restrict BBRaiseVals,  
           const int   * restrict vmapM,
           const dfloat * restrict rhsq,
           const dfloat * restrict q,
           dfloat * restrict fQM,
           dfloat * restrict fQP,
           const int   rhsShift){
  
  for(int et=0;et<Nelements;++et;outer0){  // for all elements
    shared dfloat s_q[p_Np*p_Nfields];

    shared dfloat s_un[p_Nfaces*p_Nfp];
    shared dfloat s_vn[p_Nfaces*p_Nfp];
    shared dfloat s_pn[p_Nfaces*p_Nfp];

    shared dfloat s_unp[p_Nfaces*p_Nfpp1];
    shared dfloat s_vnp[p_Nfaces*p_Nfpp1];
    shared dfloat s_pnp[p_Nfaces*p_Nfpp1];

    shared dfloat s_sourceu[p_Nfp*p_Nfaces];
    shared dfloat s_sourcev[p_Nfp*p_Nfaces];
    shared dfloat s_sourcep[p_Nfp*p_Nfaces];

    shared dfloat s_p[p_cubNp];
    exclusive dfloat r_p;

    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      if (n < p_Np){
        const int e = elementIds[et];
        const int id = p_Nfields*(e*p_NpMax + n);
        const int rhsId = 3*id + rhsShift*p_Nfields;
        s_p[n] = rhsq[rhsId + 2]; // extract pressure rhs
      }

      // Initialize register variable
      r_p = 0.f;
    }
    barrier(localMemFence);

    // Interpolate rhs to cubature nodes
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        const int e = elementIds[et];
        // Prefetch value of c2
        const dfloat c2n = c2[n + e*p_cubNpMax];
        
        dfloat val = 0.f;
        occaUnroll(p_Np)
        for (int i=0;i<p_Np;++i){
          val += cubInterp[n + i*p_cubNp] * s_p[i];
        }

        // Multiply result by wavespeed c2 at cubature node
        r_p = val * c2n;
      }
    }
    barrier(localMemFence);

    // Move temporary result back to shared memory
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n<p_cubNp) {
        s_p[n] = r_p;
      }
    }
    barrier(localMemFence);
    
    // Increment solution, project result back down
    for(int n=0;n<p_maxCubNodes;++n;inner0){
      if (n < p_Np){
        const int e = elementIds[et];
        // Extract velocity rhs
        const int id = p_Nfields*(e*p_NpMax + n);
        const int rhsId = 3*id + rhsShift*p_Nfields;
        dfloat rhsqn[p_Nfields];
        rhsqn[0] = rhsq[rhsId + 0];
        rhsqn[1] = rhsq[rhsId + 1];  
        
        // Project scaled rhs down
        dfloat rhsp = 0.f;
        occaUnroll(p_cubNp)
        for (int i=0;i<p_cubNp;++i){
          rhsp += cubProject[n + i*p_Np] * s_p[i];
        }
        rhsqn[2] = rhsp;

        const int rhsId1 = 3*id + ((rhsShift+0)%3)*p_Nfields;
        const int rhsId2 = 3*id + ((rhsShift+1)%3)*p_Nfields;
        const int rhsId3 = 3*id + ((rhsShift+2)%3)*p_Nfields;

        // Increment solutions (saving rhs)
        for (int fld = 0; fld < p_Nfields; ++fld) {
          s_q[p_Nfields*n+fld] = q[id+fld] + dt*(a1*rhsqn[fld] + a2*rhsq[rhsId2+fld] + a3*rhsq[rhsId3+fld]);
        }
      }      
    }
    barrier(localMemFence);

    //write update and negative traces
    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      const int e = elementIds[et];

      if (n<p_Nfaces*p_Nfp) {
        const int f = n / p_Nfp;
        const int iid = n % p_Nfp;
        const int id  = e*p_NfpMax*p_Nfaces + f*p_NfpMax + iid;
        const int qidM = p_Nfields*(vmapM[id]-e*p_NpMax);
        const int qid   = p_Nfields*id;

        //compute source injection if present
        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          const int idM = vmapM[id];

          //get the nodal values of the incident field along the trace
          const dfloat X = x[idM];
          const dfloat Y = y[idM];

          const dfloat c = sqrt(p_sourceC2);

          dfloat u,v,p;

          acousticsPointSource2D((X-p_sourceX0), (Y-p_sourceY0), (t+p_sourceT0), p_sourceFreq, c, u, v, p);

          s_sourceu[n] = u;
          s_sourcev[n] = v;
          s_sourcep[n] = p;
        }

        //gather negative traces
        s_un[n] = s_q[qidM+0];
        s_vn[n] = s_q[qidM+1];
        s_pn[n] = s_q[qidM+2];

        //write negative traces
        fQM[qid+0] = s_un[n];
        fQM[qid+1] = s_vn[n];
        fQM[qid+2] = s_pn[n];
      }
    }

    barrier(localMemFence); 

    for(int n=0; n < p_maxNodes; ++n; inner0){  
      if (n < p_Nfp*p_Nfaces){
        const int e = elementIds[et];
        const int f  = n/p_Nfp; //face number
        const int id  = n%p_Nfp; //local node number

        dfloat sourceu = 0.f;
        dfloat sourcev = 0.f;
        dfloat sourcep = 0.f;

        dfloat s = 0.f;

        int bc = EToB[e*p_Nfaces+f];
        if ((bc==-10)||(bc==-11)) { //check if this is a special source injection face
          if (bc==-10) s= 1.f;
          if (bc==-11) s=-1.f;

          occaUnroll(p_Nfp)
          for (int m=0;m<p_Nfp;m++) {
            sourceu += invVB1D[id + p_Nfp*m]*s_sourceu[f*p_Nfp+m];
            sourcev += invVB1D[id + p_Nfp*m]*s_sourcev[f*p_Nfp+m];
            sourcep += invVB1D[id + p_Nfp*m]*s_sourcep[f*p_Nfp+m];
          }
        }
        s_un[n] += sourceu;
        s_vn[n] += sourcev;
        s_pn[n] += sourcep;
      }
    }

    barrier(localMemFence);    

    for(int n=0; n < p_maxCubNodes; ++n; inner0){  
      const int e = elementIds[et];      
      
      if (n < p_Nfp*p_Nfaces){
        const int f = n / p_Nfp;
              int id = n % p_Nfp;

        int eP = EToE[e*p_Nfaces+f];
        if (eP < 0) eP = e;
        const int NP = N[eP];

        if (NP > p_N) { 
          while (id<p_Nfpp1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(2)
            for (int m=0;m<2;m++){ //apply raise operator sparsly
              const dfloat BBRaiseVal = BBRaiseVals[2*id+m];
              const int BBRaiseid = BBRaiseids[2*id+m] + f*p_Nfp;
              s_unp[f*p_Nfpp1+id] += BBRaiseVal*s_un[BBRaiseid];
              s_vnp[f*p_Nfpp1+id] += BBRaiseVal*s_vn[BBRaiseid];
              s_pnp[f*p_Nfpp1+id] += BBRaiseVal*s_pn[BBRaiseid];
            }
            
            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];

            id += p_Nfp;
          }
        } else if (NP < p_N) { 
          if (id < p_Nfpm1) {
            s_unp[f*p_Nfpp1+id] = 0.0;
            s_vnp[f*p_Nfpp1+id] = 0.0;
            s_pnp[f*p_Nfpp1+id] = 0.0;
            occaUnroll(p_Nfp)
            for (int m=0;m<p_Nfp;m++){
              s_unp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_un[f*p_Nfp + m];
              s_vnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_vn[f*p_Nfp + m];
              s_pnp[f*p_Nfpp1+id] += BBLower[p_Nfp*id+m]*s_pn[f*p_Nfp + m];
            }

            //write positive trace
            const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
            fQP[qid+0] = s_unp[f*p_Nfpp1+id];
            fQP[qid+1] = s_vnp[f*p_Nfpp1+id];
            fQP[qid+2] = s_pnp[f*p_Nfpp1+id];
          }
        } else { //equal order neighbor
          //write positive trace
          const int qid = p_Nfields*(e*p_NfpMax*p_Nfaces + f*p_NfpMax + id);
          fQP[qid+0] = s_un[n];
          fQP[qid+1] = s_vn[n];
          fQP[qid+2] = s_pn[n];
        }        
      }
    }
  }
}
