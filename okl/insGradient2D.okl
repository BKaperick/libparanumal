
// Gradient only applies to Pressure and Pressure Incremament
// Boundary Conditions are implemented in strong form
void boundaryConditions2D(const iint bc,
        const dfloat  t, const dfloat  x, const dfloat  y,
        const dfloat  nx, const dfloat  ny,
        const dfloat pM, dfloat * restrict pB){

  if(bc==1){ // Wall
    *pB = pM; // Neumann for Pressure // do nothing
  } else if(bc==2){ // Inflow
    *pB = pM; // Neumann for Pressure // do nothing
  } else if(bc==3){ // Outflow
#if 0
    dfloat nu   = 1.0f/40.0f;
    dfloat lambda = 1.f/(2.f * nu) - occaSqrt( 1.f/(4.f*nu*nu) + 4.f*OCCA_PI*OCCA_PI) ;

    *pB = 0.5f*(1.0f - occaExp(2.0f*lambda*x));
#else
    *pB = 0.f;
#endif
  }
  //(*pB) = 2.f*(*pB) - pM; //Strong form BCs
}

// Compute Gradient in Strong Form
kernel void insGradientVolume2D(const iint Nelements,
        const dfloat * restrict vgeo,
        const dfloat * restrict DrT,
        const dfloat * restrict DsT,
        const iint  offset,
        const dfloat * restrict P,
        dfloat * restrict Px,
        dfloat * restrict Py){

  for(iint eo=0;eo<Nelements;eo+=p_NblockV;outer0){
    // for all elements
    shared dfloat s_P[p_NblockV][p_Np];

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element
        iint e = eo+es; // element in block
        if(e<Nelements){
                s_P[es][n]  = P[n + (e+offset)*p_Np];
        }
      }
    }

    // Make sure all node data is loaded into shared
    barrier(localMemFence);

    for(iint es=0;es<p_NblockV;++es;inner1){// for all elements in block
      for(iint n=0;n<p_Np;++n;inner0){     // for all nodes in this element

        iint e = eo+es; // element in block
        if(e<Nelements){
          // prefetch geometric factors (constant on triangle)
          const dfloat drdx = vgeo[e*p_Nvgeo + p_RXID];
          const dfloat drdy = vgeo[e*p_Nvgeo + p_RYID];
          const dfloat dsdx = vgeo[e*p_Nvgeo + p_SXID];
          const dfloat dsdy = vgeo[e*p_Nvgeo + p_SYID];

          dfloat dpdr  = 0.f, dpds  = 0.f;
          occaUnroll(p_Np)
            for(iint i=0;i<p_Np;++i){
              const dfloat Drni = DrT[n+i*p_Np];
              const dfloat Dsni = DsT[n+i*p_Np];

              dpdr  += Drni*s_P[es][i];
              dpds  += Dsni*s_P[es][i];
            }

          const iint id = (e+offset)*p_Np+n;
          Px[id] = drdx*dpdr + dsdx*dpds;
          Py[id] = drdy*dpdr + dsdy*dpds;
        }
      }
    }
  }
}

kernel void insGradientSurface2D(const iint Nelements,
         const dfloat * restrict sgeo,
         const dfloat * restrict LIFTT,
         const iint   * restrict vmapM,
         const iint   * restrict vmapP,
         const iint   * restrict EToB,
         const dfloat * restrict x,
         const dfloat * restrict y,
         const dfloat time,
         const dfloat dt,
         const dfloat a0,
         const dfloat a1,
         const dfloat a2,
         const int index,
         const iint offset,
         const int solverID,
         const dfloat * restrict POld,
         const dfloat * restrict P,
         dfloat * restrict Px,
         dfloat * restrict Py){

  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){

    shared dfloat s_fluxPx[p_NblockS][p_Nfp*p_Nfaces];
    shared dfloat s_fluxPy[p_NblockS][p_Nfp*p_Nfaces];

    // for all face nodes of all elements
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){ // maxNodes = max(Nfp*Nfaces,Np)
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Nfp*p_Nfaces){
            // find face that owns this node
            iint face = n/p_Nfp;
            // load surface geofactors for this face
            iint sid    = p_Nsgeo*(e*p_Nfaces+face);
            dfloat nx   = sgeo[sid+p_NXID];
            dfloat ny   = sgeo[sid+p_NYID];
            dfloat sJ   = sgeo[sid+p_SJID];
            dfloat invJ = sgeo[sid+p_IJID];

            // indices of negative and positive traces of face node
            iint id  = e*p_Nfp*p_Nfaces + n;
            iint idM, idP;
            if(solverID == 1){ //no offset
              idM = vmapM[id];
              idP = vmapP[id];
            } else {
              idM = vmapM[id]+p_Np*index*offset;
              idP = vmapP[id]+p_Np*index*offset;
            }
            if(idP<0) idP = idM;
            dfloat  PM = P[idM], PP = P[idP];

            // apply boundary condition
            iint bc = EToB[face+p_Nfaces*e];
            if(bc>0){
              idM = vmapM[id];
              boundaryConditions2D(bc, time, x[idM], y[idM], nx, ny, PM, &PP);

#if 0
              //TODO fix this later. On a Neumann BC for pressure this is wrong.
              //  Need the boundary values from the previous pressure steps.
              // Note: Or is it? Tried changing it and didnt help
              if((solverID == 1)&&(bc==3)){ //compute BC on pressure increment
                dfloat PMm0, PMm1, PMm2;  //hard coded for 3 stages
                dfloat PPm0, PPm1, PPm2;  //hard coded for 3 stages

                int index0 = (index+0)%3;
                int index1 = (index+2)%3; //one step back
                int index2 = (index+1)%3; //two steps back

                PMm0 = POld[idM+p_Np*index0*offset];
                PMm1 = POld[idM+p_Np*index1*offset];
                PMm2 = POld[idM+p_Np*index2*offset];

                boundaryConditions2D(bc, time-1*dt, x[idM], y[idM], nx, ny, PMm0, &PPm0);
                boundaryConditions2D(bc, time-2*dt, x[idM], y[idM], nx, ny, PMm1, &PPm1);
                boundaryConditions2D(bc, time-3*dt, x[idM], y[idM], nx, ny, PMm2, &PPm2);
                PP = PP - a0*PPm0 - a1*PPm1 - a2*PPm2;
	      }
#endif
              PP = 2.f*PP - PM; //Strong form BCs
            }

            // evaluate "flux" terms: LLF
            const dfloat sc = invJ * sJ ;

            // Centered flux for pr p*-p = 0.5(PP-PM) // Central Flux
            s_fluxPx[es][n]  = sc*(.5f*nx*(PP-PM));
            s_fluxPy[es][n]  = sc*(.5f*ny*(PP-PM));
          }
        }
      }
    }

    // wait for all flux functions are written to shared
    barrier(localMemFence);

    // for each node in the element
    for(iint es=0;es<p_NblockS;++es;inner1){
      for(iint n=0;n<p_maxNodes;++n;inner0){
        iint e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            iint id;
            if (solverID==1) { //no offset
              id = e*p_Np + n;
            } else {
              id = (e+index*offset)*p_Np + n;
            }

            dfloat px  = Px[id];
            dfloat py  = Py[id];
            // Lift
            occaUnroll(p_NfacesNfp)
              for(int m=0;m<p_Nfaces*p_Nfp;++m){
                dfloat L = LIFTT[n+m*p_Np];
                px += L*s_fluxPx[es][m];
                py += L*s_fluxPy[es][m];
              }
            //  rhsu = grad(p) // Note that multiplied with M^-1
            Px[id] = px;
            Py[id] = py;
          }
        }
      }
    }
  }
}

